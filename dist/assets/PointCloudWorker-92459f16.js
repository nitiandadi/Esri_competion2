import{ft as A,r as l,og as S,es as c,fB as d,n9 as y,fI as D,fK as M,tm as h}from"./MapView-d4248bee.js";import{c as g,a as p,f as w,m as z}from"./PointCloudWorkerUtil-83ebcf87.js";import"./index-9ba3f23e.js";import"./PointCloudUniqueValueRenderer-9684576e.js";import"./PointSizeSplatAlgorithm-89325c27.js";import"./I3SBinaryReader-0c2e63aa.js";class _{transform(t){const a=this._transform(t),e=[a.points.buffer,a.rgb.buffer];l(a.pointIdFilterMap)&&e.push(a.pointIdFilterMap.buffer);for(const r of a.attributes)"buffer"in r.values&&S(r.values.buffer)&&r.values.buffer!==a.rgb.buffer&&e.push(r.values.buffer);return Promise.resolve({result:a,transferList:e})}_transform(t){const a=g(t.schema,t.geometryBuffer);let e=a.length/3,r=null;const i=[],s=p(t.primaryAttributeData,a,e);l(t.primaryAttributeData)&&s&&i.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:s});const f=p(t.modulationAttributeData,a,e);l(t.modulationAttributeData)&&f&&i.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:f});let n=w(t.rendererInfo,s,f,e);if(t.filterInfo&&t.filterInfo.length>0&&l(t.filterAttributesData)){const o=t.filterAttributesData.filter(l).map(b=>{const v=p(b,a,e),m={attributeInfo:b.attributeInfo,values:v};return i.push(m),m});r=new Uint32Array(e),e=z(a,n,r,t.filterInfo,o)}for(const o of t.userAttributesData){const b=p(o,a,e);i.push({attributeInfo:o.attributeInfo,values:b})}3*e<n.length&&(n=new Uint8Array(n.buffer.slice(0,3*e))),this._applyElevationOffsetInPlace(a,e,t.elevationOffset);const u=this._transformCoordinates(a,e,t.obb,c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obb:t.obb,points:u,rgb:n,attributes:i,pointIdFilterMap:r}}_transformCoordinates(t,a,e,r,i){if(!d(t,r,0,t,i,0,a))throw new Error("Can't reproject");const s=y(e.center[0],e.center[1],e.center[2]),f=h(),n=h();D(I,e.quaternion);const u=new Float32Array(3*a);for(let o=0;o<a;o++)f[0]=t[3*o]-s[0],f[1]=t[3*o+1]-s[1],f[2]=t[3*o+2]-s[2],M(n,f,I),e.halfSize[0]=Math.max(e.halfSize[0],Math.abs(n[0])),e.halfSize[1]=Math.max(e.halfSize[1],Math.abs(n[1])),e.halfSize[2]=Math.max(e.halfSize[2],Math.abs(n[2])),u[3*o]=f[0],u[3*o+1]=f[1],u[3*o+2]=f[2];return u}_applyElevationOffsetInPlace(t,a,e){if(e!==0)for(let r=0;r<a;r++)t[3*r+2]+=e}}const I=A();function B(){return new _}export{B as default};

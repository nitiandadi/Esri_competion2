/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Error.js";import{unwrap as r}from"../../../core/maybe.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import{createGenerateRendererClassBreaks as s,createGenerateRendererUniqueValues as o}from"../../../rest/support/generateRendererUtils.js";import{getDataValues as a,mergeWhereClauses as n}from"../../statistics/support/utils.js";import{WorkerClient as l}from"../../statistics/support/WorkerClient.js";import{getFieldsList as c}from"../utils.js";import p from"./FeatureLayerAdapter.js";import{ensureFeaturesJSON as u}from"./support/utils.js";let m=class extends p{constructor(e){super(e)}async _createGenerateRendererResult(e,r,i,n,l){const c=e?.features,p=c?.length;if(!p)throw new t("csv-layer-adapter:insufficient-data","No features are available to calculate statistics");const m=u(c);let d=null;if("percent-of-total"===n){if(d=(await this.workerClient.summaryStatistics({field:r},m)).sum,null==d)throw new t("csv-layer-adapter:invalid","invalid normalizationTotal")}if("class-breaks-definition"===l.type){const e=(await a({field:r,normalizationType:n,normalizationField:i,normalizationTotal:d},m)).filter((e=>Number.isFinite(e)));return s({definition:l,values:e,normalizationTotal:d})}const f=(await a({field:r},m)).filter((e=>null!=e&&"string"==typeof e&&""!==e.trim()));return o(f)}generateRenderer(e,t){const r=e.classificationDefinition;let i=null,s=null,o=null;"class-breaks-definition"===r.type?(i=r.classificationField,s=r.normalizationField,o=r.normalizationType):i=r.attributeField;const a=this.layer;return c({field:i,normalizationField:s}).then((l=>{const c=a.createQuery();return c.returnGeometry=!1,c.outFields=l,c.where=n(c.where,e.where),a.queryFeatures(c,{signal:t}).then((e=>this._createGenerateRendererResult(e,i,s,o,r)))}))}load(e){const t=this.layer.load(e).then((async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.workerClient=l.getInstance(),await this.workerClient.open(r(r(e).signal))}));return this.addResolvingPromise(t),Promise.resolve(this)}};m=e([i("esri.smartMapping.support.adapters.CSVLayerAdapter")],m);const d=m;export{d as default};

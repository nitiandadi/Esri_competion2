/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import"../../geometry.js";import"../../core/has.js";import{clone as t}from"../../core/lang.js";import{clamp as e}from"../../core/mathUtils.js";import{isSome as n,isNone as r,unwrap as a,toNullable as o}from"../../core/maybe.js";import{createScreenPoint as s}from"../../core/screenUtils.js";import{f as c}from"../../chunks/vec3f64.js";import{project as i}from"../../geometry/projection.js";import{hydratedSpatialReference as l,clonePoint as u}from"../../layers/graphics/hydratedFeatures.js";import{getZForElevationMode as m}from"../../support/elevationInfoUtils.js";import{ViewingMode as p}from"../ViewingMode.js";import{move as f}from"../draw/support/drawUtils.js";import d from"../../geometry/Point.js";function y(t,e){let a=null,o=null;return s=>{if("cancel"===s.action)return void(n(o)&&(o.execute({action:"cancel"}),a=null,o=null));const c={action:s.action,screenStart:s.start,screenEnd:s.screenPoint};"start"===s.action&&r(a)&&(a=new U,o=new U,e(t,a,o,s.pointerType,c)),n(a)&&a.execute(c),"end"===s.action&&n(a)&&(a=null,o=null)}}function x(t,e){return t.events.on("drag",y(t,e))}function g(t,e){const n=[t.x,t.y,t.z??0],r=e,a=[Math.cos(r),Math.sin(r)],o=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===o)return null;a[0]/=o,a[1]/=o;const s=t=>{const e=(t.x-n[0])*a[0]+(t.y-n[1])*a[1];t.x=n[0]+e*a[0],t.y=n[1]+e*a[1]};return t=>(s(t.mapStart),s(t.mapEnd),{...t,axis:a})}function E(t,e){let n=null;return a=>{if("start"===a.action&&(n=S(t,a.mapStart.spatialReference,e)),r(n))return null;const o=a.mapEnd.x-a.mapStart.x,s=a.mapEnd.y-a.mapStart.y,c=a.mapEnd.z-a.mapStart.z;return n.move(o,s,c),{...a,translationX:o,translationY:s,translationZ:c}}}function h(t,e){return r(t)?null:t.spatialReference.equals(e)?t.clone():i(t,e)}function S(t,e,n){const a=t.geometry,o=l(e);if(r(a))return null;if("mesh"===a.type)return z(t,a,o,n);const s=h(a,o),c=a.spatialReference;return r(s)?null:{move:(e,n,r)=>{const a=f(s.clone(),e,n,r);a.spatialReference.equals(c)?t.geometry=a:t.geometry=i(a,c)}}}function z(t,e,r,a){if(n(e.transform))return j(t,e,e.transform,r);if(!e.spatialReference.equals(r))return null;let o=0,s=0,c=0;return{move:(n,r,i)=>{const l=n-o,u=r-s,m=i-c;if(l||u||m){const f=new d(e.origin.x+l,e.origin.y+u,e.origin.z+m,e.origin.spatialReference);e.centerAt(f,{geographic:a===p.Global}),t.notifyGeometryChanged(),o=n,s=r,c=i}}}}function j(t,e,a,o){const s=h(a.getOriginPoint(e.spatialReference),o),l=e.spatialReference;return r(s)?null:{move:(e,r,o)=>{const u=f(s.clone(),e,r,o);if(u.spatialReference.equals(l))a.origin=c(u.x,u.y,u.z);else{const t=i(u,l);n(t)&&(a.origin=c(t.x,t.y,t.z))}t.notifyMeshTransformChanged(),t.notifyGeometryChanged()}}}function v(t,e=null,a){let o=null;const s=n(e)&&!t.spatialReference?.equals(e)?t=>n(t)?i(t,e):t:t=>t,c={exclude:[],...a};return e=>{if("start"===e.action&&(o=s(t.toMap(e.screenStart,c))),r(o))return null;const a=s(t.toMap(e.screenEnd,c));return n(a)?{...e,mapStart:o,mapEnd:a}:null}}function R(t,e){const r=t.map((t=>a(E(t,e)))).filter((t=>n(t)));return t=>{const e=t.mapEnd.x-t.mapStart.x,n=t.mapEnd.y-t.mapStart.y,a=t.mapEnd.z-t.mapStart.z;return r.forEach((e=>e(t))),{...t,translationX:e,translationY:n,translationZ:a}}}function w(e,n){const r=new Map;for(const a of n)r.set(a,t(e[a]));return t=>(r.forEach(((t,n)=>{e[n]=t})),t)}function M(t){return n(t.geometry)&&"mesh"===t.geometry.type?P(t,t.geometry):w(t,["geometry"])}function P(t,e){const r=n(e.transform)?e.transform.clone():null,a=e.vertexAttributes.clonePositional();return n=>(e.transform=r,e.vertexAttributes=a,t.notifyGeometryChanged(),n)}function q(t){const e=t.map((t=>a(M(t)))).filter((t=>n(t)));return t=>(e.forEach((e=>e(t))),t)}function D(){let t=0,e=0,n=0;return r=>{"start"===r.action&&(t=r.mapStart.x,e=r.mapStart.y,n=r.mapStart.z);const a=r.mapEnd.x-t,o=r.mapEnd.y-e,s=r.mapEnd.z-n;return t=r.mapEnd.x,e=r.mapEnd.y,n=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:o,mapDeltaZ:s,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function b(){let t=0,e=0;return n=>{"start"===n.action&&(t=n.screenStart.x,e=n.screenStart.y);const r=n.screenEnd.x-t,a=n.screenEnd.y-e;return t=n.screenEnd.x,e=n.screenEnd.y,{...n,screenDeltaX:r,screenDeltaY:a}}}function C(t,n){let r=null,a=0,o=0;return c=>{if("start"===c.action&&(r=t.toScreen?.(n),null!=r&&(r.x<0||r.x>t.width||r.y<0||r.y>t.height?r=null:(a=c.screenStart.x-r.x,o=c.screenStart.y-r.y))),null==r)return null;const i=e(c.screenEnd.x-a,0,t.width),l=e(c.screenEnd.y-o,0,t.height),u=s(i,l);return c.screenStart=r,c.screenEnd=u,c}}const G=()=>{};class U{constructor(){this.execute=G}next(t,e=new U){return n(t)&&(this.execute=r=>{const a=t(r);n(a)&&e.execute(a)}),e}}function X(t,e,r=[]){if("2d"===t.type)return t=>t;let a=null;return o=>{"start"===o.action&&(a=t.toMap(o.screenStart,{exclude:r}),n(a)&&(a.z=m(a,t,e)));const s=t.toMap(o.screenEnd,{exclude:r});n(s)&&(s.z=m(s,t,e));const c=n(a)&&n(s)?{sceneStart:a,sceneEnd:s}:null;return{...o,scenePoints:c}}}function Y(t,e,n){const r=o(e.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene"))??0,a=u(t);return a.z=r,a.hasZ=!0,a.z=m(a,e,n),a}function Z(t,e){if("2d"===t.type)return t=>t;let r=null;return a=>{"start"===a.action&&(r=Y(a.mapStart,t,e));const o=Y(a.mapEnd,t,e),s=n(r)&&n(o)?{sceneStart:r,sceneEnd:o}:null;return{...a,scenePoints:s}}}export{U as EventPipeline,D as addMapDelta,b as addScreenDelta,g as constrainToMapAxis,y as createDragEventPipelineCallback,x as createManipulatorDragEventPipeline,C as dragAtLocation,E as dragGraphic,R as dragGraphicMany,M as resetGraphic,q as resetGraphicMany,w as resetProperties,X as sceneSnappingAtLocation,Z as sceneSnappingAtProjectedLocation,v as screenToMap};

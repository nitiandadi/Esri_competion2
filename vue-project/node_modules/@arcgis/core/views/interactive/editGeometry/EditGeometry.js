/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import t from"../../../core/Evented.js";import{isSome as s}from"../../../core/maybe.js";import i from"../../../geometry/Polygon.js";import r from"../../../geometry/Polyline.js";import{createCoordinateHelper as n}from"../coordinateHelper.js";import{unnormalize as o,getUnnormalizationInfo as h}from"./unnormalizationHelper.js";class c{constructor(e){this.component=e,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class l{constructor(e,t,s){this.component=e,this.leftVertex=t,this.rightVertex=s,this.type="edge",t.rightEdge=this,s.leftEdge=this}}class p{constructor(e,t){this._spatialReference=e,this._viewingMode=t,this.vertices=[],this.edges=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||o(this.vertices,h(this._spatialReference,this._viewingMode))}updateVertexIndex(e,t){if(0===this.vertices.length)return;const s=this.vertices[0];let i=null,r=e,n=t;do{i=r,i.index=n++,r=i.rightEdge?i.rightEdge.rightVertex:null}while(null!=r&&r!==s);i.leftEdge&&i!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(i),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(e,t){const s=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=s}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let i=t;do{e(i,i.index),i=s(i.rightEdge)?i.rightEdge.rightVertex:null}while(i!==t&&null!=i)}}class g extends t{constructor(e,t){super(),this.type=e,this.coordinateHelper=t,this._geometry=null,this._dirty=!0,this.components=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon()}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(e){this._dirty=!0,this.emit("change",e)}_toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}_toPolyline(){const e=[],t=this.coordinateHelper.vectorToArray;for(const s of this.components){if(s.vertices.length<1)continue;const i=[];let r=s.vertices.find((e=>null==e.leftEdge));const n=r;do{i.push(t(r.pos)),r=r.rightEdge?r.rightEdge.rightVertex:null}while(r&&r!==n);e.push(i)}return new r({paths:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const e=[],t=this.coordinateHelper.vectorToArray;for(const i of this.components){if(i.vertices.length<1)continue;const r=[],n=i.vertices[0];let o=n;const h=o;do{r.push(t(o.pos)),o=s(o.rightEdge)?o.rightEdge.rightVertex:null}while(o&&o!==h);i.isClosed()&&r.push(t(n.pos)),e.push(r)}return new i({rings:e,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(t,s){const i=t.spatialReference,r=n(t.hasZ,t.hasM,i),o=new g(t.type,r);switch(t.type){case"polygon":{const n=t.rings;for(let t=0;t<n.length;++t){const h=n[t],g=new p(i,s);g.index=t;const a=h.length>2&&e(h[0],h[h.length-1]),d=a?h.length-1:h.length;for(let e=0;e<d;++e){const t=r.arrayToVector(h[e]),s=new c(g);g.vertices.push(s),s.pos=t,s.index=e}const u=g.vertices.length-1;for(let e=0;e<u;++e){const t=g.vertices[e],s=g.vertices[e+1],i=new l(g,t,s);g.edges.push(i)}if(a){const e=new l(g,g.vertices[g.vertices.length-1],g.vertices[0]);g.edges.push(e)}o.components.push(g)}break}case"polyline":{const e=t.paths;for(let t=0;t<e.length;++t){const n=e[t],h=new p(i,s);h.index=t;const g=n.length;for(let e=0;e<g;++e){const t=r.arrayToVector(n[e]),s=new c(h);h.vertices.push(s),s.pos=t,s.index=e}const a=h.vertices.length-1;for(let e=0;e<a;++e){const t=h.vertices[e],s=h.vertices[e+1],i=new l(h,t,s);h.edges.push(i)}o.components.push(h)}break}case"point":{const e=new p(i,s);e.index=0;const n=new c(e);n.index=0,n.pos=r.pointToVector(t),e.vertices.push(n),o.components.push(e);break}}return o}}export{p as Component,l as Edge,g as EditGeometry,c as Vertex};

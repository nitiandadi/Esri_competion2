/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isNone as e,abortMaybe as n,isSome as t,removeMaybe as o,unwrap as i}from"../../../core/maybe.js";import{ignoreAbortErrors as r,debounce as a}from"../../../core/promiseUtils.js";import{watch as s}from"../../../core/reactiveUtils.js";import{pointEquals as c}from"../../../layers/graphics/dehydratedFeatureComparison.js";import{clonePoint as l}from"../../../layers/graphics/hydratedFeatures.js";import{EventPipeline as p}from"../dragEventPipeline.js";import{SnappingContext as u}from"./SnappingContext.js";import{TaskPriority as f,ImmediateTask as d}from"../../support/Scheduler.js";function m({predicate:a=(()=>!0),snappingManager:c,snappingContext:l,updatingHandles:u,useZ:f=!0}){const d=new p;if(e(c))return{snappingStep:[j,d],cancelSnapping:j};let m,z=null,T=null,k=null;const w=()=>{z=n(z),c.doneSnapping(),t(T)&&T.frameTask.remove(),T=null,m=o(m),k=null},C=g(c,f,d);let E=null,I=null,U=null;return{snappingStep:[n=>{if(!a(n))return n;const{action:o}=n;if("start"===o){const{info:e}=n,o=x(c.view);if(T=P(l,n,o),T.context.selfSnappingZ=null,!f&&t(e)){const n=Z(l.coordinateHelper,e.handle.component);t(n)&&(T.context.selfSnappingZ={value:n,elevationInfo:l.elevationInfo})}}if(t(T)){const{context:t,originalScenePos:a,originalPos:l}=T,{mapEnd:p,mapStart:d,scenePoints:g}=n,x=h(l,S(p,d)),P=S(d,l),Z={...n,action:"update"},j=T.context,w=v(a,g),b=c.update({point:x,scenePoint:w,context:t});if(U=b,y(p,b,P,f),E=x,I=w,"end"!==o){const{frameTask:n}=T;e(z)&&(z=new AbortController),k=e=>{u.addPromise(r(C({frameTask:n,event:Z,context:j,point:x,scenePoint:w,delta:P,getLastState:()=>({point:E,scenePoint:I,updatePoint:e.forceUpdate?null:U})},i(z).signal)))},k({forceUpdate:!1}),e(m)&&(m=s((()=>c.options.effectiveEnabled),(()=>k?.({forceUpdate:!0}))))}}return"end"===o&&w(),n},d],cancelSnapping:e=>(w(),e)}}function g(n,o,i){return a((async({frameTask:r,point:a,scenePoint:s,context:l,event:p,delta:u,getLastState:f},d)=>{const m=await r.schedule((()=>n.snap({point:a,scenePoint:s,context:l,signal:d})),d);if(m.valid){let s=await r.schedule((()=>m.apply()),d);const g=f();t(g.point)&&a!==g.point&&(s=n.update({point:g.point,scenePoint:g.scenePoint,context:l})),!e(g.updatePoint)&&c(s,g.updatePoint)||(y(p.mapEnd,s,u,o),i.execute(p))}}))}function x(e){return"3d"===e.type?e.resourceController.scheduler.registerTask(f.SNAPPING):d}function P(e,n,o){return{context:new u({editGeometryOperations:e.editGeometryOperations,elevationInfo:e.elevationInfo,pointer:e.pointer,vertexHandle:t(n.info)?n.info.handle:null,excludeFeature:e.excludeFeature,visualizer:e.visualizer}),originalPos:t(n.snapOrigin)?e.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:t(n.scenePoints)?n.scenePoints.sceneStart:null,frameTask:o}}function h(e,[n,t,o]){const i=l(e);return i.x+=n,i.y+=t,i.hasZ&&(i.z+=o),i}function v(n,t){return e(n)||e(t)?null:h(n,S(t.sceneEnd,t.sceneStart))}function S(e,n){const t=e.hasZ&&n.hasZ?e.z-n.z:0;return[e.x-n.x,e.y-n.y,t]}function y(e,n,[t,o,i],r){e.x=n.x+t,e.y=n.y+o,r&&e.hasZ&&n.hasZ&&(e.z=n.z+i)}function Z(n,o){if(!n.hasZ())return null;const i=o.vertices;let r=null;for(const a of i){const o=n.getZ(a.pos);if(t(r)&&t(o)&&Math.abs(o-r)>1e-6)return null;e(r)&&(r=o)}return r}function j(e){return e}export{m as createSnapDragEventPipelineStep};

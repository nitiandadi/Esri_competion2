/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{isSome as r,isNone as s}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as i}from"../../../../core/screenUtils.js";import{c as o}from"../../../../chunks/vec2.js";import{s as a,b as n,e as c,g as l,a as u,c as p,l as f,i as m,m as h}from"../../../../chunks/vec3.js";import{c as d}from"../../../../chunks/vec3f64.js";import{O as g}from"../../../../chunks/vec4f64.js";import{PlaneIndex as A}from"../../../../geometry/support/frustum.js";import{create as _,distance2 as O,fromPoints as S,closestLineSegmentPoint as T}from"../../../../geometry/support/lineSegment.js";import{create as P,fromPoints as j,signedDistance as b,normal as x}from"../../../../geometry/support/plane.js";import{BufferViewVec3f as y,BufferViewVec2f as v}from"../../../../geometry/support/buffer/BufferView.js";import{ShaderOutput as R}from"../core/shaderLibrary/ShaderOutput.js";import E from"../lib/GLMaterial.js";import{Material as N,MaterialParameters as I}from"../lib/Material.js";import{RenderSlot as L}from"../lib/RenderSlot.js";import{isTranslationMatrix as w}from"../lib/Util.js";import{VertexAttribute as C}from"../lib/VertexAttribute.js";import{DefaultBufferWriter as U}from"./DefaultBufferWriter.js";import{PositionColorLayout as V,PositionLayout as B}from"./DefaultLayouts.js";import{writeDefaultAttributes as M}from"./internal/bufferWriterUtils.js";import{NativeLineTechnique as D}from"../shaders/NativeLineTechnique.js";import{NativeLineTechniqueConfiguration as X}from"../shaders/NativeLineTechniqueConfiguration.js";var k;!function(e){e[e.START=0]="START",e[e.END=1]="END"}(k||(k={}));class q extends N{constructor(e){super(e,new G),this._configuration=new X}getConfiguration(e,t){this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._configuration.draped=t.slot===L.DRAPED_MATERIAL;const s=r(this.parameters.stipplePattern);return this._configuration.stippleEnabled=s,this._configuration.stippleOffColorEnabled=s&&r(this.parameters.stippleOffColor),this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._configuration}intersect(t,r,s,i,h,d){if(!s.options.selectionMode||!t.visible)return;if(!w(r))return void e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");const g=t.vertexAttributes.get(C.POSITION).data,_=s.camera,P=re;o(P,s.point);const y=2;a(se[0],P[0]-y,P[1]+y,0),a(se[1],P[0]+y,P[1]+y,0),a(se[2],P[0]+y,P[1]-y,0),a(se[3],P[0]-y,P[1]-y,0);for(let e=0;e<4;e++)if(!_.unprojectFromRenderScreen(se[e],ie[e]))return;j(_.eye,ie[0],ie[1],oe),j(_.eye,ie[1],ie[2],ae),j(_.eye,ie[2],ie[3],ne),j(_.eye,ie[3],ie[0],ce);let v=Number.MAX_VALUE,R=0;for(let e=0;e<g.length-5;e+=3){if(H[0]=g[e]+r[12],H[1]=g[e+1]+r[13],H[2]=g[e+2]+r[14],Q[0]=g[e+3]+r[12],Q[1]=g[e+4]+r[13],Q[2]=g[e+5]+r[14],b(oe,H)<0&&b(oe,Q)<0||b(ae,H)<0&&b(ae,Q)<0||b(ne,H)<0&&b(ne,Q)<0||b(ce,H)<0&&b(ce,Q)<0)continue;if(_.projectToRenderScreen(H,J),_.projectToRenderScreen(Q,K),J[2]<0&&K[2]>0){n(Z,H,Q);const e=_.frustum,t=-b(e[A.NEAR],H)/c(Z,x(e[A.NEAR]));l(Z,Z,t),u(H,H,Z),_.projectToRenderScreen(H,J)}else if(J[2]>0&&K[2]<0){n(Z,Q,H);const e=_.frustum,t=-b(e[A.NEAR],Q)/c(Z,x(e[A.NEAR]));l(Z,Z,t),u(Q,Q,Z),_.projectToRenderScreen(Q,K)}else if(J[2]<0&&K[2]<0)continue;J[2]=0,K[2]=0;const t=O(S(J,K,ee),P);t<v&&(v=t,p(Y,H),p($,Q),R=e/3)}const E=s.rayBegin,N=s.rayEnd;if(v<y*y){let e=Number.MAX_VALUE;if(T(S(Y,$,ee),S(E,N,te),z)){n(z,z,E);const t=f(z);l(z,z,1/t),e=t/m(E,N)}d(e,z,R,!1)}}intersectDraped(e,r,s,i,o,a){if(!s.options.selectionMode)return;const n=e.vertexAttributes.get(C.POSITION).data,c=e.vertexAttributes.get(C.SIZE),l=c?c.data[0]:0,u=i[0],p=i[1],f=((l+1)/2+4)*e.screenToWorldRatio;let m=Number.MAX_VALUE,h=0;for(let d=0;d<n.length-5;d+=3){const e=n[d],r=n[d+1],s=u-e,i=p-r,o=n[d+3]-e,a=n[d+4]-r,c=t((o*s+a*i)/(o*o+a*a),0,1),l=o*c-s,f=a*c-i,g=l*l+f*f;g<m&&(m=g,h=d/3)}m<f*f&&o(a.dist,a.normal,h,!1)}requiresSlot(e,t){return!(t!==R.Color&&t!==R.Highlight&&t!==R.ObjectAndLayerIdColor||e!==L.OPAQUE_MATERIAL&&e!==L.DRAPED_MATERIAL)}createGLMaterial(e){return new W(e)}createBufferWriter(){const e=this.parameters.hasVertexColors?V:B;return s(this.parameters.stipplePattern)?new U(e):new F(e.clone().vec3f(C.AUXPOS1).vec2f(C.UV0))}}class W extends E{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output===R.Color&&this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,t)),this._stipplePattern=t),this.ensureTechnique(D,e)}}class F{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(C.POSITION).length}write(e,t,r,s,i){M(r,this.vertexBufferLayout,e,t,s,i),this._writeAuxpos1(e,r,s,i),this._writeUV0(e,r,s,i)}_writeAuxpos1(e,t,r,s){const i=r.getField(C.AUXPOS1,y),o=t.indices.get(C.POSITION),a=t.vertexAttributes.get(C.POSITION).data,n=e,c=i.typedBufferStride,l=i.typedBuffer;s*=c;for(let u=0;u<o.length-1;u+=2)for(const e of[1,0]){const t=3*o[u+e],r=a[t],i=a[t+1],p=a[t+2],f=n[0]*r+n[4]*i+n[8]*p+n[12],m=n[1]*r+n[5]*i+n[9]*p+n[13],h=n[2]*r+n[6]*i+n[10]*p+n[14];l[s]=f,l[s+1]=m,l[s+2]=h,s+=c}}_writeUV0(e,t,r,s){const i=r.getField(C.UV0,v),o=t.indices.get(C.POSITION),n=t.vertexAttributes.get(C.POSITION).data,c=t.vertexAttributes.get(C.DISTANCETOSTART)?.data,l=i.typedBufferStride,u=i.typedBuffer;let f=0;u[s*=l]=k.START,u[s+1]=f,s+=l;const d=3*o[0],g=a(H,n[d],n[d+1],n[d+2]);e&&h(g,g,e);const A=Q,_=o.length-1;let O=1;const S=c?(e,t,r)=>f=c[r]:(e,t,r)=>f+=m(e,t);for(let m=1;m<_;m+=2){const t=3*o[m];a(A,n[t],n[t+1],n[t+2]),e&&h(A,A,e),S(g,A,O++);for(let e=0;e<2;++e)u[s]=1-e,u[s+1]=f,s+=l;p(g,A)}const T=3*o[_];a(A,n[T],n[T+1],n[T+2]),e&&h(A,A,e),S(g,A,O),u[s]=k.END,u[s+1]=f}}class G extends I{constructor(){super(...arguments),this.color=g,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1,this.stippleTexture=null}}const H=d(),Q=d(),Z=d(),z=d(),J=i(),K=i(),Y=d(),$=d(),ee=_(),te=_(),re=d(),se=[i(),i(),i(),i()],ie=[d(),d(),d(),d()],oe=P(),ae=P(),ne=P(),ce=P();export{q as NativeLineMaterial,G as Parameters};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import{equals as i}from"../../../../core/arrayUtils.js";import s from"../../../../core/Handles.js";import{smoothstep as r}from"../../../../core/mathUtils.js";import{isSome as a,isNone as o,disposeMaybe as n,releaseMaybe as h}from"../../../../core/maybe.js";import{watch as c,syncAndInitial as _,sync as l}from"../../../../core/reactiveUtils.js";import{property as u}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as m}from"../../../../core/accessorSupport/decorators/subclass.js";import{F as p,c as d}from"../../../../chunks/vec3.js";import{c as g}from"../../../../chunks/vec3f64.js";import{BindParameters as f}from"./BindParameters.js";import{ZERO as v}from"./depthRange.js";import{createQuadVAO as b}from"./glUtil3D.js";import{ShadowCastRenderer as w,shadowCastDisabledElevationThreshold as A,shadowCastDisableElevationMax as R,shadowCastDisableElevationMin as y}from"./ShadowCastRenderer.js";import{ShadowMap as T}from"./ShadowMap.js";import{S as C,a as D}from"../../../../chunks/ShadowCastAccumulate.glsl.js";import{ShadowCastAccumulateTechnique as S}from"../shaders/ShadowCastAccumulateTechnique.js";import{TaskPriority as F}from"../../../support/Scheduler.js";import{TargetType as j,DepthStencilTargetType as E,TextureType as P,PixelFormat as x,PixelType as q,TextureSamplingMode as M,TextureWrapMode as I,ClearBufferBit as U}from"../../../webgl/enums.js";import{FramebufferObject as L}from"../../../webgl/FramebufferObject.js";import{vertexCount as O}from"../../../webgl/Util.js";let B=class extends t{constructor(e,t,i,r,o,n){super({}),this._rctx=e,this._stage=i,this._prepareForShadowMapPass=r,this._renderToShadowMap=o,this._requestRender=n,this._progress=0,this._sampleCount=0,this._passParameters=new C,this._enabledInternal=!1,this._cachedLightDirections=[],this._depthRange=v,this._previewing=!1,this._handles=new s,this._cameraForcedForScreenshot=!1,this._bindParameters=new f(new T(e,i.viewingMode),null,null),this._bindParameters.shadowMap.enabled=!0,this._vao=b(e);const h={colorTarget:j.TEXTURE,depthStencilTarget:E.NONE,width:0,height:0},u={target:P.TEXTURE_2D,pixelFormat:x.RGBA,dataType:q.UNSIGNED_BYTE,samplingMode:M.LINEAR,wrapMode:I.CLAMP_TO_EDGE,width:0,height:0};this._fbo=new L(e,h,u),this._accumulationRenderer=new w(t,e,this,n);const m=this._stage.view.resourceController.scheduler;this._handles.add([m.registerTask(F.SHADOW_ACCUMULATOR,this),c((()=>i.renderView),(e=>{this._handles.remove(k),a(e)&&this._handles.add(e.events.on("force-camera-for-screenshot",(()=>this._cameraForcedForScreenshot=!0)),k)}),_),c((()=>this._previewing),(()=>this._requestRenderIfEnabled()),l)])}normalizeCtorArgs(){return{}}get computedSamples(){return this._progress}get shadowCastTexture(){return this._fbo.colorTexture}get isAccumulating(){return this._isPreviewing||this._isRefining}get _accumulationTechnique(){if(o(this._accumulationTechniqueCached)){const e={rctx:this._rctx,viewingMode:this._stage.viewingMode};this._accumulationTechniqueCached=new S(e)}return this._accumulationTechniqueCached}get _isRefining(){return this._isActive&&!this._isDoneAccumulating&&!this._previewing}get _isPreviewing(){return this._isActive&&this._previewing}get _isActive(){return this._enabledInternal&&this._sampleCount>0}get canAccumulate(){return null!==this._passParameters.linearDepthTexture&&this._depthRange!==v&&this._opacityFromElevation>A}get _isDoneAccumulating(){return this._progress>=this._sampleCount}get _lightDirections(){return this._cachedLightDirections}set _lightDirections(e){const t=this._cachedLightDirections;if(i(t,e,p))return;const s=Math.min(D,e.length);t.length=s,this._sampleCount=s;for(let i=0;i<s;++i)t[i]=d(t[i]??g(),e[i]);this._invalidate()}get _opacityFromElevation(){return this._accumulationRenderer.opacityFromElevation}set _opacityFromElevation(e){this._accumulationRenderer.opacityFromElevation=e}get running(){return this._isRefining&&this.canAccumulate&&this._progress>0}runTask(e){for(this._prepareForShadowMapPass(this._bindParameters);!e.done&&!this._isDoneAccumulating;)this._accumulateShadow(),e.madeProgress();this._requestRender()}renderAccumulation(e,t,i,s){if(this._depthRange=t,this._updateCamera(i),this._bindParameters.contentCamera=s,this._passParameters.linearDepthTexture=e,this._passParameters.origin=this._bindParameters.camera.center,this.notifyChange("canAccumulate"),!this.isAccumulating||!this.canAccumulate)return;(this._previewing||0===this._progress||this._cameraForcedForScreenshot)&&this._clear();const r=this._cameraForcedForScreenshot?this._sampleCount:Math.min(N,this._sampleCount-this._progress);for(let a=0;a<r;++a)this._accumulateShadow();this._cameraForcedForScreenshot=!1,this._requestRender()}render(e){this._accumulationRenderer.render(e)}dispose(){this._stop(),this._handles.destroy(),this._accumulationRenderer=n(this._accumulationRenderer),this._bindParameters.shadowMap.dispose(),this._fbo=n(this._fbo),this._vao=n(this._vao),this._accumulationTechniqueCached=h(this._accumulationTechniqueCached),this._cachedLightDirections.length=0,this._sampleCount=0}setOptions(e){void 0!==e.enabled&&(this._enabled=e.enabled),void 0!==e.previewing&&(this._previewing=e.previewing),void 0!==e.lightDirections&&(this._lightDirections=e.lightDirections),this._accumulationRenderer.setOptions(e)}readAccumulatedShadow(e,t){return!this._isActive||this._progress<1||e<0||e>this._fbo.width||t<0||t>this._fbo.height?0:(this._fbo.readPixels(e,t,1,1,x.RGBA,q.UNSIGNED_BYTE,H),H[0]/this._progress)}_start(){this._progress=0,this._enabledInternal=!0}_stop(){this._enabledInternal=!1}_invalidate(){this._progress=0,this._requestRenderIfEnabled()}_clear(){this._rctx.bindFramebuffer(this._fbo),this._rctx.setClearColor(0,0,0,0),this._rctx.clearSafe(U.COLOR_BUFFER_BIT),this._progress=0}_accumulateShadow(){this._renderToShadowMap(this._bindParameters,this._sampleLightDirection(),this._depthRange);const e=this._accumulationTechnique;this._rctx.bindFramebuffer(this._fbo),this._rctx.bindTechnique(e,this._passParameters,this._bindParameters),this._rctx.bindVAO(this._vao),this._rctx.drawArrays(e.primitiveType,0,O(this._vao,"geometry"))}_sampleLightDirection(){return this._progress++,this._lightDirections[this._progress*G%this._lightDirections.length]}_updateCamera(e){e.equals(this._bindParameters.camera)||(this._bindParameters.camera.copyFrom(e),this._fbo.resize(e.fullWidth,e.fullHeight),this._opacityFromElevation=1-r(y,R,e.relativeElevation))}set _enabled(e){e!==this._enabledInternal&&(e?this._start():this._stop())}_requestRenderIfEnabled(){this._enabledInternal&&this._requestRender()}get test(){const e=this;return{lightDirections:this._lightDirections,get isDone(){return e._isDoneAccumulating},get isActive(){return e._isActive}}}};e([u()],B.prototype,"_progress",void 0),e([u()],B.prototype,"_sampleCount",void 0),e([u()],B.prototype,"_enabledInternal",void 0),e([u()],B.prototype,"_depthRange",void 0),e([u()],B.prototype,"_previewing",void 0),e([u()],B.prototype,"_accumulationRenderer",void 0),e([u()],B.prototype,"_isRefining",null),e([u()],B.prototype,"_isActive",null),e([u()],B.prototype,"canAccumulate",null),e([u()],B.prototype,"_isDoneAccumulating",null),e([u()],B.prototype,"_opacityFromElevation",null),e([u()],B.prototype,"running",null),B=e([m("esri.views.3d.webgl-engine.lib.ShadowAccumulator")],B);const N=6,k="renderView",G=104729,H=new Uint8Array(4);export{B as ShadowAccumulator};

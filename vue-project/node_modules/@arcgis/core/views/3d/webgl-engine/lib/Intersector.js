/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isSome as t,unwrapOr as r}from"../../../../core/maybe.js";import{c as s}from"../../../../chunks/mat4.js";import{c as i,I as e}from"../../../../chunks/mat4f64.js";import{a,m as n,g as o,l as h,c as d,n as c}from"../../../../chunks/vec3.js";import{c as l,U as m}from"../../../../chunks/vec3f64.js";import{t as f}from"../../../../chunks/vec4.js";import{c as y}from"../../../../chunks/vec4f64.js";import{create as u,fromPoints as p,copy as g}from"../../../../geometry/support/ray.js";import{ViewingMode as _}from"../../../ViewingMode.js";import{IntersectorOptions as O,StoreResults as L,IntersectorType as j}from"./IntersectorInterfaces.js";import{HudTarget as v}from"./IntersectorTarget.js";import{isValidIntersectorResult as E}from"./intersectorUtils.js";import{IntersectorTransform as w,getVerticalOffsetObject3D as b}from"./verticalOffsetUtils.js";const A=1e-5;class T{constructor(t){this.options=new O,this._results=new I,this.transform=new w,this.tolerance=A,this.verticalOffset=null,this._ray=u(),this._rayEnd=l(),this._rayBeginTransformed=l(),this._rayEndTransformed=l(),this.viewingMode=t??_.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,r,s){this.resetWithRay(p(t,r,this._ray),s)}resetWithRay(t,r){this.camera=r,t!==this._ray&&g(t,this._ray),0!==this.options.verticalOffset?this.viewingMode===_.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,a(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(r=null,s,i,e,a){this.point=s,this.filterPredicate=e,this.tolerance=i??A;const n=b(this.verticalOffset);if(t(r)&&r.length>0){const s=a?t=>{a(t)&&this.intersectObject(t)}:t=>{this.intersectObject(t)};for(const i of r){const r=i.getSpatialQueryAccelerator&&i.getSpatialQueryAccelerator();t(r)?(t(n)?r.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,s,n):r.forEachAlongRay(this._ray.origin,this._ray.direction,s),this.options.selectionMode&&this.options.hud&&r.forEachDegenerateObject(s)):i.objects.forAll((t=>s(t)))}}this.sortResults()}intersectObject(r){const s=r.geometries;if(!s)return;const i=r.transformation,a=b(this.verticalOffset);for(const o of s){if(!o.visible)continue;const{material:s,id:h}=o;this.transform.setAndInvalidateLazyTransforms(i,o.shaderTransformation),n(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),n(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const d=this.transform.transform;t(a)&&(a.objectTransform=this.transform),s.intersect(o,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,((s,i,a,n,o,c)=>{if(s>=0){if(t(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEnd,s))return;const l=n?this._results.hud:this._results,m=n?t=>{const n=new v(r,h,a,c);t.set(j.HUD,n,s,i,e,o)}:t=>t.set(j.OBJECT,{object:r,geometryId:h,triangleNr:a},s,i,d,o);if((null==l.min.drapedLayerOrder||o>=l.min.drapedLayerOrder)&&(null==l.min.dist||s<l.min.dist)&&m(l.min),this.options.store!==L.MIN&&(null==l.max.drapedLayerOrder||o<l.max.drapedLayerOrder)&&(null==l.max.dist||s>l.max.dist)&&m(l.max),this.options.store===L.ALL)if(n){const t=new N(this._ray);m(t),this._results.hud.all.push(t)}else{const t=new M(this._ray);m(t),this._results.all.push(t)}}}))}}sortResults(t=this._results.all){t.sort(((t,s)=>t.dist!==s.dist?r(t.dist,0)-r(s.dist,0):t.drapedLayerOrder!==s.drapedLayerOrder?r(t.drapedLayerOrder,Number.MAX_VALUE)-r(s.drapedLayerOrder,Number.MAX_VALUE):r(s.drapedLayerGraphicOrder,Number.MIN_VALUE)-r(t.drapedLayerGraphicOrder,Number.MIN_VALUE)))}}function x(t){return new T(t)}class I{constructor(){this.min=new M(u()),this.max=new M(u()),this.hud={min:new N(u()),max:new N(u()),all:new Array},this.ground=new M(u()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}class M{get ray(){return this._ray}get distanceInRenderSpace(){return t(this.dist)?(o(B,this.ray.direction,this.dist),h(B)):null}getIntersectionPoint(t){return!!E(this)&&(o(B,this.ray.direction,this.dist),a(t,this.ray.origin,B),!0)}getTransformedNormal(t){return d(G,this.normal),G[3]=0,f(G,G,this.transformation),d(t,G),c(t,t)}constructor(t){this.intersector=j.OBJECT,this.normal=l(),this.transformation=i(),this._ray=u(),this.init(t)}init(t){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=j.OBJECT,g(t,this._ray)}set(t,i,a,n,o,h,c){this.intersector=t,this.dist=a,d(this.normal,r(n,m)),s(this.transformation,r(o,e)),this.target=i,this.drapedLayerOrder=h,this.drapedLayerGraphicOrder=c}copy(t){g(t.ray,this._ray),this.intersector=t.intersector,this.dist=t.dist,this.target=t.target,this.drapedLayerOrder=t.drapedLayerOrder,this.drapedLayerGraphicOrder=t.drapedLayerGraphicOrder,d(this.normal,t.normal),s(this.transformation,t.transformation)}}class N extends M{constructor(){super(...arguments),this.intersector=j.HUD}}function U(t){return new M(t)}const B=l(),G=y();export{A as DEFAULT_TOLERANCE,x as newIntersector,U as newIntersectorResult};

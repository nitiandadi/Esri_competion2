/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isNone as t,isSome as e,unwrapOr as i}from"../../../../core/maybe.js";import{I as s,b as n}from"../../../../chunks/mat4f64.js";import{m as r}from"../../../../chunks/vec3.js";import{cloneAttributeData as o}from"./AttributeArray.js";import{Object3DState as h}from"./basicInterfaces.js";import{BoundingInfo as a}from"./BoundingInfo.js";import{ContentObject as u}from"./ContentObject.js";import{ContentObjectType as g}from"./ContentObjectType.js";import{computeAttachmentOriginTriangles as c,computeAttachmentOriginLines as m,computeAttachmentOriginPoints as d}from"./geometryDataUtils.js";import{generateDefaultIndexArray as l,compactIndices as f}from"./Indices.js";import{Object3DStateID as I}from"./Object3DStateID.js";import{assert as _}from"./Util.js";import{VertexAttribute as b}from"./VertexAttribute.js";import{addObject3DStateID as p,removeObject3DStateID as O}from"../materials/renderers/utils.js";class v extends u{constructor(t,e,i=[],s=null,n=g.Mesh,r=null,o=-1){super(),this.material=t,this.mapPositions=s,this.type=n,this.objectAndLayerIdColor=r,this.edgeIndicesLength=o,this.visible=!0,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[h,a]of e)a&&this._vertexAttributes.set(h,{...a});if(null==i||0===i.length){const t=A(this._vertexAttributes),e=l(t);this.edgeIndicesLength=this.edgeIndicesLength<0?t:this.edgeIndicesLength;for(const i of this._vertexAttributes.keys())this._indices.set(i,e)}else for(const[h,a]of i)a&&(this._indices.set(h,f(a)),h===b.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(h).length:this.edgeIndicesLength))}instantiate(t={}){const e=new v(t.material||this.material,[],void 0,this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._vertexAttributes.forEach(((t,i)=>{t.exclusive=!1,e._vertexAttributes.set(i,t)})),this._indices.forEach(((t,i)=>e._indices.set(i,t))),e._boundingInfo=this._boundingInfo,e.transformation=t.transformation||this.transformation,e}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(t){let e=this._vertexAttributes.get(t);return e&&!e.exclusive&&(e={...e,exclusive:!0,data:o(e.data)},this._vertexAttributes.set(t,e)),e}get indices(){return this._indices}get indexCount(){const t=this._indices.values().next().value;return t?t.length:0}get faceCount(){return this.indexCount/3}get boundingInfo(){return t(this._boundingInfo)&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===g.Mesh?this._computeAttachmentOriginTriangles(t):this.type===g.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(e(this._transformation)&&r(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){const e=this.indices.get(b.POSITION),i=this.vertexAttributes.get(b.POSITION);return c(i,e,t)}_computeAttachmentOriginLines(t){const e=this.vertexAttributes.get(b.POSITION),i=this.indices.get(b.POSITION);return m(e,i,i&&x(this.material.parameters,e,i),t)}_computeAttachmentOriginPoints(t){const e=this.indices.get(b.POSITION),i=this.vertexAttributes.get(b.POSITION);return d(i,e,t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.indices.get(b.POSITION),e=this.vertexAttributes.get(b.POSITION);if(!t||0===t.length||!e)return null;const i=this.type===g.Mesh?3:1;_(t.length%i==0,"Indexing error: "+t.length+" not divisible by "+i);const s=l(t.length/i);return new a(s,i,t,e)}get transformation(){return i(this._transformation,s)}set transformation(t){this._transformation=t&&t!==s?n(t):null}get shaderTransformation(){return e(this._shaderTransformer)?this._shaderTransformer(this.transformation):this.transformation}get shaderTransformer(){return this._shaderTransformer}set shaderTransformer(t){this._shaderTransformer=t}get hasVolatileTransformation(){return e(this._shaderTransformer)}addHighlight(){const t=new I(h.Highlight);return this.highlights=p(this.highlights,t),t}removeHighlight(t){this.highlights=O(this.highlights,t)}}function A(t){const e=t.values().next().value;return null==e?0:e.data.length/e.size}function x(t,e,i){return!(!("isClosed"in t)||!t.isClosed)&&(i?i.length>2:e.data.length>6)}export{v as Geometry};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{c as t}from"../../../../chunks/mat2f64.js";import{w as e,d as i}from"../../../../chunks/mat4.js";import{c as s}from"../../../../chunks/mat4f64.js";import{s as r,h as o,q as h,a as n,b as a,j as l,f as u,i as p}from"../../../../chunks/vec2.js";import{a as f,d as x,f as c}from"../../../../chunks/vec2f64.js";import{e as d,c as m,a as v,n as g,g as b,b as V,f as A,l as C,s as D,m as I}from"../../../../chunks/vec3.js";import{c as N}from"../../../../chunks/vec3f64.js";import{create as P,fromPositionAndNormal as R,intersectRay as S}from"../../../../geometry/support/plane.js";import{wrap as T}from"../../../../geometry/support/ray.js";import{Attribute as _}from"./Attribute.js";import{newFloatArray as y}from"./FloatArray.js";import{makeOrthoBasisDirUpFallback as U}from"./GeometryUtil.js";import{compactIndices as L}from"./Indices.js";import{VertexAttribute as O}from"./VertexAttribute.js";import{intersectTriangles as E}from"../materials/internal/MaterialUtil.js";function M(){return{up:N(),right:N()}}function k(t,e,i){I(t.up,e.up,i),I(t.right,e.right,i)}function w(t,e,i){t[0]=i[0]*e.right[0]+i[1]*e.up[0],t[1]=i[0]*e.right[1]+i[1]*e.up[1],t[2]=i[0]*e.right[2]+i[1]*e.up[2]}function B(t,e,i){r(t,d(i,e.right),d(i,e.up))}class G{constructor(){this.pos=N(),this.posES=N(),this.vLeft=N(),this.vRight=N(),this.vMinSiblingLength=0,this.frame=M(),this.rotationFrameUp=N(),this.rotationRight=f(),this.rotationAngle=0,this.miterStretch=t(),this.maxStretchDistance=0}setFrameFromUpVector(t){m(this.frame.up,t),v(at,this.vLeft,this.vRight),g(at,at),b(nt,this.frame.up,d(at,this.frame.up)),V(pt,at,nt),g(pt,pt),A(this.frame.right,pt,this.frame.up)}}class j{constructor(){this.vertices=[],this.vertexIndices=[],this.vertexNormals=[],this.poles=[],this.poleIndices=[]}addVertex(t,e){return this.vertices.push(x(t)),this.vertexNormals.push(x(e)),this.vertices.length-1}addPole(t,e=null){return this.poles.push({position:x(t),normal:e?x(e):null}),this.poles.length-1}addSegment(t,e=null){this.vertexIndices.push(t.v0),this.vertexIndices.push(t.v1),e&&(this.poleIndices.push(e.v0),this.poleIndices.push(e.v1))}get numSegments(){return this.vertexIndices.length/2}translate(t,e){for(const i of this.vertices)i[0]+=t,i[1]+=e;for(const i of this.poles)i.position[0]+=t,i.position[1]+=e}}function F(t=20){const e=.5,i=new j,s={v0:0,v1:0};i.addPole(c(0,0));for(let o=0;o<t;++o){const s=2*o*Math.PI/t,r=Math.cos(s),h=Math.sin(s),n=c(r*e,h*e),a=c(r,h);i.addVertex(n,a)}for(let o=0;o<t-1;++o){const t={v0:o,v1:o+1};i.addSegment(t,s)}const r={v0:t-1,v1:0};return i.addSegment(r,s),i}function z(){const t=1,e=1,i=new j,s=c(.5*-t,.5*-e),r=c(.5*t,.5*-e),o=c(.5*t,.5*e),h=c(.5*-t,.5*e),n=c(0,-1),a=c(1,0),l=c(0,1),u=c(-1,0);return i.addPole(c(0,.5*e),l),i.addPole(c(0,.5*e)),i.addPole(c(0,.5*-e)),i.addPole(c(0,.5*-e),n),i.addVertex(s,n),i.addVertex(r,n),i.addSegment({v0:0,v1:1},{v0:3,v1:3}),i.addVertex(r,a),i.addVertex(o,a),i.addSegment({v0:2,v1:3},{v0:2,v1:1}),i.addVertex(o,l),i.addVertex(h,l),i.addSegment({v0:4,v1:5},{v0:0,v1:0}),i.addVertex(h,u),i.addVertex(s,u),i.addSegment({v0:6,v1:7},{v0:1,v1:2}),i}class J{constructor(t){this.vertices=t,this.offset=N(),this.xform=s();const i=Math.floor((t.length-1)/2);m(this.offset,this.vertices[i].pos);for(const e of this.vertices)V(e.pos,e.pos,this.offset);e(this.xform,this.xform,this.offset),this.updatePathVertexInformation()}updatePathVertexInformation(){const t=this.vertices.length,e=this.vertices[0];e.index=0,e.vLeft=N(),V(e.vRight,this.vertices[1].pos,e.pos);let i=C(e.vRight);e.vMinSiblingLength=i,g(e.vRight,e.vRight);let s=e;for(let r=1;r<t;++r){const e=this.vertices[r];if(e.index=r,e.vLeft=s.vRight,r<t-1){V(e.vRight,this.vertices[r+1].pos,e.pos);const t=C(e.vRight);e.vMinSiblingLength=Math.min(i,t),i=t,g(e.vRight,e.vRight)}else m(e.vRight,e.vLeft),e.vMinSiblingLength=i;s=e}}}function q(t,e){let i=null;const s=t.vertices.length,r=.99619469809,o=N(),h=N(),n=N(),a=N(),l=N(),u=N(),p=P();let f=t.vertices[0];m(h,e),D(o,0,1,0),U(f.vRight,h,o,o,n,h,r),m(f.frame.up,h),m(f.frame.right,n),i=f;for(let x=1;x<s;++x){f=t.vertices[x],v(l,f.vLeft,f.vRight);let e=C(l);e>0?(e=1/Math.sqrt(e),l[0]=l[0]*e,l[1]=l[1]*e,l[2]=l[2]*e):(l[0]=f.vRight[0],l[1]=f.vRight[1],l[2]=f.vRight[2]),v(u,i.pos,i.frame.up),R(f.pos,l,p);S(p,T(u,f.vLeft),a)?(V(a,a,f.pos),g(h,a),A(n,l,h),g(n,n)):U(l,i.frame.up,i.frame.right,o,n,h,r),m(f.frame.up,h),m(f.frame.right,n),i=f}}class H{}class X{numProfilesPerJoin(){return 1}extrude(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],!1)}}class K{constructor(t=.8*Math.PI,e=1){this.cutoffAngle=t,this.numBendSubdivisions=e}numProfilesPerJoin(){return this.numBendSubdivisions+1}extrude(t,e,s){const r=ft;if(Math.abs(t.rotationAngle)>=this.cutoffAngle)for(let n=0;n<this.numBendSubdivisions+1;++n){i(xt,.5*-t.rotationAngle+n*t.rotationAngle/this.numBendSubdivisions,t.rotationFrameUp),k(r,t.frame,xt);for(let i=0;i<e.vertices.length;++i){o(e.vertices[i],t.rotationRight)*t.rotationAngle>=0?s(t.index,r,e.vertices[i],e.vertexNormals[i],!1):(h(rt,e.vertices[i],t.miterStretch),s(t.index,t.frame,rt,e.vertexNormals[i],!0))}}else for(let i=0;i<this.numBendSubdivisions+1;++i)for(let r=0;r<e.vertices.length;++r){const i=o(e.vertices[r],t.rotationRight)*t.rotationAngle>=0;h(rt,e.vertices[r],t.miterStretch),s(t.index,t.frame,rt,e.vertexNormals[r],!i)}}}class Q{rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],0,0)}}class W extends Q{constructor(){super()}getNumVertices(){return 0}getNumIndices(){return 0}rebuildCapGeometry(){}buildTopology(){}}class Y extends Q{constructor(t,e=0,i=!1){super(),this.profile=t,this.profilePlaneOffset=e,this.flip=i}getNumVertices(){return this.profile.vertices.length}getNumIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(t,e,i){for(let s=0;s<e.vertices.length;++s)i(t.index,t.frame,e.vertices[s],e.vertexNormals[s],this.profilePlaneOffset,0)}rebuildCapGeometry(t,e){const i=ot;r(i,0,0);const s=this.flip?1:-1;for(let r=0;r<this.profile.vertices.length;++r)e(t.index,t.frame,this.profile.vertices[r],i,this.profilePlaneOffset,s)}buildTopology(t,e){const i=this.vertexBufferStart+this.profile.vertexIndices[0];for(let s=1;s<this.profile.numSegments;++s){const t=this.profile.vertexIndices[2*s+0],r=this.profile.vertexIndices[2*s+1],o=this.vertexBufferStart+t,h=this.vertexBufferStart+r;this.flip?e(h,o,i):e(i,o,h)}}}class Z extends Q{constructor(t){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=t.profile,this.flip=t.flip,this.sign=this.flip?1:-1,this.breakNormals=t.breakNormals,this.numSegments=t.subdivisions}getNumVertices(){let t=0;return t=this.profile.vertices.length*(this.numSegments-1),this.breakNormals&&(t+=this.profile.vertices.length),t+=this.profile.poles.length,t}getNumIndices(){let t=0;t+=2*this.profile.numSegments*(this.numSegments-1);for(let e=0;e<this.profile.numSegments;++e){const i=this.profile.vertexIndices[2*e+0],s=this.profile.vertexIndices[2*e+1];this.profile.poleIndices[i]===this.profile.poleIndices[s]?t+=1:t+=2}return 3*t}rebuildCapGeometry(t,e){const i=t.frame,s=.5*this.sign,o=rt,h=ot;r(h,0,0);for(let r=0;r<this.profile.poles.length;++r){const o=this.profile.poles[r];o.normal?e(t.index,i,o.position,o.normal,s,0):e(t.index,i,o.position,h,s,this.sign)}if(this.breakNormals)for(let r=0;r<this.profile.vertices.length;++r)e(t.index,i,this.profile.vertices[r],this.profile.vertexNormals[r],0,0);for(let r=0;r<this.numSegments-1;++r){const p=(1-(r+1)/this.numSegments)*Math.PI*.5,f=Math.sin(p),x=Math.cos(p);for(let r=0;r<this.profile.vertices.length;++r){const p=this.profile.poles[this.profile.poleIndices[r]];n(o,this.profile.vertices[r],p.position),a(o,o,f),p.normal?(l(o,o,p.position),e(t.index,i,o,p.normal,s*x,0)):(u(h,o),a(h,h,f),l(o,o,p.position),e(t.index,i,o,h,s*x,this.sign*x))}}}buildTopology(t,e){const i=this.breakNormals?this.vertexBufferStart+this.profile.poles.length:this.firstProfileVertexIndex,s=this.breakNormals?this.vertexBufferStart+this.profile.poles.length+this.profile.vertices.length:this.vertexBufferStart+this.profile.poles.length;for(let r=0;r<this.profile.numSegments;++r){const t=this.profile.vertexIndices[2*r+0],o=this.profile.vertexIndices[2*r+1],h=this.vertexBufferStart+this.profile.poleIndices[t],n=this.vertexBufferStart+this.profile.poleIndices[o];let a=i+t,l=i+o;for(let i=0;i<this.numSegments-1;++i){const r=s+i*this.profile.vertices.length+t,h=s+i*this.profile.vertices.length+o;this.flip?(e(r,l,a),e(l,r,h)):(e(a,l,r),e(h,r,l)),a=r,l=h}this.flip?(e(h,l,a),h!==n&&e(h,n,l)):(e(a,l,h),h!==n&&e(l,n,h))}}}class ${constructor(t,e,i,s,r,o={}){this.options=o,this._extrusionVertexCount=0,this.numExtrusionProfiles=0,this.numVerticesTotal=0,this.numNormalsTotal=0,this.profile=e,this.path=t,this.extruder=i,this.startCap=s,this.endCap=r;const h=this.path.vertices.length-2;this.numExtrusionProfiles=i.numProfilesPerJoin()*h+2,this.numVerticesTotal=e.vertices.length*this.numExtrusionProfiles,this.numNormalsTotal=this.numVerticesTotal,this.startCap.vertexBufferStart=this.numVerticesTotal;const n=this.startCap.getNumVertices();this.numVerticesTotal+=n,this.numNormalsTotal+=n,this.endCap.vertexBufferStart=this.numVerticesTotal;const a=this.endCap.getNumVertices();this.numVerticesTotal+=a,this.numNormalsTotal+=a,this.pathVertexData=y(1*this.numVerticesTotal),this.profileRightAxisData=y(4*this.numVerticesTotal),this.profileUpAxisData=y(4*this.numVerticesTotal),this.profileVertexAndNormalData=y(4*this.numVerticesTotal),this.originData=y(3*this.path.vertices.length),this._rebuildGeometry(),this.buildTopology()}emitVertex(t,e,i,s,r){if(this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,r){const e=this.path.vertices[t];this.profileRightAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[0]*e.maxStretchDistance,this.profileUpAxisData[4*this._extrusionVertexCount+3]=e.rotationRight[1]*e.maxStretchDistance}else this.profileRightAxisData[4*this._extrusionVertexCount+3]=0,this.profileUpAxisData[4*this._extrusionVertexCount+3]=0;++this._extrusionVertexCount}emitCapVertex(t,e,i,s,r,o){this.profileRightAxisData[4*this._extrusionVertexCount+0]=e.right[0],this.profileRightAxisData[4*this._extrusionVertexCount+1]=e.right[1],this.profileRightAxisData[4*this._extrusionVertexCount+2]=e.right[2],this.profileUpAxisData[4*this._extrusionVertexCount+0]=e.up[0],this.profileUpAxisData[4*this._extrusionVertexCount+1]=e.up[1],this.profileUpAxisData[4*this._extrusionVertexCount+2]=e.up[2],this.profileVertexAndNormalData[4*this._extrusionVertexCount+0]=i[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+1]=i[1],this.profileVertexAndNormalData[4*this._extrusionVertexCount+2]=s[0],this.profileVertexAndNormalData[4*this._extrusionVertexCount+3]=s[1],this.pathVertexData[this._extrusionVertexCount]=t,this.profileRightAxisData[4*this._extrusionVertexCount+3]=r,this.profileUpAxisData[4*this._extrusionVertexCount+3]=o,++this._extrusionVertexCount}_rebuildGeometry(){const t=(t,e,i,s,r)=>this.emitVertex(t,e,i,s,r),e=(t,e,i,s,r,o)=>this.emitCapVertex(t,e,i,s,r,o);this._extrusionVertexCount=0;for(const i of this.path.vertices)this.originData[3*i.index+0]=i.pos[0],this.originData[3*i.index+1]=i.pos[1],this.originData[3*i.index+2]=i.pos[2];this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0],this.profile,e);for(let i=1;i<this.path.vertices.length-1;++i)this.extruder.extrude(this.path.vertices[i],this.profile,t);this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length-1],this.profile,e),this.startCap.rebuildCapGeometry(this.path.vertices[0],e),this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length-1],e)}buildTopology(){const t=this.profile.vertices.length,e=this.profile.numSegments,i=this.numExtrusionProfiles-1;let s=3*(2*(e*i));this.startCap.indexBufferStart=s,this.startCap.firstProfileVertexIndex=0,s+=this.startCap.getNumIndices(),this.endCap.indexBufferStart=s,this.endCap.firstProfileVertexIndex=t*(this.numExtrusionProfiles-1);const r=new Array,o=new Array,h=new Array,n=(t,e,i)=>{r.push(t),r.push(e),r.push(i),o.push(t),o.push(e),o.push(i),h.push(this.pathVertexData[t]),h.push(this.pathVertexData[e]),h.push(this.pathVertexData[i])};for(let a=0;a<e;++a){const e=this.profile.vertexIndices[2*a],s=this.profile.vertexIndices[2*a+1];for(let r=0;r<i;++r){const i=r*t+e,o=(r+1)*t+s,h=r*t+s;n(i,(r+1)*t+e,o),n(i,o,h)}}this.startCap.buildTopology(this.path.vertices[0],n),this.endCap.buildTopology(this.path.vertices[this.path.vertices.length-1],n),this.vertexIndices=L(r),this.normalIndices=L(o),this.pathVertexIndices=L(h)}onPathChanged(){this._rebuildGeometry()}}class tt{constructor(t){this.builder=t}get xform(){return this.builder.path.xform}onPathChanged(){this.builder.onPathChanged()}}class et extends tt{constructor(t){super(t),this.vertexAttributePosition=null,this.vertexAttributeNormal=null,this.vertexAttributeColor=null,this.vertexAttributePosition=y(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=y(3*this.builder.numNormalsTotal),this.vertexAttributeColor=new Uint8Array(4),this.vertexAttributeColor[0]=255,this.vertexAttributeColor[1]=255,this.vertexAttributeColor[2]=255,this.vertexAttributeColor[3]=255}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(t){this.size=t;for(let e=0;e<this.builder.numVerticesTotal;++e){let i=this.builder.pathVertexData[e];const s=0===i||i===this.builder.path.vertices.length-1;i*=3;const h=st;D(h,this.builder.originData[i++],this.builder.originData[i++],this.builder.originData[i]);const n=4*e,f=nt,x=rt,c=at,d=lt,m=ut;let v=0,g=0;if(D(d,this.builder.profileRightAxisData[n],this.builder.profileRightAxisData[n+1],this.builder.profileRightAxisData[n+2]),D(m,this.builder.profileUpAxisData[n],this.builder.profileUpAxisData[n+1],this.builder.profileUpAxisData[n+2]),r(x,this.builder.profileVertexAndNormalData[n]*t[0],this.builder.profileVertexAndNormalData[n+1]*t[1]),s)A(c,m,d),v=this.builder.profileRightAxisData[n+3]*t[0],g=this.builder.profileUpAxisData[n+3];else{const t=ot,e=ht;r(t,this.builder.profileRightAxisData[n+3],this.builder.profileUpAxisData[n+3]);const i=p(t);u(t,t);const s=o(x,t);if(Math.abs(s)>i){r(e,-t[1],t[0]);const h=o(x,e);a(t,t,i*Math.sign(s)),a(e,e,h),l(x,t,e)}D(c,0,0,0)}D(f,d[0]*x[0]+m[0]*x[1],d[1]*x[0]+m[1]*x[1],d[2]*x[0]+m[2]*x[1]),this.vertexAttributePosition[3*e+0]=h[0]+f[0]+c[0]*v,this.vertexAttributePosition[3*e+1]=h[1]+f[1]+c[1]*v,this.vertexAttributePosition[3*e+2]=h[2]+f[2]+c[2]*v;const b=rt;r(b,this.builder.profileVertexAndNormalData[n+2],this.builder.profileVertexAndNormalData[n+3]),this.vertexAttributeNormal[3*e+0]=d[0]*b[0]+m[0]*b[1]+c[0]*g,this.vertexAttributeNormal[3*e+1]=d[1]*b[0]+m[1]*b[1]+c[1]*g,this.vertexAttributeNormal[3*e+2]=d[2]*b[0]+m[2]*b[1]+c[2]*g}}createGeometryData(){const t=[[O.POSITION,this.builder.vertexIndices],[O.NORMAL,this.builder.normalIndices]],e=[[O.POSITION,new _(this.vertexAttributePosition,3,!0)],[O.NORMAL,new _(this.vertexAttributeNormal,3,!0)]];if(this.vertexAttributeColor){const i=this.builder.vertexIndices.length;t.push([O.COLOR,new Array(i).fill(0)]),e.push([O.COLOR,new _(this.vertexAttributeColor,4)])}return{vertexAttributes:e,indices:t}}onPathChanged(){super.onPathChanged(),this.bake(this.size)}intersect(t,e,i){const s=this.builder.vertexIndices,r=new _(this.vertexAttributePosition,3),o=s.length/3;E(t,e,0,o,s,r,void 0,void 0,i)}}class it extends tt{constructor(t,e,i,s){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=i,this.opacityAttributeValue=s,this.vvData=null,this.baked=new et(t),this.vvData=y(4*this.builder.path.vertices.length);for(let r=0;r<this.builder.path.vertices.length;++r){this.vvData[4*r+0]=e,this.vvData[4*r+1]=i,this.vvData[4*r+2]=s;const t=0===r||r===this.builder.path.vertices.length-1;this.vvData[4*r+3]=t?1:0}}createGeometryData(){return{vertexAttributes:[[O.POSITION,new _(this.builder.originData,3,!0)],[O.PROFILERIGHT,new _(this.builder.profileRightAxisData,4,!0)],[O.PROFILEUP,new _(this.builder.profileUpAxisData,4,!0)],[O.PROFILEVERTEXANDNORMAL,new _(this.builder.profileVertexAndNormalData,4,!0)],[O.FEATUREVALUE,new _(this.vvData,4,!0)]],indices:[[O.POSITION,this.builder.pathVertexIndices],[O.PROFILERIGHT,this.builder.vertexIndices],[O.PROFILEUP,this.builder.vertexIndices],[O.PROFILEVERTEXANDNORMAL,this.builder.vertexIndices],[O.FEATUREVALUE,this.builder.pathVertexIndices]]}}}const st=N(),rt=f(),ot=f(),ht=f(),nt=N(),at=N(),lt=N(),ut=N(),pt=N(),ft=M(),xt=s();export{$ as Builder,Q as CapBuilder,H as Extruder,it as FastUpdatePathGeometry,K as MiterExtruder,W as NoCapBuilder,J as Path,tt as PathGeometryData,G as PathVertex,j as Profile,Z as RoundCapBuilder,X as SimpleExtruder,et as StaticPathGeometry,Y as TriangulationCapBuilder,q as computeMinimumRotationTangentFrame,z as creatQuadProfile,F as createCircleProfile,M as makeFrame,w as profileSpaceToVertexSpace,B as vertexSpaceToProfileSpace};

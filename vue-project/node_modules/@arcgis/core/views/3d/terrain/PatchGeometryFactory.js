/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isPowerOfTwo as t,clamp as e}from"../../../core/mathUtils.js";import{isNone as n,isSome as o}from"../../../core/maybe.js";import{s}from"../../../chunks/vec4.js";import{empty as i}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as r}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as a}from"./ElevationData.js";import{PatchType as c,NeighborIndex as l}from"./interfaces.js";import{acquireTerrainAttributes as u,minMaxBoundingBox as f,encodeUVInBuffer as d,encodeNormalToBufferFromValues as g,EdgeDescriptor as m}from"./PatchGeometry.js";import{PatchGeometryLUT as h}from"./PatchGeometryLUT.js";import{neighborTileIfLoadedOrSelf as p}from"./PatchRenderData.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as M,internalAssert as x,neighborEdgeIndices as y,almostEquals as S}from"./terrainUtils.js";import{isCornerNeighbor as b}from"./Tile.js";import{compareTilesByLij as v}from"./tileUtils.js";const L=65536;function B(t,e){const n=t.tile,{extent:o,extentInRadians:s,surface:r}=n,a=t.localOrigin,l=t.geometryState,m=r.isWebMercator,h=r.shading||rt,p=l.numVerticesPerSide,y=p-1,S=(p-2)**2,b=m&&(e===c.HAS_SOUTH_POLE||e===c.HAS_BOTH_POLES),v=m&&(e===c.HAS_NORTH_POLE||e===c.HAS_BOTH_POLES),L=6,B=((b?1:0)+(v?1:0))*L*(y+1),O=l.neighborData,T=O.edgeResolutions.reduce(((t,e)=>t+e+1),0),P=u(S+B+T),D=t.geometryInfo;D.numVerticesPerSide=l.numVerticesPerSide,D.vertexAttributes=P;const A=D.boundingBox;i(A);const I=j(t);nt.update(y,s,I),R(t),X(t,S),V(t);const E=[];if((()=>{let t=S+T;const e=a[0],s=a[1],i=a[2],r=n.ellipsoid.radius,c=o[1],l=o[3],u=(n,o)=>{const a=o*p;f(-e,-s,n*r-i,A),E.push({connectedRowOffset:a,connectedOuterEdgeOffset:1===n?0:2,rowOffset:t,latitudeResolution:L});const u=U(-1===n?c:l,r),m=n*Math.PI/2-u,M=.99*(1===n?1:-1),x=r+0,S=P.position,b=P.uv0,v=P.normalCompressed;for(let r=1;r<=L;++r){const n=u+m*(r/L),o=Math.cos(n),a=Math.sin(n);for(let r=0;r<=y;r++){const n=r/y,c=nt.sinLonLUT[r],l=nt.cosLonLUT[r]*o,u=c*o,m=a,p=l*x-e,L=u*x-s,B=m*x-i;f(p,L,B,A),S.setValues(t,p,L,B),d(b,t,n,M),h&&g(v,t,l,u,m),++t}}};b&&u(-1,0),v&&u(1,y)})(),Q(D,l.numVerticesPerSide,E,[0,p-1],[0,p-1],l.wireframe),t.intersectionData=null,M)for(let i=0;i<4;++i)x(D.outerEdges[i].count===O.edgeResolutions[i]+1)}function R(t){const e=t.tile;e.intersectsClippingArea&&(e.surface.shading||rt?T(t):O(t))}function O(t){const e=t.geometryState,n=e.numVerticesPerSide,o=n-2,s=n-1,i=t.geometryInfo,r=i.vertexAttributes,c=r.position,l=r.uv0,u=t.tile,g=u.extent,m=g[0],h=g[2],p=g[1],M=g[3],x=u.ellipsoid.radius,y=e.samplerData,S=t.localOrigin,b=S[0],v=S[1],L=S[2],B=i.boundingBox,R=c.typedBuffer,O=c.typedBufferStride;let T=0;for(let P=1;P<=o;P++){const t=P/s,e=p*(1-t)+M*t,n=nt.sinLatLUT[P],i=nt.cosLatLUT[P];for(let r=1;r<=o;r++){const o=r/s,c=m*(1-o)+h*o,u=nt.sinLonLUT[r],g=nt.cosLonLUT[r],p=x+a(c,e,y),M=g*i*p-b,S=u*i*p-v,P=n*p-L;f(M,S,P,B);const D=T*O;R[D]=M,R[D+1]=S,R[D+2]=P,d(l,T,o,t),++T}}}function T(t){const e=t.geometryState,n=e.numVerticesPerSide,o=n-2,s=n-1,i=t.geometryInfo,r=i.vertexAttributes,c=r.position,l=r.uv0,u=r.normalCompressed,m=t.tile,h=m.extent,p=h[0],M=h[2],x=h[1],y=h[3],S=m.ellipsoid.radius,b=e.samplerData,v=t.localOrigin,L=v[0],B=v[1],R=v[2],O=c.typedBuffer,T=c.typedBufferStride,P=1/s,D=i.boundingBox;let V=0;if(1<=o){const t=P,e=x*(1-t)+y*t,n=nt.sinLatLUT[1],s=nt.cosLatLUT[1];for(let i=1;i<=o;i++){const o=i*P,r=p*(1-o)+M*o,c=nt.sinLonLUT[i],u=nt.cosLonLUT[i],g=S+a(r,e,b),m=g*u*s-L,h=g*c*s-B,x=g*n-R;f(m,h,x,D);const y=(i-1)*T;O[y]=m,O[y+1]=h,O[y+2]=x,d(l,i-1,o,t)}}for(let A=1;A<=o;A++){const t=A*P,e=x*(1-t)+y*t,n=nt.sinLatLUT[A],i=nt.cosLatLUT[A],r=A+1,c=r*P,m=x*(1-c)+y*c,h=nt.sinLatLUT[r],v=nt.cosLatLUT[r],I=nt.sinLonLUT[0],U=nt.cosLonLUT[0],E=S+a(p,e,b);let C=U*i*E-L,j=I*i*E-B,w=n*E-R;const N=V*T;let H=O[N],_=O[N+1],q=O[N+2];for(let y=1;y<=o;y++){const t=y*P,r=p*(1-t)+M*t,I=nt.sinLonLUT[y],U=nt.cosLonLUT[y];let E=U*i,N=I*i,W=n,F=0,k=0,z=0;{let t=0,r=0,c=0;if(y<o){const e=(V+1)*T;t=O[e],r=O[e+1],c=O[e+2]}else{const o=nt.sinLonLUT[s],l=nt.cosLonLUT[s],u=S+a(M,e,b);t=l*i*u-L,r=o*i*u-B,c=n*u-R}const l=C,u=j,f=w;C=H,j=_,w=q,H=t,_=r,q=c,F=t-l,k=r-u,z=c-f}{let e=0,n=0,s=0;if(A>1){const t=(V-o)*T;e=O[t],n=O[t+1],s=O[t+2]}else{const t=nt.sinLatLUT[0],o=nt.cosLatLUT[0],i=S+a(r,x,b);e=U*o*i-L,n=I*o*i-B,s=t*i-R}{const i=S+a(r,m,b),u=U*v*i-L,g=I*v*i-B,p=h*i-R;if(A<o){const e=V+o,n=e*T;O[n]=u,O[n+1]=g,O[n+2]=p,f(u,g,p,D),d(l,e,t,c)}const M=e-u,x=n-g,y=s-p;W*W<.999&&(E=z*x-k*y,N=F*y-z*M,W=k*M-F*x)}}const G=1/Math.sqrt(E*E+N*N+W*W);g(u,V,E*G,N*G,W*G),++V}}}function P(t){t.tile.intersectsClippingArea&&(V(t),tt(t))}function D(t){t.tile.intersectsClippingArea&&(I(t),A(t,!0),tt(t))}function V(t){t.tile.intersectsClippingArea&&(I(t),A(t))}function A(e,s=!1){const i=e.geometryState,r=e.geometryInfo,c=i.neighborData,l=e.tile,u=l.level,g=l.extent,m=l.ellipsoid.radius,h=l.extentInRadians,b=h[0],L=h[2],B=h[1],R=h[3],O=i.samplerData,T=g[0],P=g[2],D=g[1],V=g[3],A=j(e),I=r.boundingBox,U=e.localOrigin,E=U[0],C=U[1],w=U[2],N=l.surface.shading||rt,H=r.vertexAttributes,_=H.position,q=_.typedBuffer,W=_.typedBufferStride,F=H.uv0;for(let j=0;j<4;++j){const i=1===j||3===j,h=c.edgeResolutions[j];x(t(h));const U=h+1,H=p(l,c.edgePeerNeighbors[j]);if(it(l,H,j)){Y(e,j,H);continue}const _=o(H);x(!_||H.level===l.level),x(!_||v(l,H)<=0);const k=H?.renderData,z=k?.geometryState;if(M){const t=l.surface;if(!H&&t&&!t.updatingRootTiles){const e=y[j],o=l.findNeighborTile(e,(t=>t.isLoaded||t.isLeaf||t.level===l.level));o?o.intersectsClippingArea&&(x(!o.isLoaded),x(!o.isLeaf),x(o.level===u)):x(n(t?.rootTiles)||!l.shouldHaveNeighbor(e))}}const G=1===j?g[2]:g[0],J=H?.extent,K=J&&i?1===j?J[0]:J[2]:G,Q=0===j?g[3]:g[1],X=1===j?1:0,Z=0===j?1:0,$=1===j?L:b,tt=0===j?R:B,et=Math.sin($),nt=Math.cos($),ot=Math.sin(tt),st=Math.cos(tt),rt=z?.samplerData,at=_?(t,e,n)=>.5*(a(t,e,O)+a(n,e,rt)):(t,e,n)=>a(t,e,O),ct=r.outerEdges[j],lt=s&&U>3?U-3:1,ut=o(O)&&O.some((t=>null!=t)),ft=o(rt)&&rt.some((t=>null!=t)),dt=ut||ft,gt=1/h,mt=ct.index0;if(N){x(!J||S(J[2]-J[0],g[2]-g[0]));(()=>{const t=1===j?-1:3===j?1:0,e=0===j?-1:2===j?1:0,n=(g[2]-g[0])*gt,o=t*n,s=e*n,r=i?t*((L-b)*gt):0,c=i?0:e*gt,l=Z,u=i?$+r:$,h=i?Math.sin(u):et,p=i?Math.cos(u):nt,M=i?$-r:$,x=i?Math.sin(M):et,y=i?Math.cos(M):nt,S=i?tt:A(l+c),v=i?ot:Math.sin(S),B=i?st:Math.cos(S),R=i?tt:A(l-c),N=i?ot:Math.sin(R),H=i?st:Math.cos(R);let k=0,z=0,J=0;{const t=0*gt,e=i?G:T*(1-t)+P*t,n=i?K:e,o=i?D*(1-t)+V*t:Q,s=i?$:b*(1-t)+L*t,r=i?et:Math.sin(s),a=i?nt:Math.cos(s),c=i?A(t):tt,l=i?Math.sin(c):ot,u=i?Math.cos(c):st,f=m+at(e,o,n);k=a*u*f,z=r*u*f,J=l*f}let Y=0,it=0,ut=0;{const t=1*gt,e=i?G:T*(1-t)+P*t,n=i?K:e,o=i?D*(1-t)+V*t:Q,s=i?$:b*(1-t)+L*t,r=i?et:Math.sin(s),a=i?nt:Math.cos(s),c=i?A(t):tt,l=i?Math.sin(c):ot,u=i?Math.cos(c):st,f=m+at(e,o,n);Y=a*u*f,it=r*u*f,ut=l*f}for(let g=1;g<U-1;g+=lt){let t=0,e=0,n=0;{const o=(g+1)*gt,s=i?G:T*(1-o)+P*o,r=i?K:s,a=i?D*(1-o)+V*o:Q,c=i?$:b*(1-o)+L*o,l=i?et:Math.sin(c),u=i?nt:Math.cos(c),f=i?A(o):tt,d=i?Math.sin(f):ot,h=i?Math.cos(f):st,p=m+at(s,a,r);t=u*h*p,e=l*h*p,n=d*p}const r=t,c=e,l=n,u=Y,M=it,S=ut;Y=r,it=c,ut=l;{const t=mt+g,e=t*W,n=u-E,o=M-C,s=S-w;q[e]=n,q[e+1]=o,q[e+2]=s,f(n,o,s,I);const r=g*gt;d(F,t,i?X:r,i?r:Z)}const R=k,U=z,lt=J;k=u,z=M,J=S;const ft=u,ht=M,pt=S,Mt=1/Math.sqrt(ft*ft+ht*ht+pt*pt),xt=pt*Mt;let yt=0,St=0,bt=0;if(dt&&xt*xt<.999){let t=0,e=0,n=0;{const o=0===j?-1:1;t=o*(r-R),e=o*(c-U),n=o*(l-lt)}{const r=g*gt,c=i?G:T*(1-r)+P*r,l=i?K:c,u=i?D*(1-r)+V*r:Q,f=i?$:b*(1-r)+L*r,d=i?et:Math.sin(f),M=i?nt:Math.cos(f),S=i?A(r):tt,R=i?Math.sin(S):ot,I=i?Math.cos(S):st;let U=ft,E=ht,C=pt;if(_){const t=m+a(l-o,u-s,rt),e=i?I:H;U=(i?y:M)*e*t,E=(i?x:d)*e*t,C=(i?R:N)*t}{const r=m+a(c+o,u+s,O),l=i?I:B,f=(i?p:M)*l*r,g=(i?h:d)*l*r,x=(i?R:v)*r;_||(U=2*ft-f,E=2*ht-g,C=2*pt-x);const y=3===j?-1:1,S=y*(U-f),b=y*(E-g),L=y*(C-x);yt=n*b-e*L,St=t*L-n*S,bt=e*S-t*b;const T=1/Math.sqrt(yt*yt+St*St+bt*bt);yt*=T,St*=T,bt*=T}}}else yt=ft*Mt,St=ht*Mt,bt=pt*Mt;ct.setNormalFromValues(g,yt,St,bt)}})()}else{(()=>{for(let t=1;t<U-1;t+=lt){const e=t*gt,n=i?X:e,o=i?e:Z,s=i?G:T*(1-e)+P*e,r=i?D*(1-e)+V*e:Q,a=i?K:s,c=i?$:b*(1-e)+L*e,l=i?et:Math.sin(c),u=i?nt:Math.cos(c),g=i?A(e):tt,h=i?Math.sin(g):ot,p=i?Math.cos(g):st,M=at(s,r,a),x=m+M,y=u*p*x-E,S=l*p*x-C,v=h*x-w;f(y,S,v,I);const B=mt+t,R=B*W;q[R]=y,q[R+1]=S,q[R+2]=v,d(F,B,n,o)}})()}}}function I(t){Z(t)}function U(t,e){return Math.PI/2-2*Math.atan(Math.exp(-t/e))}function E(t,e,n,o){return U(t*(1-o)+e*o,n)}function C(t,e,n){return t*(1-n)+e*n}function j(t){const e=t.tile;if(e.surface.isWebMercator){const t=e.extent,n=e.ellipsoid.radius;return e=>E(t[1],t[3],n,e)}const n=e.extentInRadians;return t=>C(n[1],n[3],t)}function w(t,e){const n=t.tile.extent,r=t.geometryState,a=n[0],c=n[1],l=n[2]-a,f=n[3]-c,d=r.clippingArea,g=o(d)?Math.max(0,(d[0]-a)/l):0,m=o(d)?Math.max(0,(d[1]-c)/f):0,h=o(d)?Math.min(1,(d[2]-a)/l):1,p=o(d)?Math.min(1,(d[3]-c)/f):1,M=r.numVerticesPerSide,x=(M-2)**2,y=r.neighborData.edgeResolutions.reduce(((t,e)=>t+e+1),0),S=u(x+y),b=t.geometryInfo,v=b.boundingBox;i(v),b.numVerticesPerSide=r.numVerticesPerSide,b.vertexAttributes=S,s(b.uvRange,g,m,h,p),N(t),X(t,x),F(t),Q(b,r.numVerticesPerSide,[],[0,M-1],[0,M-1],r.wireframe),t.intersectionData=null}function N(t){const e=t.tile;e.intersectsClippingArea&&(e.surface.shading?_(t):H(t))}function H(t){const n=t.geometryState,s=n.samplerData,i=t.tile,r=i.surface,c=t.localOrigin,l=r.isWebMercatorOnPlateeCarree,u=n.clippingArea,g=o(u)?u:ot,m=i.extent,h=m[0],p=m[1],M=m[2],x=m[3],y=Math.max(h,g[0]),S=Math.min(M,g[2]),b=Math.max(p,g[1]),v=Math.min(x,g[3]),L=c[0],B=c[1],R=c[2],O=i.ellipsoid.radius,T=i.horizontalScale,P=K(l,O,T),D=n.numVerticesPerSide,V=D-1,A=D-2,I=t.geometryInfo,U=I.uvRange,E=U[0],C=U[1],j=U[2],w=U[3],N=I.boundingBox,H=I.vertexAttributes,_=H.position,q=H.uv0;let W=0;for(let o=1;o<=A;o++){const t=o/V,n=e(p*(1-t)+x*t,b,v),i=e(t,C,w),r=P(n)-B;for(let o=1;o<=A;o++){const t=o/V,c=e(h*(1-t)+M*t,y,S),l=e(t,E,j),u=c*T-L,g=a(c,n,s)-R;f(u,r,g,N),_.setValues(W,u,r,g),d(q,W,l,i),++W}}}function _(t){const n=t.tile,s=n.surface;if(!(s.shading||rt))return;const i=t.geometryState,r=i.samplerData,c=t.localOrigin,l=s.isWebMercatorOnPlateeCarree,u=i.clippingArea,m=o(u)?u:ot,h=n.extent,p=h[0],M=h[1],x=h[2],y=h[3],S=Math.max(p,m[0]),b=Math.min(x,m[2]),v=Math.max(M,m[1]),L=Math.min(y,m[3]),B=n.ellipsoid.radius,R=n.horizontalScale,O=i.numVerticesPerSide,T=O-1,P=O-2,D=t.geometryInfo,V=D.vertexAttributes,A=V.position,I=V.uv0,U=V.normalCompressed,E=D.uvRange,C=E[0],j=E[1],w=E[2],N=E[3],H=D.boundingBox,_=c[0],q=c[1],W=c[2],F=A.typedBuffer,k=A.typedBufferStride;let z=0;const G=e(M,v,L),J=l?(Math.PI/2-2*Math.atan(Math.exp(-G/B)))*B:G*R,K=1/T,Q=e(M*(1-K)+y*K,v,L);let X=J,Y=l?(Math.PI/2-2*Math.atan(Math.exp(-Q/B)))*B:Q*R;for(let o=1;o<=P;o++){const t=o/T,n=e(M*(1-t)+y*t,v,L),s=e(t,j,N),i=Y,c=(o-1)/T,u=e(M*(1-c)+y*c,v,L),m=X,h=(o+1)/T,O=e(M*(1-h)+y*h,v,L),D=l?(Math.PI/2-2*Math.atan(Math.exp(-O/B)))*B:O*R,V=e(h,j,N);X=Y,Y=D;const A=e(p,S,b);let E=A*R,G=a(A,n,r);const J=1/T,K=e(J,C,w),Q=e(p*(1-K)+x*K,S,b);let Z=K,$=Q,tt=Q*R,et=a(Q,n,r);if(1===o){const t=tt-_,n=X-q,o=et-W,i=0*k;F[i]=t,F[i+1]=n,F[i+2]=o,f(t,n,o,H);const r=e(J,C,w);d(I,z,r,s)}for(let l=1;l<=P;l++){const t=tt,c=et,h=(l+1)/T,M=e(h,C,w),y=e(p*(1-h)+x*h,S,b),v=$;$=y;{const t=z+1,e=t*k;if(1===o||l===P){const c=y*R,u=a(y,n,r);if(1===o&&l<P){const n=c-_,o=i-q,r=u-W;F[e]=n,F[e+1]=o,F[e+2]=r,f(n,o,r,H),d(I,t,M,s)}tt=c,et=u}else tt=F[e]+_,et=F[e+2]+W}const L=tt,B=et,A=E,j=G;E=t,G=c;const N=(z-P)*k,J=1===o?a(v,u,r):F[N+2]+W,K=a(v,O,r);if(o<P){const e=z+P,n=e*k,o=t-_,s=D-q,i=K-W;F[n]=o,F[n+1]=s,F[n+2]=i,f(o,s,i,H);const r=Z;Z=M,d(I,e,r,V)}{const t=L-A,e=m-D,n=e*(B-j),o=t*(J-K),s=-e*t,i=n*n+o*o+s*s;if(0===i)g(U,z,0,0,1);else{const t=1/Math.sqrt(i);g(U,z,n*t,o*t,s*t)}}++z}}}function q(t,e){t.tile.intersectsClippingArea&&(z(t),k(t,!0),tt(t))}function W(t,e){t.tile.intersectsClippingArea&&(F(t),tt(t))}function F(t,e){t.tile.intersectsClippingArea&&(z(t),k(t,!1))}function k(s,i){const r=s.geometryState,c=r.neighborData,l=s.tile,u=l.surface,d=u.shading||rt,g=l.extent,m=r.clippingArea,h=o(m)?m:ot,S=g[0],b=g[2],L=g[1],B=g[3],R=[B>h[3],b>h[2],L<h[1],S<h[0]],O=s.geometryInfo,T=l.horizontalScale,P=K(u.isWebMercatorOnPlateeCarree,l.ellipsoid.radius,T),D=O.boundingBox,V=O.uvRange[0],A=O.uvRange[1],I=O.uvRange[2],U=O.uvRange[3],E=Math.max(S,h[0]),C=Math.min(b,h[2]),j=Math.max(L,h[1]),w=Math.min(B,h[3]),N=s.localOrigin,H=N[0],_=N[1],q=N[2],W=r.samplerData;for(let F=0;F<4;++F){const r=1===F||3===F,g=c.edgeResolutions[F];x(t(g));const m=g+1,h=R[F],N=p(l,c.edgePeerNeighbors[F]);if(!h&&it(l,N,F)){Y(s,F,N);continue}const k=o(N)&&!h,z=N?.renderData,G=z?.geometryState;if(M&&(x(!k||N.level===l.level),x(!k||v(l,N)<=0),l&&!N&&!u.updatingRootTiles)){const t=y[F],e=l.findNeighborTile(t,(t=>t.isLoaded||t.isLeaf||t.level===l.level));u.updatingRootTiles||(e?e.intersectsClippingArea&&(x(!e.isLoaded),x(!e.isLeaf),x(e.level===l.level)):x(n(u?.rootTiles)||!l.shouldHaveNeighbor(t)))}const J=e(1===F?b:S,E,C),K=e(0===F?B:L,j,w),Q=G?.samplerData,X=O.outerEdges[F],Z=i&&m>3?m-3:1,$=e(1===F?1:0,V,I),tt=e(0===F?1:0,A,U),et=k?(t,e)=>.5*(a(t,e,Q)+a(t,e,W)):(t,e)=>a(t,e,W);if(d){const t=(b-S)/g,n=r?1===F?t:-t:0,o=r?0:0===F?t:-t,s=-n,i=-o;let c=0,l=0,u=0;{const t=0/g,n=r?J:e(S*(1-t)+b*t,E,C),o=r?e(L*(1-t)+B*t,j,w):K,s=et(n,o);c=n*T,l=P(o),u=s}let d=0,h=0,p=0;{const t=1/g,n=r?J:e(S*(1-t)+b*t,E,C),o=r?e(L*(1-t)+B*t,j,w):K,s=et(n,o);d=n*T,h=P(o),p=s}for(let M=1;M<m-1;M+=Z){const t=M/g,m=d,x=h,y=p;{const n=r?$:e(t,V,I),o=r?e(t,A,U):tt,s=m-H,i=x-_,a=y-q;f(m,i,a,D),X.setVertexFromValuesRawPositionUV(M,s,i,a,n,o)}{const t=(M+1)/g,n=r?J:e(S*(1-t)+b*t,E,C),o=r?e(L*(1-t)+B*t,j,w):K,s=et(n,o);d=n*T,h=P(o),p=s}const v=d,R=p,O=c,N=l,z=u;c=m,l=x,u=y;let G=0,Y=0,Z=0;if(r){const o=h-x,i=R-y,r=N-x,c=z-y,l=e(L*(1-t)+B*t,j,w),u=J+s,f=u*T-m,d=a(u,l,W)-y,g=3===F?-1:1;if(G=g*(-r+o)*d,Y=g*f*(-c+i),Z=-g*f*(-r+o),k){const t=J+n,e=t*T-m;G=(-r+o)*(d-(a(t,l,Q)-y)),Y=(f-e)*(-c+i),Z=-(f-e)*(-r+o)}}else{const n=v-m,s=R-y,r=O-m,c=z-y,l=e(S*(1-t)+b*t,E,C),u=K+i,f=a(l,u,W)-y,d=P(u)-x,g=2===F?-1:1;if(G=g*d*(-c+s),Y=g*(-r+n)*f,Z=-g*d*(-r+n),k){const t=l,e=K+o,i=P(e)-x;G=(-d+i)*(-c+s),Y=(-r+n)*(-f+(a(t,e,Q)-y)),Z=-(-d+i)*(-r+n)}}const nt=1/Math.sqrt(G*G+Y*Y+Z*Z);X.setNormalFromValues(M,G*nt,Y*nt,Z*nt)}}else for(let t=1;t<m-1;t+=Z){const n=t/g,o=r?J:e(S*(1-n)+b*n,E,C),s=r?e(L*(1-n)+B*n,j,w):K,i=r?$:e(n,V,I),a=r?e(n,A,U):tt,c=et(o,s),l=o*T-H,u=P(s)-_,d=c-q;f(l,u,d,D),X.setVertexFromValuesRawPositionUV(t,l,u,d,i,a)}}}function z(t,e){Z(t)}function G(t,e){return(Math.PI/2-2*Math.atan(Math.exp(-t/e)))*e}function J(t,e){return t*e}function K(t,e,n){return t?t=>G(t,e):t=>J(t,n)}function Q(t,e,n,o,s,i){const r=e-1,a=t.vertexAttributes.count,c=2*(Math.min(e-2,o[1])-Math.max(1,o[0]))*(Math.min(e-2,s[1])-Math.max(1,s[0])),l=y.map(((t,n)=>0===n&&s[1]<e-2||1===n&&o[1]<e-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=t.outerEdges.reduce(((t,e,n)=>t+(l[n]?0:r-2+e.count-1)),0),f=n.reduce(((t,e)=>t+r*(2*(e.latitudeResolution-1)+1)),0),d=i?2:1,g=3*(c+u+f)*d,m=a>=L?new Uint32Array(g):new Uint16Array(g);let h=0;const p=e-2,S=r-2;x(S>=0);const b=(t,e,n,o,s,i)=>{const r=t*s,a=i[r],c=i[r+1],l=i[r+2],u=e*s,f=i[u],d=i[u+1],g=i[u+2],m=n*s,h=i[m],p=i[m+1],M=i[m+2],x=o*s,y=i[x],S=i[x+1],b=i[x+2];return(f-y)*(f-y)+(d-S)*(d-S)+(g-b)*(g-b)>(a-h)*(a-h)+(c-p)*(c-p)+(l-M)*(l-M)};if(i){const i=(t,e,n)=>{m[h++]=t,m[h++]=e,m[h++]=e,m[h++]=n,m[h++]=n,m[h++]=t,M&&(x(t<a),x(e<a),x(n<a),x(h<=g))};(()=>{for(let n=Math.max(s[0],1)-1;n<Math.min(s[1],e-2)-1;++n){const s=n*p;for(let r=Math.max(o[0],1)-1;r<Math.min(o[1],e-2)-1;++r){const e=n*p+r,o=e+1,a=o+p,c=a-1,l=s+r,u=l+1,f=u+p,d=f-1,g=t.vertexAttributes.position.typedBuffer,m=t.vertexAttributes.position.typedBufferStride;b(l,u,f,d,m,g)?(i(e,o,a),i(a,c,e)):(i(e,o,c),i(c,a,o))}}})(),x(h===3*c*d);(()=>{for(let e=0;e<4;++e){const n=h;if(l[e])continue;const o=t.outerEdges[e],s=t.innerEdges[e];let a=0,c=0;const u=o.count,f=s.count;x(f===r-1);let g=0;const m=1===e||2===e?(t,e,n)=>i(t,e,n):(t,e,n)=>i(t,n,e);for(;a<u-1||c<f-1;){const t=s.getVertexIndex(c),e=o.getVertexIndex(a),n=a<u-1,i=c<f-1;if(n&&(!i||(n?0+r*(a+.5)/(u-1):0)<=(i?1+S*(c+.5)/(f-1):0))){++a,M&&x(a<u);m(t,e,o.getVertexIndex(a)),g++}else{++c,M&&x(c<f);m(t,e,s.getVertexIndex(c)),g++}}M&&(x(a===u-1),x(c===f-1),x(g===u+f-2),x(g===r-2+o.count-1),x(h===n+3*g*d))}})(),x(h===3*(c+u)*d);const f=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<r;e++)i(s,s+1,o+e),t<n.latitudeResolution-1&&i(s+1,o+e+1,o+e),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const n=Math.max(s[0],1)-1,i=Math.min(s[1],e-2)-1,r=Math.max(o[0],1)-1,a=Math.min(o[1],e-2)-1;for(let e=n;e<i;++e){const n=e*p;for(let e=r;e<a;++e){const o=n+e,s=o+1,i=s+p,r=i-1,a=t.vertexAttributes.position.typedBuffer,c=t.vertexAttributes.position.typedBufferStride;b(o,s,i,r,c,a)?(m[h]=o,m[h+1]=s,m[h+2]=i,m[h+3]=i,m[h+4]=r,m[h+5]=o):(m[h]=o,m[h+1]=s,m[h+2]=r,m[h+3]=r,m[h+4]=s,m[h+5]=i),h+=6}}})(),x(h===3*c*d);(()=>{for(let e=0;e<4;++e){if(l[e])continue;const n=t.outerEdges[e],o=t.innerEdges[e];let s=0,i=0;const a=n.count,c=o.count;x(c===r-1);const u=1===e||2===e,f=u?1:2,d=u?2:1,g=n.index0,p=n.stride,M=o.index0,y=o.stride;for(;s<a-1||i<c-1;){const t=M+i*y,e=g+s*p,n=s<a-1,o=i<c-1,l=n&&(!o||(n?0+r*(s+.5)/(a-1):0)<=(o?1+S*(i+.5)/(c-1):0));l?++s:++i;const u=l?e+p:t+y;m[h]=t,m[h+f]=e,m[h+d]=u,h+=3}}})(),x(h===3*(c+u)*d);const i=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),i=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<r;e++){const r=o+e;m[h]=s,m[h+1]=s+1,m[h+2]=r,t<n.latitudeResolution-1?(m[h+3]=s+1,m[h+4]=r+1,m[h+5]=r,h+=6):h+=3,s+=i}s=o,i=1}};(()=>n.forEach(i))()}x(h===g),t.indices=m,t.indexCount=g}function X(t,e){const n=t.localOrigin,o=t.geometryInfo,s=t.geometryState.neighborData.edgeResolutions,i=o.numVerticesPerSide-2,r=o.vertexAttributes;let a=e;for(let c=0;c<4;++c){{const t=0===c||2===c,e=(0===c?i-1:0)*i+(1===c?i-1:0),s=(t?0:1)*i+(t?1:0);o.innerEdges[c]=new m(r,n,e,s,i)}{const t=a,e=s[c]+1;o.outerEdges[c]=new m(r,n,t,1,e),a+=e}}}function Y(n,o,s){const i=(o+2)%4,r=n.geometryState,a=n.tile,c=r.neighborData,l=a.level-s.level,u=1===o||3===o,g=c.edgeResolutions[o];x(t(g));const m=g+1,h=n.geometryInfo,p=h.boundingBox,M=h.outerEdges[o],y=h.uvRange[0],S=h.uvRange[1],b=h.uvRange[2],v=h.uvRange[3],L=e(1===o?1:0,y,b),B=e(0===o?1:0,S,v),R=s.renderData,O=R.geometryState,T=R.geometryInfo.outerEdges[i],P=a.getNeighborEdgeStartVertexIndex(o,s)*g,D=g*2**l;x(O.neighborData.edgeResolutions[i]===D),x(T.count-1===D);const V=R.localOrigin[0]-n.localOrigin[0],A=R.localOrigin[1]-n.localOrigin[1],I=R.localOrigin[2]-n.localOrigin[2],U=M.attributes,E=M.index0,C=M.stride,j=U.position.typedBuffer,w=U.position.typedBufferStride,N=U.normalCompressed.typedBuffer,H=U.normalCompressed.typedBufferStride,_=U.uv0,q=T.attributes,W=T.index0,F=T.stride,k=q.position.typedBuffer,z=q.position.typedBufferStride,G=q.normalCompressed.typedBuffer,J=q.normalCompressed.typedBufferStride;for(let t=1;t<m-1;++t){const n=E+C*t,o=W+F*(P+t),s=n*w,i=o*z,r=k[i]+V,a=k[i+1]+A,c=k[i+2]+I;j[s]=r,j[s+1]=a,j[s+2]=c,f(r,a,c,p);const l=n*H,m=o*J;N[l]=G[m],N[l+1]=G[m+1];const h=t/g,M=u?L:e(h,y,b),x=u?e(h,S,v):B;d(_,n,M,x)}}function Z(t){const n=t.geometryState,s=n.neighborData,i=t.localOrigin,r=s.cornerNeighborData,c=t.geometryInfo,l=c.outerEdges,u=c.boundingBox,g=t.tile,m="local"===t.tile.surface.view?.viewingMode,h=g.ellipsoid.radius,p=g.extentInRadians,M=g.horizontalScale;let y=0,S=0,b=0;const L=(t,e,n)=>{const o=p[0===e?1:3],s=p[0===t?0:2],i=Math.cos(o),r=Math.sin(o),a=Math.sin(s),c=Math.cos(s),l=h+n;y=c*i*l,S=a*i*l,b=r*l},B=m?(()=>{const n=t.geometryState.clippingArea,s=g.extent,i=o(n)&&(s[3]>n[3]||s[2]>n[2]||s[1]<n[1]||s[0]<n[0]),r=K(g.surface.isWebMercatorOnPlateeCarree,g.ellipsoid.radius,M);return(t,o,s)=>{const a=0===t?w[0]:w[2],c=0===o?w[1]:w[3],l=i?e(a,n[0],n[2]):a,u=i?e(c,n[1],n[3]):c,f=s;y=l*M,S=r(u),b=f}})():L;let R=0,O=0,T=0,P=0,D=0,V=0,A=0,I=0,U=0;const E=m&&t.tile.surface.isWebMercatorOnPlateeCarree,C=(t,e,n,o,s)=>{let i=0,r=0,a=0;if(m){const t=e*M,s=E?(Math.PI/2-2*Math.atan(Math.exp(-n/h)))*h:n*M;i=t-y,r=s-S,a=o-b}else{const s=j(t),c=t.tile,l=c.extent,u=c.extentInRadians,f=(e-l[0])/(l[2]-l[0]),d=(n-l[1])/(l[3]-l[1]),g=u[0]*(1-f)+u[2]*f,m=s(d),p=Math.cos(m),M=Math.sin(m),x=Math.sin(g),v=Math.cos(g),L=h+o;i=v*p*L-y,r=x*p*L-S,a=M*L-b}switch(s){case 0:A+=i,I+=r,U+=a;break;case 1:P-=i,D-=r,V-=a;break;case 2:A-=i,I-=r,U-=a;break;case 3:P+=i,D+=r,V+=a}},w=g.extent,N=n.clippingArea,H=o(N)?N:ot,_=w[0],q=w[2],W=w[1],F=w[3],k=[F>H[3],q>H[2],W<H[1],_<H[0]],z=Math.max(_,H[0]),G=Math.min(q,H[2]),J=Math.max(W,H[1]),Q=Math.min(F,H[3]),X=c.uvRange[0],Y=c.uvRange[1],Z=c.uvRange[2],tt=c.uvRange[3],nt=g.surface.shading||rt,it=t=>{const e=r[t].cornerTiles;R=0,O=0,T=1;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,e[r]?.level??1/0);for(let r=0;r<4;++r){const t=e[r];st[r]=t?.level===n?t:null}let o=1,s=0;for(let r=0;r<4;++r){const t=st[r];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),s=t.extent[2]-t.extent[0])}const i=s,c=o;x(c>1);const l=i/c;for(let r=0;r<4;++r){const t=st[(r+3)%4],e=st[r%4];if(!t&&!e)continue;const n=0===r?1:1===r?2:2===r?3:0,o=0===r?2:1===r?3:2===r?0:1;if(t&&e){const s=et[r][0]*l,i=et[r][1]*l,c=t.extent,u=c[0===n||1===n?2:0]+s,f=c[0===n||3===n?3:1]+i,d=e.extent,g=d[0===o||1===o?2:0]+s,m=d[0===o||3===o?3:1]+i,h=t.renderData,p=e.renderData,M=a(u,f,h.geometryState.samplerData),x=a(g,m,p.geometryState.samplerData);C(h,u,f,.5*(M+x),r)}else{const s=t??e,i=t?n:o,c=s.extent,u=et[r],f=c[0===i||1===i?2:0]+u[0]*l,d=c[0===i||3===i?3:1]+u[1]*l,g=s.renderData,m=a(f,d,g.geometryState.samplerData);C(g,f,d,m,r)}}if(!m){const t=Math.sqrt(y*y+S*S+b*b);R=y/t,O=S/t,T=b/t}const u=Math.sqrt(P*P+D*D+V*V);P/=u,D/=u,V/=u;const f=Math.sqrt(A*A+I*I+U*U);if(A/=f,I/=f,U/=f,m||T*T<.999){R=V*I-D*U,O=P*U-V*A,T=D*A-P*I;const t=1/Math.sqrt(R*R+O*O+T*T);R*=t,O*=t,T*=t}};for(let o=0;o<4;++o){const s=o,c=(o+1)%4,m=0===o||1===o?1:0,h=0===o||3===o?1:0,p=e(m,X,Z),M=e(h,Y,tt),L=l[s],P=0===o||3===o?L.count-1:0,D=l[c],V=0===o||1===o?D.count-1:0,A=r[o].cornerTiles;let I=-1;for(let t=0;t<4;++t){const e=A[t];e&&(-1===I||v(A[I],e)>0)&&(I=t)}const U=I,E=A[U];if(R=0,O=0,T=1,E!==g){const e=g.level-E.level,n=2**e,s=[E.lij[0]+e,E.lij[1]*n,E.lij[2]*n],i=[s[1]+n===g.lij[1],0===o&&(1===U||0===U&&E!==A[3])||1===o&&(0===U||1===U&&E!==A[2]),s[1]===g.lij[1]+1,2===o&&(3===U||2===U&&E!==A[1])||3===o&&(2===U||3===U&&E!==A[0])],r=i.reduce(((t,e)=>t+(e?1:0)),0);x(1===r||2===r);let a=-1,c=-1;const l=E.renderData;if(1===r){const e=i.findIndex((t=>t));x(0<=e&&e<=3),a=(e+2)%4;const n=t.geometryState.neighborData.edgeResolutions[e];c=g.getNeighborEdgeStartVertexIndex(e,E)*n+n*(0===e&&0===o||1===e&&0===o||2===e&&1===o||3===e&&3===o?1:0)}else{x(i[1]||i[3]),a=i[1]?3:1;const t=l.geometryState.neighborData.edgeResolutions[a];c=0===o||3===o?0:t}const m=l.geometryInfo.outerEdges[a];{const e=L.index0+P*L.stride,n=D.index0+V*D.stride,o=m.index0+c*m.stride;{const s=m.attributes.position,i=s.typedBuffer,r=o*s.typedBufferStride,a=t.localOrigin,c=m.localOrigin,l=i[r]+c[0]-a[0],d=i[r+1]+c[1]-a[1],g=i[r+2]+c[2]-a[2];f(l,d,g,u);{const t=L.attributes.position,n=t.typedBuffer,o=e*t.typedBufferStride;n[o]=l,n[o+1]=d,n[o+2]=g}{const t=D.attributes.position,e=t.typedBuffer,o=n*t.typedBufferStride;e[o]=l,e[o+1]=d,e[o+2]=g}}d(L.attributes.uv0,e,p,M),d(D.attributes.uv0,n,p,M);{const t=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=L.attributes.normalCompressed,o=n.typedBuffer,i=e*n.typedBufferStride;o[i]=t[s],o[i+1]=t[s+1]}{const e=D.attributes.normalCompressed,o=e.typedBuffer,i=n*e.typedBufferStride;o[i]=t[s],o[i+1]=t[s+1]}}}}else{const t=k[s],r=k[c];let l;if(t||r){const t=e(_*(1-m)+q*m,z,G),o=e(W*(1-h)+F*h,J,Q),s=n.samplerData;l=a(t,o,s)}else l=$(A);B(m,h,l),(nt||rt)&&it(o);const d=y-i[0],g=S-i[1],x=b-i[2];f(d,g,x,u),L.setVertexFromValuesRawPositionUVNormal(P,d,g,x,p,M,R,O,T),D.setVertexFromValuesRawPositionUVNormal(V,d,g,x,p,M,R,O,T)}}for(let e=0;e<4;++e)st[e]=null}function $(t){const e=t.reduce(((t,e)=>Math.min(t,e?.level??1/0)),1/0);M&&(x(!t[0]||!t[2]||b(t[0],t[2],l.SOUTH_WEST)),x(!t[1]||!t[3]||b(t[1],t[3],l.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=t[i];if(s&&s.level===e){const t=0===i||1===i,e=0===i||3===i,r=s.extent,c=r[t?0:2],l=r[e?1:3],u=s.renderData?.geometryState?.samplerData;o+=a(c,l,u),n++}}const s=n?o/n:0;return x(null!=s),s}function tt(t){const e=t.vao,n=t.geometryInfo.vertexAttributes.position.typedBuffer;e.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const et=[[0,1],[1,0],[0,-1],[-1,0]],nt=new h,ot=r(-1/0,-1/0,1/0,1/0),st=[null,null,null,null];function it(t,e,n){if(!e)return!1;const o=v(t,e);return o>0||0===o&&n>=2}const rt=!0;export{O as createInternalVerticesPositionsSpherical,w as createPlanarGlobePatch,B as createSphericalGlobePatch,D as updateCornerSpherical,q as updateCornersPlanar,W as updateEdgesAndCornersPlanar,P as updateEdgesAndCornersSpherical};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{clamp as i}from"../../../../../core/mathUtils.js";import{isSome as e}from"../../../../../core/maybe.js";import{Milliseconds as r}from"../../../../../core/time.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as o,n as a,g as n,e as m,l as c,b as h,a as p,d as _}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as y}from"../../../../../geometry/ellipsoidUtils.js";import{c as f}from"../../../../../chunks/sphere.js";import{applyAll as d}from"../../../camera/constraintUtils.js";import{ConstraintTypes as g}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as j}from"../../../camera/constraintUtils/InteractionType.js";import{applySurfaceCollisionConstraint as w}from"../../../camera/constraintUtils/surfaceCollision.js";import{TiltMode as u}from"../../../camera/constraintUtils/TiltMode.js";import{PointToPointAnimationController as C}from"../PointToPointAnimationController.js";import{contentIntersectorOptions as D,decideNavigationMode as v,ZOOM_MAX_DISTANCE_MODIFIER as R,ZOOM_MIN_DISTANCE_MODIFIER as b,ZOOM_DISTANCE_MODIFIER as M,NavigationMode as L,panToPosition as S}from"../../utils/navigationUtils.js";import{fromScreenAtEye as U}from"../../../support/geometryUtils/ray.js";import{intersectScreen as z}from"../../../support/geometryUtils/sphere.js";import{Camera as O}from"../../../webgl-engine/lib/Camera.js";import{newIntersector as V}from"../../../webgl-engine/lib/Intersector.js";import{outExpo as T}from"../../../../animation/easing.js";const F=.6,k=4,A=60;let E=class extends C{constructor(){super(...arguments),this._zoomLocation=l(),this._tmpCamera=new O,this._tmpViewDir=l(),this._tmpRayDir={origin:l(),direction:l()},this._targetOnSphere=l(),this._tmpCenter=l(),this._constraintOptions={selection:g.ALL_EXCEPT_COLLISION,interactionType:j.ZOOM,interactionFactor:null,interactionStartCamera:new O,interactionDirection:null,tiltMode:u.TUMBLE},this._sphere=f()}initialize(){this._intersector=V(this.view.state.viewingMode)}zoomStep(t,i){if(!this.active)return;const e=this.view.state,{interactionStartCamera:r}=this._constraintOptions;r&&(this.animation.finished?r.copyFrom(e.camera):this.animation.cameraAt(1,r));let s=!1,a=!1;this.intersectionHelper.intersectScreen(i,this._zoomLocation,0===this.view.map.ground.opacity?D:{})&&(s=t>0,a=!0),this._tmpCamera.copyFrom(e.camera),s?this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._tmpCenter)&&(this._tmpCamera.center=this._tmpCenter):this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._zoomLocation)?this._tmpCamera.center=this._zoomLocation:o(this._zoomLocation,this._tmpCamera.center),this._updateCamera(this._tmpCamera,t,this._zoomLocation,i,a),this.begin(this._tmpCamera)}animationSettings(){return{duration:r(600),easing:T}}_updateCamera(t,r,s,o,l){const f=y(this.view.spatialReference),g=v(t,o,f),j=Math.abs(this.view.camera.position.z);a(I,t.eye),n(I,I,-1),U(t,o,this._tmpRayDir),a(this._tmpRayDir.direction,this._tmpRayDir.direction);const u=i(Math.min(M,1/Math.abs(m(I,this._tmpRayDir.direction)))*j,b,R);if(g===L.Horizontal){let i=F**r;this._sphere[3]=c(s),h(this._tmpViewDir,t.center,t.eye);const e=Math.min(c(this._tmpViewDir),u);let a=e*i;if(i<=1&&a<k&&(a=k,i=a/e),Math.abs(e-a)<1e-6)return;const m=c(t.center);if(this._sphere[3]!==m){const e=this._sphere[3]+i*(m-this._sphere[3]);t.center=n(H,t.center,e/m)}n(this._tmpViewDir,this._tmpViewDir,-i),t.eye=p(H,t.center,this._tmpViewDir),d(this.view,t,this._constraintOptions),_(s,t.center)>1e-12&&z(this._sphere,t,o,this._targetOnSphere)&&S(this._sphere,t,s,this._targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let i=F**Math.abs(r);const a=r>0?1:-1;h(this._tmpViewDir,s,t.eye);const m=c(this._tmpViewDir),_=this.view._stage.renderView.getMinimalDepthForArea(null,o[0],o[1],this.view.state.camera,A);let y=e(_)?_:u;y=l&&r>0?Math.min(y,m):y,n(this._tmpRayDir.direction,this._tmpRayDir.direction,y),p(s,this._tmpRayDir.origin,this._tmpRayDir.direction);let f=y*i;const d=Math.max(k,1.01*t.nearFar[0]);if(r>0&&f<d&&(f=d,i=f/y),Math.abs(y-f)<1e-6)return;n(this._tmpRayDir.direction,this._tmpRayDir.direction,a*(1-i)),t.eye=p(H,t.eye,this._tmpRayDir.direction),t.center=p(H,t.center,this._tmpRayDir.direction)}w(this.view,t)}};E=t([s("esri.views.3d.state.controllers.global.ZoomStepController")],E);const H=l(),I=l();export{E as ZoomStepController};

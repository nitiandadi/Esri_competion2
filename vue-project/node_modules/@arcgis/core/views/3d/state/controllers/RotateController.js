/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{isSome as r,unwrapOr as o,isNone as e}from"../../../../core/maybe.js";import{createScreenPointArray as a}from"../../../../core/screenUtils.js";import{property as n}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/arrayUtils.js";import{subclass as h}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as p,e as m}from"../../../../chunks/mat4.js";import{c}from"../../../../chunks/mat4f64.js";import{c as l}from"../../../../chunks/vec2.js";import{a as _}from"../../../../chunks/vec2f64.js";import{c as v,b as u,l as C,e as f,n as P,a as E,g as d,f as w,m as T}from"../../../../chunks/vec3.js";import{c as R}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as y}from"../../../../geometry/ellipsoidUtils.js";import{applyAll as j}from"../../camera/constraintUtils.js";import{ConstraintTypes as U}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as M}from"../../camera/constraintUtils/InteractionType.js";import{TiltMode as O}from"../../camera/constraintUtils/TiltMode.js";import{TiltDefault as x}from"../Constraints.js";import{InteractiveController as D}from"./InteractiveController.js";import{contentIntersectorOptions as g,normalizeCoordinate as A,ROTATE_PIVOT_DISTANCE_MODIFIER as N,ROTATE_PIVOT_MIN_DISTANCE_MODIFIER as b,decideNavigationMode as k,ROTATE_SCREEN_PIXEL_AREA as L,NavigationMode as S}from"../utils/navigationUtils.js";var V;!function(t){t[t.CENTER=0]="CENTER",t[t.EYE=1]="EYE"}(V||(V={}));let H=class extends D{get _intersectionHelper(){return this.view.sceneIntersectionHelper}constructor(t){super(t),this.pivot=V.CENTER,this._rotScale=0,this._lastPoint=_(),this._tmpWorldUp=R(),this._tmpViewDir=R(),this._tmpRotCurPoint=_(),this._tmpTransf=c(),this._tmpAxis=R(),this._tmpPivotPoint=R(),this._pivotPos=R(),this._constraintOptions={selection:U.ALL,interactionType:M.TUMBLE,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:O.TUMBLE}}initialize(){this._rotScale=this.pivot===V.CENTER?3:1.5}begin(t){if(this.active){switch(this.pivot){case V.EYE:v(this._pivotPos,this.startCamera.eye),this._constraintOptions.interactionType=M.LOOK_AROUND,this._constraintOptions.tiltMode=O.LOOK_AROUND,this._constraintOptions.selection=U.NONE;break;case V.CENTER:{const i=this._intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this._pivotPos,0===this.view.map.ground.opacity?g:{});i||v(this._pivotPos,this.startCamera.center),this._constrainPivotPoint(t,i),this.startCamera.center=this._pivotPos,this._constraintOptions.interactionType=M.TUMBLE,this._constraintOptions.tiltMode=O.TUMBLE,this._constraintOptions.selection=U.ALL&~U.DISTANCE;break}}this._constraintOptions.interactionStartCamera=this.startCamera,A(this.startCamera,t,this._lastPoint)}}_constrainPivotPoint(t,i){const s=this.startCamera,n=R();u(n,this._pivotPos,s.eye);const h=C(n),p=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(s.eye,F);let m=Math.max(Math.min(N,1/Math.abs(f(F,s.viewForward)))*p,b);i&&(m=Math.min(h,m));const c=y(this.view.spatialReference),l=a(s.width/s.pixelRatio*.5,s.height/s.pixelRatio*.5),_=k(this.startCamera,l,c);let w=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,s.fullWidth/s.pixelRatio*.5,s.fullHeight/s.pixelRatio*.5,s,2.5*L,L),T=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,t[0],t[1],s,L);(r(w)||r(T))&&(w=o(w,T),T=e(T)||_===S.Horizontal?w:T,m=w>T?T:w,m=i?Math.min(m,h):m),P(n,n),v(this._pivotPos,E(this._tmpPivotPoint,s.eye,d(this._tmpPivotPoint,n,m)))}update(t){if(this.active){switch(this.pivot){case V.EYE:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this._pivotPos);break;case V.CENTER:this.currentCamera.center=this._pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this._pivotPos)}j(this.view,this.currentCamera,this._constraintOptions),this.commitCamera()}}end(){this.active&&this.finishController()}_applyRotation(t,r,o,e){this.view.renderCoordsHelper.worldUpAtPosition(e,this._tmpWorldUp),A(t,r,this._tmpRotCurPoint);let a=(this._lastPoint[1]-this._tmpRotCurPoint[1])*this._rotScale,n=(this._tmpRotCurPoint[0]-this._lastPoint[0])*this._rotScale;u(this._tmpViewDir,o,e);const h=C(this._tmpViewDir),c=i(f(this._tmpViewDir,this._tmpWorldUp)/h);if(this.pivot===V.EYE){a*=-.5;const t=.5*Math.PI-c,i=.5*Math.PI*.99;a=t-Math.max(-i,Math.min(i,t+a))}return a=s(a+c,x.min,x.max)-c,w(this._tmpAxis,t.up,this._tmpViewDir),this.pivot===V.CENTER&&(n=-n),p(this._tmpTransf,n,this._tmpWorldUp),m(this._tmpTransf,this._tmpTransf,a,this._tmpAxis),T(this._tmpViewDir,this._tmpViewDir,this._tmpTransf),t.up=T(W,t.up,this._tmpTransf),E(W,e,this._tmpViewDir),l(this._lastPoint,this._tmpRotCurPoint),W}};t([n()],H.prototype,"pivot",void 0),H=t([h("esri.views.3d.state.controllers.RotateController")],H);const W=R(),F=R();export{V as PivotPoint,H as RotateController};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{clamp as i}from"../../../../../core/mathUtils.js";import{unwrapOr as r,isSome as e}from"../../../../../core/maybe.js";import{createScreenPointArray as s}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as n,d as o}from"../../../../../chunks/vec2.js";import{a as c}from"../../../../../chunks/vec2f64.js";import{n as h,b as m,l as p,e as l,g as _,a as u}from"../../../../../chunks/vec3.js";import{c as P}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as y}from"../../../../../geometry/ellipsoidUtils.js";import{create as C,fromPoints as d}from"../../../../../geometry/support/axisAngle.js";import{c as f}from"../../../../../chunks/sphere.js";import{pixelDistanceToInteractionFactor as g,applyAll as j}from"../../../camera/constraintUtils.js";import{ConstraintTypes as v}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as R}from"../../../camera/constraintUtils/InteractionType.js";import{applySurfaceCollisionConstraint as k}from"../../../camera/constraintUtils/surfaceCollision.js";import{TiltMode as D}from"../../../camera/constraintUtils/TiltMode.js";import{InteractiveController as M}from"../InteractiveController.js";import{NavigationMode as w,normalizeCoordinate as A,pickPointAndInitSphere as U,contentIntersectorOptions as O,SpherePickPointFallback as b,decideNavigationMode as z,DISTANCE_CLAMP_VALUES as S,PIVOT_DISTANCE_MODIFIER as H,SCREEN_PIXEL_AREA as T,sphereOrPlanePointFromScreenPoint as x,applyRotation as L}from"../../utils/navigationUtils.js";import{fromScreenAtEye as B}from"../../../support/geometryUtils/ray.js";let E=class extends M{constructor(){super(...arguments),this._pickPoint=P(),this._tmpP0=c(),this._panAxisAngle=C(),this._tmpRayDir=P(),this._tmpRayDirPick=P(),this._targetOnSphere=P(),this._navMode=w.Horizontal,this._tmpRay={origin:P(),direction:P()},this.dragBeginPoint=s(),this._normalizedAnchorPoint=c(),this._constraintOptions={selection:v.ALL_EXCEPT_COLLISION,interactionType:R.ZOOM,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:D.TUMBLE},this._sphere=f(),this._hasPickPoint=!1}get _intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;n(this.dragBeginPoint,t),A(this.startCamera,t,this._normalizedAnchorPoint);const s=y(this.view.spatialReference),a=U(this._intersectionHelper,this.startCamera,t,s,b.Ellipsoid,0===this.view.map.ground.opacity?O:{});if(this._navMode=z(this.startCamera,t,s),this._navMode===w.Horizontal)this._hasPickPoint=!!a.scenePickPoint,this._pickPoint=r(a.scenePickPoint,this._pickPoint),this._sphere=a.sphere;else{let r;B(this.startCamera,t,this._tmpRay),h(this._tmpRay.direction,this._tmpRay.direction),e(a.scenePickPoint)&&(m(this._tmpRayDirPick,this.startCamera.eye,a.scenePickPoint),r=p(this._tmpRayDirPick));const s=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(this.startCamera.eye,F);let n=i(Math.min(H,1/Math.abs(l(F,this._tmpRay.direction)))*s,S[0],S[1]);const o=this.view._stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,T);n=e(o)?o:n,n=null!=r?Math.min(n,r):n,this._hasPickPoint=!0,_(this._tmpRay.direction,this._tmpRay.direction,n),u(this._pickPoint,this._tmpRay.origin,this._tmpRay.direction)}this._constraintOptions.interactionStartCamera=this.startCamera}update(t){if(this.active){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this._navMode===w.Horizontal){m(this._tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const i=p(this._tmpRayDir);A(this.currentCamera,t,this._tmpP0);const r=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let e=i*2**r;const s=this.view.state.constraints.minimumPoiDistance;if(r<0&&e<s&&(e=s),Math.abs(i-e)<1e-6)return;if(this._hasPickPoint&&e<i){const t=1-(1-e/i)*(1-this._sphere[3]/p(this.currentCamera.center));this.currentCamera.center=_(I,this.currentCamera.center,t)}_(this._tmpRayDir,this._tmpRayDir,-e/i),this.currentCamera.eye=u(I,this.currentCamera.center,this._tmpRayDir),this._constraintOptions.interactionFactor=g(o(this.dragBeginPoint,t)),j(this.view,this.currentCamera,this._constraintOptions),this._hasPickPoint&&(x(this._sphere,this.currentCamera,this.dragBeginPoint,this._targetOnSphere),d(this._pickPoint,this._targetOnSphere,this._panAxisAngle),L(this.currentCamera,this._sphere,this._panAxisAngle))}else{const i=p(this._tmpRay.direction);A(this.currentCamera,t,this._tmpP0);const r=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let e=i*2**r;const s=this.view.state.constraints.minimumPoiDistance;if(r<0&&e<s&&(e=s),Math.abs(i-e)<1e-6)return;_(this._tmpRayDir,this._tmpRay.direction,1-e/i),this.currentCamera.eye=u(I,this.currentCamera.eye,this._tmpRayDir),this.currentCamera.center=u(I,this.currentCamera.center,this._tmpRayDir)}k(this.view,this.currentCamera),this.commitCamera()}}end(){this.active&&this.finishController()}};E=t([a("esri.views.3d.state.controllers.global.ZoomController")],E);const I=P(),F=P();export{E as ZoomController};

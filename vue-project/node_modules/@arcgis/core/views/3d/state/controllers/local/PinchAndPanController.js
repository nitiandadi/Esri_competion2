/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{isSome as e}from"../../../../../core/maybe.js";import{createScreenPointArray as n,screenPointObjectToArray as o}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/Error.js";import"../../../../../core/has.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{d as r}from"../../../../../chunks/vec2.js";import{o as a,c as m,e as h,b as c,l,n as p,g as _,a as u}from"../../../../../chunks/vec3.js";import{c as d,f as C}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as g}from"../../../../../geometry/support/axisAngle.js";import{create as M,fromNormalAndOffset as v,setOffsetFromPoint as b,negate as f,normal as w}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as j,applyAll as E}from"../../../camera/constraintUtils.js";import{ConstraintTypes as P}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as S}from"../../../camera/constraintUtils/InteractionType.js";import{TiltMode as V}from"../../../camera/constraintUtils/TiltMode.js";import{ExponentialFalloff as z}from"../../../input/util.js";import{InteractiveController as H}from"../InteractiveController.js";import{PanPlanarMomentumController as y}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as O}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as T}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as A,contentIntersectorOptions as F,PAN_DISTANCE_MODIFIER as L,MIN_HEIGHT_LIMIT as U,SCREEN_PIXEL_AREA as x,centroid as R,applyZoomToPoint as D,applyPanPlanar as N,normalizeRotationDelta as k,applyRotation as I,intersectPlaneFromScreenPointAtEye as G}from"../../utils/navigationUtils.js";import{Camera as Z}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as B}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as W}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as q}from"../../../../navigation/ZoomMomentumEstimator.js";const J=C(0,0,1),K={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};let Q=class extends H{constructor(){super(...arguments),this._rotationValueSmooth=new z(.05),this._scalingValueSmooth=new z(.05),this._planeHorizontal=M(),this._planeVertical=M(),this._rotationMomentumEstimator=new W,this._panMomentumEstimator=new B(300,12,.9),this._zoomMomentumEstimator=new q,this._beginRadius=0,this._beginCenter=d(),this._beginAngle=0,this._tmpPoints=[],this._panMode=A.Horizontal,this._beginCenterScreen=n(),this._tmpCentroid3d=d(),this._tmpCentroid2d=n(),this._tmp2d=n(),this._pointerCount=0,this._constraintOptions={selection:P.ALL,interactionType:S.NONE,interactionFactor:0,interactionStartCamera:new Z,interactionDirection:null,tiltMode:V.TUMBLE}}begin(t){if(!this.active)return;const n=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=n,this._rotationMomentumEstimator.enabled=n,this._panMomentumEstimator.enabled=n,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),o(t.center,this._beginCenterScreen),v(J,0,this._planeHorizontal);const s=d(),r=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,s,0===this.view.map.ground.opacity?F:{}),C=d();a(C,this.startCamera.viewForward);const g=d();m(g,J);const M=h(C,g),j=i(M<0?-M:M);this._panMode=j>=K.ANGLE_THRESHOLD?A.Horizontal:A.Vertical;const E=Math.min(L,1/Math.abs(h(g,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),U);b(this._planeHorizontal,this._planeHorizontal,s),this.startCamera.aboveGround||f(this._planeHorizontal,this._planeHorizontal);const P=d(),S=d(),V=d();c(P,s,this.currentCamera.eye);const z=l(P);if(p(P,P),this._panMode===A.Vertical){_(g,g,M),c(this._planeVertical,C,g),p(this._planeVertical,this._planeVertical),b(this._planeVertical,this._planeVertical,s);const i=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,x);let n=e(i)?i:E;n=r?Math.min(n,z):n,m(V,u(S,this.currentCamera.eye,_(S,P,n))),this._planeVertical[3]=-h(this._planeVertical,V),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),R(this._tmpPoints,this._beginCenter)}else{const i=r?z:E;m(V,u(S,this.currentCamera.eye,_(S,P,i))),this._planeHorizontal[3]=-h(w(this._planeHorizontal),V),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),R(this._tmpPoints,this._beginCenter)}this._constraintOptions.interactionStartCamera?.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this._panMode===A.Horizontal?this._planeHorizontal:this._planeVertical,n=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),D(this.currentCamera,n,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=S.ZOOM,this._constraintOptions.interactionFactor=j(Math.abs(t.radius-this._beginRadius)),E(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,e,this.currentCamera,this._tmpPoints),R(this._tmpPoints,this._tmpCentroid3d),o(t.center,this._tmpCentroid2d),N(this.currentCamera,n,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=S.PAN,this._constraintOptions.interactionFactor=j(r(this._beginCenterScreen,this._tmpCentroid2d)),E(this.view,this.currentCamera,this._constraintOptions),i){const i=this._planeHorizontal,e=n,o=this._rotationValueSmooth.value,s=o+k(t.angle-o),r=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=r,this._rotationValueSmooth.update(s);const a=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(a,.001*t.timestamp),I(this.currentCamera,e,g(i,a)),this._constraintOptions.interactionType=S.TUMBLE,this._constraintOptions.interactionFactor=j(Math.abs(t.radius*a)),E(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new T({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new O({view:this.view,momentum:e,center:this._beginCenter,axis:w(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new y({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const o=this._tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=d()),G(i,e,o,n[s]),s+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};Q=t([s("esri.views.3d.state.controllers.local.PinchAndPanController")],Q);export{Q as PinchAndPanController};

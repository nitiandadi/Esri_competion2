/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import s from"../../../core/Handles.js";import{lerp as i}from"../../../core/mathUtils.js";import{isSome as r,releaseMaybe as a,disposeMaybe as o,destroyMaybe as n,isNone as h}from"../../../core/maybe.js";import{watch as d,initial as u}from"../../../core/reactiveUtils.js";import{property as l}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import{f as m}from"../../../chunks/mat3.js";import{v as p}from"../../../chunks/mat4.js";import{c as _}from"../../../chunks/mat4f64.js";import{s as f,o as g,c as w}from"../../../chunks/vec2.js";import{a as x}from"../../../chunks/vec2f64.js";import{f as T,z as v}from"../../../chunks/vec3f32.js";import{getReferenceEllipsoid as C}from"../../../geometry/ellipsoidUtils.js";import{C as y,a as P}from"../../../chunks/Clouds.glsl.js";import{CloudsTextureChannels as b,CloudsRenderingStages as S}from"./CloudsData.js";import{cloudPresets as I}from"./CloudsPresets.js";import{CloudsTechnique as E}from"./CloudsTechnique.js";import{CloudsTechniqueConfiguration as j,RayMarchingSteps as D}from"./CloudsTechniqueConfiguration.js";import{NoiseTextureAtlas as M}from"./NoiseTextureAtlas.js";import{BindParameters as z}from"../webgl-engine/lib/BindParameters.js";import{createQuadVAO as F}from"../webgl-engine/lib/glUtil3D.js";import{TaskPriority as R,Task as U}from"../../support/Scheduler.js";import{TextureType as N,PixelFormat as q,PixelType as B,TextureWrapMode as H,TextureSamplingMode as A,TargetType as O}from"../../webgl/enums.js";import{FramebufferObject as k}from"../../webgl/FramebufferObject.js";let G=class extends t{constructor(e){super(e),this._handles=new s,this._techniques=new Array,this._techniqueConfiguration=new j,this._bindParameters=new z(null,null,null),this._passParameters=new y,this._drawParameters=new P,this._weatherTile=x(),this._weatherTileCount=128,this._faceIndex=0,this._tileIndex=0,this.coverage=i(I.default.coverage[0],I.default.coverage[1],.5),this.density=i(I.default.density[0],I.default.density[1],.5),this.absorption=i(I.default.absorption[0],I.default.absorption[1],.5),this.cloudSize=i(I.default.cloudSize[0],I.default.cloudSize[1],.5),this.detailSize=i(I.default.detailSize[0],I.default.detailSize[1],.5),this.smoothness=i(I.default.smoothness[0],I.default.smoothness[1],.5),this.cloudHeight=i(I.default.cloudHeight[0],I.default.cloudHeight[1],.5),this.raymarchingSteps=I.default.raymarchingSteps,this._viewMatrix=_(),this._dirty=!1,this.running=!1}_getTechnique(e){const t=1-this.context.renderContext.bindParameters.cloudsFade.readChannels,s=t===b.RG?2*e:2*e+1,i=this._techniques[s];return i||(this._techniqueConfiguration.writeTextureChannels=t,this._techniqueConfiguration.steps=e,this._techniques[s]=new E({rctx:this.context.renderContext.rctx,viewingMode:this.view.state.viewingMode},this._techniqueConfiguration),this._techniques[s])}updateWeatherTile(){const e=this.view.camera.position.latitude,t=this.view.camera.position.longitude;if(null==e||null==t)return;f(this._weatherTile,(e+90)/180,(t+180)/360);const s=Math.floor(this._weatherTileCount*Math.abs(2*this._weatherTile[0]-1));this._weatherTile[0]=Math.floor(2*this._weatherTileCount*this._weatherTile[0]),this._weatherTile[1]=Math.floor(4*(this._weatherTileCount-s)*this._weatherTile[1]);let i=0,a=0;if(r(this.view.environment)&&"virtual"!==this.view.environment.lighting.type&&r(this.view.environment.lighting.date)){const e=new Date(this.view.environment.lighting.date);e.setUTCHours(this.view.environment.lighting.date.getUTCHours()+(this.view.environment.lighting.displayUTCOffset??0)),i=31*e.getUTCMonth()+e.getUTCDate(),a=e.getUTCFullYear()}this._weatherTile[0]=(this._weatherTile[0]+i)%(2*this._weatherTileCount),this._weatherTile[1]=(this._weatherTile[1]+a%100)%(4*this._weatherTileCount),g(this._passParameters.weatherTile,this._weatherTile)||this.setDirty()}initialize(){this._vao=F(this.context.renderContext.rctx);const e=C(this.view.spatialReference);this._passParameters.cloudRadius=.5*e.radius,this.setDirty(),this.updateWeatherTile(),this._handles.add([this.view.resourceController.scheduler.registerTask(R.CLOUDS_GENERATOR,this),d((()=>[this.coverage,this.density,this.absorption,this.cloudSize,this.detailSize,this.smoothness,this.cloudHeight,this.raymarchingSteps]),(()=>this.setDirty()),u)])}destroy(){this._handles.destroy(),this._techniques.forEach((e=>a(e))),this._frameBufferCube=o(this._frameBufferCube),this._techniques.length=0,this._vao=o(this._vao),this._passParameters.noiseTexture=n(this._passParameters.noiseTexture)}get _tilesPerFace(){switch(this._techniqueConfiguration.steps){case D.SIXTEEN:return 1;case D.HUNDRED:return 4;case D.COUNT:case D.TWOHUNDRED:return 8}}_ensureNoiseTexture(){if(r(this._passParameters.noiseTexture))this._passParameters.noiseTexture.updateWeatherMap(this._passParameters.weatherTile);else{const e=this.context;this._passParameters.noiseTexture=new M({context:e}),this._passParameters.noiseTexture.updateWeatherMap(this._passParameters.weatherTile)}return r(this._passParameters.noiseTexture.textureAtlas)}_ensureFrameBufferCube(e){if(h(this._frameBufferCube)){const t={target:N.TEXTURE_CUBE_MAP,pixelFormat:q.RGBA,dataType:B.UNSIGNED_BYTE,wrapMode:H.CLAMP_TO_EDGE,samplingMode:A.LINEAR,hasMipmap:!1,width:e,height:e};this._frameBufferCube=new k(this.context.renderContext.rctx,{colorTarget:O.CUBEMAP,width:e,height:e},t)}return this._frameBufferCube}get cubeMap(){return this._frameBufferCube}destroyFrameBufferCube(){this._frameBufferCube=o(this._frameBufferCube)}applyPreset(e,t){const s=e.median,r=e=>{const r=i(e[0],e[1],s);return t<.5?i(e[0],r,2*t):i(r,e[1],2*(t-.5))};this.coverage=r(e.coverage),this.density=r(e.density),this.absorption=r(e.absorption),this.cloudSize=r(e.cloudSize),this.detailSize=r(e.detailSize),this.smoothness=r(e.smoothness),this.cloudHeight=r(e.cloudHeight),this.raymarchingSteps=e.raymarchingSteps}setDirty(){this._dirty=this.running=!0}runTask(e){if(h(this._vao))return this._dirty=this.running=!1,this.context.renderContext.bindParameters.cloudsFade.renderingStage=S.FINISHED_RENDERING,void e.madeProgress();0===this._faceIndex&&0===this._tileIndex&&(this._passParameters.raymarchingSteps=this.raymarchingSteps,this.updateWeatherTile(),w(this._passParameters.weatherTile,this._weatherTile));const t=this._getTechnique(this._passParameters.raymarchingSteps);if(!t.compiled)return U.YIELD;if(!this.context.renderContext.bindParameters.cloudsFade.isCameraPositionFinal||this.context.renderContext.bindParameters.cloudsFade.isFading||!this._ensureNoiseTexture())return U.YIELD;0===this._faceIndex&&0===this._tileIndex&&(this.context.renderContext.bindParameters.cloudsFade.renderingStage=S.RENDERING,this._passParameters.absorption=this.absorption,this._passParameters.density=this.density,this._passParameters.cloudSize=this.cloudSize,this._passParameters.detailSize=this.detailSize,this._passParameters.smoothness=this.smoothness,this._passParameters.cloudHeight=this.cloudHeight,this._passParameters.coverage=this.coverage,this._dirty=!1);const s=this.context.renderContext.rctx,i=s.bindTechnique(t,this._passParameters,this._bindParameters);s.bindVAO(this._vao),i.assertCompatibleVertexAttributeLocations(this._vao);const r=s.getViewport(),a=t.configuration.cubeMapSize,o=a/this._tilesPerFace,n=this._tileIndex*o;s.setViewport(0,n,a,o);const d=this._ensureFrameBufferCube(a);s.bindFramebuffer(d);const u=L[this._faceIndex],l=V[this._faceIndex];p(this._viewMatrix,W,u,l),m(this._drawParameters.viewMatrix,this._viewMatrix);const c=N.TEXTURE_CUBE_MAP_POSITIVE_X+this._faceIndex;return d.setColorTextureTarget(c),i.bindDraw(this._drawParameters,this._bindParameters,this._passParameters),s.gl.drawArrays(s.gl.TRIANGLE_STRIP,0,4),s.gl.flush(),s.setViewport(r.x,r.y,r.width,r.height),this.requestRender(),++this._tileIndex,4===this._faceIndex&&this._tileIndex===this._tilesPerFace?(this.running=this._dirty,this._faceIndex=0,this._tileIndex=0,this.context.renderContext.bindParameters.cloudsFade.renderingStage=S.FINISHED_RENDERING):this._tileIndex===this._tilesPerFace&&(++this._faceIndex,this._tileIndex=0),e.madeProgress(),U.YIELD}};e([l({constructOnly:!0})],G.prototype,"context",void 0),e([l({constructOnly:!0})],G.prototype,"view",void 0),e([l({constructOnly:!0})],G.prototype,"requestRender",void 0),e([l()],G.prototype,"coverage",void 0),e([l()],G.prototype,"density",void 0),e([l()],G.prototype,"absorption",void 0),e([l()],G.prototype,"cloudSize",void 0),e([l()],G.prototype,"detailSize",void 0),e([l()],G.prototype,"smoothness",void 0),e([l()],G.prototype,"cloudHeight",void 0),e([l()],G.prototype,"raymarchingSteps",void 0),e([l()],G.prototype,"running",void 0),G=e([c("esri.views.3d.environment.CloudsGenerator")],G);const L=[T(1,0,0),T(-1,0,0),T(0,1,0),T(0,-1,0),T(0,0,1)],V=[T(0,1,0),T(0,1,0),T(0,0,-1),T(0,0,1),T(0,1,0)],W=v();export{G as CloudsGenerator};

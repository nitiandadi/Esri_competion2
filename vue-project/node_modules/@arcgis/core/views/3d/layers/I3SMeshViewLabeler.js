/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import r from"../../../Graphic.js";import"../../../symbols.js";import i from"../../../core/Accessor.js";import t from"../../../core/Handles.js";import{destroyMaybe as s,isNone as o,isSome as a}from"../../../core/maybe.js";import{watch as n}from"../../../core/reactiveUtils.js";import{property as l}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{diff as c}from"../../../core/accessorSupport/diffUtils.js";import{c as d}from"../../../chunks/vec3f64.js";import{makeDehydratedPoint as h}from"../../../layers/graphics/dehydratedFeatures.js";import{Graphics3DCore as g}from"./graphics/Graphics3DCore.js";import m from"./graphics/Graphics3DScaleVisibility.js";import{boundingBoxTop as y}from"./i3s/I3SGeometryUtil.js";import{LimitGraphicsMap as u}from"../support/LimitGraphicsMap.js";import{UpdatePolicy as f}from"../webgl-engine/lib/UpdatePolicy.js";import b from"../../../symbols/PointSymbol3D.js";let v=class extends i{get updating(){return this._graphicsCore?.updating??!1}constructor(e){super(e),this.loadedGraphics=new u(5e4),this.slicePlaneEnabled=!1,this._renderingInfo={symbol:new b},this._handles=new t,this._graphicsByNode=new Map}initialize(){const e=this.view.basemapTerrain;this._graphicsCore=new g({owner:this,layer:this.layer,preferredUpdatePolicy:f.ASYNC,elevationFeatureExpressionEnabled:!1,graphicSymbolSupported:!1,getRenderingInfoWithoutRenderer:!0,hasZ:!0,hasM:!1,componentFactories:{deconflictor:e=>this.view.deconflictor.addGraphicsOwner(e),labeler:(e,r)=>this.view.labeler.addGraphicsOwner(e,r,{emptySymbolLabelSupported:!0,elevationInfoOverride:{mode:"absolute-height",offset:0},disablePlacement:{logEntityDescription:"3D Object Scene Layer features"}}),scaleVisibility:(r,i)=>new m({graphicsCoreOwner:this,layer:this.layer,queryGraphicUIDsInExtent:i,graphicsCore:r,basemapTerrain:e,layerScaleEnabled:!1})}}),this._graphicsCore.initializePromise.then((()=>this._graphicsCore.startCreateGraphics())).catch((()=>{})),this._handles.add(n((()=>this.layer.labelingInfo),((e,r)=>{c(e,r)&&this._graphicsCore.updateLabelingInfo()})))}destroy(){this._handles=s(this._handles),this._graphicsCore=s(this._graphicsCore),this.loadedGraphics=s(this.loadedGraphics),this.view=null}addNodeMeta(e,i){let t=0;const s=e.filteredIds,a=this.view.spatialReference,n=e.featureIds.map(((n,l)=>{y(l,this.collection,e.objectHandle,_);const p=h(0,0,0,a);this.view.renderCoordsHelper.fromRenderCoords(_,p);const c=i(l,e);let d=!1;return o(s)?d=!0:t<s.length&&n===s[t]&&(d=!0,t++),{objectId:n,uid:r.generateUID(),attributes:c,visible:d,geometry:p}}));this.loadedGraphics.addMany(n),this._graphicsByNode.set(e.node.index,n)}updateLabelPositions(e){const r=this._graphicsByNode.get(e.node.index);if(!r)return;let i=0;const t=this.view.spatialReference,s=this.view.renderCoordsHelper;for(let n=0;n<e.featureIds.length;n++){const l=r[i];if(e.featureIds[n]===l.objectId){i++;const r=this._graphicsCore.getGraphics3DGraphicById(l.uid);if(o(r))continue;y(n,this.collection,e.objectHandle,_),this.view.renderCoordsHelper.fromRenderCoords(_,_,t),r.alignWithAbsoluteElevation(_[2],s,!1),a(l.geometry)&&"point"===l.geometry.type&&(l.geometry.z=_[2])}}}setNodeMetaAttributes(e,r){const i=this._graphicsByNode.get(e.node.index);if(!i)return;const t=new Array(i.length);for(let s=0;s<i.length;s++){const o=i[s];o.attributes=r(s,e),t[s]=o.uid}this._graphicsCore.updateLabelingInfo(t)}applyFilterChange(e){const r=this._graphicsByNode.get(e.node.index);if(r)if(o(e.filteredIds))for(const i of r)i.visible||(i.visible=!0,C.graphic=i,C.property="visible",C.oldValue=!1,C.newValue=!0,this._graphicsCore.graphicUpdateHandler(C));else{let i=0;for(const t of r){const r=t.visible;i<e.filteredIds.length&&t.objectId===e.filteredIds[i]?(t.visible=!0,i++):t.visible=!1,r!==t.visible&&(C.graphic=t,C.property="visible",C.oldValue=r,C.newValue=t.visible,this._graphicsCore.graphicUpdateHandler(C))}}}removeNodeMeta(e){this.loadedGraphics.removeManyByObjectId(e.featureIds)}getRenderingInfo(){return this._renderingInfo}notifyGraphicGeometryChanged(){}notifyGraphicVisibilityChanged(){}get updatePolicy(){return this._graphicsCore.effectiveUpdatePolicy}get usedMemory(){return this._graphicsCore.usedMemory}get unloadedMemoryEstimate(){return this._graphicsCore.unprocessedMemoryEstimate}get test(){return{graphicsCore:this._graphicsCore}}};e([l()],v.prototype,"view",void 0),e([l()],v.prototype,"layer",void 0),e([l()],v.prototype,"collection",void 0),e([l()],v.prototype,"loadedGraphics",void 0),e([l()],v.prototype,"updating",null),e([l()],v.prototype,"slicePlaneEnabled",void 0),e([l()],v.prototype,"_graphicsCore",void 0),v=e([p("esri.views.3d.layers.I3SMeshViewLabeler")],v);const C={graphic:null,property:null,oldValue:null,newValue:null},_=d(),j=v;export{j as default};

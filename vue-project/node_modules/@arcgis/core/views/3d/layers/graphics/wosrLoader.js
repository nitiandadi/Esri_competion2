/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{result as t}from"../../../../core/asyncUtils.js";import{estimateNestedObjectSize as r}from"../../../../core/byteSizeEstimations.js";import n from"../../../../core/Error.js";import s from"../../../../core/Logger.js";import{isSome as o,unwrap as a,isNone as i}from"../../../../core/maybe.js";import{NestedMap as u}from"../../../../core/NestedMap.js";import{throwIfAbortError as l}from"../../../../core/promiseUtils.js";import{Version as c}from"../../../../core/Version.js";import{d as p}from"../../../../chunks/vec3f64.js";import{empty as m,expandWithVec3 as f}from"../../../../geometry/support/aaBoundingBox.js";import{requestImage as d}from"../../../../support/requestImageUtils.js";import{Attribute as g}from"../../webgl-engine/lib/Attribute.js";import{CullFaceOptions as y,AlphaDiscardMode as b}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as w}from"../../webgl-engine/lib/Geometry.js";import{Texture as x}from"../../webgl-engine/lib/Texture.js";import{DefaultMaterial as h}from"../../webgl-engine/materials/DefaultMaterial.js";import{TextureWrapMode as v}from"../../../webgl/enums.js";const j=s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");async function A(e,t){const n=await M(e,t),s=await k(n.textureDefinitions??{},t);let o=0;for(const r in s)if(s.hasOwnProperty(r)){const e=s[r];o+=e?.image?e.image.width*e.image.height*4:0}return{resource:n,textures:s,size:o+r(n)}}async function M(r,n){const s=o(n)&&n.streamDataRequester;if(s)return P(r,s,n);const i=await t(e(r,a(n)));if(!0===i.ok)return i.value.data;l(i.error),U(i.error)}async function P(e,r,n){const s=await t(r.request(e,"json",n));if(!0===s.ok)return s.value;l(s.error),U(s.error.details.url)}function U(e){throw new n("",`Request for object resource failed: ${e}`)}function E(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(j.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(j.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(j.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(j.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else j.warn("Indexed geometries must specify faces"),n=!1;break}default:j.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(j.warn("Geometry requires material"),n=!1);const s=e.params.vertexAttributes;for(const o in s){s[o].values||(j.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function I(e,t){const r=new Array,n=new Array,s=new Array,a=new u,l=e.resource,m=c.parse(l.version||"1.0","wosr");R.validate(m);const f=l.model.name,d=l.model.geometries,b=l.materialDefinitions??{},v=e.textures;let j=0;const A=new Map;for(let u=0;u<d.length;u++){const e=d[u];if(!E(e))continue;const l=O(e),c=e.params.vertexAttributes,m=[];for(const t in c){const e=c[t],r=e.values;m.push([t,new g(r,e.valuesPerElement,!0)])}const f=[];if("PerAttributeArray"!==e.params.topology){const t=e.params.faces;for(const e in t)f.push([e,t[e].values])}const M=l.texture,P=v&&v[M];if(P&&!A.has(M)){const{image:e,params:t}=P,r=new x(e,t);n.push(r),A.set(M,r)}const U=A.get(M),I=U?U.id:void 0,T=l.material;let k=a.get(T,M);if(i(k)){const e=b[T.substring(T.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=P&&P.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,s=P?q(P.alphaChannelUsage):void 0,i={ambient:p(e.diffuse),diffuse:p(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:s,textureAlphaCutoff:.33,textureId:I,initTextureTransparent:!0,doubleSided:!0,cullFace:y.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:!!P&&!!P.params.preMultiplyAlpha};o(t)&&t.materialParamsMixin&&Object.assign(i,t.materialParamsMixin),k=new h(i),a.set(T,M,k)}s.push(k);const R=new w(k,m,f);j+=f.position?f.position.length:0,r.push(R)}return{engineResources:[{name:f,stageResources:{textures:n,materials:s,geometries:r},pivotOffset:l.model.pivotOffset,numberOfVertices:j,lodThreshold:null}],referenceBoundingBox:T(r)}}function T(e){const t=m();return e.forEach((e=>{const r=e.boundingInfo;o(r)&&(f(t,r.bbMin),f(t,r.bbMax))})),t}async function k(e,t){const r=[];for(const a in e){const n=e[a],s=n.images[0].data;if(!s){j.warn("Externally referenced texture data is not yet supported");continue}const i=n.encoding+";base64,"+s,u="/textureDefinitions/"+a,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",c={noUnpackFlip:!0,wrap:{s:v.REPEAT,t:v.REPEAT},preMultiplyAlpha:q(l)!==b.Opaque},p=o(t)&&t.disableTextures?Promise.resolve(null):d(i,t);r.push(p.then((e=>({refId:u,image:e,params:c,alphaChannelUsage:l}))))}const n=await Promise.all(r),s={};for(const o of n)s[o.refId]=o;return s}function q(e){switch(e){case"mask":return b.Mask;case"maskAndTransparency":return b.MaskBlend;case"none":return b.Opaque;default:return b.Blend}}function O(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const R=new c(1,2,"wosr");export{k as createTextureResources,A as load,I as processLoadResult};

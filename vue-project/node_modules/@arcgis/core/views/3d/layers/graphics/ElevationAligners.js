/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isNone as t}from"../../../../core/maybe.js";import{c as e}from"../../../../chunks/mat4.js";import{c as o}from"../../../../chunks/mat4f64.js";import{s as n}from"../../../../chunks/vec3.js";import{c as a}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as r,projectBuffer as s}from"../../../../geometry/projection.js";import{SampleElevationInfo as i}from"./elevationAlignmentUtils.js";import{updateVertexAttributeAuxpos1w as l}from"./graphicUtils.js";import m from"../../support/debugFlags.js";import{SamplePosition as c}from"../../support/ElevationProvider.js";import{isGeometryWithMapPositions as f}from"../../webgl-engine/lib/GeometryWithMapPositions.js";import{VertexAttribute as u}from"../../webgl-engine/lib/VertexAttribute.js";function p(t,e,o,n,a){const r=t.stageObject,s=r.geometries;let i=0;for(const l of s){if(!f(l))continue;const{update:t,averageGeometrySampledElevation:s}=O(l,e,o,n,a);i+=s,t&&r.geometryVertexAttrsUpdated(l)}return i/s.length}function d(t,o,a,s,i){const c=t.stageObject,f=o.centerPointInElevationSR;let u=0;if(c.metadata?.usesVerticalDistanceToGround)s(f,A),l(c,A.verticalDistanceToGround),u=A.sampledElevation;else{s(f,A);"absolute-height"!==o.mode&&(u=A.sampledElevation)}const p=e(g,c.transformation),d=n(M,p[12],p[13],p[14]);m.TESTS_DISABLE_OPTIMIZATIONS?(h[0]=f.x,h[1]=f.y,h[2]=A.z,r(f.spatialReference,h,p,i.spatialReference)&&(c.transformation=p)):i.setAltitudeOfTransformation(A.z,p);const b=T/i.unitInMeters;return(Math.abs(p[12]-d[0])>=b||Math.abs(p[13]-d[1])>=b||Math.abs(p[14]-d[2])>=b)&&(c.transformation=p),u}const g=o();function b(e,o,a,s,i){const l=e.graphics3DSymbolLayer.lodRenderer;if(t(l))return 0;const c=o.centerPointInElevationSR;s(c,A);const f="absolute-height"!==o.mode?A.sampledElevation:0,u=l.instanceData,p=e.instanceIndex,d=E;u.getGlobalTransform(p,d);const g=n(M,d[12],d[13],d[14]);m.TESTS_DISABLE_OPTIMIZATIONS?(h[0]=c.x,h[1]=c.y,h[2]=A.z,r(c.spatialReference,h,d,i.spatialReference)&&u.setGlobalTransform(p,d)):i.setAltitudeOfTransformation(A.z,d);const b=T/i.unitInMeters;return(m.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(d[12]-g[0])>=b||Math.abs(d[13]-g[1])>=b||Math.abs(d[14]-g[2])>=b)&&u.setGlobalTransform(p,d),f}function I(t,e,o,n,a){const r=t.stageObject,s=r.geometries;if(0===s.length)return 0;let i=0,l=null,m=0,c=!1;for(const p of s){if(!f(p))continue;const t=p.vertexAttributes.get(u.POSITION);if(t!==l){const{update:r,averageGeometrySampledElevation:s}=O(p,e,o,n,a);m=s,l=t,c=r}c&&r.geometryVertexAttrsUpdated(p),i+=m}return i/s.length}const T=.01,h=a(),S=a(),v=a(),E=o(),M=a(),A=new i;function O(t,e,o,n,a){let r=!1;const i=t.shaderTransformation,l=e.requiresSampledElevationInfo;S[0]=i[12],S[1]=i[13],S[2]=i[14],t.invalidateBoundingInfo();const f=t.getMutableAttribute(u.POSITION),p=f.data,d=f.size,g=p.length/d,b=new c(t.mapPositions,o);let I=0,E=0;for(let c=0;c<g;c++){if(v[0]=p[I],v[1]=p[I+1],v[2]=p[I+2],n(b,A),l&&(E+=A.sampledElevation),m.TESTS_DISABLE_OPTIMIZATIONS)p[I]=b.array[b.offset],p[I+1]=b.array[b.offset+1],p[I+2]=A.z,s(p,o,I,p,a.spatialReference,I,1),p[I]-=S[0],p[I+1]-=S[1],p[I+2]-=S[2],r=!0;else{h[0]=p[I]+S[0],h[1]=p[I+1]+S[1],h[2]=p[I+2]+S[2],a.setAltitude(h,A.z),p[I]=h[0]-S[0],p[I+1]=h[1]-S[1],p[I+2]=h[2]-S[2];const t=T/a.unitInMeters;(Math.abs(v[0]-p[I])>=t||Math.abs(v[1]-p[I+1])>=t||Math.abs(v[2]-p[I+2])>=t)&&(r=!0)}I+=d,b.offset+=3}return E/=g,{update:r,averageGeometrySampledElevation:E}}export{b as perLodInstanceElevationAligner,d as perObjectElevationAligner,p as perVertexElevationAligner,I as sharedGeometryElevationAligner};

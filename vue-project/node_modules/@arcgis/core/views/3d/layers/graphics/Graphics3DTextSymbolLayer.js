/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{isNone as t,isSome as r,get as s,unwrap as n}from"../../../../core/maybe.js";import{isPromiseLike as i}from"../../../../core/promiseUtils.js";import{pt2px as o}from"../../../../core/screenUtils.js";import{f as a,Z as l,a as c}from"../../../../chunks/vec2f64.js";import{hasCalloutSupport as m,textSymbolLayerSupportsVerticalOffset as h}from"../../../../symbols/callouts/calloutUtils.js";import{CreateLabelParameters as d}from"./CreateLabelParameters.js";import{perObjectElevationAligner as p}from"./ElevationAligners.js";import{SymbolUpdateType as f,needsElevationUpdates2D as u}from"./elevationAlignmentUtils.js";import{ElevationContext as g}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as y}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DObjectMetadata as x}from"./Graphics3DObjectMetadata.js";import{Graphics3DSymbolLayer as b}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as v}from"./graphicUtils.js";import{verticalPlacementFromAlignment as P,textRenderAlignmentFromHorizontalPlacement as O,horizontalPlacementToAnchorX as j,anchorFromPlacements as w,namedAnchorToHUDMaterialAnchorPos as S}from"./placementUtils.js";import{placePointOnGeometry as _,createStageObject as E,extendPointGraphicElevationContext as L}from"./pointUtils.js";import{createPointGeometry as C}from"../../webgl-engine/lib/GeometryUtil.js";import{TextRenderParameters as z}from"../../webgl-engine/lib/TextRenderParameters.js";import G from"../../webgl-engine/lib/TextTextureFactory.js";import{HUDMaterial as R}from"../../webgl-engine/materials/HUDMaterial.js";const U=[0,0,1];class D extends b{constructor(e,t,r,s){super(e,t,r,s),this._elevationOptions={supportsOffsetAdjustment:!0,supportsOnTheGround:!1},this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=v(this.symbolLayer.size);if(t)throw new e("graphics3dtextsymbollayer:invalid-size",t)}await this._createTextRenderParameters()}async _createTextRenderParameters(){const e=this._context.graphicsCoreOwner.view.state.rasterPixelRatio;this._textRenderParameters=await z.fromSymbol(this.symbolLayer,e)}destroy(){super.destroy()}createGraphics3DGraphic(e){const s=e.graphic,n=_(s.geometry);if(t(n))return this.logger.warn(`unsupported geometry type for text symbol: ${s.geometry.type}`),null;const i=this.symbolLayer.text;if(t(i)||""===i)return null;const o=m(this.symbol)&&this.symbol.hasVisibleVerticalOffset()?this.symbol.verticalOffset:null;if(r(o)&&!h(this.symbolLayer))return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`),null;const a=new d(o,this.symbolLayer.horizontalAlignment,P(this.symbolLayer.verticalAlignment));return this._createAs3DShape(s,n,i,a)}createLabel(e,r,s,n){const i=e.graphic,o=_(i.geometry);if(t(o))return this.logger.warn(`unsupported geometry type for label: ${i.geometry.type}`),null;const a=r.text;return!a||/^\s+$/.test(a)?null:this._createAs3DShape(i,o,a,r,s,n)}setGraphicElevationContext(e,t,r=0){const s=super.setGraphicElevationContext(e,t);return s.addOffsetRenderUnits(r),s}layerOpacityChanged(){return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"),!1}layerElevationInfoChanged(e,t){return A(e,t,((e,t)=>{this.updateGraphicElevationContext(t,e)})),f.UPDATE}slicePlaneEnabledChanged(e,t){return A(e,t,(e=>{for(const t of e.stageObject.geometries)t.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),!0}physicalBasedRenderingChanged(){return!0}pixelRatioChanged(){return!1}skipHighSymbolLodsChanged(){return!0}updateGraphicElevationContext(e,t){const s=t.elevationContext;this.setGraphicElevationContext(e,s,r(t.metadata)?t.metadata.elevationOffset:0),t.needsElevationUpdates=u(s.mode)||"absolute-height"===s.mode}_defaultElevationInfoNoZ(){return W}_createAs3DShape(e,m,h,d,f,b){const v=this.setGraphicElevationContext(e,new g,d.elevationOffset),P="polyline"===s(e.geometry,"type"),j=e.uid;let w=null,S=null;if(t(b)){const e=O(d.horizontalPlacement);w=new G(h,e,this._textRenderParameters);let s=null;if(r(this._context.sharedResources.textures)){S=this._context.sharedResources.textures.fromData(w.key,(()=>n(w).create()),(()=>{r(s)&&s.release()}));const e=this._context.stage.renderView.textureRepository.acquire(S.texture.id);if(t(e)||i(e))return S.release(),null;s=e}}const _=T(w,d),z={occlusionTest:!0,screenOffset:d.screenOffset,anchorPosition:_,polygonOffset:!0,color:[1,1,1,1],centerOffsetUnits:d.centerOffsetUnits,drawInSecondSlot:!0};if(r(b)?z.textureId=b.id:r(S)&&(z.textureId=S.texture.id),r(d.verticalOffset)){const{screenLength:e,minWorldLength:t,maxWorldLength:s}=d.verticalOffset;z.verticalOffset={screenLength:o(e),minWorldLength:t||0,maxWorldLength:r(s)?s:1/0}}if(this._context.screenSizePerspectiveEnabled){const{screenSizePerspectiveSettings:e,screenSizePerspectiveSettingsLabels:t}=this._context.sharedResources;z.screenSizePerspective=t.overridePadding(this._textRenderParameters.haloSize+this._textRenderParameters.definition.background.padding[0]),z.screenSizePerspectiveAlignment=e}let D;if(P&&(z.shaderPolygonOffset=1e-4),z.hasSlicePlane=this._context.slicePlaneEnabled,r(f)){const e=JSON.stringify(z);D=f.get(e),t(D)&&(D=new R(z),f.add(e,D))}else D=new R(z);const A=d.translation,W=r(w)?a(w.displayWidth,w.displayHeight):l,k=d.centerOffset,I=C(D,U,A,null,W,k,[0,0],null),H=E(this._context,m,I,v,j);if(t(H))return null;const $=new y(this,H.object,[I],t(f)?[D]:null,S,p,v);$.alignedSampledElevation=H.sampledElevation,$.needsElevationUpdates=u(v.mode)||"absolute-height"===v.mode;const{displayWidth:V,displayHeight:M}=r(w)?w:d;$.getScreenSize=(e=c())=>(e[0]=V,e[1]=M,e);const N=new x(d.elevationOffset,h);return $.metadata=N,L($,m,this._context.elevationProvider),$}}function A(e,t,s){e&&e.forEach((e=>{const n=t(e);r(n)&&s(n,e.graphic)}))}function T(e,t){if("baseline"===t.verticalPlacement){const s=j[t.horizontalPlacement],n=r(e)?e.baselineAnchorY:0;return a(s,n)}const s=w(t.horizontalPlacement,t.verticalPlacement);return S[s]}const W={mode:"relative-to-ground",offset:0};export{D as Graphics3DTextSymbolLayer};

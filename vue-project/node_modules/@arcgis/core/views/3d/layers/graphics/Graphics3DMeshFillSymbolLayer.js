/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import e from"../../../../Color.js";import"../../../../core/has.js";import{isSome as t,isNone as r,unwrapOr as o,get as a}from"../../../../core/maybe.js";import{f as n,t as s}from"../../../../chunks/mat3.js";import{c as i}from"../../../../chunks/mat3f64.js";import{f as l,m as c,a as u}from"../../../../chunks/mat4.js";import{c as m,b as h}from"../../../../chunks/mat4f64.js";import{a as f,g as p,e as g,n as d,b as x,f as _}from"../../../../chunks/vec3.js";import{Z as T,O as y,c as b}from"../../../../chunks/vec3f64.js";import{O as v}from"../../../../chunks/vec4f64.js";import{projectVectorToDehydratedPoint as C,projectBuffer as O,computeTranslationToOriginAndRotation as w,canProjectWithoutEngine as A}from"../../../../geometry/projection.js";import{create as M,empty as j,expandWithBuffer as E,intersectsClippingArea as R}from"../../../../geometry/support/aaBoundingBox.js";import N from"../../../../geometry/support/MeshComponent.js";import P from"../../../../geometry/support/MeshMaterialMetallicRoughness.js";import{BufferViewVec3f64 as I,BufferViewVec3f as B}from"../../../../geometry/support/buffer/BufferView.js";import{t as S,a as F}from"../../../../chunks/vec32.js";import{transformPosition as L,transformNormal as V,projectNormalToPCPF as U,transformTangent as G,projectTangentToPCPF as $}from"../../../../geometry/support/meshUtils/projection.js";import{makeDehydratedPoint as D}from"../../../../layers/graphics/dehydratedFeatures.js";import{ViewingMode as k}from"../../../ViewingMode.js";import{isEncodedMeshTexture as H}from"../../glTF/internal/resourceUtils.js";import{getTransformMatrix as q}from"../../glTF/internal/TextureTransformUtils.js";import{perObjectElevationAligner as W}from"./ElevationAligners.js";import{needsElevationUpdates3D as Y,evaluateElevationInfoAtPoint as z}from"./elevationAlignmentUtils.js";import{ElevationContext as Z}from"./ElevationContext.js";import{Object3DEdgeState as J,Graphics3DObject3DGraphicLayer as K}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as Q}from"./Graphics3DSymbolLayer.js";import{createMaterial as X}from"../support/edgeUtils.js";import{parseColorMixMode as ee,encodeSymbolColor as te}from"../support/symbolColorUtils.js";import re from"../../support/debugFlags.js";import{Attribute as oe}from"../../webgl-engine/lib/Attribute.js";import{AlphaDiscardMode as ae,CullFaceOptions as ne}from"../../webgl-engine/lib/basicInterfaces.js";import{ContentObjectType as se}from"../../webgl-engine/lib/ContentObjectType.js";import{newFloatArray as ie}from"../../webgl-engine/lib/FloatArray.js";import{Geometry as le}from"../../webgl-engine/lib/Geometry.js";import{generateDefaultIndexArray as ce}from"../../webgl-engine/lib/Indices.js";import{Object3D as ue}from"../../webgl-engine/lib/Object3D.js";import{Texture as me}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as he}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as fe}from"../../webgl-engine/materials/DefaultMaterial.js";import{NativeLineMaterial as pe}from"../../webgl-engine/materials/NativeLineMaterial.js";import{TextureWrapMode as ge}from"../../../webgl/enums.js";const de=["mesh"];class xe extends Q{constructor(e,t,r,o){super(e,t,r,o),this._materials=new Map,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){re.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new pe({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new pe({color:[0,1,1,1]}))}destroy(){super.destroy(),this._context.stage.removeMany(Array.from(this._materials.values(),(e=>e.material))),this._context.stage.removeMany(Array.from(this._textures.values())),this._materials.clear(),this._textures.clear()}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,de,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t,new Z),o=e.renderingInfo;return this._createAs3DShape(t,o,r,t.uid)}layerOpacityChanged(e,r){const o=this._getLayerOpacity();this._materials.forEach((e=>{e.material.setParameters({layerOpacity:o});const t=e.material.parameters;this._setMaterialTransparentParameter(t,e),e.material.setParameters({transparent:t.transparent})})),e.forEach((e=>{const a=r(e);t(a)&&a.layerOpacityChanged(o,this._context.isAsync)}))}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,Y)}slicePlaneEnabledChanged(e,r){return this._materials.forEach((e=>{e.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e.forEach((e=>{const o=r(e);t(o)&&o.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){const e=this._usePBR();return this._materials.forEach((t=>t.material.setParameters({usePBR:e}))),!0}pixelRatioChanged(){return!0}skipHighSymbolLodsChanged(){return!0}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_colorOrTextureUid(t){return r(t)?"-":t instanceof e?t.toHex():t.contentHash}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),o=!!e.vertexAttributes.color,a=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:o,hasVertexTangents:a,uid:`vc:${o},vt:${a},vct${t},svc:${r}`}}_materialProperties(e,t,r){const o=this._materialPropertiesDefault(e,r);if(!t.material)return o;const{color:a,colorTexture:n,normalTexture:s,doubleSided:i,alphaCutoff:l,alphaMode:c}=t.material,u=this._colorOrTextureUid(a),m=this._colorOrTextureUid(n),h=this._colorOrTextureUid(s);if(o.color=a,o.colorTexture=n,o.normalTexture=s,o.uid=`${o.uid},cmuid:${u},ctmuid:${m},ntmuid:${h},ds:${i},ac:${l},am:${c}`,t.material instanceof P){const{metallic:e,roughness:r,metallicRoughnessTexture:a,emissiveColor:n,emissiveTexture:s,occlusionTexture:i}=t.material,l=this._colorOrTextureUid(a),c=this._colorOrTextureUid(n),u=this._colorOrTextureUid(s),m=this._colorOrTextureUid(i);o.metallic=e,o.roughness=r,o.metallicRoughnessTexture=a,o.emissiveColor=n,o.emissiveTexture=s,o.occlusionTexture=i,o.colorTextureTransform=t.material.colorTextureTransform,o.normalTextureTransform=t.material.normalTextureTransform,o.emissiveTextureTransform=t.material.emissiveTextureTransform,o.occlusionTextureTransform=t.material.occlusionTextureTransform,o.metallicRoughnessTextureTransform=t.material.metallicRoughnessTextureTransform,o.uid=`${o.uid},mrm:${e},mrr:${r},mrt:${l},emuid:${c},etmuid:${u},otmuid:${m}`}return o}_setInternalColorValueParameters(t,r){r.diffuse=e.toUnitRGB(t),r.opacity=t.a}_getLoadableTextureResource(e){return e.data?e.data:e.url}_getInternalTextureId(e){const r=this._getInternalTexture(e,ae.Opaque);return t(r)?r.id:null}_getInternalTexture(e,r){const o=this._getLoadableTextureResource(e);if(!o)return null;const a=`${e.contentHash}/${r}`;let n=this._textures.get(a);return n||(n=new me(H(o)?o.data:o,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:!H(o)&&r!==ae.Opaque,encoding:H(o)&&t(o.encoding)?o.encoding:void 0}),this._textures.set(a,n),this._context.stage.add(n),this._context.stage.loadImmediate(n)),n}_castTextureWrap(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}}_castTextureWrapIndividual(e){switch(e){case"clamp":return ge.CLAMP_TO_EDGE;case"mirror":return ge.MIRRORED_REPEAT;default:return ge.REPEAT}}_setInternalMaterialParameters(r,o){if(t(r.color)&&this._setInternalColorValueParameters(r.color,o),t(r.colorTexture)){const e=this._getInternalTexture(r.colorTexture,o.textureAlphaMode);t(e)?(o.textureId=e.id,o.textureAlphaPremultiplied=!!e.params.preMultiplyAlpha):o.textureId=void 0}t(r.normalTexture)&&(o.normalTextureId=this._getInternalTextureId(r.normalTexture)),t(r.emissiveColor)&&(o.emissiveFactor=e.toUnitRGB(r.emissiveColor)),t(r.emissiveTexture)&&(o.emissiveTextureId=this._getInternalTextureId(r.emissiveTexture)),t(r.occlusionTexture)&&(o.occlusionTextureId=this._getInternalTextureId(r.occlusionTexture)),t(r.metallicRoughnessTexture)&&(o.metallicRoughnessTextureId=this._getInternalTextureId(r.metallicRoughnessTexture)),o.colorTextureTransformMatrix=q(r.colorTextureTransform),o.normalTextureTransformMatrix=q(r.normalTextureTransform),o.occlusionTextureTransformMatrix=q(r.occlusionTextureTransform),o.emissiveTextureTransformMatrix=q(r.emissiveTextureTransform),o.metallicRoughnessTextureTransformMatrix=q(r.metallicRoughnessTextureTransform)}_setExternalMaterialParameters(r){const o=this._drivenProperties.color;let a=t(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;if(o)r.externalColor=v;else{const o=t(this.symbolLayer.material)?this.symbolLayer.material.color:null;t(o)?r.externalColor=e.toUnitRGBA(o):(a=null,r.externalColor=v)}a&&(r.colorMixMode=a),r.castShadows=!!this.symbolLayer.castShadows}_hasTransparentVertexColors(e){const t=e.vertexAttributes.color;if(r(t))return!1;for(let r=3;r<t.length;r+=4)if(255!==t[r])return!0;return!1}_getOrCreateMaterial(e,r){const o=r.material?.color,a=r.material?.colorTexture,n=r.material?.alphaMode,s="blend"===n,i=!("opaque"===n)&&(this._hasTransparentVertexColors(e)||t(o)&&o.a<1||t(a)&&a.transparent||s),l=this._materialProperties(e,r,i),c=this._materials.get(l.uid);if(c)return c.material;const u={material:null,isComponentTransparent:i,alphaMode:r.material?r.material.alphaMode:"opaque"},m=null==l.metallicRoughnessTexture&&null==l.metallic&&null==l.roughness,h={usePBR:this._usePBR(),isSchematic:m,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:T,diffuse:y,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:ne.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,initTextureTransparent:!0};m||(h.mrrFactors=[null!=l.metallic?l.metallic:1,null!=l.roughness?l.roughness:1,.5]),r.material&&(h.doubleSided=r.material.doubleSided,h.cullFace=r.material.doubleSided?ne.None:ne.Back,h.textureAlphaCutoff=r.material.alphaCutoff),this._setExternalMaterialParameters(h),this._setMaterialTransparentParameter(h,u),this._setInternalMaterialParameters(l,h);const f=new fe(h);return u.material=f,this._materials.set(l.uid,u),this._context.stage.add(f),f}_usePBR(){return this._context.physicalBasedRenderingEnabled}_setMaterialTransparentParameter(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?ae.MaskBlend:ae.Opaque:e.textureAlphaMode="opaque"===t.alphaMode?ae.Opaque:"mask"===t.alphaMode?ae.Mask:ae.Blend}_addDebugNormals(e,t){const r=t.length,o=e.spatialReference.isGeographic?20015077/180:1,a=.1*Math.max(e.extent.width*o,e.extent.height*o,e.extent.zmax-e.extent.zmin),n=[],s=[],i=[],l=[];for(let h=0;h<r;h++){const e=t[h],r=e.vertexAttributes.get(he.POSITION),o=e.vertexAttributes.get(he.NORMAL),c=e.indices.get(he.POSITION),u=e.indices.get(he.NORMAL),m=r.data,g=o.data;for(let t=0;t<c.length;t++){const e=3*c[t],r=3*u[t];for(let t=0;t<3;t++)n.push(m[e+t]);for(let t=0;t<3;t++)n.push(m[e+t]+g[r+t]*a);if(s.push(s.length),s.push(s.length),t%3==0){this._calculateFaceNormal(m,c,t,Ce),this._getFaceVertices(m,c,t,ye,be,ve),f(ye,ye,be),f(ye,ye,ve),p(ye,ye,1/3);for(let e=0;e<3;e++)i.push(ye[e]);for(let e=0;e<3;e++)i.push(ye[e]+Ce[e]*a);l.push(l.length),l.push(l.length)}}}const c=t[0].transformation,u=new le(this._debugVertexNormalMaterial,[[he.POSITION,new oe(n,3,!0)]],[[he.POSITION,s]],null,se.Line);t.push(u),u.transformation=c;const m=new le(this._debugFaceNormalMaterial,[[he.POSITION,new oe(i,3,!0)]],[[he.POSITION,l]],null,se.Line);m.transformation=c,t.push(m)}_createAs3DShape(e,o,a,n){const s=e.geometry;if("mesh"!==s.type)return null;const i=this._createGeometryInfo(s,o,n);if(r(i))return null;const{geometries:l,objectTransformation:c}=i;re.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(s,l);const u=new ue({geometries:l,metadata:{layerUid:this._context.layer.uid,graphicUid:n}});u.transformation=c;const m=X(this.symbolLayer,{opacity:this._getLayerOpacity()}),h=t(m)?new J(l[0].material,[m],{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}):null,f=new K(this,u,l,null,null,W,a,h);f.needsElevationUpdates=Y(a.mode),f.useObjectOriginAsAttachmentOrigin=!0,a.centerPointInElevationSR=this._getCenterPointInElevationSR(u);const{elevationProvider:p,renderCoordsHelper:g}=this._context,d=(e,t)=>z(e,p,a,g,t);return f.alignedSampledElevation=W(f,a,p.spatialReference,d,g),f}_getCenterPointInElevationSR(e){const r=D(0,0,0,t(this._context.elevationProvider.spatialReference)?this._context.elevationProvider.spatialReference:null);return C([e.transformation[12],e.transformation[13],e.transformation[14]],this._context.renderCoordsHelper.spatialReference,r),r}_createComponentNormals(e,t,r,o){switch(r.shading||"flat"){default:case"source":return this._createComponentNormalsSource(e,t,r,o);case"flat":return this._createComponentNormalsFlat(e,o);case"smooth":return this._createComponentNormalsSmooth(e,o)}}_createComponentNormalsSource(e,t,o,a){if(r(t))return this._createComponentNormalsFlat(e,a);let n=!1;if(!o.trustSourceNormals)for(let r=0;r<a.length;r+=3){this._calculateFaceNormal(e,a,r,Ce);for(let e=0;e<3;e++){const o=3*a[r+e];ye[0]=t[o+0],ye[1]=t[o+1],ye[2]=t[o+2],g(Ce,ye)<0&&(t[o+0]=-t[o+0],t[o+1]=-t[o+1],t[o+2]=-t[o+2],n=!0)}}return new _e(t,a,n)}_createComponentNormalsFlat(e,t){const r=ie(t.length),o=new Array(3*t.length);for(let a=0;a<t.length;a+=3){const n=this._calculateFaceNormal(e,t,a,Ce);for(let e=0;e<3;e++)r[a+e]=n[e],o[a+e]=a/3}return new _e(r,o,!1)}_createComponentNormalsSmooth(e,t){const r={};for(let n=0;n<t.length;n+=3){const o=this._calculateFaceNormal(e,t,n,Ce);for(let e=0;e<3;e++){const a=t[n+e];let s=r[a];s||(s={normal:b(),count:0},r[a]=s),f(s.normal,s.normal,o),s.count++}}const o=ie(3*t.length),a=new Array(3*t.length);for(let n=0;n<t.length;n++){const e=r[t[n]];1!==e.count&&(d(e.normal,e.normal),e.count=1);for(let t=0;t<3;t++)o[3*n+t]=e.normal[t];a[n]=n}return new _e(o,a,!1)}_getFaceVertices(e,t,r,o,a,n){const s=3*t[r+0],i=3*t[r+1],l=3*t[r+2];o[0]=e[s+0],o[1]=e[s+1],o[2]=e[s+2],a[0]=e[i+0],a[1]=e[i+1],a[2]=e[i+2],n[0]=e[l+0],n[1]=e[l+1],n[2]=e[l+2]}_calculateFaceNormal(e,t,r,o){return this._getFaceVertices(e,t,r,ye,be,ve),x(be,be,ye),x(ve,ve,ye),_(ye,be,ve),d(o,ye),o}_getOrCreateComponents(e){return o(e.components,Me)}_createPositionBuffer(e,r){let o=e.vertexAttributes.position;const a=r.reprojection===je.ECEF?r.transformBeforeProject:null;if(t(a)&&(o=L(o,new Float64Array(o.length),a)),r.reprojection===je.NONE)return r.needsBufferCopy?new Float64Array(o):o;const n=t(a)?o:new Float64Array(o.length);return O(o,e.spatialReference,0,n,this._context.renderCoordsHelper.spatialReference,0,o.length/3),n}_createNormalBuffer(e,o,a){let n=e.vertexAttributes.normal;if(r(n))return null;const s=a.reprojection===je.ECEF?a.transformBeforeProject:null;t(s)&&(n=V(n,new Float32Array(n.length),s));if("local"===this._context.graphicsCoreOwner.view.viewingMode||a.reprojection===je.NONE)return a.needsBufferCopy&&e.vertexAttributes.normal===n?new Float32Array(n):n;const i=e.vertexAttributes.position,l=t(s)?n:new Float32Array(n.length);return U(n,i,o,e.spatialReference,l)}_createTangentBuffer(e,o,a){let n=e.vertexAttributes.tangent;if(r(n))return null;const s=a.reprojection===je.ECEF?a.transformBeforeProject:null;t(s)&&(n=G(n,new Float32Array(n.length),s));if("local"===this._context.graphicsCoreOwner.view.viewingMode||a.reprojection===je.NONE)return a.needsBufferCopy&&e.vertexAttributes.normal===n?new Float32Array(n):n;const i=e.vertexAttributes.position,l=t(s)?n:new Float32Array(n.length);return $(n,i,o,e.spatialReference,l)}_createColorBuffer(e){return e.vertexAttributes.color}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=ee(a(this.symbolLayer,"material","colorMixMode")),o=new Uint8Array(4);return te(t,r,o),o}return null}_createBuffers(e,r){const o=e.vertexAttributes&&e.vertexAttributes.position;if(!o)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const a=e.vertexAttributes.normal,n=e.vertexAttributes.uv,s=e.vertexAttributes.tangent;if(t(a)&&a.length!==o.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(t(s)&&s.length/4!=o.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(t(n)&&n.length/2!=o.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const i=this._computeReprojectionInfo(e),l=this._createPositionBuffer(e,i),c=this._createColorBuffer(e),u=this._createSymbolColorBuffer(r),h=this._createNormalBuffer(e,l,i),f=this._createTangentBuffer(e,l,i);return{positionBuffer:l,normalBuffer:h,tangentBuffer:f,uvBuffer:n,colorBuffer:c,symbolColorBuffer:u,objectTransformation:i.reprojection===je.NONE&&t(i.objectTransformation)?i.objectTransformation:this._transformOriginLocal(e,l,h,f),geometryTransformation:i.reprojection===je.NONE&&t(i.geometryTransformation)?i.geometryTransformation:m()}}_computeReprojectionInfo(e){const r=t(e.transform),o=r&&e.transform.geographic||this._context.renderCoordsHelper.viewingMode===k.Local?je.NONE:je.ECEF;if(r){if(o===je.NONE){const t=m();w(e.spatialReference,e.transform.origin,t,this._context.renderCoordsHelper.spatialReference);return{reprojection:o,objectTransformation:t,geometryTransformation:h(e.transform.localMatrix),needsBufferCopy:!1}}const t=l(m(),e.transform.origin);return c(t,t,e.transform.localMatrix),{reprojection:o,transformBeforeProject:t,needsBufferCopy:!0}}return{reprojection:o,needsBufferCopy:!0}}_transformOriginLocal(e,r,o,a){const i=this._context.renderCoordsHelper.spatialReference,l=e.anchor;Te[0]=l.x,Te[1]=l.y,Te[2]=l.z;const c=m();w(e.spatialReference,Te,c,i);const h=I.fromTypedArray(r);if(u(Oe,c),S(h,h,Oe),t(o)||t(a)){if(n(we,c),s(we,we),t(o)){const e=B.fromTypedArray(o);F(e,e,we)}if(t(a)){const e=B.fromTypedArray(a,4*a.BYTES_PER_ELEMENT);F(e,e,we)}}return c}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,o=t.faces;if(o){let e=-1;for(let t=0;t<o.length;t++){const r=o[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_getOrCreateFaces(e,t){return t.faces?t.faces:ce(e.vertexAttributes.position.length/3)}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return!1;const o=this._context.elevationProvider.spatialReference;let a;const n=r.length/3;return t(o)&&!e.spatialReference.equals(o)?(a=new Float64Array(r.length),O(e.vertexAttributes.position,e.spatialReference,0,a,o,0,n)):a=r,j(Ae),E(Ae,a,0,n),!R(Ae,this._context.clippingExtent)}_createGeometryInfo(e,o,a){if(!A(e.spatialReference,this._context.graphicsCoreOwner.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const n=this._createBuffers(e,o);if(r(n))return null;const{positionBuffer:s,uvBuffer:i,colorBuffer:l,symbolColorBuffer:c,normalBuffer:u,tangentBuffer:m,objectTransformation:h,geometryTransformation:f}=n,p=this._getOrCreateComponents(e),g=new Array;let d=!1;for(const r of p){if(!this._validateFaces(e,r))return null;const o=this._getOrCreateFaces(e,r);if(0===o.length)continue;const n=this._createComponentNormals(s,u,r,o);n.didFlipNormals&&(d=!0);const h=[[he.POSITION,new oe(s,3,!0)],[he.NORMAL,new oe(n.normals,3,!0)]],p=[[he.POSITION,o],[he.NORMAL,n.indices]];t(l)&&(h.push([he.COLOR,new oe(l,4,!0)]),p.push([he.COLOR,o])),t(c)&&(h.push([he.SYMBOLCOLOR,new oe(c,4,!0)]),p.push([he.SYMBOLCOLOR,new Array(o.length).fill(0)])),t(i)&&(h.push([he.UV0,new oe(i,2,!0)]),p.push([he.UV0,o])),t(m)&&(h.push([he.TANGENT,new oe(m,4,!0)]),p.push([he.TANGENT,o]));const x=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:a,layerUid:this._context.layer.uid}),_=this._getOrCreateMaterial(e,r),T=new le(_,h,p,null,se.Mesh,x);T.transformation=f,g.push(T)}return d&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:g,objectTransformation:h}}}class _e{constructor(e,t,r){this.normals=e,this.indices=t,this.didFlipNormals=r}}const Te=b(),ye=b(),be=b(),ve=b(),Ce=b(),Oe=m(),we=i(),Ae=M(),Me=[new N];var je;!function(e){e[e.NONE=0]="NONE",e[e.ECEF=1]="ECEF"}(je||(je={}));export{xe as Graphics3DMeshFillSymbolLayer};

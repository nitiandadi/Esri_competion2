/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import e from"../../../../core/Evented.js";import{someMap as t}from"../../../../core/MapUtils.js";import{isNone as s,isSome as o}from"../../../../core/maybe.js";class n extends e{constructor(e,t){super(),this._updateAndCompare=e,this._notifyUpdated=t,this._nodes=new Map,this._graphics=new Map,this._duplicates=new Map}clear(){if(this._graphics.size>0){const e=this.toArray();this._graphics.clear(),this.emit("change",{added:[],removed:e})}this._nodes.clear()}get length(){return this._graphics.size}get(e){return this._graphics.get(e)}getNode(e){return this._nodes.get(e)}hasNode(e){return this._nodes.has(e)}nodes(){return this._nodes.values()}addNode(e,t){this._nodes.set(e,t);const s=t.graphics;if(0===s.length)return;const o=new Set;for(let r=0;r<s.length;r++){const t=s[r],n=t.objectId,i=this._graphics.get(n);if(i){o.add(n),t!==i&&(s[r]=i);const d=this._duplicates.get(n);d?d.push(e):this._duplicates.set(n,[i.nodeIndex,e])}else t.nodeIndex=e,this._graphics.set(n,t)}o.size&&this._updateForeignGraphics(t);const n=o.size>0?s.filter((e=>!o.has(e.objectId))):s;n.length>0&&this.emit("change",{added:n,removed:[]})}removeNode(e){const t=this._nodes.get(e);if(!t)return void console.error("Removing unknown node");this._nodes.delete(e);const n=new Set,r=[];for(const i of t.graphics){const t=i.objectId,d=this._graphics.get(t);if(!d)continue;const c=this._duplicates.get(t);if(c){const r=c.indexOf(e);if(-1===r){console.error("error: removing graphic from node that should not reference it.");continue}if(c.splice(r,1),d.nodeIndex===e){let e=this.getNode(c[0]);for(let t=1;t<c.length;t++){const n=this.getNode(c[t]);(s(e)||o(n)&&n.node.level>e.node.level)&&(e=n)}o(e)&&n.add(e)}1===c.length&&this._duplicates.delete(t)}else this._graphics.delete(t),r.push(i)}r.length>0&&this.emit("change",{added:[],removed:r}),n.forEach((e=>this._updateForeignGraphics(e)))}_updateForeignGraphics(e){const t=[],s=e.node.index,n=e.node.level;let r=0;for(;r<e.graphics.length;){const i=e.graphics[r].nodeIndex;if(i===s){r++;continue}let d=1;for(;r+d<e.graphics.length&&e.graphics[r+d].nodeIndex===i;)d++;const c=this.getNode(i);if(o(c)&&c.node.level>n)r+=d;else{for(let o=r;o<r+d;o++){const n=e.graphics[o];n.nodeIndex=s,this._updateAndCompare(n,e,o)&&t.push(n)}r+=d}}this._notifyUpdated(t)}toArray(){return Array.from(this._graphics.values())}find(e){let s;return t(this._graphics,(t=>!!e(t)&&(s=t,!0))),s}forEach(e){this._graphics.forEach((t=>e(t)))}forEachNode(e){this._nodes.forEach(((t,s)=>e(t,s)))}get nodeCount(){return this._nodes.size}_checkInvariants(){const e=new Map;this._nodes.forEach(((t,s)=>{s!==t.node.index&&console.error("Mismatched node index"),t.graphics.forEach((t=>{e.set(t.objectId,1+(e.get(t.objectId)??0));const o=this._duplicates.get(t.objectId);o&&!o.includes(s)&&console.error("Node not listed in duplicate list"),o||t.nodeIndex===s||console.error("Unique graphic does not reference owning node index")}))})),this._graphics.size!==e.size&&console.error("Mismatch between actual and expected number of graphics");let t=0;e.forEach(((e,s)=>{t+=e>1?1:0;const o=this._graphics.get(s);if(!o)return void console.error("Missing graphic entry");const n=this._nodes.get(o.nodeIndex);if(!n)return void console.error("Graphic references unkown node");const r=this._duplicates.get(s);r?(r.length!==e&&console.error("Wrong number of entries in duplicate list"),r.forEach((e=>{const t=this._nodes.get(e);t?t.node.level>n.node.level&&console.error("Duplicated graphic does not reference highest level node"):console.error("Unknown node in duplicate list")}))):e>1&&console.error("Missing duplicates entry")})),this._duplicates.size!==t&&console.error("Mismatch between expected and actual number of duplicate entries")}}export{n as I3SGraphicsMap};

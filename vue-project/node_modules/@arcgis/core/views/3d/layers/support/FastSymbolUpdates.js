/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{f as o}from"../../../../chunks/mat3.js";import{c as t}from"../../../../chunks/mat3f64.js";import{i,c as n,s as r,m as s,k as l,w as a,o as u,r as f,n as c}from"../../../../chunks/mat4.js";import{c as p}from"../../../../chunks/mat4f64.js";import{s as d}from"../../../../chunks/vec3.js";import{c as v}from"../../../../chunks/vec3f64.js";import{meterIn as z}from"../../../../renderers/support/lengthUtils.js";import m from"../../support/debugFlags.js";var S,y;function h(e){return null!=e}function x(e){return"number"==typeof e}function b(e){return"string"==typeof e}function C(e){return null==e||b(e)}function g(e,o){e&&e.push(o)}function V(e,o,t,i=p()){const n=e||0,r=o||0,s=t||0;return 0!==n&&u(i,i,-n/180*Math.PI),0!==r&&f(i,i,r/180*Math.PI),0!==s&&c(i,i,s/180*Math.PI),i}function D(e,o,t,i,n){const r=e.minSize,s=e.maxSize;if(e.expression)return g(n,"Could not convert size info: expression not supported"),!1;if(e.useSymbolValue){const e=i.symbolSize[t];return o.minSize[t]=e,o.maxSize[t]=e,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=S.DefinedSize,!0}if(h(e.field))return h(e.stops)?2===e.stops.length&&x(e.stops[0].size)&&x(e.stops[1].size)?(M(e.stops[0].size,e.stops[1].size,e.stops[0].value,e.stops[1].value,o,t),o.type[t]=S.DefinedSize,!0):(g(n,"Could not convert size info: stops only supported with 2 elements"),!1):x(r)&&x(s)&&h(e.minDataValue)&&h(e.maxDataValue)?(M(r,s,e.minDataValue,e.maxDataValue,o,t),o.type[t]=S.DefinedSize,!0):null!=z[e.valueUnit]?(o.minSize[t]=-1/0,o.maxSize[t]=1/0,o.offset[t]=0,o.factor[t]=1/z[e.valueUnit],o.type[t]=S.DefinedSize,!0):"unknown"===e.valueUnit?(g(n,"Could not convert size info: proportional size not supported"),!1):(g(n,"Could not convert size info: scale-dependent size not supported"),!1);if(!h(e.field)){if(e.stops&&e.stops[0]&&x(e.stops[0].size))return o.minSize[t]=e.stops[0].size,o.maxSize[t]=e.stops[0].size,o.offset[t]=o.minSize[t],o.factor[t]=0,o.type[t]=S.DefinedSize,!0;if(x(r))return o.minSize[t]=r,o.maxSize[t]=r,o.offset[t]=r,o.factor[t]=0,o.type[t]=S.DefinedSize,!0}return g(n,"Could not convert size info: unsupported variant of sizeInfo"),!1}function M(e,o,t,i,n,r){const s=Math.abs(i-t)>0?(o-e)/(i-t):0;n.minSize[r]=s>0?e:o,n.maxSize[r]=s>0?o:e,n.offset[r]=e-t*s,n.factor[r]=s}function U(e,o,t,i){if(e.normalizationField||e.valueRepresentation)return g(i,"Could not convert size info: unsupported property"),null;if(!C(e.field))return g(i,"Could not convert size info: field is not a string"),null;if(o.size){if(e.field)if(o.size.field){if(e.field!==o.size.field)return g(i,"Could not convert size info: multiple fields in use"),null}else o.size.field=e.field}else o.size={field:e.field,minSize:[0,0,0],maxSize:[0,0,0],offset:[0,0,0],factor:[0,0,0],type:[S.Undefined,S.Undefined,S.Undefined]};let n;switch(e.axis){case"width":return n=D(e,o.size,0,t,i),n?o:null;case"height":return n=D(e,o.size,2,t,i),n?o:null;case"depth":return n=D(e,o.size,1,t,i),n?o:null;case"width-and-depth":return n=D(e,o.size,0,t,i),n&&D(e,o.size,1,t,i),n?o:null;case null:case void 0:case"all":return n=D(e,o.size,0,t,i),n=n&&D(e,o.size,1,t,i),n=n&&D(e,o.size,2,t,i),n?o:null;default:return g(i,`Could not convert size info: unknown axis "${e.axis}""`),null}}function T(e,o,t){for(let n=0;n<3;++n){let t=o.unitInMeters;e.type[n]===S.DefinedSize&&(t*=o.modelSize[n],e.type[n]=S.DefinedScale),e.minSize[n]=e.minSize[n]/t,e.maxSize[n]=e.maxSize[n]/t,e.offset[n]=e.offset[n]/t,e.factor[n]=e.factor[n]/t}let i;if(e.type[0]!==S.Undefined)i=0;else if(e.type[1]!==S.Undefined)i=1;else{if(e.type[2]===S.Undefined)return g(t,"No size axis contains a valid size or scale"),!1;i=2}for(let n=0;n<3;++n)e.type[n]===S.Undefined&&(e.minSize[n]=e.minSize[i],e.maxSize[n]=e.maxSize[i],e.offset[n]=e.offset[i],e.factor[n]=e.factor[i],e.type[n]=e.type[i]);return!0}function E(e,o,t){e[4*o+0]=t.r/255,e[4*o+1]=t.g/255,e[4*o+2]=t.b/255,e[4*o+3]=t.a}function O(e,o,t){if(e.normalizationField)return g(t,"Could not convert color info: unsupported property"),null;if(b(e.field)){if(!e.stops)return g(t,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return g(t,"Could not convert color info: too many color stops"),null;o.color={field:e.field,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.color.values[e]=t.value,E(o.color.colors,e,t.color)}}}else{if(!(e.stops&&e.stops.length>=0))return g(t,"Could not convert color info: no field and no colors/stops"),null;{const t=e.stops&&e.stops.length>=0&&e.stops[0].color;o.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.color.values[e]=1/0,E(o.color.colors,e,t)}}return o}function j(e,o,t){if(e.normalizationField)return g(t,"Could not convert opacity info: unsupported property"),null;if(b(e.field)){if(!e.stops)return g(t,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return g(t,"Could not convert opacity info: too many opacity stops"),null;o.opacity={field:e.field,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};const i=e.stops;for(let e=0;e<8;++e){const t=i[Math.min(e,i.length-1)];o.opacity.values[e]=t.value,o.opacity.opacityValues[e]=t.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return g(t,"Could not convert opacity info: no field and no opacities/stops"),null;{const t=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;o.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)o.opacity.values[e]=1/0,o.opacity.opacityValues[e]=t}}return o}function k(e,o,t){const i=2===t&&"arithmetic"===e.rotationType;o.offset[t]=i?90:0,o.factor[t]=i?-1:1,o.type[t]=1}function w(e,o,t){if(!b(e.field))return g(t,"Could not convert rotation info: field is not a string"),null;if(o.rotation){if(e.field)if(o.rotation.field){if(e.field!==o.rotation.field)return g(t,"Could not convert rotation info: multiple fields in use"),null}else o.rotation.field=e.field}else o.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return k(e,o.rotation,0),o;case"roll":return k(e,o.rotation,1),o;case null:case void 0:case"heading":return k(e,o.rotation,2),o;default:return g(t,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}function F(e,o,t){if(!e)return null;const i=!o.supportedTypes||!!o.supportedTypes.size,n=!o.supportedTypes||!!o.supportedTypes.color,r=!o.supportedTypes||!!o.supportedTypes.rotation,s=!!o.supportedTypes&&!!o.supportedTypes.opacity,l=e.reduce(((e,l)=>{if(!e)return e;if(l.valueExpression)return g(t,"Could not convert visual variables: arcade expressions not supported"),null;switch(l.type){case"size":return i?U(l,e,o,t):e;case"color":return n?O(l,e,t):e;case"opacity":return s?j(l,e,t):null;case"rotation":return r?w(l,e,t):e;default:return null}}),{size:null,color:null,opacity:null,rotation:null});return!(e.length>0&&l)||l.size||l.color||l.opacity||l.rotation?l&&l.size&&!T(l.size,o,t)?null:l:null}function A(e){return e&&null!=e.size}function I(e,o){if(!e)return{enabled:!1};if(m.TESTS_DISABLE_FAST_UPDATES)return{enabled:!1};const t=F(e.visualVariables,o);return t?{enabled:!0,visualVariables:t,materialParameters:_(t,o),requiresShaderTransformation:A(t)}:{enabled:!1}}function P(e,o,t){if(!o||!e.enabled)return!1;const i=e.visualVariables,n=F(o.visualVariables,t);return!!n&&(!!(R(i.size,n.size,"size")&&R(i.color,n.color,"color")&&R(i.rotation,n.rotation,"rotation")&&R(i.opacity,n.opacity,"opacity"))&&(e.visualVariables=n,e.materialParameters=_(n,t),e.requiresShaderTransformation=A(n),!0))}function R(e,o,t){if(!!e!=!!o)return!1;if(e&&e.field!==o.field)return!1;if(e&&"rotation"===t){const t=e,i=o;for(let e=0;e<3;e++)if(t.type[e]!==i.type[e]||t.offset[e]!==i.offset[e]||t.factor[e]!==i.factor[e])return!1}return!0}function _(e,n){const r={vvSizeEnabled:!1,vvSizeMinSize:null,vvSizeMaxSize:null,vvSizeOffset:null,vvSizeFactor:null,vvSizeValue:null,vvColorEnabled:!1,vvColorValues:null,vvColorColors:null,vvOpacityEnabled:!1,vvOpacityValues:null,vvOpacityOpacities:null,vvSymbolAnchor:null,vvSymbolRotationMatrix:null},s=A(e);return e&&e.size?(r.vvSizeEnabled=!0,r.vvSizeMinSize=e.size.minSize,r.vvSizeMaxSize=e.size.maxSize,r.vvSizeOffset=e.size.offset,r.vvSizeFactor=e.size.factor):e&&s&&(r.vvSizeValue=n.transformation.scale),e&&s&&(r.vvSymbolAnchor=n.transformation.anchor,r.vvSymbolRotationMatrix=t(),i(N),V(n.transformation.rotation[2],n.transformation.rotation[0],n.transformation.rotation[1],N),o(r.vvSymbolRotationMatrix,N)),e&&e.color&&(r.vvColorEnabled=!0,r.vvColorValues=e.color.values,r.vvColorColors=e.color.colors),e&&e.opacity&&(r.vvOpacityEnabled=!0,r.vvOpacityValues=e.opacity.values,r.vvOpacityOpacities=e.opacity.opacityValues),r}function q(o,t,i){if(!o.vvSizeEnabled)return i;n(B,i);const u=o.vvSymbolRotationMatrix;r(N,u[0],u[1],u[2],0,u[3],u[4],u[5],0,u[6],u[7],u[8],0,0,0,0,1),s(B,B,N);for(let n=0;n<3;++n){const i=o.vvSizeOffset[n]+t[0]*o.vvSizeFactor[n];L[n]=e(i,o.vvSizeMinSize[n],o.vvSizeMaxSize[n])}return l(B,B,L),a(B,B,o.vvSymbolAnchor),B}function $(o,t,i){if(!t.vvSizeEnabled)return d(o,1,1,1);for(let n=0;n<3;++n){const r=t.vvSizeOffset[n]+i[0]*t.vvSizeFactor[n];o[n]=e(r,t.vvSizeMinSize[n],t.vvSizeMaxSize[n])}return o}!function(e){e[e.Undefined=0]="Undefined",e[e.DefinedSize=1]="DefinedSize",e[e.DefinedScale=2]="DefinedScale"}(S||(S={})),function(e){e[e.Undefined=0]="Undefined",e[e.DefinedAngle=1]="DefinedAngle"}(y||(y={}));const B=p(),L=v(),N=p();export{y as FastRotationType,S as FastSizeType,F as convertVisualVariables,q as evaluateModelTransform,$ as evaluateModelTransformScale,_ as getMaterialParameters,I as initFastSymbolUpdatesState,P as updateFastSymbolUpdatesState};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{isSome as t,unwrapOr as e}from"../../../../../../core/maybe.js";import{pt2px as i}from"../../../../../../core/screenUtils.js";import{Alignment as s}from"../../../../../../symbols/cim/enums.js";import{getXAnchorDirection as o,getYAnchorDirection as r}from"../../alignmentUtils.js";import{premultiplyAlphaRGBA as a}from"../../color.js";import{GLYPH_SIZE as n,MIN_MAX_ZOOM_PRECISION_FACTOR as l}from"../../definitions.js";import{i1616to32 as h}from"../../number.js";import{TextMaterialKey as c}from"../../materialKey/MaterialKey.js";import{isFunction as m,getMinMaxZoom as _}from"./util.js";import f from"./WGLBaseTextTemplate.js";import y from"./WGLDynamicMeshTemplate.js";import{codepoints as p}from"../../../../layers/features/textUtils.js";const d=5;function M(t,e,i,s){return"string"==typeof t.text?t.text:"function"==typeof t.text?t.text(e,i,s)??"":""}class g extends(f(y)){constructor(e,o,r){super(e),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=h(Math.round(o*l),Math.round(r*l));const n=e.scaleFactor||1;this._cimTextLayer=e;const _=e.color;if(m(_)){const t=(t,e,i)=>a(_(t,e,i));this._dynamicPropertyMap.set("_color",t)}else this._color=a(_);const f=e.outlineColor;if(m(f)){const t=(t,e,i)=>a(f(t,e,i));this._dynamicPropertyMap.set("_haloColor",t)}else this._haloColor=a(f);let y;m(e.size)||(y=Math.min(Math.round(i(e.size*e.sizeRatio)),127));const p=(t,s,o)=>m(e.size)?Math.min(Math.round(i(e.size(t,s,o)*e.sizeRatio)),127):y;if(this._dynamicPropertyMap.set("_size",p),m(e.outlineSize)){const t=(t,s,o)=>Math.min(Math.floor(d*i(e.outlineSize(t,s,o)*e.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",t)}else this._haloSize=Math.min(Math.floor(d*i(e.outlineSize*e.sizeRatio)),127);let M;m(e.offsetX)||(M=Math.round(i(e.offsetX*e.sizeRatio)));const g=(t,s,o)=>m(e.offsetX)?Math.round(i(e.offsetX(t,s,o)*e.sizeRatio)):M;let u;this._dynamicPropertyMap.set("_xOffset",g),m(e.offsetY)||(u=Math.round(i(e.offsetY*e.sizeRatio)));const z=(t,s,o)=>m(e.offsetY)?Math.round(i(e.offsetY(t,s,o)*e.sizeRatio)):u;if(this._dynamicPropertyMap.set("_yOffset",z),m(e.angle)?this._dynamicPropertyMap.set("_angle",e.angle):this._angle=e.angle,m(e.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",e.horizontalAlignment):this._horizontalAlignment=e.horizontalAlignment,m(e.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",e.verticalAlignment):this._verticalAlignment=e.verticalAlignment,t(e.effects)){const t=e.effects;m(t)?this._dynamicPropertyMap.set("_effects",t):this._effects=t}if(t(e.markerPlacement)){const t=e.markerPlacement;m(t)?this._dynamicPropertyMap.set("_markerPlacement",t):this._textPlacement=t}m(e.text)?this._dynamicPropertyMap.set("_text",e.text):this._text=e.text,this._backgroundColor=e.backgroundColor&&a(e.backgroundColor),this._borderLineColor=e.borderLineColor&&a(e.borderLineColor),this._borderLineSize=e.borderLineWidth,this._scaleFactor=n;const x=Math.min(Math.round(i(e.referenceSize*e.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*x)),this._materialKey=e.materialKey;const P=c.load(this._materialKey);P.sdf=!0,this._bitset=(e.alignment===s.MAP?1:0)|(e.colorLocked?1:0)<<1,this._materialKey=P.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._isCIM=!0}static fromCIMText(t,e){const[i,s]=_(t.scaleInfo,e);return new g(t,i,s)}async analyze(t,e,i,s){const o=e.readLegacyFeature(),r=M(this._cimTextLayer,o,i,s),a=await super.analyze(t,e,i,s,p(r));return a&&a.glyphMosaicItems&&this._textToGlyphs.set(r,a.glyphMosaicItems),a}bindFeature(t,i,s){const a=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach(((t,e)=>{this[e]=t(a,i,s)})),!this._text||0===this._text.length)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/n,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=o(e(this._horizontalAlignment,"center")),this._yAlignD=r(e(this._verticalAlignment,"baseline"));const l=this._textToGlyphs.get(this._text)??[];this.bindTextInfo(l,!1)}}export{g as default};

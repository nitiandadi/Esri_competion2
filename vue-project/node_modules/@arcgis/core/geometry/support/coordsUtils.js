/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{equals as t}from"../../core/arrayUtils.js";import{getInfo as n}from"./spatialReferenceUtils.js";function e(t){if(!t)return null;if(Array.isArray(t))return t;const n=t.hasZ,e=t.hasM;if("point"===t.type)return e&&n?[t.x,t.y,t.z,t.m]:n?[t.x,t.y,t.z]:e?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const n=t.clone().normalize();if(!n)return null;let e=!1,r=!1;return n.forEach((t=>{t.hasZ&&(e=!0),t.hasM&&(r=!0)})),n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(e&&t.hasZ){const e=.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(e)}if(r&&t.hasM){const e=.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(e)}return n}))}return null}function r(t,n){const e=n[0]-t[0],r=n[1]-t[1];if(t.length>2&&n.length>2){const i=t[2]-n[2];return Math.sqrt(e*e+r*r+i*i)}return Math.sqrt(e*e+r*r)}function i(t,n,e){const r=t[0]+e*(n[0]-t[0]),i=t[1]+e*(n[1]-t[1]);return t.length>2&&n.length>2?[r,i,t[2]+e*(n[2]-t[2])]:[r,i]}function o(t,n,e,r){const[i,o]=n,[s,l]=e[r],[f,u]=e[r+1],c=f-s,h=u-l,a=c*c+h*h,g=(i-s)*c+(o-l)*h,p=Math.min(1,Math.max(0,g/a));return t[0]=s+c*p,t[1]=l+h*p,t}function s(t,n,e){const r=e.rings;let i,o,s=!1,f=1/0;for(let u=0;u<r.length;u++){const e=r[u];for(let r=0,u=e.length-1;r<e.length;u=r++)i=e[r],o=e[u],i[1]>n!=o[1]>n&&t<(o[0]-i[0])*(n-i[1])/(o[1]-i[1])+i[0]&&(s=!s),f=Math.min(f,l(t,n,i,o))}return 0===f?0:(s?1:-1)*Math.sqrt(f)}function l(t,n,e,r){let i=e[0],o=e[1],s=r[0]-i,l=r[1]-o;if(0!==s||0!==l){const e=((t-i)*s+(n-o)*l)/(s*s+l*l);e>1?(i=r[0],o=r[1]):e>0&&(i+=s*e,o+=l*e)}return s=t-i,l=n-o,s*s+l*l}function f(t,n){return i(t,n,.5)}function u(t){const n=t.length;let e=0;for(let i=0;i<n-1;++i)e+=r(t[i],t[i+1]);return e}function c(t,n){if(n<=0)return t[0];const e=t.length;let o=0;for(let s=0;s<e-1;++s){const e=r(t[s],t[s+1]);if(n-o<e){const r=(n-o)/e;return i(t[s],t[s+1],r)}o+=e}return t[e-1]}function h(t,n,e){const r=t.length;let i=0,o=0,s=0;for(let l=0;l<r;l++){const f=t[l],u=t[(l+1)%r];let c=2;i+=f[0]*u[1]-u[0]*f[1],f.length>2&&u.length>2&&e&&(o+=f[0]*u[2]-u[0]*f[2],c=3),f.length>c&&u.length>c&&n&&(s+=f[0]*u[c]-u[0]*f[c])}return i<=0&&o<=0&&s<=0}function a(n){const e=n.length;return e>2&&t(n[0],n[e-1])}function g(t){if("rings"in t&&(p(t),t.rings.length>0&&!h(t.rings[0],t.hasM??!1,t.hasZ??!1)))for(const n of t.rings)n.reverse()}function p(t){if("rings"in t)for(const n of t.rings)a(n)||n.push(n[0].slice())}function y(t){if("polygon"!==t.type&&"polyline"!==t.type)return t;return m("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function m(t,e){const r=n(e);if(!r)return;const i=r.valid[0],o=r.valid[1],s=o-i;for(const n of t){let t=1/0,e=-1/0;for(const s of n){const n=x(s[0],i,o);t=Math.min(t,n),e=Math.max(e,n),s[0]=n}const r=e-t;s-r<r&&n.forEach((t=>{t[0]<0&&(t[0]+=s)}))}}function x(t,n,e){const r=e-n;return t<n?e-(n-t)%r:t>e?n+(t-n)%r:t}function M(t){if(!t||t.length<3)return 0;let n=0;const e=t.length-1;for(let r=0;r<e;r++)n+=(t[r][0]-t[r+1][0])*(t[r][1]+t[r+1][1]);return n+=(t[e][0]-t[0][0])*(t[e][1]+t[0][1]),-.5*n}function z(t,n){if(t===n)return!0;if(t.type!==n.type)return!1;if("point"===t.type||"extent"===t.type)return!0;if("multipoint"===t.type)return t.points.length===n.points.length;const[e,r]="polyline"===t.type?[t.paths,n.paths]:[t.rings,n.rings];return e.length===r.length&&e.every(((t,n)=>t.length===r[n].length))}export{p as closeRings,g as closeRingsAndFixWinding,s as distanceFromPointToPolygon,l as distanceToSegmentSquared,e as geometryToCoordinates,r as getLength,f as getMidpoint,u as getPathLength,c as getPointOnPath,M as getRingArea,z as hasCompatibleTopology,h as isClockwise,a as isClosed,o as projectPointOnLine,y as unnormalizeGeometryOnDatelineCrossing,m as unnormalizeVerticesOnDatelineCrossing,x as unnormalizedCoordinate};

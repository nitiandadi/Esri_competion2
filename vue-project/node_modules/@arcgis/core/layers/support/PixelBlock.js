/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import e from"../../core/Error.js";import{JSONSupport as s}from"../../core/JSONSupport.js";import{clone as i}from"../../core/lang.js";import l from"../../core/Logger.js";import{isSome as r,isNone as o}from"../../core/maybe.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import{cast as h}from"../../core/accessorSupport/decorators/cast.js";import{subclass as n}from"../../core/accessorSupport/decorators/subclass.js";import{SimpleBandStatistics as p}from"./SimpleBandStatistics.js";import{getPixelValueRange as c}from"./rasterFormats/pixelRangeUtils.js";var u;let g=u=class extends s{static createEmptyBand(t,e){return new(u.getPixelArrayConstructor(t))(e)}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new e("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new p)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map((t=>this._calculateBandStatistics(t,this.mask)));const t=this.mask;let e=0;if(r(t))for(let s=0;s<t.length;s++)t[s]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;const[e,s]=c(t),i=this.pixels,l=this.width*this.height,r=i.length;let o,a,h;const n=[];for(let p=0;p<r;p++){h=u.createEmptyBand(t,l),o=i[p];for(let t=0;t<l;t++)a=o[t],h[t]=a>s?s:a<e?e:a;n.push(h)}this.pixels=n,this.pixelType=t}extractBands(t){const{pixels:e,statistics:s}=this;if(o(t)||0===t.length||!e||0===e.length)return this;const i=e.length,l=t.some((t=>t>=e.length)),r=i===t.length&&!t.some(((t,e)=>t!==e));return l||r?this:new u({pixelType:this.pixelType,width:this.width,height:this.height,mask:this.mask,validPixelCount:this.validPixelCount,maskIsAlpha:this.maskIsAlpha,pixels:t.map((t=>e[t])),statistics:s&&t.map((t=>s[t]))})}clone(){const t=new u({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;r(this.mask)&&(this.mask instanceof Uint8Array?t.mask=new Uint8Array(this.mask):t.mask=this.mask.slice(0));const s=u.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=i?this.pixels[e].slice(0,this.pixels[e].length):new s(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=i(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:s,premultiplyAlpha:i,pixels:o}=this;if(!t||!o||!o.length)return void l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let a,h,n,p;a=h=n=o[0],o.length>=3?(h=o[1],n=o[2]):2===o.length&&(h=o[1]);const c=new Uint32Array(t),u=this.width*this.height;if(a.length===u)if(r(e)&&e.length===u)if(s)for(p=0;p<u;p++){const t=e[p];if(t){const e=t/255;c[p]=i?t<<24|n[p]*e<<16|h[p]*e<<8|a[p]*e:t<<24|n[p]<<16|h[p]<<8|a[p]}}else for(p=0;p<u;p++)e[p]&&(c[p]=255<<24|n[p]<<16|h[p]<<8|a[p]);else for(p=0;p<u;p++)c[p]=255<<24|n[p]<<16|h[p]<<8|a[p];else l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:s,statistics:i}=this;if(!t||!e||!e.length)return void l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const o=this.pixelType;let a=1,h=0,n=1;if(i&&i.length>0){for(const t of i)if(null!=t.minValue&&(h=Math.min(h,t.minValue)),null!=t.maxValue&&null!=t.minValue){const e=t.maxValue-t.minValue;n=Math.max(n,e)}a=255/n}else{let t=255;"s8"===o?(h=-128,t=127):"u16"===o?t=65535:"s16"===o?(h=-32768,t=32767):"u32"===o?t=4294967295:"s32"===o?(h=-2147483648,t=2147483647):"f32"===o?(h=-34e38,t=34e38):"f64"===o&&(h=-Number.MAX_VALUE,t=Number.MAX_VALUE),a=255/(t-h)}const p=new Uint32Array(t),c=this.width*this.height;let u,g,m,d,f;if(u=g=m=e[0],u.length!==c)return l.getLogger(this.declaredClass).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(g=e[1],e.length>=3&&(m=e[2]),r(s)&&s.length===c)for(d=0;d<c;d++)s[d]&&(p[d]=255<<24|(m[d]-h)*a<<16|(g[d]-h)*a<<8|(u[d]-h)*a);else for(d=0;d<c;d++)p[d]=255<<24|(m[d]-h)*a<<16|(g[d]-h)*a<<8|(u[d]-h)*a;else if(r(s)&&s.length===c)for(d=0;d<c;d++)f=(u[d]-h)*a,s[d]&&(p[d]=255<<24|f<<16|f<<8|f);else for(d=0;d<c;d++)f=(u[d]-h)*a,p[d]=255<<24|f<<16|f<<8|f}_fillFrom32Bit(t){const{pixels:e,mask:s}=this;if(!t||!e||!e.length)return l.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,o,a,h;i=o=a=e[0],e.length>=3?(o=e[1],a=e[2]):2===e.length&&(o=e[1]);const n=this.width*this.height;if(i.length!==n)return l.getLogger(this.declaredClass).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let p=0;if(r(s)&&s.length===n)for(h=0;h<n;h++)t[p++]=i[h],t[p++]=o[h],t[p++]=a[h],t[p++]=1&s[h];else for(h=0;h<n;h++)t[p++]=i[h],t[p++]=o[h],t[p++]=a[h],t[p++]=1}_calculateBandStatistics(t,e){let s=1/0,i=-1/0;const l=t.length;let o,a=0;if(r(e))for(o=0;o<l;o++)e[o]&&(a=t[o],s=a<s?a:s,i=a>i?a:i);else for(o=0;o<l;o++)a=t[o],s=a<s?a:s,i=a>i?a:i;return new p(s,i)}};t([a({json:{write:!0}})],g.prototype,"width",void 0),t([a({json:{write:!0}})],g.prototype,"height",void 0),t([a({json:{write:!0}})],g.prototype,"pixelType",void 0),t([h("pixelType")],g.prototype,"castPixelType",null),t([a({json:{write:!0}})],g.prototype,"validPixelCount",void 0),t([a({json:{write:!0}})],g.prototype,"mask",void 0),t([a({json:{write:!0}})],g.prototype,"maskIsAlpha",void 0),t([a({json:{write:!0}})],g.prototype,"pixels",void 0),t([a()],g.prototype,"premultiplyAlpha",void 0),t([a({json:{write:!0}})],g.prototype,"statistics",void 0),t([a({json:{write:!0}})],g.prototype,"depthCount",void 0),t([a({json:{write:!0}})],g.prototype,"noDataValues",void 0),t([a({json:{write:!0}})],g.prototype,"bandMasks",void 0),g=u=t([n("esri.layers.support.PixelBlock")],g);const m=g;export{m as default};

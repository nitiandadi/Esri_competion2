/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import{unwrap as r,isSome as i,isNone as s}from"../../../core/maybe.js";import{property as a}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import o from"../RasterInfo.js";import f from"../RasterStorageInfo.js";import l from"./BaseRaster.js";import u from"./DBFParser.js";import{parseSpatialReference as c,parsePAMInfo as p}from"./pamParser.js";import{parseSignature as m,getPyramidIFDs as h,getMaskIFDs as d,getImageInfo as y,parseIFD as g,parseFieldValues as T,isBSQConfig as x}from"../rasterFormats/TiffDecoder.js";import I from"../rasterFormats/TiffTags.js";import{estimateStatisticsFromHistograms as w}from"../rasterFunctions/stretchUtils.js";import _ from"../rasterTransforms/PolynomialTransform.js";import b from"../../../rest/support/FeatureSet.js";import F from"../../../geometry/SpatialReference.js";import S from"../../../geometry/Extent.js";import R from"../../../geometry/Point.js";const E=(e,t)=>e.get(t)?.values,k=(e,t)=>e.get(t)?.values?.[0];let D=class extends l{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(e){await this.init();const s=e?r(e.signal):null,{data:a}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:s});if(!a)throw new t("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:n,firstIFDPos:o,isBigTiff:f}=m(a),l=[];await this._readIFDs(l,a,n,o,0,f?8:4,s);const{imageInfo:u,rasterInfo:c}=this._parseIFDs(l),p=h(l),y=d(l);if(this._headerInfo={littleEndian:n,isBigTiff:f,ifds:l,pyramidIFDs:p,maskIFDs:y,...u},this._set("rasterInfo",c),!u.isSupported)throw new t("tiffraster:open","this tiff is not supported: "+u.message);if(!u.tileWidth)throw new t("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");const{skipExtensions:g=[]}=this.ioConfig;if(!g.includes("aux.xml")){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&this._processPAMInfo(t,c)}g.includes("vat.dbf")||1!==c.bandCount||"u8"!==c.pixelType||(c.attributeTable=await this._fetchAuxiliaryTable(e),i(c.attributeTable)&&(c.keyProperties.DataType="thematic")),this.updateTileInfo()}async fetchRawTile(e,t,r,s={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,r))return null;const a=await this._fetchRawTiffTile(e,t,r,!1,s);if(i(a)&&this._headerInfo.hasMaskBand){const n=await this._fetchRawTiffTile(e,t,r,!0,s);i(n)&&n.pixels[0]instanceof Uint8Array&&(a.mask=n.pixels[0])}return a}_parseIFDs(e){const t=y(e),{width:r,height:i,tileWidth:s,tileHeight:a,planes:n,pixelType:l,compression:u,firstPyramidLevel:p,maximumPyramidLevel:m,pyramidBlockWidth:h,pyramidBlockHeight:d,tileBoundary:g,affine:T,metadata:x}=t,I=t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid;let w=c(I),b=!!t.isPseudoGeographic;null==w&&(b=!0,w=new F({wkid:3857}));const D=new S({...t.extent,spatialReference:w}),v=new R(D?{x:D.xmin,y:D.ymax,spatialReference:w}:{x:0,y:0}),P=new f({blockWidth:s,blockHeight:a,pyramidBlockWidth:h,pyramidBlockHeight:d,compression:u,origin:v,firstPyramidLevel:p,maximumPyramidLevel:m,blockBoundary:g}),O=new R({x:(D.xmax-D.xmin)/r,y:(D.ymax-D.ymin)/i,spatialReference:w}),j=x?{BandProperties:x.bandProperties,DataType:x.dataType}:{};let B=null;const L=k(e[0],"PHOTOMETRICINTERPRETATION"),A=E(e[0],"COLORMAP");if(L<=3&&A?.length>3&&A.length%3==0){B=[];const e=A.length/3;for(let t=0;t<e;t++)B.push([t,A[t]>>>8,A[t+e]>>>8,A[t+2*e]>>>8])}const z=new o({width:r,height:i,bandCount:n,pixelType:l,pixelSize:O,storageInfo:P,spatialReference:w,isPseudoSpatialReference:b,keyProperties:j,extent:D,colormap:B,statistics:x?x.statistics:null});return T?.length&&(z.nativeExtent=new S({xmin:-.5,ymin:.5-i,xmax:r-.5,ymax:.5,spatialReference:w}),z.transform=new _({polynomialOrder:1,forwardCoefficients:[T[2]+T[0]/2,T[5]-T[3]/2,T[0],T[3],-T[1],-T[4]]}),z.extent=z.transform.forwardTransform(z.nativeExtent),z.pixelSize=new R({x:(D.xmax-D.xmin)/r,y:(D.ymax-D.ymin)/i,spatialReference:w}),P.origin.x=-.5,P.origin.y=.5),{imageInfo:t,rasterInfo:z}}_processPAMInfo(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&s(t.statistics)&&(t.statistics=w(e.histograms)),e.transform&&s(t.transform)){t.transform=e.transform,t.nativeExtent=t.extent;const r=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new R({x:(r.xmax-r.xmin)/t.width,y:(r.ymax-r.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=r}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference)}async _readIFDs(e,t,r,i,s,a=4,n){if(!i)return null;if(i>=t.byteLength||i<0){t=(await this.request(this.url,{range:{from:i+s,to:i+s+this._bufferSize},responseType:"array-buffer",signal:n})).data,s=i+s,i=0}const o=await this._readIFD(t,r,i,s,I.TIFF_TAGS,a,n);if(e.push(o.ifd),!o.nextIFD)return null;await this._readIFDs(e,t,r,o.nextIFD-s,s,a,n)}async _readIFD(e,t,r,s,a=I.TIFF_TAGS,n=4,o){if(!e)return null;const f=g(e,t,r,s,a,n);if(f.success){const r=[];if(f.ifd?.forEach((e=>{e.values||r.push(e)})),r.length>0){const a=r.map((e=>e.offlineOffsetSize)).filter(i),n=Math.min.apply(null,a.map((e=>e[0])));if(Math.min.apply(null,a.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:i}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:o});e=i,s=n,r.forEach((r=>T(e,t,r,s)))}}if(f.ifd?.has("GEOKEYDIRECTORY")){const r=f.ifd.get("GEOKEYDIRECTORY"),i=r?.values;if(i&&i.length>4){const a=i[0]+"."+i[1]+"."+i[2],n=await this._readIFD(e,t,r.valueOffset+6-s,s,I.GEO_KEYS,2,o);r.data=n.ifd,r.data&&r.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}return f}if(f.requiredBufferSize&&f.requiredBufferSize!==e.byteLength){const r=await this.request(this.url,{range:{from:s,to:s+f.requiredBufferSize+4},responseType:"array-buffer",signal:o});return(e=r.data).byteLength<f.requiredBufferSize?null:this._readIFD(e,t,0,s,I.TIFF_TAGS,4,o)}}async _fetchRawTiffTile(e,t,r,i,s={}){const a=this._getTileLocation(e,t,r,i);if(!a)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:f,ifd:l}=a,u=n.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:s.signal}))),c=await Promise.all(u),p=c.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),m=1===c.length?c[0].data:new ArrayBuffer(p),h=[0],d=[0];if(c.length>1){const e=new Uint8Array(m);for(let t=0,r=0;t<c.length;t++){const i=c[t].data;e.set(new Uint8Array(i),r),h[t]=r,r+=i.byteLength,d[t]=i.byteLength}}const{blockWidth:y,blockHeight:g}=this.getBlockWidthHeight(e),T=await this.decodePixelBlock(m,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:l,offsets:h,sizes:d},width:y,height:g,planes:null,pixelType:null});if(null==T)return null;let x,I,w;if(o!==y||f!==g){let e=T.mask;if(e)for(x=0;x<g;x++)if(w=x*y,x<f)for(I=o;I<y;I++)e[w+I]=0;else for(I=0;I<y;I++)e[w+I]=0;else for(e=new Uint8Array(y*g),T.mask=e,x=0;x<f;x++)for(w=x*y,I=0;I<o;I++)e[w+I]=1}return T}_getTileLocation(e,t,r,i=!1){const{firstPyramidLevel:s,blockBoundary:a}=this.rasterInfo.storageInfo,n=0===e?0:e-(s-1),{_headerInfo:o}=this;if(!o)return null;const f=i?o.maskIFDs[n]:0===n?o?.ifds[0]:o?.pyramidIFDs[n-1];if(!f)return null;const l=x(f,o),u=E(f,"TILEOFFSETS");if(void 0===u)return null;const c=E(f,"TILEBYTECOUNTS"),{minRow:p,minCol:m,maxRow:h,maxCol:d}=a[n];if(t>h||r>d||t<p||r<m)return null;const y=k(f,"IMAGEWIDTH"),g=k(f,"IMAGELENGTH"),T=k(f,"TILEWIDTH"),I=k(f,"TILELENGTH"),w=l?this.rasterInfo.bandCount:1,_=w*t*(d+1)+r,b=[{from:u[_],to:u[_+w-1]+c[_+w-1]-1}];if(l){let e=!0;for(let t=0;t<w;t++)if(u[_+t]+c[_+t]!==u[_+t+1]){e=!1;break}if(!e)for(let t=0;t<w;t++)b[t]={from:u[_+t],to:u[_+t]+c[_+t]-1}}const F=u[_],S=c[_];if(null==F||null==S)return null;return{ranges:b,ifd:f,actualTileWidth:r===d&&y%T||T,actualTileHeight:t===h&&g%I||I}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return p(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),r=u.parse(t);return r?.recordSet?b.fromJSON(r.recordSet):null}catch{return null}}};e([a()],D.prototype,"_files",void 0),e([a()],D.prototype,"_headerInfo",void 0),e([a()],D.prototype,"_bufferSize",void 0),e([a({type:String,json:{write:!0}})],D.prototype,"datasetFormat",void 0),D=e([n("esri.layers.support.rasterDatasets.TIFFRaster")],D);const v=D;export{v as default};

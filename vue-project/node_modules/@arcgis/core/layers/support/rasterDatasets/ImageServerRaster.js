/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import{isNone as i,assertIsSome as s,isSome as r,unwrap as a}from"../../../core/maybe.js";import{urlToObject as l}from"../../../core/urlUtils.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import c from"../RasterInfo.js";import m from"../RasterStorageInfo.js";import{readServiceTileInfo as h}from"../serviceTileInfoProperty.js";import u from"../TileInfo.js";import{TilemapCache as f}from"../TilemapCache.js";import p from"./BaseRaster.js";import{setValidBoundary as y}from"../rasterFunctions/pixelUtils.js";import d from"../rasterTransforms/GCSShiftTransform.js";import{fetchServiceRasterInfo as x}from"../../../rest/imageService/fetchRasterInfo.js";import g from"../../../geometry/SpatialReference.js";import v from"../../../geometry/Point.js";import S from"../../../geometry/Extent.js";let I=class extends p{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(e){await this.init();const r=e&&e.signal,a=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:r});a.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const o=a.data;if(this.sourceJSON=o,!o)throw new t("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!o.tileInfo)throw new t("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const n=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=o.cacheType,null==this.tileType&&(n.includes(o.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===o.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=o.name?.slice(o.name.indexOf("/")+1)??"";const c=await this._fetchRasterInfo({signal:r});if(i(c))throw new t("image-server-raster:open","cannot initialize image service");const p="Map"===this.tileType?h(o.tileInfo,o):u.fromJSON(o.tileInfo);s(p);const[y,d]=this._computeMinMaxLOD(c,p),{extent:x,pixelSize:g}=c,v=.5/c.width*g.x,S=Math.max(g.x,g.y),{lods:I}=p;("Map"!==this.tileType&&0!==o.maxScale||Math.abs(g.x-g.y)>v||!I.some((e=>Math.abs(e.resolution-S)<v)))&&(g.x=g.y=y.resolution,c.width=Math.ceil((x.xmax-x.xmin)/g.x-.1),c.height=Math.ceil((x.ymax-x.ymin)/g.y-.1));const w=y.level-d.level,[j,T]=p.size,b=[],M=[];I.forEach(((e,t)=>{e.level>=d.level&&e.level<=y.level&&b.push({x:e.resolution,y:e.resolution}),t<I.length-1&&M.push(Math.round(10*e.resolution/I[t+1].resolution)/10)})),b.sort(((e,t)=>e.x-t.x));const _=this.computeBlockBoundary(x,j,T,p.origin,b,w),R=b.length>1?b.slice(1):null;let z;o.transposeInfo&&(z={tileSize:[o.transposeInfo.rows,o.transposeInfo.cols],packetSize:c.keyProperties?._yxs.PacketSize??0});const P=M.length<=1||M.length>=3&&M.slice(0,M.length-1).every((e=>e===M[0]))?M[0]??2:Math.round(10/(d.resolution/y.resolution)**(-1/w))/10;if(c.storageInfo=new m({blockWidth:p.size[0],blockHeight:p.size[1],pyramidBlockWidth:p.size[0],pyramidBlockHeight:p.size[1],pyramidResolutions:R,pyramidScalingFactor:P,compression:p.format,origin:p.origin,firstPyramidLevel:1,maximumPyramidLevel:w,tileInfo:p,transposeInfo:z,blockBoundary:_}),this._fixGCSShift(c),this._set("rasterInfo",c),o.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:c.storageInfo.tileInfo,parsedUrl:l(this.url),url:this.url,tileServers:[],type:"tile"};this._tilemapCache=new f({layer:e})}}async fetchRawTile(e,t,i,s={}){const{storageInfo:l,extent:o}=this.rasterInfo,{transposeInfo:n}=l,c=r(n)&&!!s.transposedVariableName;if(this._slices&&!c&&null==s.sliceId)return null;const m=c?0:l.maximumPyramidLevel-e+this._levelOffset,h=`${this.url}/tile/${m}/${t}/${i}`,u=this._slices?c?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null,{data:f}=await this.request(h,{query:u,responseType:"array-buffer",signal:s.signal});if(!f)return null;const p=c?n.tileSize:l.tileInfo.size,d=await this.decodePixelBlock(f,{width:p[0],height:p[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:c,noDataValue:a(this.rasterInfo.noDataValue)});if(null==d)return null;const x=l.blockBoundary[e];if("jpg"!==l.compression||i>x.minCol&&i<x.maxCol&&t>x.minRow&&t<x.maxRow)return d;const{origin:g,blockWidth:v,blockHeight:S}=l,{x:I,y:w}=this.getPyramidPixelSize(e),j=Math.round((o.xmin-g.x)/I)%v,T=Math.round((o.xmax-g.x)/I)%v||v,b=Math.round((g.y-o.ymax)/w)%S,M=Math.round((g.y-o.ymin)/w)%S||S,_=i===x.minCol?j:0,R=t===x.minRow?b:0,z=i===x.maxCol?T:v,P=t===x.maxRow?M:S;return y(d,{x:_,y:R},{width:z-_,height:P-R}),d}getSliceIndex(e){if(!this._slices||i(e)||0===e.length)return null;const t=e;for(let i=0;i<this._slices.length;i++){const e=this._slices[i].multidimensionalDefinition;if(e.length===t.length&&!e.some((e=>{const i=t.find((t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName));if(!i)return!0;return(Array.isArray(e.values[0])?`${e.values[0][0]}-${e.values[0][1]}`:e.values[0])!==(Array.isArray(i.values[0])?`${i.values[0][0]}-${i.values[0][1]}`:i.values[0])})))return i}return null}async fetchVariableStatisticsHistograms(e,t){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.statistics)),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.histograms)),r=await Promise.all([i,s]);return r[0]&&r[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:r[0]||null,histograms:r[1]||null}}async computeBestPyramidLevelForLocation(e,t={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,a(t.datumTransformation));if(null===i)return null;let s=0;const{maximumPyramidLevel:r}=this.rasterInfo.storageInfo;let l=r-s+this._levelOffset;const o=i.srcLocation;for(;l>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(l,i.row,i.col,t))break}catch{}if(l--,s++,i=this.identifyPixelLocation(o,s,a(t.datumTransformation)),null===i)return null}return-1===l||null==i?null:s}async _fetchRasterInfo(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,i=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),s=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),r=g.fromJSON(t.spatialReference||e.spatialReference),a=new v({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:r});return new c({width:i,height:s,bandCount:3,extent:S.fromJSON(e),spatialReference:r,pixelSize:a,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,s=x(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),r=t.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then((e=>e.data&&e.data.slices)).catch((()=>null)):null,a=await Promise.all([s,r]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_fixGCSShift(e){const{extent:t,spatialReference:i}=e;t.xmin>-1&&t.xmax>181&&i?.wkid&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new d,e.extent=e.transform.forwardTransform(t))}_computeMinMaxLOD(e,t){const{pixelSize:i}=e,s=.5/e.width*i.x,{lods:r}=t,a=t.lodAt(Math.max.apply(null,r.map((e=>e.level)))),l=t.lodAt(Math.min.apply(null,r.map((e=>e.level)))),{tileType:o}=this;if("Map"===o)return this._levelOffset=r[0].level,[a,l];if("Raster"===o){return[r.find((e=>e.resolution===i.x))??a,l]}const{minScale:n,maxScale:c}=this.sourceJSON;let m=a;c>0&&(m=r.find((e=>Math.abs(e.scale-c)<s)),m||(m=r.filter((e=>e.scale>c)).sort(((e,t)=>e.scale>t.scale?1:-1))[0]??a));let h=l;return n>0&&(h=r.find((e=>Math.abs(e.scale-n)<s))??l,this._levelOffset=h.level-l.level),[m,h]}};e([o({type:String,json:{write:!0}})],I.prototype,"datasetFormat",void 0),e([o()],I.prototype,"tileType",void 0),I=e([n("esri.layers.support.rasterDatasets.ImageServerRaster")],I);const w=I;export{w as default};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../core/Error.js";import{isNone as r,isSome as o}from"../../../core/maybe.js";import{property as i}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import a from"../LOD.js";import n from"../RasterInfo.js";import l from"../RasterStorageInfo.js";import f from"../TileInfo.js";import m from"./BaseRaster.js";import c from"./DBFParser.js";import{isTransformSupported as p,readTransform as d}from"../rasterTransforms/utils.js";import u from"../../../rest/support/FeatureSet.js";import h from"../../../geometry/SpatialReference.js";import g from"../../../geometry/Extent.js";import y from"../../../geometry/Point.js";const x=new Map;x.set("int16","esriFieldTypeSmallInteger"),x.set("int32","esriFieldTypeInteger"),x.set("int64","esriFieldTypeInteger"),x.set("float32","esriFieldTypeSingle"),x.set("float64","esriFieldTypeDouble"),x.set("text","esriFieldTypeString");const S=8;let I=class extends m{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(e){await this.init();const{data:r}=await this.request(this.url+"/conf.json",{signal:e?.signal});if(!this._validateHeader(r))throw new t("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:o,rasterInfo:i}=this._parseHeader(r);if("thematic"===i.dataType){const e=await this._fetchAuxiliaryInformation();i.attributeTable=e}this._set("storageInfo",o),this._set("rasterInfo",i),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(e,t,r,o={}){const{transposeInfo:i}=this.rasterInfo.storageInfo,{transposedVariableName:s}=o,a=!(!i||!s),n=a?0:this.rasterInfo.storageInfo.maximumPyramidLevel-e;if(n<0)return null;const l=this._buildCacheFilePath(n,t,r,o.multidimensionalDefinition,s),f=this._getIndexRecordFromBundle(t,r,a),m=await this.request(l,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:o.signal});if(!m)return null;const c=new Uint8Array(m.data),p=this._getTileEndAndContentType(c,f);if(0===p.recordSize)return null;const d=await this.request(l,{range:{from:p.position,to:p.position+p.recordSize},responseType:"array-buffer",signal:o.signal});if(!d)return null;const[u,h]=this._getTileSize(a);return this.decodePixelBlock(d.data,{width:u,height:h,planes:null,pixelType:null,returnInterleaved:a})}_validateHeader(e){const t=["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"];return e&&"RasterInfo"===e.type&&!t.some((t=>!e[t]))}_parseHeader(e){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][e.pixelType],{bandCount:r,histograms:o,colormap:i,blockWidth:s,blockHeight:m,firstPyramidLevel:c,maximumPyramidLevel:p}=e,d=e.statistics&&e.statistics.map((e=>({min:e.min,max:e.max,avg:e.mean,stddev:e.standardDeviation,median:e.median,mode:e.mode}))),u=e.extent.spatialReference,x=e.geodataXform?.spatialReference,I=new h(u?.wkid||u?.wkt?u:x);let w=new g({xmin:e.extent.xmin,ymin:e.extent.ymin,xmax:e.extent.xmax,ymax:e.extent.ymax,spatialReference:I});const _=new y({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:I}),v=Math.round((w.xmax-w.xmin)/_.x),b=Math.round((w.ymax-w.ymin)/_.y),z=this._parseTransform(e.geodataXform),T=z?w:null;z&&(w=z.forwardTransform(w),_.x=(w.xmax-w.xmin)/v,_.y=(w.ymax-w.ymin)/b);const k=e.properties??{},j=e.format.toLowerCase().replace("cache/",""),C=new y(e.origin.x,e.origin.y,I);let R,F,P,H;if(i&&i.colors)for(R=[],F=0;F<i.colors.length;F++)P=i.colors[F],H=i.values?i.values[F]:F,R.push([H,255&P,P<<16>>>24,P<<8>>>24,P>>>24]);const D=e.LODInfos,L=[];for(F=0;F<D.levels.length;F++)L.push(new a({level:D.levels[F],resolution:D.resolutions[F],scale:96/.0254*D.resolutions[F]}));const M=new f({dpi:96,lods:L,format:j,origin:C,size:[s,m],spatialReference:I}),O={recordSize:S,packetSize:e.packetSize,headerSize:e.packetSize*e.packetSize*S+64},B=[{maxCol:Math.ceil(v/s)-1,maxRow:Math.ceil(b/m)-1,minCol:0,minRow:0}];let $=2;if(p>0)for(F=0;F<p;F++)B.push({maxCol:Math.ceil(v/$/s)-1,maxRow:Math.ceil(b/$/m)-1,minCol:0,minRow:0}),$*=2;const N=e.mdInfo;let q=null;if(N&&k._yxs){const e=k._yxs;q={packetSize:e.PacketSize,tileSize:[e.TileXSize,e.TileYSize]}}return{storageInfo:O,rasterInfo:new n({width:v,height:b,pixelType:t,bandCount:r,extent:w,nativeExtent:T,transform:z,spatialReference:I,pixelSize:_,keyProperties:k,statistics:d,histograms:o,multidimensionalInfo:N,colormap:R,storageInfo:new l({blockWidth:s,blockHeight:m,pyramidBlockWidth:s,pyramidBlockHeight:m,origin:C,tileInfo:M,transposeInfo:q,firstPyramidLevel:c,maximumPyramidLevel:p,blockBoundary:B})})}}_parseTransform(e){if(!p(e))throw new t("cloudraster:open","the data contains unsupported geodata transform types");const r=d(e);if("identity"===r.type)return null;if("polynomial"!==r.type||!r.forwardCoefficients?.length||!r.inverseCoefficients?.length)throw new t("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return r}async _fetchAuxiliaryInformation(e){const t=this.request(this.url+"/conf.vat.json",{signal:e}).then((e=>e.data)).catch((()=>null)),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:e}).then((e=>e.data)).catch((()=>null)),o=await Promise.all([t,r]);let i;if(o[0]){let e=o[0].fields;const t=o[0].values;if(e&&t){e=e.map((e=>({type:"OID"===e.name?"esriFieldTypeOID":x.get(e.type),name:e.name,alias:e.alias||e.name})));const r=t.map((e=>({attributes:e})));e&&t&&(i={fields:e,features:r})}}if(!i&&o[1]){i=c.parse(o[1]).recordSet}return u.fromJSON(i)}_buildCacheFilePath(e,t,o,i,s){const a=this._getPackageSize(!!s),n=Math.floor(t/a)*a,l=Math.floor(o/a)*a,f="R"+this._toHexString4(n)+"C"+this._toHexString4(l);let m="L";m+=e>=10?e.toString():"0"+e.toString();const{multidimensionalInfo:c}=this.rasterInfo,p=i?.[0];if(r(c)||!p)return`${this.url}/_alllayers/${m}/${f}.bundle`;let d="_yxs";if(!s){d=c.variables.find((e=>e.name===p.variableName)).dimensions[0].values.indexOf(p.values[0]).toString(16);const e=4-d.length;for(let t=0;t<e;t++)d="0"+d;d="S"+d}const u=this._getVariableFolderName(s||p.variableName);return`${this.url}/_alllayers/${u}/${d}/${m}/${f}.bundle`}_getPackageSize(e=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return e&&o(t)?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(e=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:r}=t;return e&&o(r)?r.tileSize:t.tileInfo.size}_getVariableFolderName(e){return""===(e=e.trim())?"_v":e.replace(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(e,t,r=!1){const o=this._getPackageSize(r),i=o*(e%o)+t%o;if(i<0)throw new Error("Invalid level / row / col");return 20+i*this.storageInfo.recordSize+44}_getTileEndAndContentType(e,t){const r=e.subarray(t,t+8);let o,i=0;for(o=0;o<5;o++)i|=(255&r[o])<<8*o;const s=0xffffffffff&i;for(i=0,o=5;o<8;o++)i|=(255&r[o])<<8*(o-5);return{position:s,recordSize:0xffffffffff&i}}_toHexString4(e){let t=e.toString(16);if(4!==t.length){let e=4-t.length;for(;e-- >0;)t="0"+t}return t}};e([i({readOnly:!0})],I.prototype,"storageInfo",void 0),e([i({type:String,json:{write:!0}})],I.prototype,"datasetFormat",void 0),I=e([s("esri.layers.support.rasterDatasets.CloudRaster")],I);const w=I;export{w as default};

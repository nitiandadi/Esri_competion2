/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import{NUMBER_MAX_FLOAT32 as e}from"../../../core/mathUtils.js";import{isNone as s}from"../../../core/maybe.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as r}from"../../../core/accessorSupport/decorators/subclass.js";import n from"./BaseRasterFunction.js";import u from"./MaskFunctionArguments.js";import{createMaskLUT as a,MAX_MAP_SIZE_GPU as i,NoDataInterpretation as l,mask as c}from"./pixelUtils.js";let p=class extends n{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:s,normalizedNoDataValues:o}=this.functionArguments;if(!s?.length&&!o?.length)return{success:!1,supportsGPU:!1,error:"missing includedRanges or noDataValues argument"};let r=[];for(let u=0;u<t.bandCount;u++){const t=a(e,s?.slice(2*u,2*u+2),o?.[u]);if(null==t){r=null;break}r.push(t)}this.lookups=r;const n=null!=o&&o.every((t=>t?.length===o[0]?.length));return{success:!0,supportsGPU:(!s||s.length<=2*i)&&(!o||n&&o[0].length<=i)}}_processPixels(t){const e=t.pixelBlocks?.[0];if(s(e))return null;const{outputPixelType:o,lookups:r}=this,{includedRanges:n,noDataInterpretation:u,normalizedNoDataValues:a}=this.functionArguments,i=u===l.matchAll;return c(e,{includedRanges:n,noDataValues:a,outputPixelType:o,matchAll:i,lookups:r})}_getWebGLParameters(){const{includedRanges:t,normalizedNoDataValues:s}=this.functionArguments,o=new Float32Array(i);o.fill(e),s?.[0]?.length&&o.set(s[0]);const r=new Float32Array(i);for(let n=0;n<r.length;n+=2)r[n]=t?.[n]??-e,r[n+1]=t?.[n+1]??e;return t&&t.length&&r.set(t),{bandCount:this.sourceRasterInfos[0].bandCount,noDataValues:o,includedRanges:r}}};t([o({json:{write:!0,name:"rasterFunction"}})],p.prototype,"functionName",void 0),t([o({type:u,json:{write:!0,name:"rasterFunctionArguments"}})],p.prototype,"functionArguments",void 0),t([o()],p.prototype,"rasterArgumentNames",void 0),t([o({json:{write:!0}})],p.prototype,"lookups",void 0),p=t([r("esri.layers.support.rasterFunctions.MaskFunction")],p);const m=p;export{m as default};

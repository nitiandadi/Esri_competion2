/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import{isNone as e}from"../../../core/maybe.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import{convolutionKernel as r}from"../rasterFunctionConstants.js";import{getPixelValueRange as n}from"../rasterFormats/pixelRangeUtils.js";import i from"./BaseRasterFunction.js";import u from"./ConvolutionFunctionArguments.js";import{convolute as c}from"./convolutionUtils.js";const p=25;let l=class extends i{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{convolutionType:t,rows:e,cols:o,kernel:s}=this.functionArguments;if(!Object.values(r).includes(t))return{success:!1,supportsGPU:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==r.none&&e*o!==s.length)return{success:!1,supportsGPU:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const n=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(n.pixelType);const i=n.clone();i.pixelType=this.outputPixelType;const u=[r.none,r.sharpen,r.sharpen2,r.sharpening3x3,r.sharpening5x5];"u8"===this.outputPixelType||u.includes(t)||(i.statistics=null,i.histograms=null),i.colormap=null,i.attributeTable=null,this.rasterInfo=i;return{success:!0,supportsGPU:s.length<=p}}_processPixels(t){const o=t.pixelBlocks?.[0];if(e(o)||this.functionArguments.convolutionType===r.none)return o;let{kernel:s,rows:n,cols:i}=this.functionArguments;const u=s.reduce(((t,e)=>t+e));return 0!==u&&1!==u&&(s=s.map((t=>t/u))),c(o,{kernel:s,rows:n,cols:i,outputPixelType:this.outputPixelType})}_getWebGLParameters(){let{kernel:t}=this.functionArguments;const e=t.reduce(((t,e)=>t+e));0!==e&&1!==e&&(t=t.map((t=>t/e)));const o=new Float32Array(p);return o.set(t),{kernelRows:this.functionArguments.rows,kernelCols:this.functionArguments.cols,kernel:o,clampRange:n(this.outputPixelType)}}};t([o({json:{write:!0,name:"rasterFunction"}})],l.prototype,"functionName",void 0),t([o({type:u,json:{write:!0,name:"rasterFunctionArguments"}})],l.prototype,"functionArguments",void 0),t([o()],l.prototype,"rasterArgumentNames",void 0),l=t([s("esri.layers.support.rasterFunctions.ConvolutionFunction")],l);const a=l;export{a as default};

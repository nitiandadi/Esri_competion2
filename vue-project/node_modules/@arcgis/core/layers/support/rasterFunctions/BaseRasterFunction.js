/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import{JSONSupport as s}from"../../../core/JSONSupport.js";import{isSome as e,isNone as r}from"../../../core/maybe.js";import{property as i}from"../../../core/accessorSupport/decorators/property.js";import{cast as n}from"../../../core/accessorSupport/decorators/cast.js";import"../../../core/arrayUtils.js";import{subclass as o}from"../../../core/accessorSupport/decorators/subclass.js";import a from"../PixelBlock.js";import u from"../RasterInfo.js";let p=class extends s{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}bind(t,s=!1,r=-1){this.id=r+1;const i=this._getRasterValues();let n=!0;for(let o=0;o<i.length;o++){const r=i[o];if(e(r)&&this._isRasterFunctionValue(r)){const e=r.bind(t,s,this.id+o);if(!e.success)return this._bindingResult=e,e;n=n&&e.supportsGPU}}return!this.rasterInfo||s?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),this._bindingResult.supportsGPU=n&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)}process(t){const s=this._getRasterValues(),e=0===s.length?t.pixelBlocks??t.primaryPixelBlocks:s.map((s=>this._readRasterValue(s,t)));return this._processPixels({...t,pixelBlocks:e})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);let s;if(t.length>1){const s=t.map((t=>t.processInputBandIds()[0]));this.rawInputBandIds=s,this.isInputBandIdsSwizzled=this.rawInputBandIds.some(((t,s)=>t!==s));const e=t.filter((t=>"ExtractBand"===t.functionName));return e.length&&e.forEach(((t,s)=>{t.isInputBandIdsSwizzled=!0,t.swizzledBandSelection=[s,s,s]})),this.rawInputBandIds}const e=t[0];if(e){if(s=e.processInputBandIds(),e.isInputBandIdsSwizzled)return this.rawInputBandIds=s,s}else{s=[];const{bandCount:t}=this.sourceRasterInfos[0];for(let e=0;e<t;e++)s.push(e)}const r=this._getInputBandIds(s);return this.isInputBandIdsSwizzled=r.some(((t,s)=>t!==s)),this.rawInputBandIds=r,this.rawInputBandIds}getPrimaryRasters(){const t=[],s=[];return this._getPrimaryRasters(this,t,s),{rasters:t,rasterIds:s}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:s,rasters:e}=this.functionArguments;return e&&Array.isArray(e)&&e.length?(t.rasters=e.map((t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((t=>null!=t))||(t.rasters=null)):this._isRasterFunctionValue(s)&&(t.raster=s.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getFlatWebGLFunctionChain(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const s=[t],{parameters:e}=t;let r=e.rasters||e.raster&&[e.raster];for(;r?.length;){s.unshift(...r);const t=[];for(let s=0;s<r.length;s++){const{parameters:e}=r[s],i=e.rasters||e.raster&&[e.raster];i?.length&&t.push(...i)}r=t}for(let n=s.length-1;n>=0;n--)s[n].isNoopProcess&&s.splice(n,1);let i=!1;for(let n=0;n<s.length;n++){const t=s[n];t.id=s.length-n-1;const{rasters:e}=t.parameters;i=i||null!=e&&e.length>1}return{hasBranches:i,functions:s}}_getOutputPixelType(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_isOutputRoundingNeeded(){const{outputPixelType:t}=this;return(t?.startsWith("u")||t?.startsWith("s"))??!1}_getRasterValues(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.map((t=>this.functionArguments[t]))}_getSourceRasterInfos(t){const s=this._getRasterValues(),{rasterInfos:e,rasterIds:r}=t;if(0===s.length)return e;const i=s.map((t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&r.includes(t)?e[r.indexOf(t)]:"number"!=typeof t?e[0]:void 0)),n=i.find((t=>t))??e[0];return i.forEach(((t,s)=>{void 0===t&&(i[s]=n)})),i}_getPrimaryRasterId(t){return t?.url}_getPrimaryRasters(t,s=[],e=[]){for(let r=0;r<t.sourceRasters.length;r++){const i=t.sourceRasters[r];if("number"!=typeof i)if("bind"in i)this._getPrimaryRasters(i,s,e);else{const t=i,r=this._getPrimaryRasterId(t);if(null==r)continue;e.includes(r)||(this.mainPrimaryRasterId===r?(s.unshift(t),e.unshift(r)):(s.push(t),e.push(r)))}}}_isRasterFunctionValue(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,s){const{primaryPixelBlocks:e}=s;if(r(t)||"$$"===t){const t=e[0];return r(t)?null:t.clone()}if("string"==typeof t){const r=s.primaryRasterIds.indexOf(t);return-1===r?null:e[r]}if("number"==typeof t){const s=e[0];if(r(s))return null;const{width:i,height:n,pixelType:o,mask:u}=s,p=u?new Uint8Array(u):null,l=new Float32Array(i*n);l.fill(t);const d=this.sourceRasterInfos[0].bandCount,c=new Array(d).fill(l);return new a({width:i,height:n,pixelType:o,pixels:c,mask:p})}return t.process(s)}};t([i({json:{write:!0}})],p.prototype,"functionName",void 0),t([i({json:{write:!0}})],p.prototype,"functionArguments",void 0),t([i()],p.prototype,"rasterArgumentNames",void 0),t([i({json:{write:!0}}),n((t=>t?.toLowerCase()))],p.prototype,"outputPixelType",void 0),t([i({json:{write:!0}})],p.prototype,"mainPrimaryRasterId",void 0),t([i()],p.prototype,"sourceRasters",void 0),t([i({type:[u],json:{write:!0}})],p.prototype,"sourceRasterInfos",void 0),t([i({json:{write:!0}})],p.prototype,"rasterInfo",void 0),t([i({json:{write:!0}})],p.prototype,"readingBufferSize",void 0),t([i({json:{write:!0}})],p.prototype,"id",void 0),t([i()],p.prototype,"isNoopProcess",void 0),t([i()],p.prototype,"supportsGPU",null),t([i()],p.prototype,"rawInputBandIds",void 0),t([i()],p.prototype,"isInputBandIdsSwizzled",void 0),t([i()],p.prototype,"swizzledBandSelection",void 0),t([i()],p.prototype,"isBranch",void 0),t([i()],p.prototype,"_bindingResult",void 0),p=t([o("esri.layers.support.rasterFunctions.BaseRasterFunction")],p);const l=p;export{l as default};

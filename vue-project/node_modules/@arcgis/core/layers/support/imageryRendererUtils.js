/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import{isNone as n}from"../../core/maybe.js";import t from"./RasterFunction.js";import{schema as r}from"./rasterFunctionUtils.js";import{getPixelValueRange as o}from"./rasterFormats/pixelRangeUtils.js";import{getRFxArgColorRampValue as a,convertColorRampToColormap as i,getColorRampName as s,rgbaConvertTo32Bit as u}from"../../renderers/support/colorRampUtils.js";import{stretchTypeJSONDict as l}from"../../renderers/support/stretchRendererUtils.js";import c from"../../renderers/visualVariables/SizeVariable.js";const m=new Set(["u1","u2","u4","u8","s8","u16","s16"]),p={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},f=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function g(e){return f.has(e.type)}function d(n,t){if(!n||!t)return e(n||t);const r=e(n);if(r.rasterFunctionDefinition&&t.rasterFunctionDefinition){const e=t.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=void 0),h(r.rasterFunctionDefinition.arguments,t)}else if("none"!==t.functionName?.toLowerCase()){R(r.functionArguments).Raster=t}return r}function h(e,n){for(const t in e)"raster"===t.toLowerCase()&&("RasterFunctionVariable"===e[t].type?(e[t]=n.rasterFunctionDefinition,e[t].type="RasterFunctionTemplate"):"RasterFunctionTemplate"===e[t].type&&h(e[t].arguments,n))}function y(n){const t=e(r[n.functionName+"Function"]),o=n.functionArguments;for(const e in o)"raster"===e.toLowerCase()?(t.arguments[e]=y(o[e]),t.arguments[e].type="RasterFunctionTemplate"):"colormap"===e.toLowerCase()?(t.arguments[e].value=D(o[e]),t.arguments.ColorSchemeType.value=0):t.arguments[e].value=o[e];return t}function b(e,n){switch(n=n||{},e.type){case"raster-stretch":return x(e,n);case"class-breaks":return S(e,n);case"unique-value":return A(e,n);case"raster-colormap":return N(e,n);case"vector-field":return w(e,n);case"raster-shaded-relief":return v(e,n);case"flow":throw new Error("Unsupported rendering rule.")}}function R(e){const n=e?.Raster;return n&&"esri.layers.support.RasterFunction"===n.declaredClass?R(n.functionArguments):e}const T={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function w(e,n){const r=new t;r.functionName="VectorFieldRenderer";const{dataType:o,bandProperties:a}=n,i="vector-uv"===o;let s,u;a&&2===a.length&&(s=a.map((e=>e.BandName.toLowerCase())).indexOf("magnitude"),u=a.map((e=>e.BandName.toLowerCase())).indexOf("direction")),-1!==s&&null!==s||(s=0,u=1);const l="arithmetic"===e.rotationType?1:2,m="flow-from"===e.flowRepresentation?0:1,f=e.visualVariables?e.visualVariables.find((e=>"Magnitude"===e.field)):new c,g={magnitudeBandID:s,directionBandID:u,isUVComponents:i,referenceSystem:l,massFlowAngleRepresentation:m,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:p[e.style.toLowerCase().replace("-","_")],minimumMagnitude:f.minDataValue,maximumMagnitude:f.maxDataValue,minimumSymbolSize:f.minSize,maximumSymbolSize:f.maxSize};return r.functionArguments=g,n.convertToRFT?new t({rasterFunctionDefinition:y(r)}):r}function v(e,n){const r=n.convertToRFT;if("elevation"!==n.dataType&&("generic"!==n.dataType||1!==n.bandCount||"s16"!==n.pixelType&&"s32"!==n.pixelType&&"f32"!==n.pixelType&&"f64"!==n.pixelType))return new t;const o=new t;o.functionName="Hillshade";const s="traditional"===e.hillshadeType?0:1,u="none"===e.scalingType?1:3,l={HillshadeType:s,SlopeType:u,ZFactor:e.zFactor};return 0===s&&(l.Azimuth=e.azimuth,l.Altitude=e.altitude),3===u&&(l.PSPower=e.pixelSizePower,l.PSZFactor=e.pixelSizeFactor),o.functionArguments=l,o.variableName="Raster",e.colorRamp&&(o.functionName="ShadedRelief",r?l.ColorRamp=a(e.colorRamp):l.Colormap=i(e.colorRamp)),r?new t({rasterFunctionDefinition:y(o)}):o}function x(e,n){const r=n.convertToRFT,o=new t;o.functionName="Stretch";const u=T[l.toJSON(e.stretchType)],c="u8",m={StretchType:u,Statistics:V(e.statistics??[]),DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(null!=e.outputMin&&(m.Min=e.outputMin),null!=e.outputMax&&(m.Max=e.outputMax),u===T.standardDeviation?(m.NumberOfStandardDeviations=e.numberOfStandardDeviations,o.outputPixelType=c):u===T.percentClip?(m.MinPercent=e.minPercent,m.MaxPercent=e.maxPercent,o.outputPixelType=c):u===T.minMax?o.outputPixelType=c:u===T.sigmoid&&(m.SigmoidStrengthLevel=e.sigmoidStrengthLevel),o.functionArguments=m,o.variableName="Raster",e.colorRamp){const u=e.colorRamp,l=new t;if(r)l.functionArguments={ColorRamp:a(u)};else{const t=s(u);if(t)l.functionArguments={colorRamp:t};else if(!n.convertColorRampToColormap||"algorithmic"!==u.type&&"multipart"!==u.type){const n=e.colorRamp.toJSON();"algorithmic"===n.type?n.algorithm=n.algorithm||"esriCIELabAlgorithm":"multipart"===n.type&&n.colorRamps?.length&&n.colorRamps.forEach((e=>e.algorithm=e.algorithm||"esriCIELabAlgorithm")),l.functionArguments={colorRamp:n}}else l.functionArguments={Colormap:i(u)}}return l.variableName="Raster",l.functionName="Colormap",l.functionArguments.Raster=o,r?new t({rasterFunctionDefinition:y(l)}):l}return r?new t({rasterFunctionDefinition:y(o)}):o}function S(e,r){const o=[],a=[],i=[],s=[],u=1e-6,{pixelType:l,rasterAttributeTable:c}=r,m=n(c)?null:c.features,p=F(c);if(p&&m&&Array.isArray(m)&&e.classBreakInfos){e.classBreakInfos.forEach(((n,t)=>{const r=n.symbol?.color;let o;r?.a&&null!=n.minValue&&null!=n.maxValue&&m.forEach((a=>{null!=n.minValue&&null!=n.maxValue&&(o=a.attributes[e.field],(o>=n.minValue&&o<n.maxValue||t===e.classBreakInfos.length-1&&o>=n.minValue)&&s.push([a.attributes[p],r.r,r.g,r.b]))}))}));const n=l?C(s,l):s,o=new t;return o.functionName="Colormap",o.functionArguments={},o.functionArguments.Colormap=n,o.variableName="Raster",r.convertToRFT?new t({rasterFunctionDefinition:y(o)}):o}e.classBreakInfos.forEach(((e,n)=>{if(null==e.minValue||null==e.maxValue)return;const t=e.symbol&&e.symbol.color;t?.a?(0===n?o.push(e.minValue,e.maxValue+u):o.push(e.minValue+u,e.maxValue+u),a.push(n),s.push([n,t.r,t.g,t.b])):i.push(e.minValue,e.maxValue)}));const f=l?C(s,l):s,g=new t;g.functionName="Remap",g.functionArguments={InputRanges:o,OutputValues:a,NoDataRanges:i},g.variableName="Raster";const d=new t;return d.functionName="Colormap",d.functionArguments={Colormap:f,Raster:g},r.convertToRFT?new t({rasterFunctionDefinition:y(d)}):d}function C(e,n){const t=m.has(n)?o(n):null;return t&&e.push([Math.floor(t[0]-1),0,0,0],[Math.ceil(t[1]+1),0,0,0]),e}function F(e){if(n(e))return;const{fields:t}=e,r=t&&t.find((e=>e&&e.name&&"value"===e.name.toLowerCase()));return r&&r.name}function A(e,r){const o=[],{pixelType:a,rasterAttributeTable:i}=r,s=n(i)?null:i.features,u=F(i),l=e.defaultSymbol?.color?.toRgb(),c=e.uniqueValueInfos;if(c)if(s){if(u){const n=new Map;c.forEach((e=>{const t=e.value,r=e.symbol?.color;null!=t&&r&&r.a&&n.set(String(t),r.toRgb())}));const t=e.field;s.forEach((({attributes:e})=>{const r=String(e[t]),a=e[u],i=n.get(r);i?o.push([a,...i]):l&&o.push([a,...l])}))}}else for(let n=0;n<c.length;n++){const e=c[n],t=e.symbol?.color,r=+e.value;if(t?.a){if(isNaN(r))return null;o.push([r,t.r,t.g,t.b])}}const m=a&&o.length>0?C(o,a):o,p=new t;return p.functionName="Colormap",p.functionArguments={},p.functionArguments.Colormap=m,p.variableName="Raster",r.convertToRFT?new t({rasterFunctionDefinition:y(p)}):p}function N(e,n){const r=e.extractColormap();if(!r||0===r.length)return null;const{pixelType:o}=n,a=o?C(r,o):r,i=new t;return i.functionName="Colormap",i.functionArguments={},i.functionArguments.Colormap=a,n.convertToRFT?new t({rasterFunctionDefinition:y(i)}):i}function V(e){const n=[];return e?.forEach((e=>{const t=e;if(Array.isArray(t))n.push(t);else{if(null==t.min||null==t.max)return;const e=[t.min,t.max,t.avg||0,t.stddev||0];n.push(e)}})),n}function D(e){const n=[],t=[];return e.forEach((e=>{n.push(e[0]),t.push(u([...e.slice(1),255]))})),{type:"RasterColormap",values:n,colors:t}}export{d as combineRenderingRules,b as convertRendererToRenderingRule,y as convertRenderingRuleToRFT,g as isSupportedRendererType};

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.26/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e}from"../../rasterRenderers.js";import r from"../../request.js";import i from"../../core/Error.js";import s from"../../core/Logger.js";import{isNone as n,isSome as o}from"../../core/maybe.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import{subclass as l}from"../../core/accessorSupport/decorators/subclass.js";import{getInfo as u}from"../../geometry/support/spatialReferenceUtils.js";import{sanitizeUrl as m}from"../support/arcgisLayerUrl.js";import{url as d}from"../support/commonProperties.js";import c from"../support/DimensionalDefinition.js";import h from"../support/MultidimensionalSubset.js";import f from"../support/RasterFunction.js";import p from"../support/RasterJobHandler.js";import y from"../support/TileInfo.js";import b from"../support/rasterDatasets/FunctionRaster.js";import{getDefaultMultidimensionalDefinition as g,hasExcludedVariableOrDimension as J,getDefaultVariablInfo as _,isMultiSliceOrRangeDefinition as F,getSubsetVariablesFromMdInfo as I}from"../support/rasterDatasets/multidimensionalUtils.js";import{create as R}from"../support/rasterFunctions/rasterFunctionHelper.js";import{convertVectorFieldData as S}from"../support/rasterFunctions/vectorFieldUtils.js";import{normalizeRendererJSON as v,getVariableRasterInfo as x,getDefaultInterpolation as D,getDefaultBandCombination as j,createDefaultRenderer as H}from"../../renderers/support/rasterRendererHelper.js";import T from"../../renderers/support/RasterSymbolizer.js";import{createFlowMesh as w}from"../../views/2d/engine/flow/dataUtils.js";import N from"../../geometry/SpatialReference.js";const O=s.getLogger("esri.layers.mixins.ImageryTileMixin"),z=s=>{let z=class extends s{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===t[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}get tileInfo(){return this.rasterInfo?.storageInfo.tileInfo}set url(t){this._set("url",m(t,O))}set renderer(t){this._set("renderer",t),this.updateRenderer()}async convertVectorFieldData(t,e){if(n(t)||!this.rasterInfo)return null;const r=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:t,dataType:i},e):S(t,i)}async createFlowMesh(t,e){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(t,e):w(t.meshType,t.simulationSettings,t.flowData,o(e.signal)?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.rasterInfo??{};if(n(e))return t;let r=t.multidimensionalDefinition||this.multidimensionalDefinition;!n(r)&&r.length||(r=g(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const i=t.timeExtent||this.timeExtent;if(o(r)&&o(i)&&(o(i.start)||o(i.end))){r=r.map((t=>t.clone()));const s=e.variables.find((({name:t})=>t===r[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),a=r.find((({dimensionName:t})=>"StdTime"===t));if(!s||!a)return{...t,multidimensionalDefinition:null};const{start:l,end:u}=i,m=n(l)?null:l.getTime(),d=n(u)?null:u.getTime(),c=m??d,h=d??m;if(o(s.values)){const t=s.values.filter((t=>{if(Array.isArray(t)){if(c===h)return t[0]<=c&&t[1]>=c;const e=t[0]<=c&&t[1]>c||t[0]<h&&t[1]>=h,r=t[0]>=c&&t[1]<=h||t[0]<c&&t[1]>h;return e||r}return c===h?t===c:t>=c&&t<=h}));if(t.length){const e=t.sort(((t,e)=>{if(c===h)return(t[0]??t)-(e[0]??e);return Math.abs((t[1]??t)-h)-Math.abs((e[1]??e)-h)}))[0];a.values=[e]}else r=null}else if(s.hasRegularIntervals&&s.extent){const[t,e]=s.extent;c>e||h<t?r=null:a.values=c===h?[c]:[Math.max(t,c),Math.min(e,h)]}}return o(r)&&J(r,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:r}}async updateRasterFunction(){if("imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const t=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&t&&this._set("rasterFunction",f.fromJSON(t)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let t,e=this.raster,r=!1;"Function"===e.datasetFormat?(t=e.primaryRasters.rasters,e=t[0],r=!0):t=[e];const{rasterFunction:i}=this;if(i){const r={raster:e};t.length>1&&t.forEach((t=>r[t.url]=t));const s=R(i.rasterFunctionDefinition??i.toJSON(),r),n=new b({rasterFunction:s});n.rasterJobHandler=this._rasterJobHandler.instance,await n.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=n}else this.raster=e,this._cachedRasterFunctionJson=null;if(this._cachedRendererJson=null,!r&&!i)return;const{bandIds:s}=this,{bandCount:n}=this.raster.rasterInfo,o=s?.length?s.some((t=>t>=n)):n>=3;s&&(o||"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e)return;const{rasterInfo:r}=this.raster,i=_(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset})?.name,s=v({...this.renderer.toJSON(),variableName:i});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;const n=this._rasterJobHandler.instance;n&&(e.rasterInfo=x(r,i),e.rendererJSON=s,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=s)}async applyRenderer(t,e){const r=t&&t.pixelBlock;if(!(o(r)&&r.pixels&&r.pixels.length>0))return null;let i;await this.updateRenderer();const s=this._rasterJobHandler.instance,n=this.bandIds??[];return i=s?await s.symbolize({...t,simpleStretchParams:e,bandIds:n}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:n}),i}getTileUrl(t,e,r){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${r}`:""}getCompatibleTileInfo(t,e,r=!1){if(!this.loaded||n(e))return null;if(r&&t.equals(this.spatialReference))return this.tileInfo;const i=u(t);return y.create({size:256,spatialReference:t,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,i,s={}){if(C(this),s.requestAsImageElement){const n=this.getTileUrl(t,e,i);return r(n,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then((t=>t.data))}const{rasterInfo:a}=this;if(o(a.multidimensionalInfo)&&(s=this.normalizeRasterFetchOptions(s),n(s.multidimensionalDefinition))){const r=s.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,i,r),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,i,s)}async fetchPixels(t,e,r,i={}){return o(this.rasterInfo.multidimensionalInfo)&&(i=this.normalizeRasterFetchOptions(i),n(i.multidimensionalDefinition))?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),this.raster.fetchPixels(t,e,r,i))}async identify(t,e={}){const{raster:r,rasterInfo:s}=this;if(o(s.multidimensionalInfo)){if(!(s.hasMultidimensionalTranspose&&!!(F(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent))&&(e=this.normalizeRasterFetchOptions(e),n(e.multidimensionalDefinition)))return{location:t,value:null}}const a=this.multidimensionalSubset?.areaOfInterest;if(a&&!a.contains(t))throw new i("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return r.identify(t,e)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.rasterInfo?.multidimensionalInfo;if(n(t)||"standard-time"!==this.rasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,r=e?.[0]?.variableName;return t.variables.some((t=>t.name===r&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.rasterInfo?.multidimensionalInfo;return I(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=g(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new p;return this._rasterJobHandler.connectionPromise=t.initialize().then((()=>{C(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,this.renderer&&this.updateRenderer(),"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){C(this);const{raster:t}=this,e=D(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){C(this);const{rasterInfo:e}=this.raster;!this.bandIds&&e.bandCount>1&&(this.bandIds=j(e));const r=_(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset})?.name;if(!this.renderer||"override"===t){const t=H(e,{bandIds:this.bandIds,variableName:r});"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&((e.statistics?.[0].max??0)>1e24||(e.statistics?.[0].min??0)<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}const i=v({...this.renderer.toJSON(),variableName:r}),s=x(e,r);this.symbolizer?(this.symbolizer.rendererJSON=i,this.symbolizer.rasterInfo=s):this.symbolizer=new T({rendererJSON:i,rasterInfo:s});const n=this.symbolizer.bind();if(n.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(o(t))if("raster-colormap"!==e.type)this._configDefaultRenderer("override");else{const t=H(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,r=e.statistics?.length;!e.dynamicRangeAdjustment&&r&&t&&r!==t&&this._configDefaultRenderer("override")}}}else O.warn("imagery-tile-mixin",n.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}};function C(t){if(!t.raster||!t.rasterInfo)throw new i("imagery-tile","no raster")}return t([a()],z.prototype,"_cachedRendererJson",void 0),t([a()],z.prototype,"_cachedRasterFunctionJson",void 0),t([a()],z.prototype,"_compatibleFullExtent",void 0),t([a()],z.prototype,"_isConstructedFromFunctionRaster",void 0),t([a()],z.prototype,"_rasterJobHandler",void 0),t([a()],z.prototype,"bandIds",void 0),t([a({json:{origins:{service:{read:{source:"copyrightText"}}}}})],z.prototype,"copyright",void 0),t([a({json:{read:!1}})],z.prototype,"fullExtent",null),t([a()],z.prototype,"interpolation",void 0),t([a()],z.prototype,"ioConfig",void 0),t([a({type:[c],json:{write:!0}})],z.prototype,"multidimensionalDefinition",null),t([a({type:h,json:{write:!0}})],z.prototype,"multidimensionalSubset",void 0),t([a()],z.prototype,"raster",void 0),t([a({type:f})],z.prototype,"rasterFunction",void 0),t([a()],z.prototype,"rasterInfo",void 0),t([a()],z.prototype,"sourceJSON",void 0),t([a({readOnly:!0,type:N,json:{read:!1}})],z.prototype,"spatialReference",void 0),t([a({json:{read:!1}})],z.prototype,"tileInfo",null),t([a(d)],z.prototype,"url",null),t([a({types:e})],z.prototype,"renderer",null),t([a()],z.prototype,"symbolizer",void 0),z=t([l("esri.layers.ImageryTileMixin")],z),z};export{z as ImageryTileMixin};

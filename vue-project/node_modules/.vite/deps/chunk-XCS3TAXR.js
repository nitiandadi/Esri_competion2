import {
  i as i5,
  m
} from "./chunk-LUJI6E4N.js";
import {
  $,
  f as f6,
  g as g3,
  h,
  p as p2,
  u as u4,
  w as w2,
  x as x3,
  y as y3
} from "./chunk-WSPTGWUV.js";
import {
  E as E2,
  e as e3,
  n2 as n,
  o as o2,
  x as x2
} from "./chunk-RPPTWDPP.js";
import {
  i as i3
} from "./chunk-ECBW37F4.js";
import {
  V,
  Z,
  i as i2,
  oe
} from "./chunk-BTELXCWJ.js";
import {
  M,
  c as c3,
  r as r3
} from "./chunk-ZKGXZZBF.js";
import {
  F as F2,
  H as H2,
  P,
  R as R2,
  Y,
  j as j2,
  te,
  x
} from "./chunk-EMUQ7G7L.js";
import {
  b
} from "./chunk-E7Q7UFBO.js";
import {
  o
} from "./chunk-UNKGAJFQ.js";
import {
  U as U4
} from "./chunk-DJZ2IN55.js";
import {
  S
} from "./chunk-372CNO3V.js";
import {
  p
} from "./chunk-LIDKQETZ.js";
import {
  E as E3,
  f as f5
} from "./chunk-SX7NW3RK.js";
import {
  U as U3
} from "./chunk-QCYWXXBM.js";
import {
  F
} from "./chunk-DNXRTHCH.js";
import {
  f as f4,
  g as g2
} from "./chunk-FFQ74L2K.js";
import {
  O,
  U
} from "./chunk-4S6QYDLW.js";
import {
  i as i4
} from "./chunk-SXVHYYSN.js";
import {
  l as l4
} from "./chunk-3FNYVRHQ.js";
import {
  U as U2
} from "./chunk-3F26JL34.js";
import {
  C,
  H,
  gt,
  mt,
  rt
} from "./chunk-UZM66DAH.js";
import {
  t as t2
} from "./chunk-MI7FJDLG.js";
import {
  N,
  O as O2,
  j as j3
} from "./chunk-ARRABRN2.js";
import {
  a as a2
} from "./chunk-F6Y6UABE.js";
import {
  l as l3
} from "./chunk-QP5ZWBKN.js";
import {
  E,
  e as e2,
  l as l2,
  q,
  s as s2,
  u as u2
} from "./chunk-33RBBVRO.js";
import {
  s as s3
} from "./chunk-OTDDRQS2.js";
import {
  c as c2,
  f as f3,
  l,
  s,
  u,
  y as y2
} from "./chunk-M7CMZTD6.js";
import {
  c,
  g,
  r as r2
} from "./chunk-ERJGVLTB.js";
import {
  R,
  f2
} from "./chunk-T5VSOT6T.js";
import {
  u as u3
} from "./chunk-F4DUNBGT.js";
import {
  a2 as a,
  e,
  v2 as v,
  y3 as y
} from "./chunk-OA5ES74L.js";
import {
  f,
  j,
  w
} from "./chunk-6ZUWLK7F.js";
import {
  has
} from "./chunk-H32MMKAJ.js";
import {
  i,
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js
var t3 = -1;
var e4 = class {
  constructor() {
    this._dirties = [{ vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }, { vertexFrom: t3, vertexCount: t3, indexFrom: t3, indexCount: t3, allDirty: false }];
  }
  hasDirty() {
    return this._dirties.some((e10) => e10.indexCount !== t3 || e10.allDirty);
  }
  markAllClean() {
    for (const e10 of this._dirties)
      e10.indexFrom = t3, e10.indexCount = t3, e10.vertexFrom = t3, e10.vertexCount = t3, e10.allDirty = false;
  }
  markAllDirty() {
    for (const t9 of this._dirties)
      t9.allDirty = true;
  }
  forEach(e10) {
    for (let r7 = 0; r7 < this._dirties.length; ++r7) {
      const { indexCount: i7, indexFrom: o7, vertexCount: n5, vertexFrom: x5, allDirty: l6 } = this._dirties[r7], s7 = {};
      let d4, m2 = false;
      (l6 || x5 !== t3 && n5 > 0) && (s7.geometry = { count: n5, from: x5, allDirty: l6 }, m2 = true), (l6 || o7 !== t3 && i7 > 0) && (d4 = { count: i7, from: o7, allDirty: l6 }, m2 = true), m2 && e10({ indices: d4, vertices: s7 }, r7);
    }
  }
  markDirtyIndices(e10, r7, i7) {
    const o7 = this._dirties[e10], n5 = r7, x5 = i7;
    if (!o7.allDirty)
      if (o7.indexCount !== t3) {
        const t9 = Math.min(o7.indexFrom, n5), e11 = Math.max(o7.indexFrom + o7.indexCount, n5 + x5) - t9;
        o7.indexFrom = t9, o7.indexCount = e11;
      } else
        o7.indexFrom = n5, o7.indexCount = x5;
  }
  markDirtyVertices(e10, r7, i7, o7) {
    const n5 = this._dirties[e10], x5 = i7, l6 = o7;
    if (!n5.allDirty)
      if (n5.vertexCount !== t3) {
        const t9 = Math.min(n5.vertexFrom, x5), e11 = Math.max(n5.vertexFrom + n5.vertexCount, x5 + l6) - t9;
        n5.vertexFrom = t9, n5.vertexCount = e11;
      } else
        n5.vertexFrom = x5, n5.vertexCount = l6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js
var e5 = class {
  get largestRange() {
    return this._largestRange;
  }
  constructor(e10) {
    this._largestRange = null, this._parent = e10, this._updateLargestRange();
  }
  rangeCreated(e10) {
    (!this._largestRange || e10.count > this._largestRange.count) && (this._largestRange = e10);
  }
  rangeResized(e10, t9) {
    e10 === this._largestRange ? e10.count < t9 && this._updateLargestRange() : (!this._largestRange || e10.count > this._largestRange.count) && (this._largestRange = e10);
  }
  findBestRange(e10) {
    let t9 = this._parent._freeHead, n5 = null;
    for (; null !== t9; )
      t9.count >= e10 && (!n5 || t9.count - e10 < n5.count - e10) && (n5 = t9), t9 = t9.next;
    return n5;
  }
  findAdjacentRanges(e10, t9) {
    let n5 = true, r7 = false, s7 = null, o7 = this._parent._freeHead;
    for (; n5 && !r7; ) {
      const a4 = null !== s7 ? s7.from + s7.count : 0, l6 = null !== o7 ? o7.from : this._parent._size;
      e10 >= a4 && e10 + t9 <= l6 ? (n5 = false, r7 = true) : null !== o7 ? (s7 = o7, o7 = o7.next) : n5 = false;
    }
    return [s7, o7];
  }
  _updateLargestRange() {
    let e10 = null, t9 = this._parent._freeHead;
    for (; null !== t9; )
      (!e10 || t9.count > e10.count) && (e10 = t9), t9 = t9.next;
    this._largestRange = e10;
  }
};
var t4 = class {
  constructor(t9, n5) {
    this._allocated = 0, this._size = t9, this._freeHead = t9 > 0 ? { from: 0, count: t9, prev: null, next: null } : null, this._bookKeeper = n5 || new e5(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e10) {
    const n5 = this._bookKeeper.findBestRange(e10);
    if (null == n5)
      return -1;
    const r7 = n5.from, s7 = n5.count;
    if (n5.from += e10, n5.count -= e10, this._bookKeeper.rangeResized(n5, r7, s7), this._allocated += e10, 0 === n5.count) {
      const e11 = null !== n5.prev ? this._freeHead : n5.next;
      t4._removeRange(n5), this._freeHead = e11;
    }
    return r7;
  }
  free(e10, n5) {
    const [r7, s7] = this._bookKeeper.findAdjacentRanges(e10, n5), o7 = { from: e10, count: n5, prev: r7 ?? null, next: s7 ?? null };
    if (null != r7 && (r7.next = o7), null != s7 && (s7.prev = o7), this._bookKeeper.rangeCreated(o7), this._allocated -= n5, null != s7 && o7.from + o7.count === s7.from) {
      const e11 = o7.from, n6 = o7.count;
      t4._fuse(o7, s7), t4._removeRange(s7), this._bookKeeper.rangeResized(o7, e11, n6), this._bookKeeper.rangeResized(s7, void 0, 0);
    }
    if (null != r7 && r7.from + r7.count === o7.from) {
      const e11 = r7.from, n6 = r7.count;
      t4._fuse(r7, o7), t4._removeRange(o7), this._bookKeeper.rangeResized(r7, e11, n6), this._bookKeeper.rangeResized(o7, void 0, 0);
    }
    this._freeHead = null !== o7.prev ? this._freeHead : o7;
  }
  get fragmentation() {
    const e10 = this._size - this._allocated;
    if (0 === e10)
      return 0;
    return 1 - this._bookKeeper.largestRange.count / e10;
  }
  static _removeRange(e10) {
    null !== e10.prev ? null !== e10.next ? (e10.prev.next = e10.next, e10.next.prev = e10.prev) : e10.prev.next = null : null !== e10.next && (e10.next.prev = null);
  }
  static _fuse(e10, t9) {
    e10.count += t9.count, e10.next = t9.next, t9.from += t9.count, t9.count = 0, null !== t9.next && (t9.next.prev = e10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js
var s4 = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o3(e10) {
  const t9 = e10.getStrides(), r7 = {};
  for (let i7 = 0; i7 < t9.length; i7++)
    r7[s4[i7]] = t9[i7];
  return r7;
}
var n2 = 0.5;
var d = class {
  constructor(r7, i7, s7, o7) {
    this._strides = r7, this._displayList = i7, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s7;
    for (const n5 in r7) {
      this._freeListsAndStorage[n5] = { vtxFreeList: o7 ? new t4(o7) : null, idxFreeList: o7 ? new t4(o7) : null, vertexBuffers: {}, indexBuffer: o7 ? new Uint32Array(o7) : null };
      for (const e10 in r7[n5])
        this._freeListsAndStorage[n5].vertexBuffers[e10] = { data: o7 ? x(o7, r7[n5][e10]) : null, stride: r7[n5][e10] };
    }
  }
  static fromTileData(t9, i7) {
    var _a;
    const n5 = o3(t9), a4 = [0, 0, 0, 0, 0], x5 = [0, 0, 0, 0, 0];
    for (const e10 of t9.tileDisplayData.displayObjects)
      for (const t10 of e10.displayRecords)
        a4[t10.geometryType] = Math.max(a4[t10.geometryType], t10.vertexFrom + t10.vertexCount), x5[t10.geometryType] = Math.max(x5[t10.geometryType], t10.indexFrom + t10.indexCount);
    const u5 = new d(n5, t9.tileDisplayData.displayList, i7, void 0), f11 = ((_a = t9.tileBufferData) == null ? void 0 : _a.geometries) ?? [];
    for (let o7 = 0; o7 < f11.length; ++o7) {
      const t10 = a4[o7], i8 = x5[o7], n6 = f11[o7], d4 = s4[o7], l6 = u5._storageFor(d4), c4 = f11[o7].indexBuffer;
      l6.indexBuffer = c4, l6.idxFreeList = new t4(c4.length), l6.idxFreeList.allocate(i8);
      let m2 = 0;
      for (const e10 in n6.vertexBuffer) {
        const t11 = f11[o7].vertexBuffer[e10];
        l6.vertexBuffers[e10].data = t11.data, l6.vertexBuffers[e10].stride = t11.stride;
        const i9 = F2(t11.stride), s7 = t11.data.length * i9 / t11.stride;
        m2 || (m2 = s7);
      }
      l6.vtxFreeList = new t4(m2), l6.vtxFreeList.allocate(t10);
    }
    return u5;
  }
  delete(e10) {
    const t9 = s4[e10.geometryType];
    this._freeVertices(t9, e10.vertexFrom, e10.vertexCount), this._freeIndices(t9, e10.indexFrom, e10.indexCount), this._displayList.removeFromList(e10), e10.vertexFrom = void 0, e10.indexFrom = void 0;
  }
  setMeshData(e10, t9, r7, o7, n5) {
    const d4 = s4[e10.geometryType];
    let a4, x5;
    e10.meshData = null, void 0 === e10.vertexFrom ? (x5 = t9.vertexCount, a4 = this._allocateVertices(d4, x5)) : t9.vertexCount > e10.vertexCount ? (this._freeVertices(d4, e10.vertexFrom, e10.vertexCount), x5 = t9.vertexCount, a4 = this._allocateVertices(d4, x5)) : t9.vertexCount === e10.vertexCount ? (a4 = e10.vertexFrom, x5 = e10.vertexCount) : (this._freeVertices(d4, e10.vertexFrom + t9.vertexCount, e10.vertexCount - t9.vertexCount), a4 = e10.vertexFrom, x5 = t9.vertexCount);
    let u5, f11, l6, c4 = true;
    if (void 0 === e10.indexFrom ? (u5 = n5, l6 = t9.indexCount, f11 = this._allocateIndices(d4, l6)) : t9.indexCount > e10.indexCount ? (u5 = this._displayList.removeFromList(e10), this._freeIndices(d4, e10.indexFrom, e10.indexCount), l6 = t9.indexCount, f11 = this._allocateIndices(d4, l6)) : t9.indexCount === e10.indexCount ? (c4 = false, f11 = e10.indexFrom, l6 = e10.indexCount) : (u5 = this._displayList.removeFromList(e10), this._freeIndices(d4, e10.indexFrom + t9.indexCount, e10.indexCount - t9.indexCount), f11 = e10.indexFrom, l6 = t9.indexCount), -1 !== a4 && -1 !== f11) {
      const s7 = this._storageFor(d4);
      if (j2(a4, f11, s7.vertexBuffers, s7.indexBuffer, t9, r7, o7), e10.vertexFrom = a4, e10.indexFrom = f11, e10.vertexCount = t9.vertexCount, e10.indexCount = t9.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e10.geometryType, e10.indexFrom, e10.indexCount);
        for (const t10 in r7)
          this._dirtyMap.markDirtyVertices(e10.geometryType, t10, e10.vertexFrom, e10.vertexCount);
      }
      return c4 && this._displayList.addToList(e10, u5), true;
    }
    return -1 !== a4 && this._freeVertices(d4, a4, x5), -1 !== f11 && this._freeIndices(d4, f11, l6), e10.setMeshDataFromBuffers(t9, r7, o7), e10.vertexFrom = void 0, e10.vertexCount = 0, e10.indexFrom = void 0, e10.indexCount = 0, false;
  }
  tryAddMeshData(e10, t9) {
    const r7 = t9.vertexBuffer, o7 = t9.indexBuffer, n5 = s4[e10.geometryType], d4 = this._allocateVertices(n5, e10.vertexCount);
    if (-1 === d4)
      return this._freeVertices(n5, d4, e10.vertexCount), false;
    const a4 = this._allocateIndices(n5, e10.indexCount);
    if (-1 === a4)
      return this._freeVertices(n5, d4, e10.vertexCount), this._freeIndices(n5, a4, e10.indexCount), false;
    const x5 = this._storageFor(n5);
    if (j2(d4, a4, x5.vertexBuffers, x5.indexBuffer, e10, r7, o7), e10.vertexFrom = d4, e10.indexFrom = a4, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e10.geometryType, e10.indexFrom, e10.indexCount);
      for (const t10 in r7)
        this._dirtyMap.markDirtyVertices(e10.geometryType, t10, d4, e10.vertexCount);
    }
    return this._displayList.addToList(e10), true;
  }
  _allocateVertices(e10, t9) {
    var _a, _b;
    const r7 = this._storageFor(e10), i7 = (_a = r7.vtxFreeList) == null ? void 0 : _a.allocate(t9);
    if (null == i7 || -1 === i7)
      return -1;
    const s7 = (_b = r7.vtxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s7 || s7 > n2 ? -1 : i7;
  }
  _freeVertices(e10, t9, r7) {
    var _a;
    (_a = this._storageFor(e10).vtxFreeList) == null ? void 0 : _a.free(t9, r7);
  }
  _freeIndices(e10, t9, r7) {
    var _a;
    (_a = this._storageFor(e10).idxFreeList) == null ? void 0 : _a.free(t9, r7);
  }
  _allocateIndices(e10, t9) {
    var _a, _b;
    const r7 = this._storageFor(e10), i7 = (_a = r7.idxFreeList) == null ? void 0 : _a.allocate(t9);
    if (null == i7 || -1 === i7)
      return -1;
    const s7 = (_b = r7.idxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s7 || s7 > n2 ? -1 : i7;
  }
  _storageFor(e10) {
    return this._freeListsAndStorage[e10];
  }
  _stridesFor(e10, t9) {
    return this._strides[e10][t9];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js
var f7 = class {
  constructor(a4) {
    this.geometryMap = H2(() => ({ indexBuffer: E3.createIndex(a4, F.STATIC_DRAW), vao: null }), (e10, s7) => ({ vertexBuffer: E3.createVertex(a4, Y[s7]) }));
  }
  dispose() {
    for (let e10 = 0; e10 < 5; e10++) {
      const t9 = this.geometryMap[e10];
      if (t9) {
        t9.data.vao && t9.data.vao.dispose(false), t9.data.indexBuffer && t9.data.indexBuffer.dispose();
        for (const e11 in t9.buffers)
          t9.buffers[e11] && t9.buffers[e11].data.vertexBuffer.dispose();
      }
    }
  }
  get(e10) {
    const t9 = this.geometryMap[e10];
    return { getVAO(e11, r7, s7) {
      if (!t9.data.vao) {
        const f11 = {};
        for (const e12 in t9.buffers)
          f11[e12] = t9.buffers[e12].data.vertexBuffer;
        t9.data.vao = new f5(e11, s7, r7, f11, t9.data.indexBuffer);
      }
      return t9.data.vao;
    } };
  }
  has(e10) {
    return null != this.geometryMap[e10];
  }
  upload(e10, t9) {
    t9.forEach((t10, r7) => {
      this._upload(t10, r7, e10);
    });
  }
  _upload(e10, t9, r7) {
    if (e10.indices && (e10.indices.allDirty ? this._uploadIndices(r7, t9) : null != e10.indices.from && null != e10.indices.count && this._uploadIndices(r7, t9, e10.indices.from, e10.indices.count)), e10.vertices) {
      const s7 = e10.vertices;
      for (const e11 in s7) {
        const a4 = s7[e11];
        a4.allDirty ? this._uploadVertices(r7, t9, e11) : null != a4.from && null != a4.count && this._uploadVertices(r7, t9, e11, a4.from, a4.count);
      }
    }
  }
  _uploadVertices(e10, t9, r7, s7, a4) {
    const f11 = this.geometryMap[t9];
    if (!f11)
      return;
    const o7 = e10.geometries[t9].vertexBuffer[r7];
    if (!o7)
      return;
    const { data: i7, stride: n5 } = o7;
    if (f11.buffers[r7] && i7.length > 0) {
      const e11 = n5 / i7.BYTES_PER_ELEMENT;
      null != s7 && null != a4 ? f11.buffers[r7].data.vertexBuffer.setSubData(i7, s7 * e11, s7 * e11, (s7 + a4) * e11) : f11.buffers[r7].data.vertexBuffer.setData(i7);
    }
  }
  _uploadIndices(e10, t9, r7, s7) {
    const a4 = this.geometryMap[t9];
    if (!a4)
      return;
    const f11 = e10.geometries[t9].indexBuffer;
    a4.data.indexBuffer && f11.length > 0 && (null != r7 && null != s7 ? a4.data.indexBuffer.setSubData(f11, r7, r7, r7 + s7) : a4.data.indexBuffer.setData(f11));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js
var a3 = class extends m {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = false, this._invalidated = false, this._wglBuffers = null, this._dirtyMap = new e4();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    return this._displayObjects ?? [];
  }
  getGeometry(t9) {
    return this._wglBuffers && this._wglBuffers.has(t9) ? this._wglBuffers.get(t9) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(s7) {
    var _a2, _b;
    if (true === s7.clear)
      return this.clear(), void (this._hasData = false);
    const i7 = s7.addOrUpdate, a4 = s7.remove;
    !this._data && i7 && ((_a2 = i7.tileDisplayData) == null ? void 0 : _a2.displayObjects.length) ? (i7.tileDisplayData.computeDisplayList(), this._dirtyMap = new e4(), this._dispRecStore = d.fromTileData(i7, this._dirtyMap), this._data = i7, this._dirtyMap.markAllDirty(), this._hasData = true, s7.end && this.ready()) : this._data && (i7 && ((_b = i7.tileDisplayData) == null ? void 0 : _b.displayObjects.length) || a4.length) ? this._doPatchData(s7) : s7.end && this.ready(), s7.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t9) {
    t9.time && t9.time === this._lastCommitTime || (this._lastCommitTime = t9.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new f7(t9.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = false, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t9) {
    this._invalidated = true, this._patchData(t9) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = d.fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t9) {
    let e10 = true;
    const s7 = t9.addOrUpdate && t9.addOrUpdate.tileDisplayData && t9.addOrUpdate.tileDisplayData.displayObjects || [], i7 = (t9.remove || []).slice();
    for (const r7 of s7)
      null != r7.insertAfter && i7.push(r7.id);
    let a4;
    i7.length > 0 && (a4 = new Set(i7));
    const l6 = this._data.tileDisplayData;
    for (const r7 of i7) {
      const t10 = l6.displayObjectRegistry.get(r7);
      if (t10) {
        l6.displayList.removeFromList(t10.displayRecords);
        for (const e11 of t10.displayRecords)
          this._dispRecStore.delete(e11);
        l6.displayObjectRegistry.delete(r7);
      }
    }
    (a4 == null ? void 0 : a4.size) && (l6.displayObjects = l6.displayObjects.filter((t10) => !a4.has(t10.id)));
    for (const r7 of s7) {
      let s8, i8 = l6.displayObjectRegistry.get(r7.id);
      if (i8) {
        const t10 = i8.displayRecords;
        i8.set(r7), i8.displayRecords = t10;
        const e11 = i8.displayRecords.length;
        for (let s9 = 0; s9 < e11; ++s9) {
          const t11 = i8.displayRecords[s9], e12 = r7.displayRecords[s9];
          (s9 >= r7.displayRecords.length || t11.geometryType !== e12.geometryType || t11.symbolLevel !== e12.symbolLevel || t11.zOrder !== e12.zOrder || t11.materialKey !== e12.materialKey) && (this._dispRecStore.delete(i8.displayRecords[s9]), s9 < r7.displayRecords.length && (i8.displayRecords[s9] = void 0));
        }
        i8.displayRecords.length = r7.displayRecords.length;
      } else {
        let t10;
        i8 = r7.copy(), i8.displayRecords = [], l6.displayObjectRegistry.set(r7.id, i8);
        const e11 = l6.displayObjects;
        if (null != i8.insertAfter)
          if (s8 = {}, i8.insertAfter >= 0) {
            const s9 = l6.displayObjectRegistry.get(i8.insertAfter);
            s9 ? (t10 = e11.indexOf(s9) + 1, t10 < e11.length ? e11.splice(t10, 0, i8) : (e11.push(i8), t10 = e11.length)) : (e11.push(i8), t10 = e11.length);
          } else
            e11.unshift(i8), t10 = 0;
        else
          e11.push(i8), t10 = e11.length;
        if (s8) {
          const i9 = r7.displayRecords.length > 0 ? 1 : 0;
          let a6 = 0;
          for (let r8 = t10 - 1; r8 >= 0 && a6 < i9; --r8)
            for (let t11 = e11[r8].displayRecords.length - 1; t11 >= 0 && a6 < i9; --t11) {
              const i10 = e11[r8].displayRecords[t11], d4 = l6.displayList.getDPInfoType();
              s8[d4] || (s8[d4] = i10, ++a6);
            }
        }
      }
      const a5 = r7.displayRecords.length;
      for (let d4 = 0; d4 < a5; ++d4) {
        const a6 = r7.displayRecords[d4];
        let o7 = i8.displayRecords[d4];
        o7 ? (o7.meshData = a6.meshData, o7.materialKey = a6.materialKey) : (o7 = a6.copy(), o7.vertexFrom = void 0, o7.indexFrom = void 0, i8.displayRecords[d4] = o7);
        const h3 = a6.geometryType, p4 = l6.displayList.getDPInfoType(), y7 = t9.addOrUpdate.tileBufferData.geometries[h3], c4 = y7.vertexBuffer, n5 = y7.indexBuffer;
        let f11;
        s8 && (f11 = s8[p4] ? l6.displayList.splitAfter(s8[p4]) : -1), e10 = this._dispRecStore.setMeshData(o7, a6, c4, n5, f11) && e10, s8 && null != o7.indexFrom && null != o7.indexFrom && (s8[p4] = o7);
      }
    }
    return e10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js
var e6 = class {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e10) {
    return this._byGeometryType ? this._byGeometryType[e10].vertices : 0;
  }
  indicesFor(e10) {
    return this._byGeometryType ? this._byGeometryType[e10].indices : 0;
  }
  needMore(e10, t9, i7) {
    if (!t9 && !i7)
      return;
    this._byGeometryType || (this._byGeometryType = [{ vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }]);
    const s7 = this._byGeometryType[e10];
    s7.vertices += t9, s7.indices += i7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js
var r4 = 5;
var f8 = class {
  constructor() {
    this.geometries = [{ indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }];
  }
  clone() {
    const e10 = new f8();
    for (let r7 = 0; r7 < this.geometries.length; r7++) {
      const f11 = this.geometries[r7], t9 = e10.geometries[r7];
      t9.indexBuffer = f11.indexBuffer.slice(), t9.vertexBuffer = {};
      for (const e11 in f11.vertexBuffer) {
        const { data: r8, stride: i7 } = f11.vertexBuffer[e11];
        t9.vertexBuffer[e11] = { data: r8.slice(), stride: i7 };
      }
    }
    return e10;
  }
  static deserialize(t9) {
    const i7 = new f8();
    for (let f11 = 0; f11 < r4; ++f11) {
      i7.geometries[f11].indexBuffer = new Uint32Array(t9.geometries[f11].indexBuffer), i7.geometries[f11].vertexBuffer = {};
      for (const r7 in t9.geometries[f11].vertexBuffer)
        i7.geometries[f11].vertexBuffer[r7] = { data: P(t9.geometries[f11].vertexBuffer[r7].data, t9.geometries[f11].vertexBuffer[r7].stride), stride: t9.geometries[f11].vertexBuffer[r7].stride };
    }
    return i7;
  }
  serialize() {
    const e10 = { geometries: [{ indexBuffer: this.geometries[0].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[1].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[2].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[3].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[4].indexBuffer.buffer, vertexBuffer: {} }] };
    for (let f11 = 0; f11 < r4; ++f11)
      for (const r7 in this.geometries[f11].vertexBuffer)
        e10.geometries[f11].vertexBuffer[r7] = { data: this.geometries[f11].vertexBuffer[r7].data.buffer, stride: this.geometries[f11].vertexBuffer[r7].stride };
    return e10;
  }
  getBuffers() {
    const e10 = [];
    for (let f11 = 0; f11 < r4; ++f11) {
      e10.push(this.geometries[f11].indexBuffer.buffer);
      for (const r7 in this.geometries[f11].vertexBuffer)
        e10.push(this.geometries[f11].vertexBuffer[r7].data.buffer);
    }
    return e10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js
function t5(e10, t9, n5, ...o7) {
  t9 < e10.length ? e10.splice(t9, n5, ...o7) : e10.push(...o7);
}
var n3 = class {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t9, n5, o7) {
    for (const i7 of this.symbolLevels)
      for (const r7 of i7.zLevels) {
        const i8 = r7.geometryDPInfo.unified;
        if (i8)
          for (const r8 of i8) {
            const { geometryType: i9, materialKey: l6, indexFrom: s7, indexCount: m2 } = r8, y7 = U4.load(l6).symbologyType, d4 = t9.painter.getBrush(i9, y7), u5 = { geometryType: i9, materialKey: l6, indexFrom: s7, indexCount: m2, target: n5.getGeometry(i9) };
            d4.prepareState(t9), d4.drawGeometry(t9, n5, u5, o7);
          }
      }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e10, t9) {
    if (Array.isArray(e10))
      for (const n5 of e10)
        this._addToList(n5, t9);
    else
      this._addToList(e10, t9);
  }
  removeFromList(e10) {
    Array.isArray(e10) || (e10 = [e10]);
    let t9 = null;
    for (const n5 of e10)
      t9 = this._removeFromList(n5);
    return t9;
  }
  clone() {
    const e10 = new n3();
    for (const t9 of this.symbolLevels)
      e10.symbolLevels.push(t9.clone());
    return e10;
  }
  splitAfter(e10) {
    const t9 = this._getDisplayList(e10.symbolLevel, e10.zOrder), n5 = t9.length, i7 = e10.indexFrom + e10.indexCount;
    for (let r7 = 0; r7 < n5; ++r7) {
      const n6 = t9[r7];
      if (n6.geometryType === e10.geometryType && i7 > n6.indexFrom && i7 <= n6.indexFrom + n6.indexCount) {
        if (i7 < n6.indexFrom + n6.indexCount) {
          const e11 = new o4();
          e11.geometryType = n6.geometryType, e11.materialKey = n6.materialKey, e11.indexFrom = i7, e11.indexCount = n6.indexFrom + n6.indexCount - i7, t9.splice(r7 + 1, 0, e11), n6.indexCount = i7 - n6.indexFrom;
        }
        return r7;
      }
    }
  }
  _addToList(e10, n5) {
    const i7 = e10.symbolLevel, r7 = e10.zOrder, l6 = this._getDisplayList(i7, r7), s7 = null != n5 ? n5 : l6.length - 1, m2 = s7 >= 0 && s7 < l6.length ? l6[s7] : null;
    if (null !== m2 && m2.materialKey === e10.materialKey && m2.indexFrom + m2.indexCount === e10.indexFrom && m2.geometryType === e10.geometryType)
      m2.indexCount += e10.indexCount;
    else {
      const n6 = new o4();
      n6.indexFrom = e10.indexFrom, n6.indexCount = e10.indexCount, n6.materialKey = e10.materialKey, n6.geometryType = e10.geometryType, t5(l6, s7 + 1, 0, n6);
    }
  }
  _removeFromList(e10) {
    const n5 = e10.symbolLevel, i7 = e10.zOrder, r7 = this._getDisplayList(n5, i7), l6 = r7.length;
    let s7;
    for (let t9 = 0; t9 < l6; ++t9) {
      const n6 = r7[t9];
      if (e10.indexFrom + e10.indexCount > n6.indexFrom && e10.indexFrom < n6.indexFrom + n6.indexCount && n6.geometryType === e10.geometryType) {
        s7 = t9;
        break;
      }
    }
    if (void 0 !== s7) {
      const n6 = r7[s7];
      if (e10.indexFrom === n6.indexFrom)
        return n6.indexCount -= e10.indexCount, n6.indexFrom += e10.indexCount, 0 === n6.indexCount && t5(r7, s7, 1), s7 - 1;
      if (e10.indexFrom + e10.indexCount === n6.indexFrom + n6.indexCount)
        return n6.indexCount -= e10.indexCount, 0 === n6.indexCount ? (t5(r7, s7, 1), s7 - 1) : s7;
      {
        const i8 = n6.indexFrom, l7 = e10.indexFrom - n6.indexFrom, m2 = e10.indexCount, y7 = n6.indexFrom + n6.indexCount - (e10.indexFrom + e10.indexCount);
        n6.indexCount = l7;
        const d4 = new o4();
        return d4.geometryType = n6.geometryType, d4.materialKey = n6.materialKey, d4.indexFrom = i8 + l7 + m2, d4.indexCount = y7, t5(r7, s7 + 1, 0, d4), s7;
      }
    }
    return null;
  }
  _getDisplayList(e10, t9) {
    let n5;
    const o7 = this.symbolLevels.length;
    for (let i7 = 0; i7 < o7; i7++)
      if (this.symbolLevels[i7].symbolLevel === e10) {
        n5 = this.symbolLevels[i7];
        break;
      }
    let s7;
    n5 || (n5 = new l5(), n5.symbolLevel = e10, this.symbolLevels.push(n5));
    const m2 = n5.zLevels.length;
    for (let i7 = 0; i7 < m2; i7++)
      if (n5.zLevels[i7].zLevel === t9) {
        s7 = n5.zLevels[i7];
        break;
      }
    return s7 || (s7 = new r5(), s7.geometryDPInfo = new i6(), s7.zLevel = t9, n5.zLevels.push(s7)), s7.geometryDPInfo.unified || (s7.geometryDPInfo.unified = []), s7.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
};
var o4 = class {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e10 = new o4();
    return e10.geometryType = this.geometryType, e10.materialKey = this.materialKey, e10.indexFrom = this.indexFrom, e10.indexCount = this.indexCount, e10;
  }
};
var i6 = class {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e10 = new i6();
    return e10.fill = this.fill && this.fill.map((e11) => e11.clone()), e10.line = this.line && this.line.map((e11) => e11.clone()), e10.marker = this.marker && this.marker.map((e11) => e11.clone()), e10.text = this.text && this.text.map((e11) => e11.clone()), e10.label = this.label && this.label.map((e11) => e11.clone()), e10.unified = this.unified && this.unified.map((e11) => e11.clone()), e10;
  }
};
var r5 = class {
  constructor() {
    this.geometryDPInfo = new i6();
  }
  clone() {
    const e10 = new r5();
    return e10.zLevel = this.zLevel, e10.geometryDPInfo = this.geometryDPInfo.clone(), e10;
  }
};
var l5 = class {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e10 = new l5();
    e10.symbolLevel = this.symbolLevel;
    for (const t9 of this.zLevels)
      e10.zLevels.push(t9.clone());
    return e10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js
var t6 = class {
  constructor() {
    this.vertexData = /* @__PURE__ */ new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t9, e10, a4) {
    for (const s7 in t9)
      this.vertexData.set(s7, t9[s7]);
    for (const s7 in this.vertexData)
      null === t9[s7] && this.vertexData.delete(s7);
    this.vertexCount = e10, this.indexData = a4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js
var s5 = class {
  constructor(t9, e10, s7, i7 = 0, r7 = 0) {
    this.id = t9, this.geometryType = e10, this.materialKey = s7, this.minZoom = i7, this.maxZoom = r7, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0, this._sortKey = null;
  }
  get sortKey() {
    return null == this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t9 = new s5(this.id, this.geometryType, this.materialKey);
    return t9.vertexFrom = this.vertexFrom, t9.vertexCount = this.vertexCount, t9.indexFrom = this.indexFrom, t9.indexCount = this.indexCount, t9.zOrder = this.zOrder, t9.symbolLevel = this.symbolLevel, t9.meshData = this.meshData, t9.minZoom = this.minZoom, t9.maxZoom = this.maxZoom, t9;
  }
  setMeshDataFromBuffers(s7, i7, r7) {
    const o7 = new t6();
    for (const t9 in i7) {
      const r8 = i7[t9].stride, a4 = i7[t9].data;
      if (!a4)
        continue;
      const h3 = [], n5 = F2(r8);
      for (let t10 = 0; t10 < r8 * s7.vertexCount / n5; ++t10)
        h3[t10] = a4[t10 + r8 * s7.vertexFrom / n5];
      o7.vertexData.set(t9, h3);
    }
    o7.indexData.length = 0;
    for (let t9 = 0; t9 < s7.indexCount; ++t9)
      o7.indexData[t9] = r7[t9 + s7.indexFrom] - s7.vertexFrom;
    o7.vertexCount = s7.vertexCount, this.meshData = o7;
  }
  readMeshDataFromBuffers(s7, i7) {
    this.meshData ? this.meshData.clear() : this.meshData = new t6();
    for (const t9 in s7) {
      const i8 = s7[t9].stride, r7 = s7[t9].data, o7 = [], a4 = F2(i8);
      for (let t10 = 0; t10 < i8 * this.vertexCount / a4; ++t10)
        o7[t10] = r7[t10 + i8 * this.vertexFrom / a4];
      this.meshData.vertexData.set(t9, o7);
    }
    this.meshData.indexData.length = 0;
    for (let t9 = 0; t9 < this.indexCount; ++t9)
      this.meshData.indexData[t9] = i7[t9 + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t9, s7, i7, r7) {
    if (this.meshData) {
      for (const i8 in s7) {
        const r8 = s7[i8].stride, o7 = this.meshData.vertexData.get(i8), a4 = s7[i8].data, h3 = F2(r8);
        for (let e10 = 0; e10 < r8 * this.meshData.vertexCount / h3; ++e10)
          a4[e10 + r8 * t9 / h3] = o7[e10];
      }
      for (let e10 = 0; e10 < this.meshData.indexData.length; ++e10)
        r7[e10 + i7] = this.meshData.indexData[e10] + t9;
      this.vertexFrom = t9, this.vertexCount = this.meshData.vertexCount, this.indexFrom = i7, this.indexCount = this.meshData.indexData.length;
    }
  }
  static writeAllMeshDataToBuffers(t9, e10, s7) {
    let i7 = 0, r7 = 0;
    for (const o7 of t9)
      o7.writeMeshDataToBuffers(i7, e10, r7, s7), i7 += o7.vertexCount, r7 += o7.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t9) {
    return t9.push(this.geometryType), t9.push(this.materialKey), t9.push(this.vertexFrom), t9.push(this.vertexCount), t9.push(this.indexFrom), t9.push(this.indexCount), t9.push(this.minZoom), t9.push(this.maxZoom), t9;
  }
  static deserialize(t9, e10) {
    const i7 = t9.readInt32(), r7 = t9.readInt32(), o7 = new s5(e10.id, i7, r7);
    return o7.vertexFrom = t9.readInt32(), o7.vertexCount = t9.readInt32(), o7.indexFrom = t9.readInt32(), o7.indexCount = t9.readInt32(), o7.minZoom = t9.readInt32(), o7.maxZoom = t9.readInt32(), o7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e7(e10, n5) {
  if (null !== n5) {
    e10.push(n5.length);
    for (const r7 of n5)
      r7.serialize(e10);
    return e10;
  }
  e10.push(0);
}
function n4(e10, n5, r7) {
  const t9 = e10.readInt32(), o7 = new Array(t9);
  for (let i7 = 0; i7 < o7.length; i7++)
    o7[i7] = n5.deserialize(e10, r7);
  return o7;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js
var e8 = class {
  constructor(s7) {
    this.insertAfter = null, this.id = s7, this.displayRecords = [];
  }
  copy() {
    const s7 = new e8(this.id);
    return s7.set(this), s7;
  }
  clone() {
    const s7 = new e8(this.id);
    return s7.displayRecords = this.displayRecords.map((s8) => s8.clone()), s7.insertAfter = this.insertAfter, s7;
  }
  set(s7) {
    this.id = s7.id, this.displayRecords = s7.displayRecords, this.insertAfter = s7.insertAfter;
  }
  serialize(s7) {
    return s7.push(this.id), e7(s7, this.displayRecords), s7;
  }
  static deserialize(i7) {
    const r7 = i7.readInt32(), d4 = new e8(r7), o7 = { id: r7 };
    return d4.displayRecords = n4(i7, s5, o7) ?? [], d4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js
var e9 = class {
  constructor() {
    this.displayObjects = [], this._displayList = null;
  }
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = /* @__PURE__ */ new Map();
      for (const s7 of this.displayObjects)
        this._displayObjectRegistry.set(s7.id, s7);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new n3();
    for (const s7 of this.displayObjects)
      for (const t9 of s7.displayRecords)
        this._displayList.addToList(t9);
  }
  clone() {
    const s7 = new e9();
    return this.displayObjects && (s7.displayObjects = this.displayObjects.map((s8) => s8.clone())), s7;
  }
  serialize(s7) {
    return e7(s7, this.displayObjects), s7;
  }
  _deserializeObjects(s7) {
    const i7 = s7.readInt32(), e10 = new Array(i7), a4 = /* @__PURE__ */ new Map();
    for (let l6 = 0; l6 < e10.length; ++l6) {
      const i8 = e8.deserialize(s7);
      e10[l6] = i8, a4.set(i8.id, i8);
    }
    this.displayObjects = e10, this._displayList = null, this._displayObjectRegistry = a4;
  }
  static deserialize(s7) {
    const t9 = new e9();
    return t9._deserializeObjects(s7), t9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js
var t7 = class {
  constructor(e10, t9) {
    this.data = e10, this.stride = t9;
  }
  static decode(r7) {
    const s7 = P(r7.data, r7.stride), n5 = r7.stride;
    return new t7(s7, n5);
  }
  static fromVertexVector(r7) {
    const s7 = P(r7.data.buffer(), r7.stride), n5 = r7.stride;
    return new t7(s7, n5);
  }
};
var r6 = class {
  constructor(e10, t9, r7) {
    this.geometryType = e10, this.indexBuffer = new Uint32Array(t9), this.namedBuffers = r7;
  }
  static decode(e10) {
    const s7 = e10.geometryType, n5 = e10.indexBuffer, o7 = {};
    for (const r7 in e10.namedBuffers)
      o7[r7] = t7.decode(e10.namedBuffers[r7]);
    return new r6(s7, n5, o7);
  }
  static fromVertexData(s7, n5) {
    const o7 = s7.indices, c4 = P(s7.vertices, s7.stride), i7 = s7.stride, d4 = { geometry: new t7(c4, i7) };
    return new r6(n5, o7, d4);
  }
  static fromVertexVectors(e10) {
    const s7 = e10.geometryType, n5 = e10.indexVector.buffer(), o7 = {};
    for (const r7 in e10.namedVectors)
      o7[r7] = t7.fromVertexVector(e10.namedVectors[r7]);
    return new r6(s7, n5, o7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js
var s6 = class {
  get vertexCount() {
    const t9 = this.stride / 4, e10 = this.data.length / t9;
    return e10 !== (0 | e10) && console.debug("Corrupted stride"), e10;
  }
  constructor(t9, e10) {
    this.data = t9, this.stride = e10;
  }
  transfer(t9, e10) {
    const r7 = this.data.buffer();
    t9.vertexCount = this.vertexCount, t9.data = r7, t9.stride = this.stride, e10.push(r7);
  }
};
var o5 = class {
  constructor(e10, o7, n5) {
    this.geometryType = e10, this.indexVector = new e3(Uint32Array, 6 * o7), this.namedVectors = {};
    const i7 = R2(e10, n5);
    for (const t9 in i7) {
      const e11 = i7[t9];
      let n6;
      switch (e11 % 4) {
        case 0:
        case 2:
          n6 = new e3(Uint32Array, e11 * o7);
          break;
        case 1:
        case 3:
          n6 = new e3(Uint8Array, e11 * o7);
      }
      this.namedVectors[t9] = new s6(n6, e11);
    }
  }
  get(t9) {
    return this.namedVectors[t9].data;
  }
  getVector(t9) {
    return this.namedVectors[t9];
  }
  transfer(t9, e10) {
    const r7 = this.indexVector.buffer(), s7 = {};
    e10.push(r7);
    for (const o7 in this.namedVectors) {
      const t10 = this.namedVectors[o7];
      s7[o7] = {}, t10.transfer(s7[o7], e10);
    }
    t9.geometryType = this.geometryType, t9.indexBuffer = r7, t9.namedBuffers = s7, this.destroy();
  }
  intoBuffers() {
    const t9 = r6.fromVertexVectors(this);
    return this.destroy(), t9;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js
var d2 = new e6();
var p3 = new e6();
var D = 1.5;
var h2 = 5;
function x4(e10, t9) {
  const r7 = {};
  for (const s7 in e10) {
    const i7 = { data: x(t9, e10[s7]), stride: e10[s7] };
    r7[s7] = i7;
  }
  return r7;
}
function y4(e10) {
  return [e10.fill || {}, e10.line || {}, e10.icon || {}, e10.text || {}, e10.label || {}];
}
function B(e10) {
  const t9 = [[], [], [], [], []], r7 = e10;
  for (const s7 of r7)
    for (const e11 of s7.displayRecords)
      t9[e11.geometryType].push(e11);
  return t9;
}
var g4 = class {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    var _a, _b, _c;
    if (d2.reset(), !this.tileDisplayData)
      return;
    const e10 = B(this.tileDisplayData.displayObjects);
    for (const s7 of e10)
      for (const e11 of s7)
        e11 && d2.needMore(e11.geometryType, e11.meshData ? e11.meshData.vertexCount : e11.vertexCount, e11.meshData ? e11.meshData.indexData.length : e11.indexCount);
    const t9 = e10.length, r7 = new f8();
    for (let s7 = 0; s7 < t9; ++s7) {
      r7.geometries[s7].indexBuffer = new Uint32Array(Math.round(D * d2.indicesFor(s7)));
      const e11 = [], t10 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries[s7].vertexBuffer;
      if (!t10)
        continue;
      for (const r8 in t10)
        e11.push(t10[r8].stride);
      const i8 = g4._computeVertexAlignment(e11), a4 = Math.round(D * d2.verticesFor(s7)), n6 = g4._align(a4, i8);
      for (const f11 in t10) {
        const e12 = t10[f11].stride;
        r7.geometries[s7].vertexBuffer[f11] = { stride: e12, data: x(n6, e12) };
      }
    }
    p3.reset(), (_b = this.tileDisplayData.displayList) == null ? void 0 : _b.clear();
    for (let s7 = 0; s7 < t9; ++s7) {
      const t10 = e10[s7];
      for (const e11 of t10) {
        if (e11.meshData)
          e11.writeMeshDataToBuffers(p3.verticesFor(s7), r7.geometries[s7].vertexBuffer, p3.indicesFor(s7), r7.geometries[s7].indexBuffer), e11.meshData = null;
        else {
          const t11 = (_c = this.tileBufferData) == null ? void 0 : _c.geometries[s7];
          if (t11) {
            const i8 = t11.vertexBuffer, o7 = t11.indexBuffer, n6 = r7.geometries[s7].vertexBuffer, f11 = r7.geometries[s7].indexBuffer, l6 = p3.verticesFor(s7), u5 = p3.indicesFor(s7);
            j2(l6, u5, n6, f11, e11, i8, o7), e11.vertexFrom = l6, e11.indexFrom = u5;
          }
        }
        p3.needMore(s7, e11.vertexCount, e11.indexCount);
      }
    }
    const { displayList: i7, displayObjects: n5 } = this.tileDisplayData;
    if (i7)
      for (const s7 of n5)
        i7.addToList(s7.displayRecords);
    this.tileBufferData = r7;
  }
  getStrides() {
    var _a;
    const e10 = [], t9 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries;
    if (!t9)
      return e10;
    for (let r7 = 0; r7 < t9.length; ++r7) {
      const s7 = t9[r7];
      e10[r7] = {};
      for (const t10 in s7.vertexBuffer)
        e10[r7][t10] = s7.vertexBuffer[t10].stride;
    }
    return e10;
  }
  clone() {
    var _a, _b;
    const e10 = new g4();
    return e10.tileBufferData = ((_a = this.tileBufferData) == null ? void 0 : _a.clone()) ?? null, e10.tileDisplayData = ((_b = this.tileDisplayData) == null ? void 0 : _b.clone()) ?? null, e10;
  }
  _guessSize() {
    var _a;
    const e10 = ((_a = this.tileDisplayData) == null ? void 0 : _a.displayObjects) ?? [], t9 = Math.min(e10.length, 4), r7 = 12, s7 = 40;
    let i7 = 0;
    for (let o7 = 0; o7 < t9; o7++)
      i7 = Math.max(i7, e10[o7].displayRecords.length);
    return 2 * (e10.length * r7 + e10.length * i7 * s7);
  }
  serialize() {
    const e10 = this.tileBufferData.serialize(), t9 = this.tileBufferData.getBuffers(), r7 = this.tileDisplayData.serialize(new e3(Int32Array, this._guessSize())).buffer();
    return t9.push(r7), { result: { displayData: r7, bufferData: e10 }, transferList: t9 };
  }
  static fromVertexData(r7, s7) {
    const i7 = {}, o7 = /* @__PURE__ */ new Map();
    for (const e10 of s7)
      o7.set(e10.id, e10);
    return te((s8) => {
      const a4 = r7.data[s8];
      if (r(a4)) {
        const e10 = i5.from(a4.records).getCursor();
        for (; e10.next(); ) {
          const t9 = e10.id, r8 = e10.materialKey, i8 = e10.indexFrom, a5 = e10.indexCount, n5 = e10.vertexFrom, l6 = e10.vertexCount, u5 = o7.get(t9), c4 = new s5(t9, s8, r8);
          c4.indexFrom = i8, c4.indexCount = a5, c4.vertexFrom = n5, c4.vertexCount = l6, u5.displayRecords.push(c4);
        }
        i7[s8] = r6.fromVertexData(a4, s8);
      } else
        i7[s8] = new o5(s8, 0, S.DEFAULT).intoBuffers();
    }), g4.fromMeshData({ displayObjects: s7, vertexBuffersMap: i7 });
  }
  static fromMeshData(e10) {
    const t9 = new g4(), r7 = new e9(), o7 = new f8();
    r7.displayObjects = e10.displayObjects;
    for (const s7 in e10.vertexBuffersMap) {
      const t10 = e10.vertexBuffersMap[s7];
      o7.geometries[s7].indexBuffer = t10.indexBuffer, o7.geometries[s7].vertexBuffer = t10.namedBuffers;
    }
    return t9.tileDisplayData = r7, t9.tileBufferData = o7, t9;
  }
  static bind(e10, t9) {
    const r7 = new g4();
    return r7.tileDisplayData = e10, r7.tileBufferData = t9, r7;
  }
  static create(e10, t9) {
    const r7 = new g4();
    r7.tileDisplayData = new e9(), r7.tileDisplayData.displayObjects = e10;
    const o7 = [0, 0, 0, 0, 0], a4 = [0, 0, 0, 0, 0], n5 = [[], [], [], [], []];
    for (const s7 of e10)
      for (const e11 of s7.displayRecords)
        n5[e11.geometryType].push(e11), o7[e11.geometryType] += e11.meshData.vertexCount, a4[e11.geometryType] += e11.meshData.indexData.length;
    const l6 = new f8(), u5 = y4(t9);
    for (let s7 = 0; s7 < h2; s7++) {
      const e11 = new Uint32Array(a4[s7]), t10 = x4(u5[s7], o7[s7]);
      s5.writeAllMeshDataToBuffers(n5[s7], t10, e11), l6.geometries[s7] = { indexBuffer: e11, vertexBuffer: t10 };
    }
    return r7.tileBufferData = l6, r7;
  }
  static _align(e10, t9) {
    const r7 = e10 % t9;
    return 0 === r7 ? e10 : e10 + (t9 - r7);
  }
  static _computeVertexAlignment(e10) {
    let t9 = false, r7 = false;
    for (const s7 of e10)
      s7 % 4 == 2 ? t9 = true : s7 % 4 != 0 && (r7 = true);
    return r7 ? 4 : t9 ? 2 : 1;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var o6 = class extends c3 {
  static from(s7, n5, i7) {
    const c4 = b.createInstance(), u5 = [], a4 = s7.filter((r7) => !!r7.geometry);
    for (const e10 of a4) {
      const s8 = c2(e10.geometry);
      rt(u5, [e10], s8, false, false, n5);
    }
    return new o6(c4, u5, i7);
  }
  constructor(r7, t9, e10) {
    super(r7, t9, null), this._transform = e10;
  }
  get geometryType() {
    const r7 = this._current;
    return r7 ? r7.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r7 = new o6(this.instance, this._features, this._transform);
    return this.copyInto(r7), r7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var y5 = new t2();
var g5 = new t2();
var f9 = "esriGeometryPolyline";
function d3(t9) {
  t9.coords.length = 0, t9.lengths.length = 0;
}
var b2 = class {
  constructor() {
    this.bounds = u2(), this.graphic = null;
  }
  static acquire(t9 = null, e10, s7, r7, o7) {
    let i7;
    return 0 === b2._pool.length ? i7 = new b2() : (i7 = b2._pool.pop(), this._set.delete(i7)), i7.acquire(t9, e10, s7, r7, o7), i7;
  }
  static release(t9) {
    t9 && !this._set.has(t9) && (t9.release(), this._pool.push(t9), this._set.add(t9));
  }
  static getCentroidQuantized(e10, s7) {
    if (y2(e10.geometry)) {
      const o7 = e10.symbol;
      if (t(o7))
        return null;
      if ((o7 == null ? void 0 : o7.layers.length) > 0 && o7.layers.some((t9) => "text" === t9.type || "marker" === t9.type)) {
        const t9 = r2(e10.geometry);
        return null !== t9 ? O(s7, {}, { x: t9[0], y: t9[1] }, false, false) : null;
      }
    }
    return null;
  }
  acquire(t9 = null, e10, s7, r7, o7) {
    t9 && this.set(t9, e10, s7, r7, o7);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t9, e10, s7, r7, o7) {
    this.graphic = t9, this.geometry = s7, this.symbolResource = e10, this.bounds = r7, o7 && (this.size = o7);
  }
  getGeometryQuantized(e10, r7, o7, n5) {
    const p4 = this.geometry, b4 = c2(p4);
    if (t(b4))
      return null;
    switch (b4) {
      case "esriGeometryPolygon": {
        const t9 = p4, { rings: s7 } = t9;
        if (!s7 || 0 === s7.length)
          return null;
        let r8;
        if (r8 = 1 === s7.length && 2 === s7[0].length ? U(e10, { paths: [[s7[0][0], s7[0][1]]] }) : U(e10, this.geometry), !r8) {
          const t10 = { x: s7[0][0][0], y: s7[0][0][1] };
          if (r8 = U(e10, t10), r8) {
            const { x: t11, y: e11 } = r8;
            return { rings: [[[t11 - 1, e11], [1, -1], [1, 1], [-1, 1], [-1, -1]]] };
          }
        }
        return r8;
      }
      case "esriGeometryPolyline": {
        const t9 = p4;
        d3(y5), d3(g5);
        const s7 = t9.hasZ ?? false, r8 = t9.hasM ?? false;
        return H(y5, t9), gt(g5, y5, s7, r8, f9, e10.scale[0]), mt(y5, g5, s7, r8, f9, e10), C(y5, t9.hasZ ?? false, t9.hasM ?? false);
      }
      case "esriGeometryMultipoint": {
        const t9 = p4, i7 = 0.5 * n5 * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]), h3 = R(o7);
        let u5 = t9.points;
        if (h3) {
          const [t10, e11] = h3.valid, o8 = e11 - t10;
          u5 = u5.filter((n6) => {
            if (n6[0] + i7 > e11 || n6[0] - i7 < t10) {
              const t11 = [...n6];
              return n6[0] + i7 > e11 ? t11[0] -= o8 : t11[0] += o8, q(r7, n6, i7) || q(r7, t11, i7);
            }
            return q(r7, n6, i7);
          });
        }
        return 0 === u5.length ? { points: u5 } : U(e10, { points: u5 });
      }
    }
    return U(e10, this.geometry);
  }
};
b2._pool = [], b2._set = /* @__PURE__ */ new Set();

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var g6 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
var f10 = u2();
var _ = 1e-5;
function b3(e10, t9, r7, i7, s7) {
  return g6.minX = t9, g6.minY = r7, g6.maxX = i7, g6.maxY = s7, e10.search(g6);
}
function y6(e10) {
  return { minX: e10.bounds[0], minY: e10.bounds[1], maxX: e10.bounds[2], maxY: e10.bounds[3] };
}
var I = class {
  constructor(e10, t9, r7, s7, o7, n5, h3) {
    this._graphics = s7, this._onAdd = o7, this._onRemove = n5, this._hashToCIM = h3, this._index = i4(9, y6), this._itemByGraphic = /* @__PURE__ */ new Map(), this._inflatedSizeHelper = new oe(), this._tileInfoView = e10, this._uidFieldName = r7;
    const a4 = e10.getClosestInfoForScale(t9);
    a4 && (this._resolution = this._tileInfoView.getTileResolution(a4.level));
  }
  setResourceManager(e10) {
    this._cimResourceManager = e10, this._hittestDrawHelper = new V(e10);
  }
  hitTest(e10, t9, r7, i7, n5) {
    var _a;
    e10 = U2(e10, this._tileInfoView.spatialReference);
    const h3 = 0.5 * i7 * window.devicePixelRatio * r7;
    f10[0] = e10 - h3, f10[1] = t9 - h3, f10[2] = e10 + h3, f10[3] = t9 + h3;
    const u5 = 0.5 * i7 * (r7 + g3), l6 = b3(this._index, e10 - u5, t9 - u5, e10 + u5, t9 + u5);
    if (!l6 || 0 === l6.length)
      return [];
    const c4 = [], d4 = u2(), p4 = u2();
    for (const s7 of l6) {
      const { geometry: e11, symbolResource: t10 } = s7;
      this._getSymbolBounds(d4, t10, e11, p4, n5), p4[3] = p4[2] = p4[1] = p4[0] = 0, E(d4, f10) && ((_a = s7.graphic) == null ? void 0 : _a.visible) && c4.push(s7);
    }
    if (0 === c4.length)
      return [];
    const g7 = this._hittestDrawHelper, _2 = [];
    for (const s7 of c4) {
      const { geometry: e11, symbolResource: t10 } = s7, { hash: r8, textInfo: o7 } = t10, h4 = this._hashToCIM.get(r8);
      h4 && (g7.hitTest(f10, h4.symbol, e11, o7, n5, i7) && _2.push(s7));
    }
    return _2.sort(z), _2.map((e11) => e11.graphic);
  }
  getGraphicsData(e10, t9, r7) {
    const i7 = this._searchForItems(t9);
    if (0 === i7.length || 0 === r7.length)
      return [];
    i7.sort((e11, t10) => e11.zorder - t10.zorder), i7[0].insertAfter = -1;
    for (let l6 = 1; l6 < i7.length; l6++)
      i7[l6].insertAfter = i7[l6 - 1].graphic.uid;
    i7.sort((e11, t10) => e11.graphic.uid - t10.graphic.uid), r7.sort((e11, t10) => e11.uid - t10.uid);
    let s7, o7 = 0, n5 = 0;
    const h3 = t9.resolution, a4 = [], u5 = { originPosition: "upperLeft", scale: [h3, h3], translate: [t9.bounds[0], t9.bounds[3]] };
    for (const l6 of r7) {
      for (n5 = -2; o7 < i7.length; )
        if (s7 = i7[o7], o7++, l6.uid === s7.graphic.uid) {
          n5 = s7.insertAfter;
          break;
        }
      if (!(s7 == null ? void 0 : s7.geometry) || -2 === n5)
        continue;
      const r8 = s7.getGeometryQuantized(u5, t9.bounds, this._tileInfoView.spatialReference, h3), c4 = { ...s7.graphic.attributes };
      c4[this._uidFieldName] = l6.uid, null == s7.groupId && (s7.groupId = e10.createTemplateGroup(s7.symbol, null)), a4.push({ centroid: b2.getCentroidQuantized(s7, u5), geometry: r8, attributes: c4, symbol: s7.symbol, groupId: s7.groupId, insertAfter: n5, zorder: s7.zorder });
    }
    return a4.sort((e11, t10) => e11.zorder - t10.zorder), a4;
  }
  queryTileData(e10, t9) {
    if (0 === this._graphics.length)
      return [];
    const { bounds: r7, resolution: i7 } = t9, s7 = this._searchForItems(t9), o7 = [];
    return 0 === s7.length || this._createTileGraphics(o7, e10, s7, { originPosition: "upperLeft", scale: [i7, i7], translate: [r7[0], r7[3]] }, t9), o7;
  }
  has(e10) {
    return this._itemByGraphic.has(e10);
  }
  getBounds(e10) {
    const t9 = this._itemByGraphic.get(e10);
    return t9 ? t9.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter((e10) => e10.graphic.visible).map((e10) => e10.bounds);
  }
  addOrModify(r7, i7, s7) {
    if (!r7 || t(i7))
      return;
    this.has(r7) && this.remove(r7), this._onAdd(r7);
    const o7 = [0, 0, 0, 0], n5 = this._getSymbolBounds(null, i7, s7, o7, 0), h3 = b2.acquire(r7, i7, s7, r(n5) ? n5 : null, o7);
    return this._itemByGraphic.set(r7, h3), s7 && this._index.insert(h3), h3.bounds;
  }
  remove(e10) {
    if (!this._itemByGraphic.has(e10))
      return;
    this._onRemove(e10);
    const t9 = this._itemByGraphic.get(e10);
    (t9 == null ? void 0 : t9.bounds) && this._index.remove(t9), this._itemByGraphic.delete(e10);
  }
  updateZ() {
    const e10 = this._graphics.items;
    let t9, r7;
    for (let i7 = 0; i7 < e10.length; i7++)
      r7 = e10[i7], t9 = this._itemByGraphic.get(r7), t9 && (t9.zorder = i7);
  }
  update(e10, r7, i7) {
    const s7 = this._itemByGraphic.get(e10);
    s7.groupId = null;
    const o7 = e2(s7.bounds);
    this._index.remove(s7);
    const h3 = this._getSymbolBounds(s7.bounds, r7, i7, s7.size, 0);
    return r(h3) && s7.set(e10, r7, i7, h3, s7.size), i7 && this._index.insert(s7), { oldBounds: o7, newBounds: s7.bounds };
  }
  updateLevel(e10) {
    if (this._resolution === e10)
      return;
    this._resolution = e10, this._index.clear();
    const r7 = this._itemByGraphic, i7 = [];
    for (const [s7, o7] of r7) {
      const e11 = this._getSymbolBounds(o7.bounds, o7.symbolResource, o7.geometry, o7.size, 0);
      o7.geometry && r(e11) && (o7.bounds = e11, i7.push(o7));
    }
    this._index.load(i7);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e10, t9, r7, i7, s7) {
    const o7 = this._uidFieldName, n5 = this._tileInfoView.spatialReference, { bounds: h3, resolution: a4 } = s7;
    let u5, l6, c4, m2;
    r7.sort((e11, t10) => e11.zorder - t10.zorder);
    for (let p4 = 0; p4 < r7.length; p4++) {
      c4 = r7[p4], u5 = c4.graphic, l6 = c4.getGeometryQuantized(i7, h3, n5, a4), m2 = 0 === p4 ? -1 : r7[p4 - 1].graphic.uid;
      const s8 = { ...c4.graphic.attributes };
      s8[o7] = u5.uid, null == c4.groupId && (c4.groupId = t9.createTemplateGroup(c4.symbol, null)), e10.push({ centroid: b2.getCentroidQuantized(c4, i7), geometry: l6, attributes: s8, symbol: c4.symbol, groupId: c4.groupId, insertAfter: m2, zorder: c4.zorder });
    }
  }
  _searchForItems(e10) {
    const t9 = this._tileInfoView.spatialReference, r7 = e10.bounds, i7 = R(t9);
    if (i7 && t9.isWrappable) {
      const [t10, o7] = i7.valid, n5 = Math.abs(r7[2] - o7) < _, h3 = Math.abs(r7[0] - t10) < _;
      if ((!n5 || !h3) && (n5 || h3)) {
        const i8 = e10.resolution;
        let h4;
        h4 = u2(n5 ? [t10, r7[1], t10 + i8 * g3, r7[3]] : [o7 - i8 * g3, r7[1], o7, r7[3]]);
        const a4 = b3(this._index, r7[0], r7[1], r7[2], r7[3]), u5 = b3(this._index, h4[0], h4[1], h4[2], h4[3]);
        return [.../* @__PURE__ */ new Set([...a4, ...u5])];
      }
    }
    return b3(this._index, r7[0], r7[1], r7[2], r7[3]);
  }
  _getSymbolBounds(e10, t9, i7, o7, n5) {
    if (!t9 || !t9.symbol || !i7)
      return null;
    if (e10 || (e10 = u2()), c(e10, i7), !o7 || 0 === o7[0] && 0 === o7[1] && 0 === o7[2] && 0 === o7[3]) {
      const { hash: e11, textInfo: i8 } = t9, s7 = this._hashToCIM.get(e11);
      if (!s7)
        return null;
      o7 || (o7 = [0, 0, 0, 0]);
      const h3 = this._inflatedSizeHelper.getSymbolInflateSize(o7, s7.symbol, this._cimResourceManager, n5, i8);
      o7[0] = u3(h3[0]), o7[1] = u3(h3[1]), o7[2] = u3(h3[2]), o7[3] = u3(h3[3]);
    }
    const a4 = this._resolution, u5 = oe.safeSize(o7);
    return e10[0] -= u5 * a4, e10[1] -= u5 * a4, e10[2] += u5 * a4, e10[3] += u5 * a4, e10;
  }
};
var z = (e10, t9) => {
  const r7 = y3(e10.graphic), i7 = y3(t9.graphic);
  return r7 === i7 ? t9.zorder - e10.zorder : r7 - i7;
};

// node_modules/@arcgis/core/views/layers/GraphicsView.js
var t8 = (t9) => {
  let p4 = class extends s3(t9) {
    constructor() {
      super(...arguments), this.graphics = null, this.renderer = null;
    }
  };
  return e([y()], p4.prototype, "graphics", void 0), e([y()], p4.prototype, "renderer", void 0), e([y()], p4.prototype, "updating", void 0), e([y()], p4.prototype, "view", void 0), p4 = e([a("esri.views.layers.GraphicsView")], p4), p4;
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var ie = has("esri-2d-graphic-debug");
function re(e10, t9, s7) {
  let i7 = s7.get(e10);
  return i7 || (i7 = { tile: t9, addedOrModified: [], removed: [] }, s7.set(e10, i7)), i7;
}
var oe2 = class extends t8(a2(v)) {
  constructor(e10) {
    super(e10), this._storage = new r3(), this._displayIds = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._tiles = /* @__PURE__ */ new Map(), this._graphicStoreUpdate = false, this._graphicsSet = /* @__PURE__ */ new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = /* @__PURE__ */ new Set(), this._tilesToUpdate = /* @__PURE__ */ new Map(), this._graphicIdToAbortController = /* @__PURE__ */ new Map(), this._attached = false, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = /* @__PURE__ */ new Map(), this._hashToExpandedSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIMSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIM = /* @__PURE__ */ new Map(), this._processing = false, this._needsProcessing = false, this._pendingUpdate = { added: /* @__PURE__ */ new Set(), updated: /* @__PURE__ */ new Set(), removed: /* @__PURE__ */ new Set() }, this.lastUpdateId = -1, this.updateRequested = false, this.defaultPointSymbolEnabled = true, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e10, t9, s7) {
    if (e10) {
      const i7 = w2(e10), r7 = $({ indexCount: 0, fields: {} }, "feature", e10, i7);
      this._matcher = o2(r7, t9, null, s7);
    }
  }
  _createDisplayId(e10) {
    let t9 = this._displayIds.get(e10);
    return t9 || (t9 = this._storage.createDisplayId(), this._displayIds.set(e10, t9)), t9;
  }
  initialize() {
    this._attributeStore = new M({ type: "local", initialize: (e11) => Promise.resolve(this.container.attributeView.initialize(e11)), update: (e11) => this.container.attributeView.requestUpdate(e11), render: () => this.container.requestRender() }, l4("2d"), () => this.notifyChange("updating")), this.container.hasHighlight = () => this._attributeStore.hasHighlight;
    const e10 = (e11) => {
      this._createDisplayId(e11.uid), this._setFilterState(e11.uid, e11.visible);
    }, t9 = (e11) => {
      const t10 = this._displayIds.get(e11.uid);
      this._displayIds.delete(e11.uid), this._storage.releaseDisplayId(t10);
    }, s7 = new x2(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new I(this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e10, t9, this._hashToCIM), this._meshFactory = new n(null, this.uid, s7), this._templateStore = s7, this.handles.add([l3(() => this.renderer, (e11) => {
      this._createMatcher(e11, s7, this.container.stage.resourceManager);
      for (const t10 of this.graphics)
        this._pendingUpdate.updated.add(t10);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      ie && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({ target: this.graphics, added: this.graphics.items, removed: [], moved: [] }), this.handles.add(this.graphics.on("change", (e12) => this._graphicsChangeHandler(e12)), "graphics");
      const e11 = this.container.stage.resourceManager;
      this._createMatcher(this.renderer, s7, e11), this._graphicStore.setResourceManager(e11), this._attached = true, this.notifyChange("updating");
    })]);
    const i7 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: i7, removed: [] });
  }
  get updating() {
    return !this._attached || null !== this._updatingGraphicsTimer || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || this._attributeStore.isUpdating();
  }
  hitTest(e10) {
    if (!this.view || !this.view.position)
      return [];
    const { resolution: t9, rotation: s7 } = this.view.state;
    return this._graphicStore.hitTest(e10.x, e10.y, 2, t9, s7);
  }
  update(e10) {
    f(this._controller.signal);
    const t9 = e10.state, { resolution: s7 } = t9;
    if (this._graphicStore.updateLevel(s7), this._graphicStoreUpdate = true, this.updateRequested = false, this._pendingUpdate.updated.size > 0) {
      if (!this._processing)
        return void this._updateGraphics();
      this._needsProcessing = true;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback());
  }
  processUpdate(e10) {
    this.updateRequested && (this.updateRequested = false, this.update(e10));
  }
  graphicUpdateHandler(e10) {
    const { graphic: t9, property: s7 } = e10;
    switch (s7) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t9), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t9.uid, t9.visible), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e10) {
    const t9 = e10.map((e11) => this._displayIds.get(e11)).filter(r);
    this._attributeStore.setHighlight(e10, t9);
  }
  _getIntersectingTiles(e10) {
    const t9 = this._graphicStore.getBounds(e10);
    if (!t9 || 0 === s2(t9) || 0 === l2(t9))
      return [];
    const s7 = u4(t9, this.view.spatialReference);
    return r(s7) ? [.../* @__PURE__ */ new Set([...this.view.graphicsTileStore.boundsIntersections(s7[0]), ...this.view.graphicsTileStore.boundsIntersections(s7[1])])] : this.view.graphicsTileStore.boundsIntersections(t9);
  }
  async _updateTile(e10) {
    f(this._controller.signal);
    const t9 = e10.tile, s7 = this._getGraphicsData(this._templateStore, t9, e10.addedOrModified), i7 = await this._processGraphics(t9, s7);
    return f(this._controller.signal), this._patchTile(t9.key, { type: "update", addOrUpdate: i7, remove: e10.removed, end: true, clear: false, sort: false }), i7;
  }
  _patchTile(e10, t9) {
    const s7 = this._tiles.get(e10);
    s7 && (this.container.onTileData(s7, t9), this.container.requestRender());
  }
  _graphicsChangeHandler(e10) {
    const t9 = this._pendingUpdate;
    for (const s7 of e10.added)
      t9.added.add(s7);
    for (const s7 of e10.moved)
      t9.updated.add(s7);
    for (const s7 of e10.removed)
      this._pendingUpdate.added.has(s7) ? t9.added.delete(s7) : t9.removed.add(s7);
    this._processing ? this._needsProcessing = true : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e10 = { added: [], removed: [], updated: [] };
    if (!this.graphics)
      return e10;
    const t9 = this._pendingUpdate;
    for (const s7 of this.graphics.items)
      t9.added.has(s7) ? e10.added.push(s7) : t9.updated.has(s7) && e10.updated.push(s7);
    for (const s7 of t9.removed)
      this._graphicStore.has(s7) && e10.removed.push(s7);
    return t9.added.clear(), t9.removed.clear(), t9.updated.clear(), e10;
  }
  async _updateGraphics() {
    this._processing = true;
    const { added: e10, removed: t9, updated: s7 } = this._getGraphicsToUpdate(), i7 = this._tilesToUpdate;
    let r7;
    try {
      if (!this._graphicStoreUpdate) {
        const e11 = this.view.state, { resolution: t10 } = e11;
        this._graphicStore.updateLevel(t10);
      }
      const o7 = [], a4 = new Array(e10.length + t9.length);
      for (let e11 = 0; e11 < s7.length; e11++) {
        const t10 = s7[e11], n6 = this._getIntersectingTiles(t10);
        for (const e12 of n6) {
          r7 = e12.id;
          re(r7, e12, i7).removed.push(this._displayIds.get(t10.uid));
        }
        o7.push(this._updateGraphic(t10, null)), a4[e11] = t10;
      }
      const n5 = s7.length;
      for (let t10 = 0; t10 < e10.length; t10++) {
        const s8 = e10[t10];
        a4[n5 + t10] = s8, this._graphicsSet.add(s8), o7.push(this._addGraphic(s8));
      }
      for (const e11 of t9) {
        this._abortProcessingGraphic(e11.uid);
        const t10 = this._getIntersectingTiles(e11);
        for (const s8 of t10) {
          r7 = s8.id;
          re(r7, s8, i7).removed.push(this._displayIds.get(e11.uid));
        }
        this._graphicsSet.delete(e11), this._graphicStore.remove(e11);
      }
      let h3;
      this._flipUpdatingGraphics(), await Promise.all(o7);
      for (let e11 = 0; e11 < a4.length; e11++) {
        h3 = a4[e11];
        const t10 = this._getIntersectingTiles(h3);
        for (const e12 of t10) {
          r7 = e12.id;
          re(r7, e12, i7).addedOrModified.push(h3);
        }
      }
      this._graphicStore.updateZ();
      const l6 = [];
      for (const [e11, t10] of i7)
        l6.push(this._updateTile(t10));
      await Promise.all(l6);
    } catch (o7) {
      j(o7), 0;
    }
    for (const a4 of t9)
      try {
        const e11 = await this._getSymbolForGraphic(a4, null);
        if (e11) {
          const t10 = e11.hash();
          this._hashToExpandedSymbol.delete(t10);
        }
      } catch (o7) {
        j(o7), 0;
      }
    i7.clear(), this.notifyChange("updating"), this._processing = false, this._needsProcessing && (this._needsProcessing = false, this._updateGraphics());
  }
  _getArcadeInfo(e10) {
    const t9 = (e10.attributes ? Object.keys(e10.attributes) : []).map((t10) => ({ name: t10, alias: t10, type: "string" == typeof e10.attributes[t10] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
    return t(e10.geometry) ? null : { geometryType: c2(e10.geometry), spatialReference: f2.fromJSON(e10.geometry.spatialReference), fields: t9 };
  }
  _getSymbolForGraphic(e10, t9) {
    return f(this._controller.signal), r(e10.symbol) ? Promise.resolve(e10.symbol) : r(this.renderer) ? this.renderer.getSymbolAsync(e10, { scale: this.view.scale, signal: r(t9) ? t9.signal : null }) : Promise.resolve(this._getNullSymbol(e10));
  }
  _getCIMSymbol(e10, t9, s7) {
    let i7 = this._hashToCIM.get(t9);
    if (i7)
      return Promise.resolve(i7);
    const o7 = Z(e10);
    if (r(o7)) {
      if ("CIMSymbolReference" === o7.type)
        return i7 = o7, this._hashToCIM.set(t9, i7), Promise.resolve(i7);
      let e11 = this._hashToCIMSymbolPromise.get(t9);
      return e11 || (e11 = o7.fetchCIMSymbol(s7).then((e12) => (this._hashToCIM.set(t9, e12.data), this._hashToCIMSymbolPromise.delete(t9), e12)).catch((e12) => (this._hashToCIMSymbolPromise.delete(t9), w(e12), null)), this._hashToCIMSymbolPromise.set(t9, e11), e11);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e10, t9, s7, i7) {
    const r7 = this._hashToExpandedSymbol.get(s7);
    if (r7)
      return Promise.resolve(r7);
    let o7 = this._hashToExpandedSymbolPromise.get(s7);
    if (o7)
      return o7;
    const a4 = this.container.stage, n5 = this._getArcadeInfo(t9), h3 = w2(null), l6 = o(e10, h3);
    return o7 = i3(l6, n5, a4.resourceManager, i7), this._hashToExpandedSymbolPromise.set(s7, o7), o7.then((e11) => (this._hashToExpandedSymbol.set(s7, e11), this._hashToExpandedSymbolPromise.delete(s7), e11)), o7;
  }
  async _getSymbolResources(e10, t9) {
    f(this._controller.signal);
    return this.container.stage ? this._getSymbolForGraphic(e10, t9).then((i7) => {
      if (!i7)
        return null;
      const r7 = i7.hash();
      return this._getCIMSymbol(i7, r7, t9).then((i8) => t(i8) ? null : this._expandCIMSymbol(i8, e10, r7, t9).then((e11) => {
        const t10 = e11.layers.filter((e12) => "text" === e12.type && "string" == typeof e12.text);
        if (t10 && t10.length > 0) {
          const i9 = new Array(t10.length);
          for (let e12 = 0; e12 < t10.length; e12++) {
            const r8 = t10[e12], o8 = [], [a4] = i2(r8.text);
            r8.text = a4;
            for (let e13 = 0; e13 < a4.length; e13++)
              o8.push(a4.charCodeAt(e13));
            i9[e12] = { symbol: r8, id: e12, glyphIds: o8 };
          }
          const o7 = /* @__PURE__ */ new Map();
          return this.container.getMaterialItems(i9).then((s7) => {
            i(s7);
            for (let e12 = 0; e12 < t10.length; e12++) {
              const i10 = t10[e12];
              o7.set(i10.cim, { text: i10.text, mosaicItem: s7[e12].mosaicItem });
            }
            return { symbol: e11, textInfo: o7, hash: r7 };
          });
        }
        return { symbol: e11, hash: r7 };
      }));
    }).catch((e11) => (w(e11), null)) : null;
  }
  async _projectAndNormalizeGeometry(e10, t9) {
    if (f(this._controller.signal), t(e10.geometry) || "mesh" === e10.geometry.type)
      return null;
    let s7 = e10.geometry;
    if (y2(s7)) {
      const e11 = s7.rings;
      s7.rings = e11;
    } else if (f3(s7)) {
      const e11 = s7.paths;
      s7.paths = e11;
    } else if (u(s7)) {
      const i8 = await this._getSymbolForGraphic(e10, t9);
      if (f(this._controller.signal), i8 && (h(i8.type) || p2(i8.type))) {
        s7 = s7.center;
      } else
        s7 = x3(s7);
    }
    await f4(s7.spatialReference, this.view.spatialReference);
    const i7 = p(s7), r7 = g2(i7, s7.spatialReference, this.view.spatialReference);
    return r7 && g(r7), r7;
  }
  _onTileUpdate(e10) {
    const t9 = R(this.view.spatialReference);
    if (e10.added && e10.added.length > 0)
      for (const s7 of e10.added)
        this._addNewTile(s7, t9);
    if (e10.removed && e10.removed.length > 0)
      for (const s7 of e10.removed)
        this._removeTile(s7.key);
  }
  async _addGraphic(e10) {
    this._abortProcessingGraphic(e10.uid), f(this._controller.signal);
    const t9 = new AbortController();
    this._graphicIdToAbortController.set(e10.uid, t9);
    const s7 = { signal: t9.signal };
    try {
      await this._addOrUpdateGraphic(e10, s7), f(this._controller.signal), this._graphicIdToAbortController.delete(e10.uid);
    } catch (i7) {
      if (this._graphicIdToAbortController.delete(e10.uid), !j(i7))
        throw i7;
    }
  }
  _updateGraphic(e10, t9) {
    f(this._controller.signal);
    const s7 = this._projectAndNormalizeGeometry(e10, t9), i7 = this._getSymbolResources(e10, t9);
    return Promise.all([s7, i7]).then(([t10, s8]) => {
      f(this._controller.signal), this._graphicStore.addOrModify(e10, s8, t10);
    });
  }
  _addOrUpdateGraphic(e10, t9) {
    f(this._controller.signal);
    const s7 = this._projectAndNormalizeGeometry(e10, t9), i7 = this._getSymbolResources(e10, t9);
    return Promise.all([s7, i7]).then(([t10, s8]) => {
      f(this._controller.signal), this._graphicsSet.has(e10) && this._graphicStore.addOrModify(e10, s8, t10);
    });
  }
  _addTile(e10) {
    const t9 = this.view.featuresTilingScheme.getTileBounds(u2(), e10), s7 = this.view.featuresTilingScheme.getTileResolution(e10.level), i7 = new a3(e10, s7, t9[0], t9[3]);
    return this._tiles.set(e10, i7), this.container.addChild(i7), i7;
  }
  async _addNewTile(e10, t9) {
    const s7 = this._addTile(e10.key), i7 = this._graphicStore.queryTileData(this._templateStore, e10);
    if (0 === i7.length)
      return;
    if (t9) {
      const s8 = Math.round((t9.valid[1] - t9.valid[0]) / e10.resolution);
      for (const e11 of i7)
        e11.geometry && (s(e11.geometry) || l(e11.geometry)) && this._wrapPoints(e11, s8);
    }
    const r7 = e10.key;
    this._tileUpdateSet.add(e10.key), this.notifyChange("updating");
    try {
      const t10 = { type: "update", clear: false, addOrUpdate: await this._processGraphics(e10, i7), remove: [], end: true, sort: false };
      s7.patch(t10), this._tileUpdateSet.delete(r7), this.notifyChange("updating");
    } catch (o7) {
      if (this._tileUpdateSet.delete(r7), this.notifyChange("updating"), !j(o7))
        throw o7;
    }
  }
  _removeTile(e10) {
    if (!this._tiles.has(e10))
      return;
    const t9 = this._tiles.get(e10);
    this.container.removeChild(t9), t9.destroy(), this._tiles.delete(e10);
  }
  _setFilterState(e10, t9) {
    const s7 = this._displayIds.get(e10), i7 = this._attributeStore.getHighlightFlag(e10);
    this._attributeStore.setData(s7, 0, 0, i7 | (t9 ? U3 : 0));
  }
  _getGraphicsData(e10, t9, s7) {
    const i7 = this.view, r7 = R(i7.spatialReference), o7 = this._graphicStore.getGraphicsData(e10, t9, s7);
    if (r7) {
      const e11 = Math.round((r7.valid[1] - r7.valid[0]) / t9.resolution);
      for (const t10 of o7)
        t10.geometry && (s(t10.geometry) || l(t10.geometry)) && this._wrapPoints(t10, e11);
    }
    return o7;
  }
  _wrapPoints(e10, t9) {
    const s7 = e10.geometry;
    l(s7) ? this._wrapMultipoint(s7, t9) : this._wrapPoint(e10, t9);
  }
  _wrapMultipoint(e10, t9) {
    const s7 = e10.points, i7 = [];
    let r7 = 0, o7 = 0;
    for (const [a4, n5] of s7) {
      if (i7.push([a4 + r7, n5]), r7 = 0, t9 === f6) {
        const e11 = 5 * g3;
        a4 + o7 < e11 ? (i7.push([t9, 0]), r7 = -t9) : a4 + o7 > f6 - e11 && (i7.push([-t9, 0]), r7 = t9);
      } else
        a4 + o7 < -g3 ? (i7.push([t9, 0]), r7 = -t9) : a4 + o7 > f6 + g3 && (i7.push([-t9, 0]), r7 = t9);
      o7 += a4;
    }
    e10.points = i7;
  }
  _wrapPoint(e10, t9) {
    const s7 = e10.geometry;
    if (t9 === f6) {
      const i7 = 5 * g3;
      s7.x < i7 ? e10.geometry = { points: [[s7.x, s7.y], [t9, 0]] } : s7.x > f6 - i7 && (e10.geometry = { points: [[s7.x, s7.y], [-t9, 0]] });
    } else
      s7.x < -g3 ? e10.geometry = { points: [[s7.x, s7.y], [t9, 0]] } : s7.x > f6 + g3 && (e10.geometry = { points: [[s7.x, s7.y], [-t9, 0]] });
  }
  _processGraphics(e10, t9, s7) {
    if (!(t9 && t9.length) || !this._meshFactory)
      return Promise.resolve(null);
    const i7 = o6.from(t9, this.uid, e10.transform), r7 = this._meshFactory;
    return this._matcher.then((t10) => r7.analyzeGraphics(i7, this.container.stage.resourceManager, t10, null, null, s7).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e10, i7))));
  }
  _processAnalyzedGraphics(e10, t9) {
    const s7 = this._meshFactory, i7 = t9.getSize(), r7 = t9.getCursor(), o7 = { features: i7, records: i7, metrics: 0 }, a4 = new E2(e10.key.id, o7, S.DEFAULT, false, false), n5 = [];
    for (; r7.next(); ) {
      const t10 = r7.readGraphic();
      t10.insertAfter = -1 === t10.insertAfter ? -1 : this._displayIds.get(t10.insertAfter), t10.displayId = this._displayIds.get(t10.attributes[this.uid]);
      const i8 = new e8(t10.displayId);
      i8.insertAfter = t10.insertAfter, n5.push(i8), s7.writeGraphic(a4, r7, e10.level, this.container.stage.resourceManager);
    }
    const h3 = e10.tileInfoView.tileInfo.isWrappable, l6 = a4.serialize(h3);
    if (1 !== l6.length)
      return new g4();
    const d4 = l6[0].message;
    return g4.fromVertexData(d4, n5);
  }
  _abortProcessingGraphic(e10) {
    var _a;
    (_a = this._graphicIdToAbortController.get(e10)) == null ? void 0 : _a.abort();
  }
  _getNullSymbol(e10) {
    const t9 = e10.geometry;
    return f3(t9) ? O2 : y2(t9) || u(t9) ? j3 : this.defaultPointSymbolEnabled ? N : null;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
e([y({ constructOnly: true })], oe2.prototype, "requestUpdateCallback", void 0), e([y()], oe2.prototype, "container", void 0), e([y({ constructOnly: true })], oe2.prototype, "graphics", void 0), e([y()], oe2.prototype, "updating", null), e([y()], oe2.prototype, "view", void 0), e([y()], oe2.prototype, "updateRequested", void 0), e([y()], oe2.prototype, "defaultPointSymbolEnabled", void 0), oe2 = e([a("esri.views.2d.layers.support.GraphicsView2D")], oe2);
var ae = oe2;

export {
  ae
};
//# sourceMappingURL=chunk-XCS3TAXR.js.map

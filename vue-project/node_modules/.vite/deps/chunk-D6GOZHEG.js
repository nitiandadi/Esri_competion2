import {
  p
} from "./chunk-ZLQYAUF7.js";
import {
  c,
  t as t3
} from "./chunk-IAJA5YP7.js";
import {
  He
} from "./chunk-ABCADCZZ.js";
import {
  d as d2
} from "./chunk-IARZYQAP.js";
import {
  O
} from "./chunk-74KT22JL.js";
import {
  x as x2
} from "./chunk-3MAMOMOP.js";
import {
  d
} from "./chunk-37HBRPHL.js";
import {
  m
} from "./chunk-CXBJMCKT.js";
import {
  U
} from "./chunk-JU2WP2RZ.js";
import {
  L
} from "./chunk-6XDV3BWZ.js";
import {
  x
} from "./chunk-FZCZQIVS.js";
import {
  f2 as f,
  w2 as w
} from "./chunk-T5VSOT6T.js";
import {
  o as o2
} from "./chunk-E4M4B5ZQ.js";
import {
  o,
  s as s3
} from "./chunk-HIRLBWV3.js";
import {
  l,
  u2 as u
} from "./chunk-AFQAO5F4.js";
import {
  a2,
  e,
  v2 as v,
  y3 as y
} from "./chunk-OA5ES74L.js";
import {
  a,
  j,
  t2
} from "./chunk-6ZUWLK7F.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-YVZY5LDV.js";
import {
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function t4(r2, t5, o4) {
  t5 = t5.clone(), r2.capabilities.query.supportsMaxRecordCountFactor && (t5.maxRecordCountFactor = u2(r2));
  const i2 = a3(r2), n2 = r2.capabilities.query.supportsPagination;
  t5.start = 0, t5.num = i2;
  let s6 = null;
  for (; ; ) {
    const a6 = await r2.source.queryFeaturesJSON(t5, o4);
    if (t(s6) ? s6 = a6 : s6.features = s6.features.concat(a6.features), s6.exceededTransferLimit = a6.exceededTransferLimit, !n2 || !a6.exceededTransferLimit)
      break;
    t5.start += i2;
  }
  return s6;
}
function a3(e4) {
  return u2(e4) * o3(e4);
}
function o3(e4) {
  return e4.capabilities.query.maxRecordCount || 2e3;
}
function u2(e4) {
  return e4.capabilities.query.supportsMaxRecordCountFactor ? x.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var l2 = o()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var m2 = class extends p {
  constructor(e4) {
    super(e4), this.featureServiceUrl = null, this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(e4) {
    const s6 = { ...e4, query: { f: "json" } }, { data: r2 } = await U(this.statusUrl, s6);
    if (this.read(r2), (this.serviceEdits || this.exceededTransferLimit) && this.featureServiceUrl) {
      const e5 = { edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true };
      d2.emit("edits", { serviceUrl: this.featureServiceUrl ?? "", layerId: null, event: e5 });
    }
    return this;
  }
  async waitForJobCompletion(e4 = {}) {
    const { interval: t5 = 1e3, statusCallback: s6 } = e4;
    return new Promise((e5, i2) => {
      this._clearTimer();
      const o4 = setInterval(() => {
        this._timer || i2(a()), this.checkJobStatus().then((t6) => {
          const { status: r2 } = t6;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), e5(this);
              break;
            case "job-waiting":
            case "job-executing":
              s6 && s6(this);
          }
        }, (e6) => {
          this._clearTimer(), i2(e6);
        });
      }, t5);
      this._timer = o4;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y()], m2.prototype, "featureServiceUrl", void 0), e([y({ type: String, json: { write: true } })], m2.prototype, "statusUrl", void 0), e([o2(l2)], m2.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (e4, t5) => {
  t5.submissionTime = e4 ? e4.getTime() : null;
} } } })], m2.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (e4, t5) => {
  t5.lastUpdatedTime = e4 ? e4.getTime() : null;
} } } })], m2.prototype, "lastUpdatedTime", void 0), m2 = e([a2("esri.networks.support.TopologyValidationJobInfo")], m2);
var u3 = m2;

// node_modules/@arcgis/core/networks/support/utils.js
async function s4(e4, t5) {
  if ("Utility Network Layer" === e4) {
    const { default: e5 } = await import("./UtilityNetwork-R6J2NOVP.js");
    return new e5({ layerUrl: t5 });
  }
  return null;
}
async function i(r2) {
  let a6 = "portalItem" in r2 ? r2 : { portalItem: r2 };
  !a6.portalItem || a6.portalItem instanceof x2 || (a6 = { ...a6, portalItem: new x2(a6.portalItem) });
  const n2 = a6.portalItem;
  if (await n2.load(), "Feature Service" !== n2.type)
    throw new s2("portal:unknown-item-type", "Unknown item type '${type}'", { type: n2.type });
  const l4 = n2.url, i2 = await U(l4, { responseType: "json", query: { f: "json" } }), u5 = "Network Layer";
  if (i2.data.type && i2.data.type.includes(u5))
    return s4(i2.data.type, l4);
  if (i2.data.layers) {
    const e4 = i2.data.layers.find((e5) => e5.type.includes(u5));
    if (e4) {
      const t5 = `${l4}/${e4.id}`;
      return s4(e4.type, t5);
    }
  }
  return null;
}

// node_modules/@arcgis/core/rest/networks/support/QueryNamedTraceConfigurationsParameters.js
var e2 = class extends l {
  constructor(r2) {
    super(r2), this.globalIds = [], this.creators = [], this.tags = [], this.names = [];
  }
};
e([y({ type: [String], json: { write: true } })], e2.prototype, "globalIds", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "creators", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "tags", void 0), e([y({ type: [String], json: { write: true } })], e2.prototype, "names", void 0), e2 = e([a2("esri.rest.networks.support.QueryNamedTraceConfigurationsParameters")], e2);
var p2 = e2;

// node_modules/@arcgis/core/networks/Network.js
var v2 = class extends O(m) {
  static fromPortalItem(e4) {
    return i(e4);
  }
  constructor(e4) {
    super(e4), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null;
  }
  initialize() {
    this.when().catch((e4) => {
      j(e4) || s.getLogger(this.declaredClass).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e4 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return L(this.layerUrl);
  }
  get featureServiceUrl() {
    const e4 = this.parsedUrl && d(this.parsedUrl.path);
    return r(e4) ? e4.url.path : null;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl ? this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer") : null;
  }
  get layerId() {
    const e4 = this.parsedUrl && d(this.parsedUrl.path);
    return r(e4) ? e4.sublayer : null;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e4) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e4)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e4)), this;
  }
  getLayerIdBySourceId(e4) {
    if (this.dataElement) {
      const r2 = this.dataElement.domainNetworks;
      for (const t5 of r2) {
        for (const r3 of t5.edgeSources ? t5.edgeSources : [])
          if (r3.sourceId === e4)
            return r3.layerId;
        for (const r3 of t5.junctionSources ? t5.junctionSources : [])
          if (r3.sourceId === e4)
            return r3.layerId;
      }
      return null;
    }
    return null;
  }
  async queryNamedTraceConfigurations(e4, r2) {
    var _a;
    const { queryNamedTraceConfigurations: t5 } = await import("./queryNamedTraceConfigurations-4UCHTA2V.js"), o4 = this.networkServiceUrl, a6 = new p2({ ...e4 });
    return ((_a = await t5(o4, a6, { ...r2 })) == null ? void 0 : _a.namedTraceConfigurations) ?? null;
  }
  async validateTopology(e4, r2) {
    if (!e4.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const { validateNetworkTopology: o4 } = await import("./validateNetworkTopology-A7CZ3W3M.js"), a6 = this.networkServiceUrl, i2 = await o4(a6, e4, { ...r2 });
    if (i2 == null ? void 0 : i2.serviceEdits) {
      const e5 = { edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: i2.serviceEdits, exceededTransferLimit: false };
      d2.emit("edits", { serviceUrl: this.featureServiceUrl ?? "", layerId: null, event: e5 });
    }
    return i2;
  }
  async submitTopologyValidationJob(e4, r2) {
    if (!e4.validateArea)
      throw new s2("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!e4.gdbVersion)
      throw new s2("network:undefined-gdb-version", "version must be defined");
    const { submitValidateNetworkTopologyJob: o4 } = await import("./validateNetworkTopology-A7CZ3W3M.js"), a6 = this.networkServiceUrl, i2 = await o4(a6, e4, { ...r2 });
    return new u3({ statusUrl: i2, featureServiceUrl: this.featureServiceUrl });
  }
  async _fetchLayerMetaData(e4, t5) {
    const o4 = await U(e4, { responseType: "json", query: { f: "json" }, ...t5 });
    this.sourceJSON = o4.data, this.read(o4.data, { origin: "service" });
  }
  async _fetchDataElement(e4, t5, o4) {
    if (this.dataElement)
      return;
    const a6 = await U(`${e4}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t5]), f: "json" }, ...o4 }).then((e5) => {
      var _a;
      return (_a = e5.data.layerDataElements) == null ? void 0 : _a[0];
    });
    a6 && this.read(a6, { origin: "service" });
  }
};
e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], v2.prototype, "id", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], v2.prototype, "title", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], v2.prototype, "layerUrl", void 0), e([y({ type: Object, json: { origins: { service: { read: true } }, read: false } })], v2.prototype, "dataElement", void 0), e([y({ type: w, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], v2.prototype, "fullExtent", void 0), e([y({ type: f, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], v2.prototype, "spatialReference", void 0), e([y({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], v2.prototype, "type", void 0), e([y({ readOnly: true })], v2.prototype, "datasetName", null), e([y({ readOnly: true })], v2.prototype, "owner", null), e([y({ readOnly: true })], v2.prototype, "schemaGeneration", null), e([y({ readOnly: true })], v2.prototype, "parsedUrl", null), e([y({ readOnly: true })], v2.prototype, "featureServiceUrl", null), e([y({ readOnly: true })], v2.prototype, "networkServiceUrl", null), e([y({ readOnly: true })], v2.prototype, "layerId", null), e([y()], v2.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], v2.prototype, "networkSystemLayers", null), v2 = e([a2("esri.networks.Network")], v2);
var w2 = v2;

// node_modules/@arcgis/core/networks/RulesTable.js
var a4 = class extends u(m) {
  constructor(e4) {
    super(e4), this.request = U;
  }
  initialize() {
  }
  async load(e4) {
    const t5 = this.layer.load(e4).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t5), this;
  }
  getFeatureSQL(e4, t5) {
    var _a, _b;
    const s6 = e4.layerId.toString(), o4 = (_a = e4.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r2 = (_b = e4.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), n2 = o4 ? t5.attributes[o4] : null, i2 = r2 ? t5.attributes[r2] : null, a6 = this.rulesHash[s6];
    if (a6) {
      const e5 = a6.assetGroupHash[n2];
      if (e5) {
        const t6 = e5.assetTypeHash[i2];
        return t6 || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const e4 = {};
    let t5;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(t5 || (t5 = {}));
    const s6 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    for (const o4 of this.rules) {
      if (o4.ruleType !== t3.RTJunctionJunctionConnectivity && o4.ruleType !== t3.RTJunctionEdgeConnectivity && o4.ruleType !== t3.RTEdgeJunctionEdgeConnectivity)
        continue;
      let r2 = [[t5.from, t5.to], [t5.to, t5.from]];
      o4.ruleType === t3.RTEdgeJunctionEdgeConnectivity && (r2 = [[t5.from, t5.via], [t5.via, t5.from], [t5.to, t5.via], [t5.via, t5.to]]);
      for (const n2 of r2) {
        const r3 = n2.shift(), a6 = n2.shift();
        let u5 = false;
        switch (o4.ruleType) {
          case t3.RTEdgeJunctionEdgeConnectivity:
            u5 = r3 === t5.from || r3 === t5.to;
            break;
          case t3.RTJunctionEdgeConnectivity:
            u5 = r3 === t5.to;
        }
        const c2 = s6[r3], p6 = o4[c2.networkSourceId].layerId.toString(), d3 = (_b = (_a = o4[c2.assetGroupId]) == null ? void 0 : _a.assetGroupCode) == null ? void 0 : _b.toString(), l4 = (_d = (_c = o4[c2.assetTypeId]) == null ? void 0 : _c.assetTypeCode) == null ? void 0 : _d.toString(), y2 = s6[a6], f3 = o4[y2.networkSourceId].layerId.toString(), m3 = (_f = (_e = o4[y2.assetGroupId]) == null ? void 0 : _e.assetGroupCode) == null ? void 0 : _f.toString(), T2 = o4[y2.assetTypeId], h = (_g = T2 == null ? void 0 : T2.assetTypeCode) == null ? void 0 : _g.toString(), v3 = e4[p6] ? e4[p6] : { assetGroupHash: {} };
        if (!(d3 && l4 && m3 && h))
          continue;
        const S = v3.assetGroupHash[d3] ? v3.assetGroupHash[d3] : { assetTypeHash: {} }, I = S.assetTypeHash[l4] ? S.assetTypeHash[l4] : {};
        if (I[f3] = I[f3] ? I[f3] : {}, u5) {
          I[p6] = I[p6] ? I[p6] : {};
          const e5 = `(assetgroup = ${d3} AND assettype = ${l4})`;
          I[p6].anyVertex = I[p6].anyVertex ? `${I[p6].anyVertex}` : `${e5}`, "esriNECPEndVertex" === T2.connectivityPolicy && (I[p6].endVertex = ((_h = I[p6]) == null ? void 0 : _h.endVertex) ? `${I[p6].endVertex}` : `${e5}`);
        }
        const g = `(assetgroup = ${m3} AND assettype = ${h})`;
        I[f3].anyVertex = ((_i = I[f3]) == null ? void 0 : _i.anyVertex) ? `${I[f3].anyVertex} OR ${g}` : `${g}`, "esriNECPEndVertex" === T2.connectivityPolicy && (I[f3].endVertex = ((_j = I[f3]) == null ? void 0 : _j.endVertex) ? `${I[f3].endVertex} OR ${g}` : `${g}`), S.assetTypeHash[l4] = I, v3.assetGroupHash[d3] = S, e4[p6] = v3;
      }
    }
    this.rulesHash = e4;
  }
};
e([y({ constructOnly: true })], a4.prototype, "layer", void 0), e([y({ constructOnly: true })], a4.prototype, "rules", void 0), e([y()], a4.prototype, "rulesHash", void 0), e([y({ constructOnly: true })], a4.prototype, "request", void 0), a4 = e([a2("esri.networks.RulesTable")], a4);
var u4 = a4;

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e3 = class extends v {
  constructor(r2) {
    super(r2), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null;
  }
};
e([y({ constructOnly: true })], e3.prototype, "rulesTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "rulesTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerId", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerUrl", void 0), e3 = e([a2("esri.networks.support.NetworkSystemLayers")], e3);
var l3 = e3;

// node_modules/@arcgis/core/networks/support/Terminal.js
var s5 = class extends l {
  constructor(r2) {
    super(r2), this.id = null, this.name = null;
  }
};
e([y({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s5.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s5.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true } })], s5.prototype, "isUpstreamTerminal", void 0), s5 = e([a2("esri.networks.support.Terminal")], s5);
var p3 = s5;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a5 = new s3({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n = class extends l {
  constructor(r2) {
    super(r2), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
e([y({ type: String, json: { write: true } })], n.prototype, "defaultConfiguration", void 0), e([y({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n.prototype, "name", void 0), e([y({ type: [p3], json: { write: true } })], n.prototype, "terminals", void 0), e([y({ type: a5.apiValues, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], n.prototype, "traversabilityModel", void 0), n = e([a2("esri.networks.support.TerminalConfiguration")], n);
var p4 = n;

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var p5 = "esri.networks.UtilityNetwork";
var T = s.getLogger(p5);
var f2 = class extends w2 {
  constructor(e4) {
    super(e4), this.sharedNamedTraceConfigurations = [], this.type = "utility";
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f;
    return new l3({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null });
  }
  get rulesTableId() {
    var _a;
    return t2(T, "rulesTableId", { replacement: "networkSystemLayers.rulesTableId", version: "4.25" }), (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId;
  }
  get rulesTableUrl() {
    return t2(T, "rulesTableUrl", { replacement: "networkSystemLayers.rulesTableUrl", version: "4.25" }), this.sourceJSON ? `${this.featureServiceUrl}/${this.networkSystemLayers.rulesTableId}` : null;
  }
  get subnetworksTableId() {
    var _a;
    return t2(T, "subnetworksTableId", { replacement: "networkSystemLayers.subnetworksTableId", version: "4.25" }), (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.subnetworksTableId;
  }
  get subnetworksTableUrl() {
    return t2(T, "subnetworksTableUrl", { replacement: "networkSystemLayers.subnetworksTableUrl", version: "4.25" }), this.sourceJSON ? `${this.featureServiceUrl}/${this.networkSystemLayers.subnetworksTableId}` : null;
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e4) => p4.fromJSON(e4))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e4) => e4.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e4 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t5) => {
      t5.edgeSources.map((t6) => {
        e4.add(t6.layerId);
      }), t5.junctionSources.map((t6) => {
        e4.add(t6.layerId);
      });
    }), e4;
  }
  async load(e4) {
    return this.addResolvingPromise(super.load(e4)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e4)), this;
  }
  getTerminalConfiguration(e4) {
    var _a, _b, _c, _d;
    let t5 = null, r2 = null;
    const s6 = e4.layer;
    let a6 = null;
    if ("feature" !== (s6 == null ? void 0 : s6.type))
      return null;
    if (a6 = s6.layerId, null === a6)
      return null;
    const o4 = e4.attributes;
    if (null == o4)
      return null;
    for (const l4 of Object.keys(o4))
      "ASSETGROUP" === l4.toUpperCase() && (t5 = e4.getAttribute(l4)), "ASSETTYPE" === l4.toUpperCase() && (r2 = e4.getAttribute(l4));
    if (!this.dataElement)
      return null;
    let n2 = null;
    const i2 = this.dataElement.domainNetworks;
    for (const l4 of i2) {
      const e5 = (_a = l4.junctionSources) == null ? void 0 : _a.find((e6) => e6.layerId === a6);
      if (e5) {
        const s7 = (_b = e5.assetGroups) == null ? void 0 : _b.find((e6) => e6.assetGroupCode === t5);
        if (s7) {
          const e6 = (_c = s7.assetTypes) == null ? void 0 : _c.find((e7) => e7.assetTypeCode === r2);
          if (e6) {
            n2 = e6.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != n2) {
      const e5 = (_d = this.dataElement.terminalConfigurations) == null ? void 0 : _d.find((e6) => e6.terminalConfigurationId === n2);
      return e5 ? p4.fromJSON(e5) : null;
    }
    return null;
  }
  getTierNames(e4) {
    var _a;
    const t5 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t6) => t6.domainNetworkName === e4);
    return (t5 == null ? void 0 : t5.tiers.map((e5) => e5.name)) || [];
  }
  async getRulesTable() {
    return this._createRulesTable();
  }
  isUtilityLayer(e4) {
    return this._utilityLayerList.has(e4.layerId);
  }
  async _loadNamedTraceConfigurationsFromNetwork(e4) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length))
      return;
    const t5 = this.sharedNamedTraceConfigurations.map((e5) => e5.globalId), r2 = await this.queryNamedTraceConfigurations({ globalIds: t5 }, e4);
    for (const s6 of this.sharedNamedTraceConfigurations) {
      const e5 = r2 == null ? void 0 : r2.find((e6) => e6.globalId === s6.globalId);
      if (e5) {
        const t6 = e5.write({}, { origin: "service" });
        s6.read(t6, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e4 = new He({ url: this.rulesTableUrl });
    await e4.load();
    const t5 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!t5)
      return null;
    const r2 = t5.flatMap((e5) => [...e5.edgeSources, ...e5.junctionSources]), s6 = (await this._queryRulesTable(e4)).map((t6) => this._hydrateRuleInfo(e4, r2, t6));
    return new u4({ layer: e4, rules: s6 });
  }
  async _queryRulesTable(e4) {
    const t5 = new x({ where: "1=1", outFields: ["*"] });
    return (await t4(e4, t5)).features;
  }
  _hydrateRuleInfo(e4, t5, r2) {
    const s6 = e4.fieldsIndex, a6 = s6.get("RULETYPE"), o4 = s6.get("CREATIONDATE"), n2 = s6.get("FROMNETWORKSOURCEID"), i2 = s6.get("FROMASSETGROUP"), l4 = s6.get("FROMASSETTYPE"), u5 = s6.get("FROMTERMINALID"), d3 = s6.get("TONETWORKSOURCEID"), m3 = s6.get("TOASSETGROUP"), y2 = s6.get("TOASSETTYPE"), p6 = s6.get("TOTERMINALID"), T2 = s6.get("VIANETWORKSOURCEID"), f3 = s6.get("VIAASSETGROUP"), b2 = s6.get("VIAASSETTYPE"), g = s6.get("VIATERMINALID"), I = r2.attributes[a6.name], S = new Date(r2.attributes[o4.name]), h = [{ networkSourceId: r2.attributes[n2.name], assetGroupId: r2.attributes[i2.name], assetTypeId: r2.attributes[l4.name], terminalId: r2.attributes[u5.name] }, { networkSourceId: r2.attributes[d3.name], assetGroupId: r2.attributes[m3.name], assetTypeId: r2.attributes[y2.name], terminalId: r2.attributes[p6.name] }, { networkSourceId: r2.attributes[T2.name], assetGroupId: r2.attributes[f3.name], assetTypeId: r2.attributes[b2.name], terminalId: r2.attributes[g.name] }];
    let w3;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(w3 || (w3 = {}));
    const N = { ruleType: I, creationDate: S };
    for (const k of [w3.from, w3.to, w3.via]) {
      if (I !== t3.RTEdgeJunctionEdgeConnectivity && k === w3.via)
        continue;
      const e5 = h[k], r3 = t5.find((t6) => t6.sourceId === e5.networkSourceId), s7 = r3 == null ? void 0 : r3.assetGroups.find((t6) => t6.assetGroupCode === e5.assetGroupId), a7 = s7 == null ? void 0 : s7.assetTypes.find((t6) => t6.assetTypeCode === e5.assetTypeId);
      let o5 = this._getTerminal(I, a7, e5);
      I !== t3.RTContainment && I !== t3.RTAttachment || (o5 = null);
      let n3 = "";
      switch (k) {
        case w3.from:
          n3 = "from";
          break;
        case w3.to:
          n3 = "to";
          break;
        case w3.via:
          n3 = "via";
      }
      N[`${n3}NetworkSource`] = r3, N[`${n3}AssetGroup`] = s7, N[`${n3}AssetType`] = a7, N[`${n3}Terminal`] = o5;
    }
    return N;
  }
  _getTerminal(e4, t5, r2) {
    var _a, _b;
    if (e4 === t3.RTAttachment || e4 === t3.RTContainment)
      return null;
    const s6 = t5 == null ? void 0 : t5.terminalConfigurationId, a6 = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e5) => e5.id === s6);
    return ((_b = a6 == null ? void 0 : a6.terminals) == null ? void 0 : _b.find((e5) => e5.id === r2.terminalId)) ?? null;
  }
};
e([y({ type: [c], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], f2.prototype, "sharedNamedTraceConfigurations", void 0), e([y({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], f2.prototype, "type", void 0), e([y({ readOnly: true })], f2.prototype, "serviceTerritoryFeatureLayerId", null), e([y({ readOnly: true })], f2.prototype, "networkSystemLayers", null), e([y({ readOnly: true })], f2.prototype, "rulesTableId", null), e([y({ readOnly: true })], f2.prototype, "rulesTableUrl", null), e([y({ readOnly: true })], f2.prototype, "subnetworksTableId", null), e([y({ readOnly: true })], f2.prototype, "subnetworksTableUrl", null), e([y({ readOnly: true })], f2.prototype, "terminalConfigurations", null), e([y({ readOnly: true })], f2.prototype, "domainNetworkNames", null), f2 = e([a2("esri.networks.UtilityNetwork")], f2);
var b = f2;

export {
  b
};
//# sourceMappingURL=chunk-D6GOZHEG.js.map

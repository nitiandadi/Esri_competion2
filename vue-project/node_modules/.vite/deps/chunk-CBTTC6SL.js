import {
  n,
  r as r5
} from "./chunk-CJ2YD4VU.js";
import {
  C,
  a,
  g,
  j as j2,
  l,
  o,
  q,
  r as r3,
  s,
  v,
  y,
  z
} from "./chunk-JGIZLXNQ.js";
import {
  u
} from "./chunk-YWFASVWM.js";
import {
  M,
  c,
  e,
  f as f2,
  h,
  i,
  r as r4
} from "./chunk-77E52HT5.js";
import {
  An,
  en,
  rn,
  tn
} from "./chunk-T5PSDOZP.js";
import {
  r as r2
} from "./chunk-EGHLQERQ.js";
import {
  j
} from "./chunk-SZO7ZKE4.js";
import {
  $,
  E,
  I,
  R,
  f2 as f,
  p3 as p,
  w,
  w2
} from "./chunk-H2ENCYR3.js";
import {
  r,
  t,
  x
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/chunks/mat2df64.js
function e2() {
  return [1, 0, 0, 1, 0, 0];
}
function r6(e3) {
  return [e3[0], e3[1], e3[2], e3[3], e3[4], e3[5]];
}
function t2(e3, r7, t3, n3, o3, a2) {
  return [e3, r7, t3, n3, o3, a2];
}
function n2(e3, r7) {
  return new Float64Array(e3, r7, 6);
}
var o2 = Object.freeze(Object.defineProperty({ __proto__: null, clone: r6, create: e2, createView: n2, fromValues: t2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/2d/viewpointUtils.js
var Q = 96;
var U = 39.37;
var B = 180 / Math.PI;
function D(t3) {
  return t3.wkid ? t3 : t3.spatialReference || f.WGS84;
}
function T(t3, e3) {
  return e3.type ? r3(t3, e3.x, e3.y) : a(t3, e3);
}
function W(t3) {
  return $(t3);
}
function H(t3, e3) {
  const n3 = Math.max(1, e3[0]), r7 = Math.max(1, e3[1]);
  return Math.max(t3.width / n3, t3.height / r7) * ct(t3.spatialReference);
}
async function J(t3, a2, i2, c2) {
  let s2, u2;
  if (!t3)
    return null;
  if (Array.isArray(t3) && !t3.length)
    return null;
  if (j.isCollection(t3) && (t3 = t3.toArray()), Array.isArray(t3) && t3.length && "object" == typeof t3[0]) {
    const e3 = t3.every((t4) => "attributes" in t4), r7 = t3.some((t4) => !t4.geometry);
    let o3 = t3;
    if (e3 && r7 && a2 && a2.allLayerViews) {
      const e4 = /* @__PURE__ */ new Map();
      for (const n3 of t3) {
        const t4 = n3.layer, r9 = e4.get(t4) || [], o4 = n3.attributes[t4.objectIdField];
        null != o4 && r9.push(o4), e4.set(t4, r9);
      }
      const r8 = [];
      e4.forEach((t4, e5) => {
        const n3 = a2.allLayerViews.find((t5) => t5.layer.id === e5.id);
        if (n3 && "queryFeatures" in n3) {
          const o4 = e5.createQuery();
          o4.objectIds = t4, o4.returnGeometry = true, r8.push(n3.queryFeatures(o4));
        }
      });
      const i3 = await Promise.all(r8), c3 = [];
      for (const t4 of i3)
        if (t4 && t4.features && t4.features.length)
          for (const e5 of t4.features)
            r(e5.geometry) && c3.push(e5.geometry);
      o3 = c3;
    }
    for (const t4 of o3)
      c2 = await J(t4, a2, i2, c2);
    return c2;
  }
  if (Array.isArray(t3) && 2 === t3.length && "number" == typeof t3[0] && "number" == typeof t3[1])
    s2 = new w(t3);
  else if (t3 instanceof p)
    s2 = t3;
  else if ("geometry" in t3) {
    if (t3.geometry)
      s2 = t3.geometry;
    else if (t3.layer) {
      const e3 = t3.layer, n3 = a2.allLayerViews.find((t4) => t4.layer.id === e3.id);
      if (n3 && "queryFeatures" in n3) {
        const o3 = e3.createQuery();
        o3.objectIds = [t3.attributes[e3.objectIdField]], o3.returnGeometry = true;
        const a3 = await n3.queryFeatures(o3);
        s2 = x(a3, "features", 0, "geometry");
      }
    }
  }
  if (t(s2))
    return null;
  if (u2 = "point" === s2.type ? new w2({ xmin: s2.x, ymin: s2.y, xmax: s2.x, ymax: s2.y, spatialReference: s2.spatialReference }) : s2.extent, !u2)
    return null;
  en() || An(u2.spatialReference, i2) || await tn();
  const f3 = rn(u2, i2);
  return f3 ? c2 = c2 ? c2.union(f3) : f3 : null;
}
function K(t3) {
  if (t3 && (!Array.isArray(t3) || "number" != typeof t3[0]) && ("object" == typeof t3 || Array.isArray(t3) && "object" == typeof t3[0])) {
    if ("layer" in t3 && t3.layer && t3.layer.minScale && t3.layer.maxScale) {
      const e3 = t3.layer;
      return { min: e3.minScale, max: e3.maxScale };
    }
    if (Array.isArray(t3) && t3.length && t3.every((t4) => "layer" in t4)) {
      let e3 = 0, n3 = 0;
      for (const r7 of t3) {
        const t4 = r7.layer;
        t4 && t4.minScale && t4.maxScale && (e3 = t4.minScale < e3 ? t4.minScale : e3, n3 = t4.maxScale > n3 ? t4.maxScale : n3);
      }
      return e3 && n3 ? { min: e3, max: n3 } : null;
    }
  }
}
function X(t3, e3) {
  return E(D(t3), e3) ? t3 : rn(t3, e3);
}
async function Y(e3, r7) {
  if (!e3 || !r7)
    return new u({ targetGeometry: new w(), scale: 0, rotation: 0 });
  let o3 = r7.spatialReference;
  const { constraints: a2, padding: i2, viewpoint: c2, size: s2 } = r7, u2 = [i2 ? s2[0] - i2.left - i2.right : s2[0], i2 ? s2[1] - i2.top - i2.bottom : s2[1]];
  let f3 = null;
  e3 instanceof u ? f3 = e3 : e3.viewpoint ? f3 = e3.viewpoint : e3.target && "esri.Viewpoint" === e3.target.declaredClass && (f3 = e3.target);
  let l2 = null;
  f3 && f3.targetGeometry ? l2 = f3.targetGeometry : e3 instanceof w2 ? l2 = e3 : (e3 || e3 && ("center" in e3 || "extent" in e3 || "target" in e3)) && (l2 = await J(e3.center, r7, o3) || await J(e3.extent, r7, o3) || await J(e3.target, r7, o3) || await J(e3, r7, o3)), !l2 && c2 && c2.targetGeometry ? l2 = c2.targetGeometry : !l2 && r7.extent && (l2 = r7.extent), o3 || (o3 = D(r7.spatialReference || r7.extent || l2)), en() || E(l2.spatialReference, o3) || An(l2, o3) || await tn();
  const m = X(l2.center ? l2.center : l2, o3);
  let y2 = 0;
  if (f3 && r(f3.targetGeometry) && "point" === f3.targetGeometry.type)
    y2 = f3.scale;
  else if ("scale" in e3 && e3.scale)
    y2 = e3.scale;
  else if ("zoom" in e3 && -1 !== e3.zoom && a2 && a2.effectiveLODs)
    y2 = a2.zoomToScale(e3.zoom);
  else if (Array.isArray(l2) || "point" === l2.type || "extent" === l2.type && 0 === l2.width && 0 === l2.height) {
    const t3 = X(r7.extent, o3);
    y2 = r(t3) ? H(t3, u2) : r7.extent ? H(r7.extent, u2) : c2.scale;
  } else
    y2 = H(X(l2.extent, o3), u2);
  const p2 = K(e3);
  p2 && (p2.min && p2.min > y2 ? y2 = p2.min : p2.max && p2.max < y2 && (y2 = p2.max));
  let g2 = 0;
  f3 ? g2 = f3.rotation : e3.hasOwnProperty("rotation") ? g2 = e3.rotation : c2 && (g2 = c2.rotation);
  let x2 = new u({ targetGeometry: m, scale: y2, rotation: g2 });
  return a2 && (x2 = a2.fit(x2), a2.constrainByGeometry(x2), a2.rotationEnabled || (x2.rotation = g2)), x2;
}
function Z(t3, e3) {
  const n3 = t3.targetGeometry, r7 = e3.targetGeometry;
  return n3.x = r7.x, n3.y = r7.y, n3.spatialReference = r7.spatialReference, t3.scale = e3.scale, t3.rotation = e3.rotation, t3;
}
function $2(t3, e3, n3) {
  return n3 ? r3(t3, 0.5 * (e3[0] - n3.right + n3.left), 0.5 * (e3[1] - n3.bottom + n3.top)) : l(t3, e3, 0.5);
}
var _ = function() {
  const t3 = n();
  return function(e3, n3, r7) {
    const o3 = n3.targetGeometry;
    T(t3, o3);
    const a2 = 0.5 * ot(n3);
    return e3.xmin = t3[0] - a2 * r7[0], e3.ymin = t3[1] - a2 * r7[1], e3.xmax = t3[0] + a2 * r7[0], e3.ymax = t3[1] + a2 * r7[1], e3.spatialReference = o3.spatialReference, e3;
  };
}();
function tt(t3, e3, n3, r7, o3) {
  return xt(t3, e3, n3.center), t3.scale = H(n3, r7), o3 && o3.constraints && o3.constraints.constrain(t3), t3;
}
function et(t3, e3, n3, r7) {
  return ft(t3, e3, n3, r7), r4(t3, t3);
}
var nt = function() {
  const t3 = n();
  return function(e3, n3, r7) {
    return C(e3, st(e3, n3), $2(t3, n3, r7));
  };
}();
var rt = function() {
  const t3 = e2(), e3 = n();
  return function(n3, r7, o3, a2) {
    const i2 = ot(r7), f3 = it(r7);
    return r3(e3, i2, i2), M(t3, e3), e(t3, t3, f3), i(t3, t3, nt(e3, o3, a2)), i(t3, t3, [0, a2.top - a2.bottom]), r3(n3, t3[4], t3[5]);
  };
}();
function ot(t3) {
  return t3.scale * at(t3.targetGeometry);
}
function at(t3) {
  return r(t3) && I(t3.spatialReference) ? 1 / (W(t3.spatialReference) * U * Q) : 1;
}
function it(t3) {
  return r2(t3.rotation) || 0;
}
function ct(t3) {
  return I(t3) ? W(t3) * U * Q : 1;
}
function st(t3, e3) {
  return l(t3, e3, 0.5);
}
var ut = function() {
  const t3 = n(), e3 = n(), n3 = n();
  return function(r7, o3, a2, i2, c2, m) {
    return g(t3, o3), l(e3, a2, 0.5 * m), r3(n3, 1 / i2 * m, -1 / i2 * m), f2(r7, e3), c2 && e(r7, r7, c2), c(r7, r7, n3), i(r7, r7, t3), r7;
  };
}();
var ft = function() {
  const t3 = n();
  return function(e3, n3, r7, o3) {
    const a2 = ot(n3), i2 = it(n3);
    return T(t3, n3.targetGeometry), ut(e3, t3, r7, a2, i2, o3);
  };
}();
var lt = function() {
  const t3 = n();
  return function(e3, n3, r7, o3) {
    const a2 = ot(n3);
    return T(t3, n3.targetGeometry), ut(e3, t3, r7, a2, 0, o3);
  };
}();
function mt(t3) {
  const e3 = R(t3);
  return e3 ? e3.valid[1] - e3.valid[0] : 0;
}
function yt(t3, e3) {
  return Math.round(mt(t3) / e3);
}
var pt = function() {
  const t3 = n(), e3 = n(), n3 = [0, 0, 0];
  return function(r7, o3, a2) {
    o(t3, r7, o3), v(t3, t3), o(e3, r7, a2), v(e3, e3), y(n3, t3, e3);
    let i2 = Math.acos(j2(t3, e3) / (q(t3) * q(e3))) * B;
    return n3[2] < 0 && (i2 = -i2), isNaN(i2) && (i2 = 0), i2;
  };
}();
var gt = function() {
  const t3 = n();
  return function(e3, n3, r7, o3) {
    const a2 = e3.targetGeometry;
    return Z(e3, n3), rt(t3, n3, r7, o3), a2.x += t3[0], a2.y += t3[1], e3;
  };
}();
var xt = function(t3, e3, n3) {
  Z(t3, e3);
  const r7 = t3.targetGeometry;
  return r7.x = n3.x, r7.y = n3.y, r7.spatialReference = n3.spatialReference, t3;
};
var ht = function() {
  const t3 = n();
  return function(e3, n3, r7, o3, a2) {
    a2 || (a2 = "center"), C(t3, r7, o3), l(t3, t3, 0.5);
    const i2 = t3[0], c2 = t3[1];
    switch (a2) {
      case "center":
        r3(t3, 0, 0);
        break;
      case "left":
        r3(t3, -i2, 0);
        break;
      case "top":
        r3(t3, 0, c2);
        break;
      case "right":
        r3(t3, i2, 0);
        break;
      case "bottom":
        r3(t3, 0, -c2);
        break;
      case "top-left":
        r3(t3, -i2, c2);
        break;
      case "bottom-left":
        r3(t3, -i2, -c2);
        break;
      case "top-right":
        r3(t3, i2, c2);
        break;
      case "bottom-right":
        r3(t3, i2, -c2);
    }
    return St(e3, n3, t3), e3;
  };
}();
function bt(t3, e3, n3) {
  return Z(t3, e3), t3.rotation += n3, t3;
}
function wt(t3, e3, n3) {
  return Z(t3, e3), t3.rotation = n3, t3;
}
var dt = function() {
  const t3 = n();
  return function(e3, n3, r7, o3, a2) {
    return Z(e3, n3), isNaN(r7) || 0 === r7 || (At(t3, o3, n3, a2), e3.scale = n3.scale * r7, kt(t3, t3, e3, a2), St(e3, e3, r3(t3, t3[0] - o3[0], o3[1] - t3[1]))), e3;
  };
}();
function jt(t3, e3, n3) {
  return Z(t3, e3), t3.scale = n3, t3;
}
var Gt = function() {
  const t3 = n();
  return function(e3, n3, r7, o3, a2, i2) {
    return Z(e3, n3), isNaN(r7) || 0 === r7 || (At(t3, a2, n3, i2), e3.scale = n3.scale * r7, e3.rotation += o3, kt(t3, t3, e3, i2), St(e3, e3, r3(t3, t3[0] - a2[0], a2[1] - t3[1]))), e3;
  };
}();
var Rt = function() {
  const t3 = n(), e3 = n();
  return function(n3, r7, o3, a2, i2, c2, s2) {
    return nt(e3, c2, s2), s(t3, i2, e3), a2 ? Gt(n3, r7, o3, a2, t3, c2) : dt(n3, r7, o3, t3, c2);
  };
}();
var At = function() {
  const t3 = e2();
  return function(e3, n3, r7, o3) {
    return z(e3, n3, et(t3, r7, o3, 1));
  };
}();
var kt = function() {
  const t3 = e2();
  return function(e3, n3, r7, o3) {
    return z(e3, n3, ft(t3, r7, o3, 1));
  };
}();
var St = function() {
  const t3 = n(), e3 = e2();
  return function(n3, r7, o3) {
    Z(n3, r7);
    const a2 = ot(r7), i2 = n3.targetGeometry;
    return h(e3, it(r7)), c(e3, e3, r5(a2, a2)), z(t3, o3, e3), i2.x += t3[0], i2.y += t3[1], n3;
  };
}();

export {
  e2 as e,
  H,
  Y,
  Z,
  $2 as $,
  _,
  tt,
  nt,
  ot,
  ut,
  ft,
  lt,
  mt,
  yt,
  pt,
  gt,
  xt,
  ht,
  bt,
  wt,
  jt,
  Gt,
  Rt,
  St
};
//# sourceMappingURL=chunk-CBTTC6SL.js.map

import {
  s as s3
} from "./chunk-ABJJZKPH.js";
import "./chunk-4UCOZDWC.js";
import "./chunk-GK4XSQTX.js";
import "./chunk-LT2MTVPF.js";
import "./chunk-V6QYNDMP.js";
import {
  v
} from "./chunk-76KZNCTA.js";
import {
  p
} from "./chunk-2HL3WCZQ.js";
import {
  u
} from "./chunk-3ZOUEUIN.js";
import "./chunk-NOYFNECX.js";
import "./chunk-7HK5OJHH.js";
import {
  _
} from "./chunk-VRZTCZFJ.js";
import {
  c
} from "./chunk-CPJE5ZZA.js";
import {
  f as f2
} from "./chunk-LJFFMEVT.js";
import "./chunk-5IWWLTWU.js";
import {
  O
} from "./chunk-74KT22JL.js";
import "./chunk-BQHZXXFC.js";
import {
  b
} from "./chunk-4JB2KWLF.js";
import "./chunk-3MAMOMOP.js";
import "./chunk-QPSL5BDS.js";
import "./chunk-37HBRPHL.js";
import "./chunk-AIOICOJJ.js";
import "./chunk-HWGER6NN.js";
import "./chunk-FI2SN5P7.js";
import "./chunk-ZXEHLMMH.js";
import "./chunk-F6Y6UABE.js";
import "./chunk-4ZMXDH56.js";
import "./chunk-EOI6A2XM.js";
import "./chunk-5W2WWLX7.js";
import "./chunk-EXHPOUUQ.js";
import "./chunk-6PNW7TCI.js";
import "./chunk-QP5ZWBKN.js";
import "./chunk-YSJ4W32U.js";
import "./chunk-PK5IA5PH.js";
import "./chunk-CXHYHUY6.js";
import "./chunk-CXBJMCKT.js";
import "./chunk-ULOJUU6K.js";
import "./chunk-3CXPBSW5.js";
import "./chunk-PLL74BYO.js";
import "./chunk-AMV7VELH.js";
import "./chunk-33RBBVRO.js";
import "./chunk-II3EAW7L.js";
import {
  U
} from "./chunk-JU2WP2RZ.js";
import "./chunk-NI6ENKKR.js";
import {
  A
} from "./chunk-6XDV3BWZ.js";
import "./chunk-OTDDRQS2.js";
import "./chunk-W3UIP6CW.js";
import "./chunk-CHJGFW3N.js";
import "./chunk-QLGPYDHY.js";
import "./chunk-IMKS3PQX.js";
import "./chunk-5WYME2YP.js";
import "./chunk-PEP3ZFMY.js";
import "./chunk-VOSZ2G24.js";
import "./chunk-YMGINT43.js";
import "./chunk-2WLZX6A7.js";
import "./chunk-M7CMZTD6.js";
import "./chunk-ERJGVLTB.js";
import "./chunk-T5VSOT6T.js";
import "./chunk-OHZM2VYI.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-JATK7CEQ.js";
import {
  o
} from "./chunk-74TXAD7S.js";
import "./chunk-HIRLBWV3.js";
import "./chunk-AFQAO5F4.js";
import {
  a2 as a,
  e,
  n2 as n,
  y3 as y2
} from "./chunk-OA5ES74L.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-RLEMMDH4.js";
import {
  f,
  w
} from "./chunk-6ZUWLK7F.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-YVZY5LDV.js";
import "./chunk-H32MMKAJ.js";
import {
  F
} from "./chunk-MKHZ5X6F.js";
import {
  e as e2,
  r,
  t,
  y
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/support/ElevationTileData.js
var e3 = class {
  constructor(a2, t2, s5, e4) {
    this._hasNoDataValues = null, this._minValue = null, this._maxValue = null, "pixelData" in a2 ? (this.values = a2.pixelData, this.width = a2.width, this.height = a2.height, this.noDataValue = a2.noDataValue) : (this.values = a2, this.width = t2, this.height = s5, this.noDataValue = e4);
  }
  get hasNoDataValues() {
    if (t(this._hasNoDataValues)) {
      const a2 = this.noDataValue;
      this._hasNoDataValues = this.values.includes(a2);
    }
    return this._hasNoDataValues;
  }
  get minValue() {
    return this._ensureBounds(), e2(this._minValue);
  }
  get maxValue() {
    return this._ensureBounds(), e2(this._maxValue);
  }
  _ensureBounds() {
    if (r(this._minValue))
      return;
    const { noDataValue: a2, values: t2 } = this;
    let e4 = 1 / 0, i = -1 / 0, h2 = true;
    for (const s5 of t2)
      s5 === a2 ? this._hasNoDataValues = true : (e4 = s5 < e4 ? s5 : e4, i = s5 > i ? s5 : i, h2 = false);
    h2 ? (this._minValue = 0, this._maxValue = 0) : (this._minValue = e4, this._maxValue = i > -3e38 ? i : 0);
  }
};

// node_modules/@arcgis/core/core/workers/WorkerHandle.js
var h = class {
  constructor(e4, t2, s5, i, h2 = {}) {
    this._mainMethod = t2, this._transferLists = s5, this._listeners = [], this._promise = u(e4, { ...h2, schedule: i }).then((e5) => {
      if (void 0 === this._thread) {
        this._thread = e5, this._promise = null, h2.hasInitialize && this.broadcast({}, "initialize");
        for (const e6 of this._listeners)
          this._connectListener(e6);
      } else
        e5.close();
    }), this._promise.catch((t3) => s.getLogger("esri.core.workers.WorkerHandle").error(`Failed to initialize ${e4} worker: ${t3}`));
  }
  on(r2, i) {
    const o3 = { removed: false, eventName: r2, callback: i, threadHandle: null };
    return this._listeners.push(o3), this._connectListener(o3), n(() => {
      o3.removed = true, F(this._listeners, o3), this._thread && r(o3.threadHandle) && o3.threadHandle.remove();
    });
  }
  destroy() {
    this._thread && (this._thread.close(), this._thread = null), this._promise = null;
  }
  invoke(e4, t2) {
    return this.invokeMethod(this._mainMethod, e4, t2);
  }
  invokeMethod(e4, t2, r2) {
    if (this._thread) {
      const s5 = this._transferLists[e4], i = s5 ? s5(t2) : [];
      return this._thread.invoke(e4, t2, { transferList: i, signal: r2 });
    }
    return this._promise ? this._promise.then(() => (f(r2), this.invokeMethod(e4, t2, r2))) : Promise.reject(null);
  }
  broadcast(e4, t2) {
    return this._thread ? Promise.all(this._thread.broadcast(t2, e4)).then(() => {
    }) : this._promise ? this._promise.then(() => this.broadcast(e4, t2)) : Promise.reject();
  }
  get promise() {
    return this._promise;
  }
  _connectListener(e4) {
    this._thread && this._thread.on(e4.eventName, e4.callback).then((t2) => {
      e4.removed || (e4.threadHandle = t2);
    });
  }
};

// node_modules/@arcgis/core/layers/support/LercDecoder.js
var s4 = class extends h {
  constructor(e4 = null) {
    super("LercWorker", "_decode", { _decode: (e5) => [e5.buffer] }, e4, { strategy: "dedicated" }), this.schedule = e4, this.ref = 0;
  }
  decode(e4, r2, t2) {
    return e4 && 0 !== e4.byteLength ? this.invoke({ buffer: e4, options: r2 }, t2) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (o2.forEach((e4, r2) => {
      e4 === this && o2.delete(r2);
    }), this.destroy());
  }
};
var o2 = /* @__PURE__ */ new Map();
function n2(t2 = null) {
  let n3 = o2.get(e2(t2));
  return n3 || (r(t2) ? (n3 = new s4((e4) => t2.immediate.schedule(e4)), o2.set(t2, n3)) : (n3 = new s4(), o2.set(null, n3))), ++n3.ref, n3;
}

// node_modules/@arcgis/core/layers/ElevationLayer.js
var w2 = class extends s3(p(c(_(O(b))))) {
  constructor(...e4) {
    super(...e4), this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = n2();
  }
  normalizeCtorArgs(e4, r2) {
    return "string" == typeof e4 ? { url: e4, ...r2 } : e4;
  }
  destroy() {
    this._lercDecoder = y(this._lercDecoder);
  }
  readVersion(e4, r2) {
    let t2 = r2.currentVersion;
    return t2 || (t2 = 9.3), t2;
  }
  load(e4) {
    const r2 = r(e4) ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e5) => {
      for (let r3 = 0; r3 < e5.typeKeywords.length; r3++)
        if ("elevation 3d layer" === e5.typeKeywords[r3].toLowerCase())
          return true;
      throw new s2("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e4).catch(w).then(() => this._fetchImageService(r2))), Promise.resolve(this);
  }
  fetchTile(e4, t2, o3, s5) {
    const a2 = r((s5 = s5 || { signal: null }).signal) ? s5.signal : s5.signal = new AbortController().signal, l = { responseType: "array-buffer", signal: a2 }, p2 = { noDataValue: s5.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e4, t2, o3, s5)).then(() => U(this.getTileUrl(e4, t2, o3), l)).then((e5) => this._lercDecoder.decode(e5.data, p2, a2)).then((e5) => new e3(e5));
  }
  getTileUrl(e4, r2, t2) {
    const o3 = !this.tilemapCache && this.supportsBlankTile, i = A({ ...this.parsedUrl.query, blankTile: !o3 && null });
    return `${this.parsedUrl.path}/tile/${e4}/${r2}/${t2}${i ? "?" + i : ""}`;
  }
  async queryElevation(e4, r2) {
    const { ElevationQuery: t2 } = await import("./ElevationQuery-TWFEVDGX.js");
    f(r2);
    return new t2().query(this, e4, r2);
  }
  async createElevationSampler(e4, r2) {
    const { ElevationQuery: t2 } = await import("./ElevationQuery-TWFEVDGX.js");
    f(r2);
    return new t2().createSampler(this, e4, r2);
  }
  _fetchTileAvailability(e4, r2, t2, o3) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e4, r2, t2, o3) : Promise.resolve("unknown");
  }
  async _fetchImageService(e4) {
    var _a;
    if (this.sourceJSON)
      return this.sourceJSON;
    const t2 = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e4 }, o3 = await U(this.parsedUrl.path, t2);
    o3.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = o3.data, this.read(o3.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile.__isDefault__;
  }
};
e([y2({ json: { read: { source: "copyrightText" } } })], w2.prototype, "copyright", void 0), e([y2({ readOnly: true, type: v })], w2.prototype, "heightModelInfo", void 0), e([y2({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], w2.prototype, "path", void 0), e([y2({ type: ["show", "hide"] })], w2.prototype, "listMode", void 0), e([y2({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w2.prototype, "minScale", void 0), e([y2({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w2.prototype, "maxScale", void 0), e([y2({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], w2.prototype, "opacity", void 0), e([y2({ type: ["ArcGISTiledElevationServiceLayer"] })], w2.prototype, "operationalLayerType", void 0), e([y2()], w2.prototype, "sourceJSON", void 0), e([y2({ json: { read: false }, value: "elevation", readOnly: true })], w2.prototype, "type", void 0), e([y2(f2)], w2.prototype, "url", void 0), e([y2()], w2.prototype, "version", void 0), e([o("version", ["currentVersion"])], w2.prototype, "readVersion", null), w2 = e([a("esri.layers.ElevationLayer")], w2), w2.prototype.fetchTile.__isDefault__ = true;
var T = w2;
export {
  T as default
};
//# sourceMappingURL=ElevationLayer-NSEGRML4.js.map

import {
  n,
  s as s2
} from "./chunk-I4IOU32T.js";
import {
  a as a2
} from "./chunk-CMMKNUCY.js";
import {
  f as f2,
  x as x2
} from "./chunk-OIJ5J5ZA.js";
import {
  ut,
  wt
} from "./chunk-XXDTEEJA.js";
import {
  f
} from "./chunk-WVLEGBEW.js";
import {
  x as x3
} from "./chunk-G356VNM2.js";
import {
  o
} from "./chunk-7YGY53FV.js";
import {
  x
} from "./chunk-IFB6JAZV.js";
import {
  K
} from "./chunk-IMDA6RVE.js";
import {
  L
} from "./chunk-M3KO43BW.js";
import {
  w2 as w
} from "./chunk-XFNXUG2G.js";
import {
  a2 as a,
  e,
  v2 as v,
  y3 as y2
} from "./chunk-3PPVODAA.js";
import {
  y
} from "./chunk-WTKFW2TD.js";
import {
  s2 as s
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  c,
  i,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/rest/query/executeForExtent.js
async function m(m2, n4, s3) {
  const p = f(m2);
  return x2(p, x.from(n4), { ...s3 }).then((t2) => ({ count: t2.data.count, extent: w.fromJSON(t2.data.extent) }));
}

// node_modules/@arcgis/core/rest/query/operations/pbfJSONFeatureSet.js
function n2(e2, t2) {
  return t2;
}
function a3(e2, t2, r2, s3) {
  switch (r2) {
    case 0:
      return c2(e2, t2 + s3, 0);
    case 1:
      return "lowerLeft" === e2.originPosition ? c2(e2, t2 + s3, 1) : l(e2, t2 + s3, 1);
  }
}
function h(e2, t2, r2, s3) {
  return 2 === r2 ? c2(e2, t2, 2) : a3(e2, t2, r2, s3);
}
function u(e2, t2, r2, s3) {
  return 2 === r2 ? c2(e2, t2, 3) : a3(e2, t2, r2, s3);
}
function d(e2, t2, r2, s3) {
  return 3 === r2 ? c2(e2, t2, 3) : h(e2, t2, r2, s3);
}
function c2({ translate: e2, scale: t2 }, r2, s3) {
  return e2[s3] + r2 * t2[s3];
}
function l({ translate: e2, scale: t2 }, r2, s3) {
  return e2[s3] - r2 * t2[s3];
}
var f3 = class {
  constructor(e2) {
    this._options = e2, this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = n2, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return { fields: [], features: [] };
  }
  finishFeatureResult(t2) {
    if (this._options.applyTransform && (t2.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !t2.hasZ)
      return;
    const r2 = o(t2.geometryType, this._options.sourceSpatialReference, t2.spatialReference);
    if (!t(r2))
      for (const e2 of t2.features)
        r2(e2.geometry);
  }
  createSpatialReference() {
    return {};
  }
  addField(e2, r2) {
    const s3 = e2.fields;
    i(s3), s3.push(r2);
    const o2 = s3.map((e3) => e3.name);
    this._attributesConstructor = function() {
      for (const e3 of o2)
        this[e3] = null;
    };
  }
  addFeature(e2, t2) {
    e2.features.push(t2);
  }
  prepareFeatures(e2) {
    switch (this._transform = e2.transform, this._options.applyTransform && e2.transform && (this._applyTransform = this._deriveApplyTransform(e2)), this._vertexDimension = 2, e2.hasZ && this._vertexDimension++, e2.hasM && this._vertexDimension++, e2.geometryType) {
      case "esriGeometryPoint":
        this.addCoordinate = (e3, t2, r2) => this.addCoordinatePoint(e3, t2, r2), this.createGeometry = (e3) => this.createPointGeometry(e3);
        break;
      case "esriGeometryPolygon":
        this.addCoordinate = (e3, t2, r2) => this._addCoordinatePolygon(e3, t2, r2), this.createGeometry = (e3) => this._createPolygonGeometry(e3);
        break;
      case "esriGeometryPolyline":
        this.addCoordinate = (e3, t2, r2) => this._addCoordinatePolyline(e3, t2, r2), this.createGeometry = (e3) => this._createPolylineGeometry(e3);
        break;
      case "esriGeometryMultipoint":
        this.addCoordinate = (e3, t2, r2) => this._addCoordinateMultipoint(e3, t2, r2), this.createGeometry = (e3) => this._createMultipointGeometry(e3);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, { attributes: new this._attributesConstructor() };
  }
  allocateCoordinates() {
  }
  addLength(e2, t2, r2) {
    0 === this._lengths.length && (this._toAddInCurrentPath = t2), this._lengths.push(t2);
  }
  addQueryGeometry(e2, t2) {
    const { queryGeometry: r2, queryGeometryType: s3 } = t2, n4 = wt(r2.clone(), r2, false, false, this._transform), a4 = ut(n4, s3, false, false);
    e2.queryGeometryType = s3, e2.queryGeometry = { ...a4 };
  }
  createPointGeometry(e2) {
    const t2 = { x: 0, y: 0, spatialReference: e2.spatialReference };
    return e2.hasZ && (t2.z = 0), e2.hasM && (t2.m = 0), t2;
  }
  addCoordinatePoint(e2, t2, s3) {
    const o2 = c(this._transform, "transform");
    switch (t2 = this._applyTransform(o2, t2, s3, 0), s3) {
      case 0:
        e2.x = t2;
        break;
      case 1:
        e2.y = t2;
        break;
      case 2:
        "z" in e2 ? e2.z = t2 : e2.m = t2;
        break;
      case 3:
        e2.m = t2;
    }
  }
  _transformPathLikeValue(e2, t2) {
    let s3 = 0;
    t2 <= 1 && (s3 = this._previousCoordinate[t2], this._previousCoordinate[t2] += e2);
    const o2 = c(this._transform, "transform");
    return this._applyTransform(o2, e2, t2, s3);
  }
  _addCoordinatePolyline(e2, t2, r2) {
    this._dehydratedAddPointsCoordinate(e2.paths, t2, r2);
  }
  _addCoordinatePolygon(e2, t2, r2) {
    this._dehydratedAddPointsCoordinate(e2.rings, t2, r2);
  }
  _addCoordinateMultipoint(e2, t2, r2) {
    0 === r2 && e2.points.push([]);
    const s3 = this._transformPathLikeValue(t2, r2);
    e2.points[e2.points.length - 1].push(s3);
  }
  _createPolygonGeometry(e2) {
    return { rings: [[]], spatialReference: e2.spatialReference, hasZ: !!e2.hasZ, hasM: !!e2.hasM };
  }
  _createPolylineGeometry(e2) {
    return { paths: [[]], spatialReference: e2.spatialReference, hasZ: !!e2.hasZ, hasM: !!e2.hasM };
  }
  _createMultipointGeometry(e2) {
    return { points: [], spatialReference: e2.spatialReference, hasZ: !!e2.hasZ, hasM: !!e2.hasM };
  }
  _dehydratedAddPointsCoordinate(e2, t2, r2) {
    0 === r2 && 0 == this._toAddInCurrentPath-- && (e2.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s3 = this._transformPathLikeValue(t2, r2), o2 = e2[e2.length - 1];
    0 === r2 && (this._coordinateBufferPtr = 0, this._coordinateBuffer = new Array(this._vertexDimension), o2.push(this._coordinateBuffer)), this._coordinateBuffer[this._coordinateBufferPtr++] = s3;
  }
  _deriveApplyTransform(e2) {
    const { hasZ: t2, hasM: r2 } = e2;
    return t2 && r2 ? d : t2 ? h : r2 ? u : a3;
  }
};

// node_modules/@arcgis/core/rest/query/executeQueryPBF.js
async function n3(o2, s3, n4) {
  const p = f(o2), i2 = { ...n4 }, u2 = x.from(s3), m2 = !u2.quantizationParameters, { data: f4 } = await f2(p, u2, new f3({ sourceSpatialReference: u2.sourceSpatialReference, applyTransform: m2 }), i2);
  return f4;
}

// node_modules/@arcgis/core/layers/graphics/sources/support/QueryTask.js
var F = class extends v {
  constructor(e2) {
    super(e2), this.dynamicDataSource = null, this.fieldsIndex = null, this.gdbVersion = null, this.infoFor3D = null, this.pbfSupported = false, this.queryAttachmentsSupported = false, this.sourceSpatialReference = null, this.url = null;
  }
  get parsedUrl() {
    return L(this.url);
  }
  async execute(e2, t2) {
    const r2 = await this.executeJSON(e2, t2);
    return this.featureSetFromJSON(e2, r2, t2);
  }
  async executeJSON(e2, t2) {
    var _a;
    const r2 = this._normalizeQuery(e2), o2 = null != ((_a = e2.outStatistics) == null ? void 0 : _a[0]), s3 = has("featurelayer-pbf-statistics"), i2 = !o2 || s3;
    let u2;
    if (this.pbfSupported && i2)
      try {
        u2 = await n3(this.url, r2, t2);
      } catch (a4) {
        if ("query:parsing-pbf" !== a4.name)
          throw a4;
        this.pbfSupported = false;
      }
    return this.pbfSupported && i2 || (u2 = await a2(this.url, r2, t2)), this._normalizeFields(u2.fields), u2;
  }
  async featureSetFromJSON(e2, t2, r2) {
    if (!this._queryIs3DObjectFormat(e2) || t(this.infoFor3D) || !t2.assetMaps || !t2.features || !t2.features.length)
      return x3.fromJSON(t2);
    const { meshFeatureSetFromJSON: s3 } = await y(import("./meshFeatureSet-BT4OC6CZ.js"), r2);
    return s3(e2, this.infoFor3D, t2);
  }
  executeForCount(e2, t2) {
    return n(this.url, this._normalizeQuery(e2), t2);
  }
  executeForExtent(e2, t2) {
    return m(this.url, this._normalizeQuery(e2), t2);
  }
  executeForIds(e2, t2) {
    return s2(this.url, this._normalizeQuery(e2), t2);
  }
  async executeRelationshipQuery(e2, t2) {
    const [{ default: r2 }, { executeRelationshipQuery: o2 }] = await y(Promise.all([import("./RelationshipQuery-PFBUNAEX.js"), import("./executeRelationshipQuery-WVCKHY2Z.js")]), t2);
    return e2 = r2.from(e2), (this.gdbVersion || this.dynamicDataSource) && ((e2 = e2.clone()).gdbVersion = e2.gdbVersion || this.gdbVersion, e2.dynamicDataSource = e2.dynamicDataSource || this.dynamicDataSource), o2(this.url, e2, t2);
  }
  async executeRelationshipQueryForCount(e2, t2) {
    const [{ default: r2 }, { executeRelationshipQueryForCount: o2 }] = await y(Promise.all([import("./RelationshipQuery-PFBUNAEX.js"), import("./executeRelationshipQuery-WVCKHY2Z.js")]), t2);
    return e2 = r2.from(e2), (this.gdbVersion || this.dynamicDataSource) && ((e2 = e2.clone()).gdbVersion = e2.gdbVersion || this.gdbVersion, e2.dynamicDataSource = e2.dynamicDataSource || this.dynamicDataSource), o2(this.url, e2, t2);
  }
  async executeAttachmentQuery(e2, t2) {
    const { executeAttachmentQuery: r2, fetchAttachments: o2, processAttachmentQueryResult: s3 } = await y(import("./queryAttachments-WY6TCRJJ.js"), t2), u2 = f(this.url);
    return s3(u2, await (this.queryAttachmentsSupported ? r2(u2, e2, t2) : o2(u2, e2, t2)));
  }
  async executeTopFeaturesQuery(e2, t2) {
    const { executeTopFeaturesQuery: r2 } = await y(import("./executeTopFeaturesQuery-BGRXWNRO.js"), t2);
    return r2(this.parsedUrl, e2, this.sourceSpatialReference, t2);
  }
  async executeForTopIds(e2, t2) {
    const { executeForTopIds: r2 } = await y(import("./executeForTopIds-E5IGGUSE.js"), t2);
    return r2(this.parsedUrl, e2, t2);
  }
  async executeForTopExtents(e2, t2) {
    const { executeForTopExtents: r2 } = await y(import("./executeForTopExtents-4XXPKYDO.js"), t2);
    return r2(this.parsedUrl, e2, t2);
  }
  async executeForTopCount(e2, t2) {
    const { executeForTopCount: r2 } = await y(import("./executeForTopCount-HM67HWO5.js"), t2);
    return r2(this.parsedUrl, e2, t2);
  }
  _normalizeQuery(e2) {
    let t2 = x.from(e2);
    if (t2.sourceSpatialReference = t2.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (t2 = t2 === e2 ? t2.clone() : t2, t2.gdbVersion = e2.gdbVersion || this.gdbVersion, t2.dynamicDataSource = e2.dynamicDataSource ? K.from(e2.dynamicDataSource) : this.dynamicDataSource), r(this.infoFor3D) && this._queryIs3DObjectFormat(e2)) {
      t2 = t2 === e2 ? t2.clone() : t2, t2.formatOf3DObjects = null;
      for (const e3 of this.infoFor3D.queryFormats) {
        if ("3D_glb" === e3) {
          t2.formatOf3DObjects = e3;
          break;
        }
        "3D_gltf" !== e3 || t2.formatOf3DObjects || (t2.formatOf3DObjects = e3);
      }
      if (!t2.formatOf3DObjects)
        throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (t(t2.outFields) || !t2.outFields.includes("*")) {
        t2 = t2 === e2 ? t2.clone() : t2, t(t2.outFields) && (t2.outFields = []);
        const { originX: r2, originY: s3, originZ: i2, translationX: u2, translationY: a4, translationZ: n4, scaleX: c3, scaleY: p, scaleZ: l2, rotationX: m2, rotationY: y3, rotationZ: d2, rotationDeg: f4 } = this.infoFor3D.transformFieldRoles;
        t2.outFields.push(r2, s3, i2, u2, a4, n4, c3, p, l2, m2, y3, d2, f4);
      }
    }
    return t2;
  }
  _normalizeFields(e2) {
    if (r(this.fieldsIndex) && r(e2))
      for (const t2 of e2) {
        const e3 = this.fieldsIndex.get(t2.name);
        e3 && Object.assign(t2, e3.toJSON());
      }
  }
  _queryIs3DObjectFormat(e2) {
    return r(this.infoFor3D) && true === e2.returnGeometry && "xyFootprint" !== e2.multipatchOption && !e2.outStatistics;
  }
};
e([y2({ type: K })], F.prototype, "dynamicDataSource", void 0), e([y2()], F.prototype, "fieldsIndex", void 0), e([y2()], F.prototype, "gdbVersion", void 0), e([y2()], F.prototype, "infoFor3D", void 0), e([y2({ readOnly: true })], F.prototype, "parsedUrl", null), e([y2()], F.prototype, "pbfSupported", void 0), e([y2()], F.prototype, "queryAttachmentsSupported", void 0), e([y2()], F.prototype, "sourceSpatialReference", void 0), e([y2({ type: String })], F.prototype, "url", void 0), F = e([a("esri.tasks.QueryTask")], F);
var x4 = F;

export {
  x4 as x
};
//# sourceMappingURL=chunk-ZC3CGFAL.js.map

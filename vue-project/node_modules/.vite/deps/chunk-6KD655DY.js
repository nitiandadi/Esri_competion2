import {
  T as T2,
  n as n5,
  r as r6
} from "./chunk-BVS3NILK.js";
import {
  m,
  n2 as n4
} from "./chunk-C5WM5BY7.js";
import {
  n as n3,
  s as s3
} from "./chunk-MAMDNRUV.js";
import {
  r as r4
} from "./chunk-VV2CU7S7.js";
import {
  s as s2
} from "./chunk-UR7T2PHF.js";
import {
  t as t4
} from "./chunk-S3GGRNUO.js";
import {
  M as M2,
  W as W2
} from "./chunk-7FRYP2QO.js";
import {
  E as E3,
  f as f2,
  i,
  x
} from "./chunk-23AC3IC7.js";
import {
  E as E2,
  a
} from "./chunk-GKD7ZY5C.js";
import {
  o as o2
} from "./chunk-ITU2WGYR.js";
import {
  t as t3
} from "./chunk-IEBU4QQL.js";
import {
  A,
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  M,
  N,
  O,
  P,
  R,
  S,
  T,
  U as U2,
  V,
  W,
  X,
  Y,
  _,
  f,
  n as n2,
  r as r3,
  t as t2
} from "./chunk-4M3AMTD4.js";
import {
  r as r5
} from "./chunk-3DBV4JBL.js";
import {
  r as r2
} from "./chunk-TNTTCGVB.js";
import {
  n4 as n
} from "./chunk-7GTATSRF.js";
import {
  U
} from "./chunk-QLY5H3XF.js";
import {
  s
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  h,
  l,
  o,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MaterialPrograms.js
var e = (r11) => {
  let t6 = "";
  t6 += r11[0].toUpperCase();
  for (let e5 = 1; e5 < r11.length; e5++) {
    const s6 = r11[e5];
    s6 === s6.toUpperCase() ? (t6 += "_", t6 += s6) : t6 += s6.toUpperCase();
  }
  return t6;
};
var s4 = (r11) => {
  const s6 = {};
  for (const t6 in r11) {
    s6[e(t6)] = r11[t6];
  }
  return n3(s6);
};
var o3 = (t6, e5, o6, n7) => {
  const a2 = t6 + t6.substring(t6.lastIndexOf("/")), p = e5 + e5.substring(e5.lastIndexOf("/")), f3 = s4(n7);
  return { attributes: o6, shaders: { vertexShader: f3 + n4(`${a2}.vert`), fragmentShader: f3 + n4(`${p}.frag`) } };
};

// node_modules/@arcgis/core/views/webgl/ContextState.js
var h2 = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO }, this.blendEquation = { mode: T.ADD, modeAlpha: T.ADD }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = N.BACK, this.frontFace = S.CCW, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = I.LESS, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: N.FRONT_AND_BACK, func: I.ALWAYS, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: N.FRONT_AND_BACK, fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.uniformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array(), this.vertexArrayObject = null;
  }
};

// node_modules/@arcgis/core/views/support/AllocationTracer.js
var t5 = class {
  constructor(t6) {
    this._allocations = /* @__PURE__ */ new Map(), t6 ? Error.stackTraceLimit = 1 / 0 : (this.add = () => {
    }, this.remove = () => {
    });
  }
  add(t6) {
    this._allocations.set(t6, new Error().stack);
  }
  remove(t6) {
    this._allocations.delete(t6);
  }
  get information() {
    let t6 = "";
    if (this._allocations.size > 0) {
      t6 += `${this._allocations.size} live object allocations:
`;
      const s6 = /* @__PURE__ */ new Map();
      this._allocations.forEach((t7) => {
        s6.set(t7, (s6.get(t7) ?? 0) + 1);
      }), s6.forEach((s7, o6) => {
        const i2 = o6.split("\n");
        i2.shift(), i2.shift(), t6 += `${s7}: ${i2.shift()}
`, i2.forEach((s8) => t6 += `   ${s8}
`);
      });
    }
    return t6;
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var e2 = { RECORD_ALLOCATIONS: false };
var s5 = class {
  constructor() {
    for (this._current = new Array(), this._max = new Array(), this._allocations = new t5(e2.RECORD_ALLOCATIONS); this._current.length < t2.COUNT; )
      this._current.push(0), this._max.push(0);
  }
  resetMax() {
    for (this._max.length = 0; this._max.length < this._current.length; )
      this._max.push(0);
  }
  increment(t6, r11) {
    const e5 = ++this._current[t6];
    this._max[t6] = Math.max(e5, this._max[t6]), this._allocations.add(r11);
  }
  decrement(t6, r11) {
    --this._current[t6], this._allocations.remove(r11);
  }
  get max() {
    return this._max;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t6, r11) => t6 + r11, 0);
  }
  get resourceInformation() {
    let t6 = "";
    if (this.total > 0) {
      t6 += "Live objects:\n";
      for (let e5 = 0; e5 < t2.COUNT; ++e5) {
        const s6 = this._current[e5];
        s6 > 0 && (t6 += `${t2[e5]}: ${s6}
`);
      }
    }
    return t6 += this._allocations.information, t6;
  }
};

// node_modules/@arcgis/core/views/webgl/WebGLDriverTestModule.js
var r7 = class {
  constructor() {
    this._result = false;
  }
  dispose() {
    this._program = h(this._program);
  }
  get result() {
    return r(this._program) && (this._result = this._test(this._program), this.dispose()), this._result;
  }
};

// node_modules/@arcgis/core/views/webgl/testAppleAmdDrawArrays.js
var u = class extends r7 {
  constructor(r11) {
    super(), this._rctx = r11, this._dummyProgram = null, this._rctx.type === r5.WEBGL2 && has("mac") && has("chrome") && (this._program = this._prepareProgram(), this._dummyProgram = this._prepareDummyProgram());
  }
  dispose() {
    var _a;
    super.dispose(), (_a = this._dummyProgram) == null ? void 0 : _a.dispose(), this._dummyProgram = null;
  }
  _test(r11) {
    const t6 = this._rctx;
    t6.resetState();
    const f3 = new x(t6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), u2 = E3.createIndex(this._rctx, F.STATIC_DRAW, new Uint8Array([0]));
    t6.bindFramebuffer(f3), t6.setViewport(0, 0, 1, 1), t6.useProgram(this._dummyProgram), t6.bindBuffer(u2, A.ELEMENT_ARRAY_BUFFER), t6.drawElements(E.POINTS, 1, C.UNSIGNED_BYTE, 0), t6.useProgram(r11), t6.bindVAO(null), t6.drawArrays(E.TRIANGLES, 0, 258);
    const h4 = new Uint8Array(4);
    return f3.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, h4), f3.dispose(), u2.dispose(), 255 === h4[0];
  }
  _prepareProgram() {
    const e5 = 85, t6 = `
    precision highp float;

    varying float triangleId;

    const vec3 triangleVertices[3] = vec3[3](vec3(-0.5, -0.5, 0.0), vec3(0.5, -0.5, 0.0), vec3(0.0, 0.5, 0.0));

    void main(void) {
      triangleId = floor(float(gl_VertexID)/3.0);

      vec3 position = triangleVertices[gl_VertexID % 3];
      float offset = triangleId / ${o2.float(e5)};
      position.z = 0.5 - offset;

      gl_Position = vec4(position, 1.0);
    }
    `, o6 = `
    precision highp float;

    varying float triangleId;

    void main(void) {
      gl_FragColor = triangleId == ${o2.float(e5)} ? vec4(0.0, 1.0, 0.0, 1.0) : vec4(1.0, 0.0, 0.0, 1.0);
    }
    `;
    return this._rctx.programCache.acquire(t6, o6, /* @__PURE__ */ new Map([]));
  }
  _prepareDummyProgram() {
    const r11 = "\n    void main(void) {\n      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);\n    }", e5 = "\n    void main(void) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }";
    return this._rctx.programCache.acquire(r11, e5, /* @__PURE__ */ new Map([]));
  }
};

// node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js
var g = class extends r7 {
  constructor(e5) {
    super(), this._rctx = e5, this._program = B(this._rctx, false), this._obfuscated = B(this._rctx, true);
  }
  dispose() {
    super.dispose(), this._obfuscated = h(this._obfuscated);
  }
  _test(e5) {
    if (has("force-double-precision-obfuscation"))
      return true;
    if (t(this._obfuscated))
      return false;
    const n7 = this._runProgram(e5), o6 = this._runProgram(this._obfuscated);
    return 0 !== n7 && (0 === o6 || n7 / o6 > 5);
  }
  _runProgram(n7) {
    const t6 = this._rctx;
    t6.resetState();
    const b = new x(t6, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), g2 = E3.createVertex(t6, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), B2 = new f2(t6, /* @__PURE__ */ new Map([["position", 0]]), { geometry: [new t3("position", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: g2 }), E5 = r2(5633261287538229e-9, 2626832878767164e-9, 1.4349880495278358e6), T3 = r2(563327146742708e-8, 2.6268736381334523e6, 1434963231608387e-9), F2 = new Float32Array(6);
    t4(E5, F2, 3);
    const O2 = new Float32Array(6);
    t4(T3, O2, 3), t6.useProgram(n7), n7.setUniform3f("u_highA", F2[0], F2[2], F2[4]), n7.setUniform3f("u_lowA", F2[1], F2[3], F2[5]), n7.setUniform3f("u_highB", O2[0], O2[2], O2[4]), n7.setUniform3f("u_lowB", O2[1], O2[3], O2[5]), t6.bindFramebuffer(b), t6.setViewport(0, 0, 1, 1), t6.bindVAO(B2), t6.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const U3 = new Uint8Array(4);
    b.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, U3), B2.dispose(false), g2.dispose(), b.dispose();
    const w = (E5[2] - T3[2]) / 25, I3 = r4(U3);
    return Math.abs(w - I3);
  }
};
function B(e5, n7) {
  const t6 = `

  precision highp float;

  attribute vec2 position;

  uniform vec3 u_highA;
  uniform vec3 u_lowA;
  uniform vec3 u_highB;
  uniform vec3 u_lowB;

  varying vec4 v_color;

  ${n7 ? "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}

  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION

  vec3 dpPlusFrc(vec3 a, vec3 b) {
    return mix(a, a + b, vec3(notEqual(b, vec3(0))));
  }

  vec3 dpMinusFrc(vec3 a, vec3 b) {
    return mix(vec3(0), a - b, vec3(notEqual(a, b)));
  }

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = dpPlusFrc(hiA, hiB);
    vec3 e = dpMinusFrc(t1, hiA);
    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
    return t1 + t2;
  }

  #else

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = hiA + hiB;
    vec3 e = t1 - hiA;
    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
    return t1 + t2;
  }

  #endif

  const float MAX_RGBA_FLOAT =
    255.0 / 256.0 +
    255.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 / 256.0;

  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);

  vec4 float2rgba(const float value) {
    // Make sure value is in the domain we can represent
    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);

    // Decompose value in 32bit fixed point parts represented as
    // uint8 rgba components. Decomposition uses the fractional part after multiplying
    // by a power of 256 (this removes the bits that are represented in the previous
    // component) and then converts the fractional part to 8bits.
    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);

    // Convert uint8 values (from 0 to 255) to floating point representation for
    // the shader
    const float toU8AsFloat = 1.0 / 255.0;

    return fixedPointU8 * toU8AsFloat;
  }

  void main() {
    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);

    v_color = float2rgba(val.z / 25.0);

    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);
  }
  `, o6 = "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ";
  return e5.programCache.acquire(t6, o6, /* @__PURE__ */ new Map([["position", 0]]));
}

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var x2 = class extends r7 {
  constructor(e5) {
    var _a, _b, _c, _d, _e;
    if (super(), this._rctx = e5, !e5.gl)
      return;
    if (e5.type === r5.WEBGL1)
      return void (this._result = !(!((_a = e5.capabilities.textureFloat) == null ? void 0 : _a.textureFloat) || !((_b = e5.capabilities.colorBufferFloat) == null ? void 0 : _b.textureFloat)));
    if (!(((_c = e5.capabilities.textureFloat) == null ? void 0 : _c.textureFloat) && ((_d = e5.capabilities.colorBufferFloat) == null ? void 0 : _d.textureFloat) && ((_e = e5.capabilities.colorBufferFloat) == null ? void 0 : _e.floatBlend)))
      return;
    const t6 = "\n    precision highp float;\n    attribute vec2 a_pos;\n\n    void main() {\n      gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ", r11 = "\n     precision highp float;\n\n     void main() {\n      gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n     }\n    ";
    this._program = e5.programCache.acquire(t6, r11, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(o6) {
    const w = this._rctx, x4 = new x(w, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.FLOAT, internalFormat: U2.RGBA32F, samplingMode: L.NEAREST, width: 1, height: 1 }), F2 = E3.createVertex(w, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), h4 = new f2(w, /* @__PURE__ */ new Map([["a_pos", 0]]), { geometry: [new t3("a_pos", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: F2 });
    w.useProgram(o6);
    const E5 = w.getBoundFramebufferObject(), { x: j, y: A3, width: y, height: O2 } = w.getViewport();
    w.bindFramebuffer(x4), w.setViewport(0, 0, 1, 1), w.bindVAO(h4), w.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const R3 = W2({ blending: s2 });
    w.setPipelineState(R3), w.drawArrays(E.TRIANGLE_STRIP, 0, 4), r6.init(w);
    const B2 = w.gl.getError();
    return w.setViewport(j, A3, y, O2), w.bindFramebuffer(E5), h4.dispose(false), F2.dispose(), x4.dispose(), 1282 !== B2 || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
  }
};

// node_modules/@arcgis/core/views/webgl/testSamplerPrecision.js
var h3 = class extends r7 {
  constructor(e5) {
    super(), this._rctx = e5;
    const r11 = "\n      precision highp float;\n      attribute vec2 a_pos;\n      uniform highp sampler2D u_texture;\n      varying vec4 v_color;\n\n      float getBit(in float bitset, in int bitIndex) {\n        float offset = pow(2.0, float(bitIndex));\n        return mod(floor(bitset / offset), 2.0);\n      }\n\n      void main() {\n        vec4 value = texture2D(u_texture, vec2(0.0));\n        float bit = getBit(value.x * 255.0, 1);\n\n        v_color = bit * vec4(1.0);\n        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n      }\n      ", t6 = "\n      precision highp float;\n      varying vec4 v_color;\n\n      void main() {\n        gl_FragColor = v_color;\n      }\n      ";
    this._program = e5.programCache.acquire(r11, t6, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(_3) {
    const h4 = this._rctx, w = new x(h4, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), T3 = new Uint8Array(4), b = E3.createVertex(h4, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), v2 = new f2(h4, /* @__PURE__ */ new Map([["a_position", 0]]), { geometry: [new t3("a_position", 2, C.SHORT, 0, 4)] }, { geometry: b });
    h4.useProgram(_3);
    const E5 = new E2(h4, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }, new Uint8Array([2, 255, 0, 0]));
    _3.setUniform1i("u_texture", 0), h4.bindTexture(E5, 0);
    const x4 = h4.getBoundFramebufferObject();
    h4.bindFramebuffer(w), h4.useProgram(_3);
    const { x: A3, y, width: j, height: D3 } = h4.getViewport();
    h4.setViewport(0, 0, 1, 1), h4.bindVAO(v2), h4.drawArrays(E.TRIANGLE_STRIP, 0, 4), h4.setViewport(A3, y, j, D3), w.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, T3), v2.dispose(false), b.dispose(), w.dispose();
    const R3 = 255 !== T3[0] || 255 !== T3[1] || 255 !== T3[2] || 255 !== T3[3];
    return R3 && s.getLogger("esri.views.webgl.testSamplerPrecision").warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${T3[0]}.${T3[1]}.${T3[2]}.${T3[3]}]`), h4.bindFramebuffer(x4), R3;
  }
};

// node_modules/@arcgis/core/views/webgl/testSVGPremultipliedAlpha.js
var l2 = class extends r7 {
  constructor(e5) {
    super(), this._rctx = e5, this._image = new Image(), this._image.src = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='5' height='5' version='1.1' viewBox='0 0 5 5' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='5' height='5' fill='%23f00' fill-opacity='.5'/%3E%3C/svg%3E%0A", this._image.width = 5, this._image.height = 5, this._image.decode();
    const t6 = "\n    precision highp float;\n\n    attribute vec2 a_pos;\n    varying vec2 v_uv;\n\n    void main() {\n      v_uv = a_pos;\n      gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ", r11 = "\n    precision highp float;\n\n    varying vec2 v_uv;\n    uniform sampler2D u_texture;\n\n    void main() {\n      gl_FragColor = texture2D(u_texture, v_uv);\n    }\n    ";
    this._program = e5.programCache.acquire(t6, r11, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  dispose() {
    super.dispose(), this._image.src = "";
  }
  _test(h4) {
    const l4 = this._rctx;
    if (!l4.gl)
      return h4.dispose(), true;
    const f3 = new x(l4, { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, { target: M.TEXTURE_2D, wrapMode: D.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 }), w = E3.createVertex(l4, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), E5 = new f2(l4, /* @__PURE__ */ new Map([["a_pos", 0]]), m, { geometry: w }), v2 = new E2(l4, { dataType: G.UNSIGNED_BYTE, pixelFormat: P.RGBA, preMultiplyAlpha: false, wrapMode: D.CLAMP_TO_EDGE, samplingMode: L.LINEAR }, this._image);
    l4.useProgram(h4), l4.bindTexture(v2, 0), h4.setUniform1i("u_texture", 0);
    const T3 = l4.getBoundFramebufferObject(), { x: x4, y: A3, width: b, height: y } = l4.getViewport();
    l4.bindFramebuffer(f3), l4.setViewport(0, 0, 1, 1), l4.setClearColor(0, 0, 0, 0), l4.setBlendingEnabled(false), l4.clearSafe(_.COLOR_BUFFER_BIT), l4.bindVAO(E5), l4.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const j = new Uint8Array(4);
    return f3.readPixels(0, 0, 1, 1, P.RGBA, G.UNSIGNED_BYTE, j), E5.dispose(false), w.dispose(), f3.dispose(), v2.dispose(), l4.setViewport(x4, A3, b, y), l4.bindFramebuffer(T3), 255 !== j[0];
  }
};

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var o4 = class {
  constructor(o6) {
    this.rctx = o6, this.floatBufferBlend = new x2(o6), this.svgPremultipliesAlpha = new l2(o6), this.doublePrecisionRequiresObfuscation = new g(o6), this.ignoresSamplerPrecision = new h3(o6), this.drawArraysRequiresIndicesTypeReset = new u(o6);
  }
  dispose() {
    this.ignoresSamplerPrecision.dispose(), this.doublePrecisionRequiresObfuscation.dispose(), this.svgPremultipliesAlpha.dispose(), this.floatBufferBlend.dispose(), this.drawArraysRequiresIndicesTypeReset.dispose();
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/DrawBuffers.js
function A2(A3, _3) {
  if (_3.disjointTimerQuery)
    return null;
  if (n5(A3))
    return { drawBuffers: A3.drawBuffers.bind(A3), MAX_DRAW_BUFFERS: A3.MAX_DRAW_BUFFERS, MAX_COLOR_ATTACHMENTS: A3.MAX_COLOR_ATTACHMENTS };
  if (_3.drawBuffers)
    return null;
  const e5 = A3.getExtension("WEBGL_draw_buffers");
  return e5 ? { drawBuffers: e5.drawBuffersWEBGL.bind(e5), MAX_DRAW_BUFFERS: e5.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: e5.MAX_COLOR_ATTACHMENTS_WEBGL } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Instancing.js
function r8(r11) {
  if (n5(r11))
    return r11;
  const t6 = r11.getExtension("ANGLE_instanced_arrays");
  return t6 ? { drawArraysInstanced: t6.drawArraysInstancedANGLE.bind(t6), drawElementsInstanced: t6.drawElementsInstancedANGLE.bind(t6), vertexAttribDivisor: t6.vertexAttribDivisorANGLE.bind(t6) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _2(t6, _3) {
  if (_3.compressedTextureETC)
    return null;
  const e5 = t6.getExtension("WEBGL_compressed_texture_etc");
  return e5 ? { COMPRESSED_R11_EAC: e5.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: e5.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: e5.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: e5.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: e5.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: e5.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: e5.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: e5.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: e5.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: e5.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function e3(t6, _3) {
  if (_3.compressedTextureS3TC)
    return null;
  const e5 = t6.getExtension("WEBGL_compressed_texture_s3tc");
  return e5 ? { COMPRESSED_RGB_S3TC_DXT1: e5.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: e5.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: e5.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: e5.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function E4(_3, e5) {
  if (n5(_3))
    return { MIN: _3.MIN, MAX: _3.MAX };
  if (e5.blendMinMax)
    return null;
  {
    const t6 = _3.getExtension("EXT_blend_minmax");
    return t6 ? { MIN: t6.MIN_EXT, MAX: t6.MAX_EXT } : null;
  }
}
function n6(t6, _3) {
  if (_3.textureFilterAnisotropic)
    return null;
  const e5 = t6.getExtension("EXT_texture_filter_anisotropic") || t6.getExtension("MOZ_EXT_texture_filter_anisotropic") || t6.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return e5 ? { MAX_TEXTURE_MAX_ANISOTROPY: e5.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: e5.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function R2(_3, e5) {
  if (n5(_3))
    return { textureFloat: true, textureFloatLinear: !e5.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: true, textureHalfFloatLinear: true, HALF_FLOAT: _3.HALF_FLOAT, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F };
  if (_3 instanceof WebGLRenderingContext) {
    const t6 = !e5.textureHalfFloat && _3.getExtension("OES_texture_half_float");
    return { textureFloat: !e5.textureFloat && !!_3.getExtension("OES_texture_float"), textureFloatLinear: !e5.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: !!t6, textureHalfFloatLinear: !e5.textureHalfFloatLinear && !!_3.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: t6 ? t6.HALF_FLOAT_OES : void 0 };
  }
  return null;
}
function r9(_3, e5) {
  if (n5(_3)) {
    const t6 = !e5.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float") || !e5.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), E5 = !e5.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), n7 = !e5.floatBlend && !e5.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t6 || E5 || n7 ? { textureFloat: !!E5, textureHalfFloat: !!t6, floatBlend: !!n7, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F } : null;
  }
  if (_3 instanceof WebGLRenderingContext) {
    const t6 = !e5.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float"), E5 = !e5.colorBufferFloat && _3.getExtension("WEBGL_color_buffer_float"), n7 = !e5.floatBlend && !e5.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t6 || E5 || n7 ? { textureFloat: !!E5, textureHalfFloat: !!t6, floatBlend: !!n7, RGBA16F: t6 ? t6.RGBA16F_EXT : void 0, RGB16F: t6 ? t6.RGB16F_EXT : void 0, RGBA32F: E5 ? E5.RGBA32F_EXT : void 0 } : null;
  }
  return null;
}
function o5(_3, e5, E5, n7, R3) {
  if (n7 && n5(_3))
    return true;
  if (e5[E5])
    return false;
  for (const t6 of R3)
    if (_3.getExtension(t6))
      return true;
  return false;
}
function l3(_3, e5) {
  if (!n5(_3))
    return null;
  if (e5.textureNorm16)
    return null;
  const E5 = _3.getExtension("EXT_texture_norm16");
  return E5 ? { R16: E5.R16_EXT, RG16: E5.RG16_EXT, RGB16: E5.RGB16_EXT, RGBA16: E5.RGBA16_EXT, R16_SNORM: E5.R16_SNORM_EXT, RG16_SNORM: E5.RG16_SNORM_EXT, RGB16_SNORM: E5.RGB16_SNORM_EXT, RGBA16_SNORM: E5.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e4(e5, t6) {
  const n7 = t6.loseContext && e5.getExtension("WEBGL_lose_context");
  return n7 ? { loseRenderingContext: () => n7.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/VertexArrayObjects.js
function r10(r11, t6) {
  if (n5(r11))
    return { createVertexArray: r11.createVertexArray.bind(r11), deleteVertexArray: r11.deleteVertexArray.bind(r11), bindVertexArray: r11.bindVertexArray.bind(r11) };
  if (t6.vao)
    return null;
  const n7 = r11.getExtension("OES_vertex_array_object") || r11.getExtension("MOZ_OES_vertex_array_object") || r11.getExtension("WEBKIT_OES_vertex_array_object");
  return n7 ? { createVertexArray: n7.createVertexArrayOES.bind(n7), deleteVertexArray: n7.deleteVertexArrayOES.bind(n7), bindVertexArray: n7.bindVertexArrayOES.bind(n7) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var x3 = class {
  constructor(t6, e5) {
    this._gl = t6, this._instancing = null, this._vertexArrayObject = null, this._compressedTextureETC = null, this._compressedTextureS3TC = null, this._textureFilterAnisotropic = null, this._textureFloat = null, this._colorBufferFloat = null, this._minMaxBlending = null, this._loseContext = null, this._drawBuffers = null, this._textureNorm16 = null, this._depthTexture = null, this._standardDerivatives = null, this._shaderTextureLOD = null, this._fragDepth = null, this._textureFloatLinear = null, this._disabledExtensions = e5.disabledExtensions || {}, this._debugWebGLExtensions = e5.debugWebGLExtensions || {};
  }
  get drawBuffers() {
    return this._drawBuffers || (this._drawBuffers = A2(this._gl, this._disabledExtensions)), this._drawBuffers;
  }
  get instancing() {
    return this._instancing || (this._instancing = r8(this._gl)), this._instancing;
  }
  get vao() {
    return this._vertexArrayObject || (this._vertexArrayObject = r10(this._gl, this._disabledExtensions)), this._vertexArrayObject;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC || (this._compressedTextureETC = _2(this._gl, this._disabledExtensions)), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC || (this._compressedTextureS3TC = e3(this._gl, this._disabledExtensions)), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic || (this._textureFilterAnisotropic = n6(this._gl, this._disabledExtensions)), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery || (this._disjointTimerQuery = T2(this._gl, this._disabledExtensions)), this._disjointTimerQuery;
  }
  get textureFloat() {
    return this._textureFloat || (this._textureFloat = R2(this._gl, this._disabledExtensions)), this._textureFloat;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat || (this._colorBufferFloat = r9(this._gl, this._disabledExtensions)), this._colorBufferFloat;
  }
  get blendMinMax() {
    return this._minMaxBlending || (this._minMaxBlending = E4(this._gl, this._disabledExtensions)), this._minMaxBlending;
  }
  get depthTexture() {
    return null === this._depthTexture && (this._depthTexture = o5(this._gl, this._disabledExtensions, "depthTexture", true, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])), this._depthTexture;
  }
  get standardDerivatives() {
    return null === this._standardDerivatives && (this._standardDerivatives = o5(this._gl, this._disabledExtensions, "standardDerivatives", true, ["OES_standard_derivatives"])), this._standardDerivatives;
  }
  get shaderTextureLOD() {
    return null === this._shaderTextureLOD && (this._shaderTextureLOD = o5(this._gl, this._disabledExtensions, "shaderTextureLOD", true, ["EXT_shader_texture_lod"])), this._shaderTextureLOD;
  }
  get fragDepth() {
    return null === this._fragDepth && (this._fragDepth = o5(this._gl, this._disabledExtensions, "fragDepth", true, ["EXT_frag_depth"])), this._fragDepth;
  }
  get loseContext() {
    return this._loseContext || (this._loseContext = e4(this._gl, this._debugWebGLExtensions)), this._loseContext;
  }
  get textureNorm16() {
    return this._textureNorm16 || (this._textureNorm16 = l3(this._gl, this._disabledExtensions)), this._textureNorm16;
  }
  get textureFloatLinear() {
    return null === this._textureFloatLinear && (this._textureFloatLinear = o5(this._gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"])), this._textureFloatLinear;
  }
  enable(t6) {
    return this[t6];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var I2 = class {
  constructor(t6, e5) {
    this.gl = t6, this.instanceCounter = new s5(), this.programCache = new s3(this), this._state = new h2(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this.type = n5(t6) ? r5.WEBGL2 : r5.WEBGL1, this._loadExtensions(), this.configure(e5);
  }
  get gl2() {
    return this.type === r5.WEBGL1 ? null : this.gl;
  }
  configure(e5) {
    this._capabilities = new x3(this.gl, e5), this._parameters = this._loadParameters(e5);
    const s6 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new h2(), this._state.viewport = { x: s6[0], y: s6[1], width: s6[2], height: s6[3] }, this._stateTracker = new M2({ setBlending: (t6) => {
      if (t6) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t6.opRgb, t6.opAlpha), this.setBlendFunctionSeparate(t6.srcRgb, t6.dstRgb, t6.srcAlpha, t6.dstAlpha);
        const e6 = t6.color;
        this.setBlendColor(e6.r, e6.g, e6.b, e6.a);
      } else
        this.setBlendingEnabled(false);
    }, setCulling: (t6) => {
      t6 ? (this.setFaceCullingEnabled(true), this.setCullFace(t6.face), this.setFrontFace(t6.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t6) => {
      t6 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t6.factor, t6.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t6) => {
      t6 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t6.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t6) => {
      if (t6) {
        this.setStencilTestEnabled(true);
        const e6 = t6.function;
        this.setStencilFunction(e6.func, e6.ref, e6.mask);
        const s7 = t6.operation;
        this.setStencilOp(s7.fail, s7.zFail, s7.zPass);
      } else
        this.setStencilTestEnabled(false);
    }, setDepthWrite: (t6) => {
      t6 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t6.zNear, t6.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t6) => {
      t6 ? this.setColorMask(t6.r, t6.g, t6.b, t6.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t6) => {
      t6 ? this.setStencilWriteMask(t6.mask) : this.setStencilWriteMask(0);
    } }), this.enforceState(), h(this._driverTest), this._driverTest = new o4(this);
  }
  dispose() {
    h(this._driverTest), this.programCache.dispose(), this.bindVAO(null), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), this.type === r5.WEBGL2 && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER)), this._state.textureUnitMap.length = 0, a() && console.log(this.instanceCounter.resourceInformation);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  setPipelineState(t6) {
    this._stateTracker.setPipeline(t6);
  }
  setBlendingEnabled(t6) {
    this._state.blend !== t6 && (true === t6 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t6, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    var _a;
    (_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t6, e5) {
    for (let s6 = 0; s6 < t6.length; ++s6)
      this._state.textureUnitMap[t6[s6]] = null;
    e5 >= 0 && (this._state.activeTexture = e5);
  }
  externalVertexArrayObjectUpdate() {
    const t6 = this.capabilities.vao;
    t6 && (t6.bindVertexArray(null), this._state.vertexArrayObject = null), this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t6, e5, s6, i2) {
    t6 === this._state.blendColor.r && e5 === this._state.blendColor.g && s6 === this._state.blendColor.b && i2 === this._state.blendColor.a || (this.gl.blendColor(t6, e5, s6, i2), this._state.blendColor.r = t6, this._state.blendColor.g = e5, this._state.blendColor.b = s6, this._state.blendColor.a = i2, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t6, e5) {
    t6 === this._state.blendFunction.srcRGB && e5 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t6, e5), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = t6, this._state.blendFunction.dstRGB = e5, this._state.blendFunction.dstAlpha = e5, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t6, e5, s6, i2) {
    this._state.blendFunction.srcRGB === t6 && this._state.blendFunction.srcAlpha === s6 && this._state.blendFunction.dstRGB === e5 && this._state.blendFunction.dstAlpha === i2 || (this.gl.blendFuncSeparate(t6, e5, s6, i2), this._state.blendFunction.srcRGB = t6, this._state.blendFunction.srcAlpha = s6, this._state.blendFunction.dstRGB = e5, this._state.blendFunction.dstAlpha = i2, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t6) {
    this._state.blendEquation.mode !== t6 && (this.gl.blendEquation(t6), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = t6, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t6, e5) {
    this._state.blendEquation.mode === t6 && this._state.blendEquation.modeAlpha === e5 || (this.gl.blendEquationSeparate(t6, e5), this._state.blendEquation.mode = t6, this._state.blendEquation.modeAlpha = e5, this._stateTracker.invalidateBlending());
  }
  setColorMask(t6, e5, s6, i2) {
    this._state.colorMask.r === t6 && this._state.colorMask.g === e5 && this._state.colorMask.b === s6 && this._state.colorMask.a === i2 || (this.gl.colorMask(t6, e5, s6, i2), this._state.colorMask.r = t6, this._state.colorMask.g = e5, this._state.colorMask.b = s6, this._state.colorMask.a = i2, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t6, e5, s6, i2) {
    this._state.clearColor.r === t6 && this._state.clearColor.g === e5 && this._state.clearColor.b === s6 && this._state.clearColor.a === i2 || (this.gl.clearColor(t6, e5, s6, i2), this._state.clearColor.r = t6, this._state.clearColor.g = e5, this._state.clearColor.b = s6, this._state.clearColor.a = i2);
  }
  setFaceCullingEnabled(t6) {
    this._state.faceCulling !== t6 && (true === t6 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t6, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t6) {
    this._state.polygonOffsetFill !== t6 && (true === t6 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t6, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t6, e5) {
    this._state.polygonOffset[0] === t6 && this._state.polygonOffset[1] === e5 || (this._state.polygonOffset[0] = t6, this._state.polygonOffset[1] = e5, this.gl.polygonOffset(t6, e5), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t6) {
    this._state.cullFace !== t6 && (this.gl.cullFace(t6), this._state.cullFace = t6, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t6) {
    this._state.frontFace !== t6 && (this.gl.frontFace(t6), this._state.frontFace = t6, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t6) {
    this._state.scissorTest !== t6 && (true === t6 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t6);
  }
  setScissorRect(t6, e5, s6, i2) {
    this._state.scissorRect.x === t6 && this._state.scissorRect.y === e5 && this._state.scissorRect.width === s6 && this._state.scissorRect.height === i2 || (this.gl.scissor(t6, e5, s6, i2), this._state.scissorRect.x = t6, this._state.scissorRect.y = e5, this._state.scissorRect.width = s6, this._state.scissorRect.height = i2);
  }
  setDepthTestEnabled(t6) {
    this._state.depthTest !== t6 && (true === t6 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t6, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t6) {
    this._state.clearDepth !== t6 && (this.gl.clearDepth(t6), this._state.clearDepth = t6);
  }
  setDepthFunction(t6) {
    this._state.depthFunction !== t6 && (this.gl.depthFunc(t6), this._state.depthFunction = t6, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t6) {
    this._state.depthWrite !== t6 && (this.gl.depthMask(t6), this._state.depthWrite = t6, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t6, e5) {
    this._state.depthRange.zNear === t6 && this._state.depthRange.zFar === e5 || (this.gl.depthRange(t6, e5), this._state.depthRange.zNear = t6, this._state.depthRange.zFar = e5, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t6) {
    this._state.stencilTest !== t6 && (true === t6 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t6, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t6) {
    t6 !== this._state.clearStencil && (this.gl.clearStencil(t6), this._state.clearStencil = t6);
  }
  setStencilFunction(t6, e5, s6) {
    this._state.stencilFunction.func === t6 && this._state.stencilFunction.ref === e5 && this._state.stencilFunction.mask === s6 || (this.gl.stencilFunc(t6, e5, s6), this._state.stencilFunction.face = N.FRONT_AND_BACK, this._state.stencilFunction.func = t6, this._state.stencilFunction.ref = e5, this._state.stencilFunction.mask = s6, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t6, e5, s6, i2) {
    this._state.stencilFunction.face === t6 && this._state.stencilFunction.func === e5 && this._state.stencilFunction.ref === s6 && this._state.stencilFunction.mask === i2 || (this.gl.stencilFuncSeparate(t6, e5, s6, i2), this._state.stencilFunction.face = t6, this._state.stencilFunction.func = e5, this._state.stencilFunction.ref = s6, this._state.stencilFunction.mask = i2, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t6) {
    this._state.stencilWriteMask !== t6 && (this.gl.stencilMask(t6), this._state.stencilWriteMask = t6, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t6, e5, s6) {
    this._state.stencilOperation.face === N.FRONT_AND_BACK && this._state.stencilOperation.fail === t6 && this._state.stencilOperation.zFail === e5 && this._state.stencilOperation.zPass === s6 || (this.gl.stencilOp(t6, e5, s6), this._state.stencilOperation.face = N.FRONT_AND_BACK, this._state.stencilOperation.fail = t6, this._state.stencilOperation.zFail = e5, this._state.stencilOperation.zPass = s6, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t6, e5, s6, i2) {
    this._state.stencilOperation.face === t6 && this._state.stencilOperation.fail === e5 && this._state.stencilOperation.zFail === s6 && this._state.stencilOperation.zPass === i2 || (this.gl.stencilOpSeparate(t6, e5, s6, i2), this._state.stencilOperation.face = t6, this._state.stencilOperation.fail = e5, this._state.stencilOperation.zFail = s6, this._state.stencilOperation.zPass = i2, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t6, e5 = false) {
    const s6 = this._state.activeTexture;
    return t6 >= 0 && (e5 || t6 !== this._state.activeTexture) && (this.gl.activeTexture(X + t6), this._state.activeTexture = t6), s6;
  }
  clear(t6) {
    t6 && this.gl.clear(t6);
  }
  clearSafe(t6, e5 = 255) {
    t6 && (t6 & _.COLOR_BUFFER_BIT && this.setColorMask(true, true, true, true), t6 & _.DEPTH_BUFFER_BIT && this.setDepthWriteEnabled(true), t6 & _.STENCIL_BUFFER_BIT && this.setStencilWriteMask(e5), this.gl.clear(t6));
  }
  drawArrays(t6, e5, s6) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += D2(t6, s6)), this.gl.drawArrays(t6, e5, s6), a()) {
      const t7 = i(this);
      t7 && console.error("drawArrays:", t7);
    }
  }
  drawElements(t6, s6, i2, a2) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += D2(t6, s6)), this.gl.drawElements(t6, s6, i2, a2), a()) {
      const r11 = i(this);
      if (r11) {
        const n7 = this.getBoundVAO(), l4 = n7 == null ? void 0 : n7.indexBuffer, h4 = n7 == null ? void 0 : n7.vertexBuffers, f3 = { indexBuffer: l4, vertexBuffers: h4 }, o6 = { mode: t6, count: s6, type: i2, offset: a2 }, _3 = o(l4, (t7) => t7.size) ?? 0, u2 = a2 + s6, c = _3 < u2 ? `. Buffer is too small. Attempted to draw index ${u2} of ${_3}` : "";
        console.error(`drawElements: ${r11}${c}`, { args: o6, vao: f3 });
      }
    }
  }
  logInfo() {
    a() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    a() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t6, e5, s6, i2) {
    s6 = Math.max(Math.round(s6), 1), i2 = Math.max(Math.round(i2), 1);
    const a2 = this._state.viewport;
    a2.x === t6 && a2.y === e5 && a2.width === s6 && a2.height === i2 || (a2.x = t6, a2.y = e5, a2.width = s6, a2.height = i2, this.gl.viewport(t6, e5, s6, i2));
  }
  getViewport() {
    const t6 = this._state.viewport;
    return { x: t6.x, y: t6.y, width: t6.width, height: t6.height };
  }
  useProgram(t6) {
    var _a;
    this._state.program !== t6 && ((_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = t6, this.gl.useProgram((t6 == null ? void 0 : t6.glName) ?? null));
  }
  bindTexture(t6, e5, a2 = false) {
    (e5 >= this.parameters.maxTextureImageUnits || e5 < 0) && console.error("Input texture unit is out of range of available units!");
    const r11 = this._state.textureUnitMap[e5];
    return t(t6) || null == t6.glName ? (r(r11) && (this.setActiveTexture(e5, a2), this.gl.bindTexture(r11.descriptor.target, null)), this._state.textureUnitMap[e5] = null, r11) : a2 || r11 !== t6 ? (this.setActiveTexture(e5, a2), this.gl.bindTexture(t6.descriptor.target, t6.glName), t6.applyChanges(), this._state.textureUnitMap[e5] = t6, r11) : (t6.isDirty && (this.setActiveTexture(e5, a2), t6.applyChanges()), r11);
  }
  unbindTexture(t6) {
    if (!t(t6))
      for (let e5 = 0; e5 < this.parameters.maxTextureImageUnits; e5++)
        this._state.textureUnitMap[e5] === t6 && (this.bindTexture(null, e5), this._state.textureUnitMap[e5] = null);
  }
  bindFramebuffer(t6, e5 = false) {
    if (e5 || this._state.readFramebuffer !== t6 || this._state.drawFramebuffer !== t6) {
      if (t(t6))
        return this.gl.bindFramebuffer(n2.FRAMEBUFFER, null), this._state.readFramebuffer = null, void (this._state.drawFramebuffer = null);
      t6.initializeAndBind(n2.FRAMEBUFFER), this._state.readFramebuffer = t6, this._state.drawFramebuffer = t6;
    }
  }
  bindFramebufferSeparate(t6, e5, i2 = false) {
    const r11 = e5 === n2.READ_FRAMEBUFFER, n7 = r11 ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (i2 || n7 !== t6) && (t(t6) ? this.gl.bindFramebuffer(e5, null) : t6.initializeAndBind(e5), r11 ? this._state.readFramebuffer = l(t6, null) : this._state.drawFramebuffer = l(t6, null));
  }
  blitFramebuffer(t6, e5, s6 = 0, i2 = 0, a2 = t6.width, r11 = t6.height, n7 = 0, l4 = 0, h4 = e5.width, f3 = e5.height, o6 = _.COLOR_BUFFER_BIT, _3 = L.NEAREST) {
    this.bindFramebufferSeparate(t6, n2.READ_FRAMEBUFFER), this.bindFramebufferSeparate(e5, n2.DRAW_FRAMEBUFFER);
    this.gl.blitFramebuffer(s6, i2, a2, r11, n7, l4, h4, f3, o6, _3);
  }
  bindBuffer(t6, e5) {
    if (t6)
      switch (e5 ?? (e5 = t6.bufferType), e5) {
        case A.ARRAY_BUFFER:
          this._state.vertexBuffer = v(this.gl, t6, e5, this._state.vertexBuffer);
          break;
        case A.ELEMENT_ARRAY_BUFFER:
          this._state.indexBuffer = v(this.gl, t6, e5, this._state.indexBuffer);
          break;
        case A.UNIFORM_BUFFER:
          this._state.uniformBuffer = v(this.gl, t6, e5, this._state.uniformBuffer);
          break;
        case A.PIXEL_PACK_BUFFER:
          this._state.pixelPackBuffer = v(this.gl, t6, e5, this._state.pixelPackBuffer);
          break;
        case A.PIXEL_UNPACK_BUFFER:
          this._state.pixelUnpackBuffer = v(this.gl, t6, e5, this._state.pixelUnpackBuffer);
          break;
        case A.COPY_READ_BUFFER:
          this._state.copyReadBuffer = v(this.gl, t6, e5, this._state.copyReadBuffer);
          break;
        case A.COPY_WRITE_BUFFER:
          this._state.copyWriteBuffer = v(this.gl, t6, e5, this._state.copyWriteBuffer);
      }
  }
  bindRenderbuffer(t6) {
    const e5 = this.gl;
    t6 || (e5.bindRenderbuffer(e5.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t6 && (e5.bindRenderbuffer(e5.RENDERBUFFER, t6.glName), this._state.renderbuffer = t6);
  }
  _getBufferBinding(t6, e5) {
    if (e5 >= this.parameters.maxUniformBufferBindings || e5 < 0)
      return console.error("Uniform buffer binding point is out of range!"), null;
    const i2 = this._state.uniformBufferBindingPoints;
    let a2 = i2[e5];
    return t(a2) && (a2 = { buffer: null, offset: 0, size: 0 }, i2[e5] = a2), a2;
  }
  bindBufferBase(t6, e5, i2) {
    const a2 = this._getBufferBinding(t6, e5);
    if (t(a2))
      return;
    if (a2.buffer === i2 && 0 === a2.offset && 0 === a2.size)
      return;
    this.gl.bindBufferBase(t6, e5, i2 ? i2.glName : null), a2.buffer = i2, a2.offset = 0, a2.size = 0;
  }
  bindBufferRange(t6, e5, i2, a2, r11) {
    const n7 = this._getBufferBinding(t6, e5);
    if (t(n7))
      return;
    if (n7.buffer === i2 && n7.offset === a2 && n7.size === r11)
      return;
    if (a2 % this._parameters.uniformBufferOffsetAlignment != 0)
      return void console.error("Uniform buffer binding offset is not a multiple of the context offset alignment");
    this.gl.bindBufferRange(t6, e5, i2.glName, a2, r11), n7.buffer = i2, n7.offset = a2, n7.size = r11;
  }
  bindUBO(t6, e5, i2, a2) {
    t(e5) ? this.bindBufferBase(A.UNIFORM_BUFFER, t6, null) : (a() && (a2 ?? e5.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), e5.initialize(), void 0 !== i2 && void 0 !== a2 ? this.bindBufferRange(A.UNIFORM_BUFFER, t6, e5.buffer, i2, a2) : this.bindBufferBase(A.UNIFORM_BUFFER, t6, e5.buffer));
  }
  unbindUBO(t6) {
    for (let e5 = 0, s6 = this._state.uniformBufferBindingPoints.length; e5 < s6; e5++) {
      const s7 = this._state.uniformBufferBindingPoints[e5];
      r(s7) && s7.buffer === t6.buffer && this.bindBufferBase(A.UNIFORM_BUFFER, e5, null);
    }
  }
  unbindBuffer(t6) {
    switch (t6) {
      case A.ARRAY_BUFFER:
        this._state.vertexBuffer = v(this.gl, null, t6, this._state.vertexBuffer);
        break;
      case A.ELEMENT_ARRAY_BUFFER:
        this._state.indexBuffer = v(this.gl, null, t6, this._state.indexBuffer);
        break;
      case A.UNIFORM_BUFFER:
        this._state.uniformBuffer = v(this.gl, null, t6, this._state.uniformBuffer);
        break;
      case A.PIXEL_PACK_BUFFER:
        this._state.pixelPackBuffer = v(this.gl, null, t6, this._state.pixelPackBuffer);
        break;
      case A.PIXEL_UNPACK_BUFFER:
        this._state.pixelUnpackBuffer = v(this.gl, null, t6, this._state.pixelUnpackBuffer);
        break;
      case A.COPY_READ_BUFFER:
        this._state.copyReadBuffer = v(this.gl, null, t6, this._state.copyReadBuffer);
        break;
      case A.COPY_WRITE_BUFFER:
        this._state.copyWriteBuffer = v(this.gl, null, t6, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t6 = null) {
    t(t6) ? this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null) : this._state.vertexArrayObject !== t6 && (t6.bind(), this._state.vertexArrayObject = t6);
  }
  async clientWaitAsync(t6 = n(10)) {
    const e5 = this.gl, s6 = e5.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!s6)
      throw new Error("Client wait failed, could not create sync object");
    let i2;
    this.instanceCounter.increment(t2.Sync, s6), e5.flush();
    do {
      await U(t6), i2 = e5.clientWaitSync(s6, 0, 0);
    } while (i2 === r3.TIMEOUT_EXPIRED);
    if (this.instanceCounter.decrement(t2.Sync, s6), e5.deleteSync(s6), i2 === r3.WAIT_FAILED)
      throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t6 = n2.FRAMEBUFFER) {
    return t6 === n2.READ_FRAMEBUFFER ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), this.type === r5.WEBGL2 && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER));
    for (let t6 = 0; t6 < this.parameters.maxTextureImageUnits; ++t6)
      this.bindTexture(null, t6);
    this.setBlendingEnabled(false), this.setBlendFunction(R.ONE, R.ZERO), this.setBlendEquation(T.ADD), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(N.BACK), this.setFrontFace(S.CCW), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(I.LESS), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(I.ALWAYS, 0, 0), this.setStencilOp(O.KEEP, O.KEEP, O.KEEP), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    var _a, _b, _c;
    const t6 = this.capabilities.vao;
    t6 && t6.bindVertexArray(null);
    const { gl: e5, gl2: s6 } = this;
    for (let i2 = 0; i2 < this.parameters.maxVertexAttributes; i2++)
      e5.disableVertexAttribArray(i2);
    if (this._state.vertexBuffer ? e5.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : e5.bindBuffer(A.ARRAY_BUFFER, null), this._state.indexBuffer ? e5.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : e5.bindBuffer(A.ELEMENT_ARRAY_BUFFER, null), r(s6)) {
      this._state.uniformBuffer ? s6.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : s6.bindBuffer(A.UNIFORM_BUFFER, null);
      for (let t7 = 0; t7 < this._parameters.maxUniformBufferBindings; t7++) {
        const e6 = this._state.uniformBufferBindingPoints[t7];
        if (r(e6)) {
          const { buffer: i2, offset: a3, size: r11 } = e6;
          null !== i2 ? 0 === a3 && 0 === r11 ? s6.bindBufferBase(A.UNIFORM_BUFFER, t7, i2.glName) : s6.bindBufferRange(A.UNIFORM_BUFFER, t7, i2.glName, a3, r11) : s6.bindBufferBase(A.UNIFORM_BUFFER, t7, null);
        }
      }
      this._state.pixelPackBuffer ? s6.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : s6.bindBuffer(A.PIXEL_PACK_BUFFER, null), this._state.pixelUnpackBuffer ? s6.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : s6.bindBuffer(A.PIXEL_UNPACK_BUFFER, null), this._state.copyReadBuffer ? s6.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : s6.bindBuffer(A.COPY_READ_BUFFER, null), this._state.copyWriteBuffer ? s6.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : s6.bindBuffer(A.COPY_WRITE_BUFFER, null), s6.bindFramebuffer(n2.READ_FRAMEBUFFER, null), s6.readBuffer(s6.BACK), this._state.readFramebuffer && (s6.bindFramebuffer(n2.READ_FRAMEBUFFER, this._state.readFramebuffer.glName), s6.readBuffer(f.COLOR_ATTACHMENT0)), s6.bindFramebuffer(n2.DRAW_FRAMEBUFFER, ((_a = this._state.drawFramebuffer) == null ? void 0 : _a.glName) ?? null);
    } else
      this._state.readFramebuffer = this._state.drawFramebuffer, e5.bindFramebuffer(n2.FRAMEBUFFER, ((_b = this._state.drawFramebuffer) == null ? void 0 : _b.glName) ?? null);
    if (t6 && this._state.vertexArrayObject) {
      const t7 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t7);
    }
    e5.useProgram(((_c = this._state.program) == null ? void 0 : _c.glName) ?? null), e5.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), e5.bindRenderbuffer(e5.RENDERBUFFER, this._state.renderbuffer ? this._state.renderbuffer.glName : null), true === this._state.blend ? e5.enable(this.gl.BLEND) : e5.disable(this.gl.BLEND), e5.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), e5.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), e5.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), e5.clearDepth(this._state.clearDepth), e5.clearStencil(this._state.clearStencil), e5.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), e5.cullFace(this._state.cullFace), e5.depthFunc(this._state.depthFunction), e5.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? e5.enable(e5.DEPTH_TEST) : e5.disable(e5.DEPTH_TEST), e5.depthMask(this._state.depthWrite), e5.frontFace(this._state.frontFace), e5.lineWidth(1), true === this._state.faceCulling ? e5.enable(e5.CULL_FACE) : e5.disable(e5.CULL_FACE), e5.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? e5.enable(e5.POLYGON_OFFSET_FILL) : e5.disable(e5.POLYGON_OFFSET_FILL), e5.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? e5.enable(e5.SCISSOR_TEST) : e5.disable(e5.SCISSOR_TEST), e5.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), e5.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? e5.enable(e5.STENCIL_TEST) : e5.disable(e5.STENCIL_TEST), e5.stencilMask(this._state.stencilWriteMask);
    for (let r11 = 0; r11 < this.parameters.maxTextureImageUnits; r11++) {
      e5.activeTexture(X + r11), e5.bindTexture(M.TEXTURE_2D, null), e5.bindTexture(M.TEXTURE_CUBE_MAP, null), this.type === r5.WEBGL2 && (e5.bindTexture(M.TEXTURE_3D, null), e5.bindTexture(M.TEXTURE_2D_ARRAY, null));
      const t7 = this._state.textureUnitMap[r11];
      r(t7) && e5.bindTexture(t7.descriptor.target, t7.glName);
    }
    e5.activeTexture(X + this._state.activeTexture);
    const a2 = this._state.viewport;
    e5.viewport(a2.x, a2.y, a2.width, a2.height), this.resetInfo();
  }
  _loadExtensions() {
    this.type === r5.WEBGL1 && this.gl.getExtension("OES_element_index_uint"), this.gl.getExtension("KHR_parallel_shader_compile");
  }
  _loadParameters(t6) {
    const e5 = this.capabilities.textureFilterAnisotropic, s6 = t6.maxAnisotropy ?? 1 / 0, i2 = this.type === r5.WEBGL2, a2 = this.gl, r11 = { versionString: this.gl.getParameter(this.gl.VERSION), maxVertexTextureImageUnits: this.gl.getParameter(this.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxVertexAttributes: this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS), maxMaxAnisotropy: e5 ? Math.min(this.gl.getParameter(e5.MAX_TEXTURE_MAX_ANISOTROPY), s6) : 1, maxTextureImageUnits: this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), maxTextureSize: this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE), maxUniformBufferBindings: i2 ? a2.getParameter(a2.MAX_UNIFORM_BUFFER_BINDINGS) : 0, maxVertexUniformBlocks: i2 ? a2.getParameter(a2.MAX_VERTEX_UNIFORM_BLOCKS) : 0, maxFragmentUniformBlocks: i2 ? a2.getParameter(a2.MAX_FRAGMENT_UNIFORM_BLOCKS) : 0, maxUniformBlockSize: i2 ? a2.getParameter(a2.MAX_UNIFORM_BLOCK_SIZE) : 0, uniformBufferOffsetAlignment: i2 ? a2.getParameter(a2.UNIFORM_BUFFER_OFFSET_ALIGNMENT) : 1, maxArrayTextureLayers: i2 ? a2.getParameter(a2.MAX_ARRAY_TEXTURE_LAYERS) : 1, maxSamples: i2 ? a2.getParameter(a2.MAX_SAMPLES) : 1 };
    return E2.TEXTURE_UNIT_FOR_UPDATES = r11.maxTextureImageUnits - 1, r11;
  }
};
function v(t6, e5, s6, i2) {
  return e5 ? i2 !== e5 && t6.bindBuffer(s6, e5.glName) : t6.bindBuffer(s6, null), e5;
}
function D2(t6, e5) {
  switch (t6) {
    case E.POINTS:
      return 2 * e5;
    case E.TRIANGLES:
      return e5 / 3;
    case E.TRIANGLE_STRIP:
    case E.TRIANGLE_FAN:
      return e5 - 2;
    default:
      return 0;
  }
}

export {
  o3 as o,
  I2 as I
};
//# sourceMappingURL=chunk-6KD655DY.js.map

import {
  C,
  i
} from "./chunk-CRUYGAVA.js";
import {
  $,
  M,
  T as T2
} from "./chunk-B7Q6YQQ3.js";
import {
  S,
  T,
  p
} from "./chunk-W54HDEYS.js";
import {
  D,
  F,
  R,
  b,
  d,
  f3 as f,
  m,
  m3 as m2
} from "./chunk-AY45UIGO.js";
import "./chunk-DXXYF357.js";
import "./chunk-VY77CAXT.js";
import {
  s2 as s
} from "./chunk-UBZEFQ76.js";
import "./chunk-D5KVII6M.js";
import "./chunk-FI2SN5P7.js";
import "./chunk-HNMSCBZJ.js";
import "./chunk-EXVE3AJP.js";
import "./chunk-EMRZKKP3.js";
import "./chunk-MKMLHQNH.js";
import "./chunk-PHPHIDTF.js";
import "./chunk-P6SQPYDS.js";
import "./chunk-3KALZGFA.js";
import "./chunk-6U5BQYRW.js";
import "./chunk-LUOENZ4F.js";
import "./chunk-QGRPG4XS.js";
import "./chunk-M73MMEC7.js";
import {
  w2 as w
} from "./chunk-A5CTLI5A.js";
import "./chunk-WUBKNERF.js";
import "./chunk-FFQG5TD2.js";
import "./chunk-DDRAFOUW.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-GLDJLPWH.js";
import "./chunk-GMLVDTS4.js";
import "./chunk-G7CHVXDR.js";
import "./chunk-OAZLVZFS.js";
import "./chunk-CPSZPA6H.js";
import "./chunk-Y54MR3BP.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-JY6H6KI3.js";
import "./chunk-TTCQP5LX.js";
import "./chunk-C2WY74GI.js";
import "./chunk-MCOYI7PX.js";
import "./chunk-EL4OGCJC.js";
import "./chunk-XPATKIHO.js";
import "./chunk-MKHZ5X6F.js";
import {
  e,
  r
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(e2) {
    const t = m.fromJSON(e2.pixelBlock), o = d(t, e2.type);
    return Promise.resolve(r(o) ? o.toJSON() : null);
  }
  async decode(r2) {
    const e2 = await S(r2.data, r2.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = m.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? w.fromJSON(e2.extent) : null;
    const t = this.symbolizer.symbolize(e2);
    return Promise.resolve(r(t) ? t.toJSON() : null);
  }
  async updateSymbolizer(r2) {
    var _a;
    this.symbolizer = T.fromJSON(r2.symbolizerJSON), r2.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r2.histograms);
  }
  async updateRasterFunction(r2) {
    this.rasterFunction = C(r2.rasterFunctionJSON);
  }
  async process(e2) {
    const t = this.rasterFunction.process({ extent: w.fromJSON(e2.extent), primaryPixelBlocks: e2.primaryPixelBlocks.map((e3) => r(e3) ? m.fromJSON(e3) : null), primaryRasterIds: e2.primaryRasterIds });
    return r(t) ? t.toJSON() : null;
  }
  stretch(e2) {
    const t = this.symbolizer.simpleStretch(m.fromJSON(e2.srcPixelBlock), e2.stretchParams);
    return Promise.resolve(r(t) && t.toJSON());
  }
  estimateStatisticsHistograms(r2) {
    const e2 = p(m.fromJSON(r2.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r2) {
    const e2 = R(m.fromJSON(r2.srcPixelBlock), r2.tileSize, r2.maximumPyramidLevel);
    return e2 && e2.forEach((r3, t) => {
      e2.set(t, r3 == null ? void 0 : r3.toJSON());
    }), Promise.resolve(e2);
  }
  async mosaicAndTransform(r2) {
    const t = r2.srcPixelBlocks.map((r3) => r3 ? new m(r3) : null), o = b(t, r2.srcMosaicSize, { blockWidths: r2.blockWidths, alignmentInfo: r2.alignmentInfo, clipOffset: r2.clipOffset, clipSize: r2.clipSize });
    let i2, l = o;
    return r2.coefs && (l = F(o, r2.destDimension, r2.coefs, r2.sampleSpacing, r2.interpolation)), r2.projectDirections && r2.gcsGrid && (i2 = D(r2.destDimension, r2.gcsGrid), l = e(m2(l, r2.isUV ? "vector-uv" : "vector-magdir", i2))), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: i2 };
  }
  async createFlowMesh(r2, e2) {
    const t = { data: new Float32Array(r2.flowData.buffer), mask: new Uint8Array(r2.flowData.maskBuffer), width: r2.flowData.width, height: r2.flowData.height }, { vertexData: s2, indexData: o } = await f(r2.meshType, r2.simulationSettings, t, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(r2) {
    const e2 = w.fromJSON(r2.projectedExtent), s2 = w.fromJSON(r2.srcBufferExtent);
    let o = null;
    r2.datumTransformationSteps && (o = new s({ steps: r2.datumTransformationSteps })), (r2.includeGCSGrid || M(e2.spatialReference, s2.spatialReference, o)) && await T2();
    const i2 = r2.rasterTransform ? i(r2.rasterTransform) : null;
    return $({ ...r2, projectedExtent: e2, srcBufferExtent: s2, datumTransformation: o, rasterTransform: i2 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-EOLUX4IW.js.map

import {
  a as a2,
  t as t4
} from "./chunk-C5WM5BY7.js";
import {
  r as r3
} from "./chunk-XBPKFV6W.js";
import {
  ee
} from "./chunk-63WRUMNA.js";
import {
  T
} from "./chunk-WAPZ634R.js";
import {
  E as E3,
  f as f3
} from "./chunk-23AC3IC7.js";
import {
  E as E2
} from "./chunk-GKD7ZY5C.js";
import {
  D2,
  F2,
  x3 as x
} from "./chunk-53QORBIP.js";
import {
  t as t2
} from "./chunk-IEBU4QQL.js";
import {
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  O,
  P,
  R
} from "./chunk-4M3AMTD4.js";
import {
  t as t3
} from "./chunk-DUEDINK5.js";
import {
  e as e2
} from "./chunk-MZ267CZB.js";
import {
  M,
  b,
  f as f2,
  h,
  i,
  l as l2,
  r as r2
} from "./chunk-PRXITTX7.js";
import {
  g
} from "./chunk-NUSLMJR5.js";
import {
  u
} from "./chunk-BQXNXAP2.js";
import {
  m
} from "./chunk-JT54I3AY.js";
import {
  l
} from "./chunk-FXMJJBXP.js";
import {
  w,
  w2
} from "./chunk-H2ENCYR3.js";
import {
  a2 as a,
  e,
  v2 as v,
  y3 as y
} from "./chunk-7GTATSRF.js";
import {
  f,
  j
} from "./chunk-QLY5H3XF.js";
import {
  s
} from "./chunk-UG2OEDEE.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/2d/engine/flow/utils.js
function n(e4) {
  const n2 = i2(a3(e4)), o2 = n2, s4 = true, r5 = Math.max(n2 / 2, 5), l7 = Math.round(u(e4.maxPathLength) / r5) + 1, u6 = 10, { density: c4 } = e4;
  return { smoothing: u(e4.smoothing), interpolate: true, velocityScale: "flow-from" === e4.flowRepresentation ? 1 : -1, verticesPerLine: l7, minSpeedThreshold: 1e-3, segmentLength: r5, maxTurnAngle: 1, collisions: s4, lineCollisionWidth: o2, lineSpacing: u6, density: c4 };
}
function i2(e4) {
  return "constant" === e4.kind ? e4.value[0] : e4.values[e4.values.length - 1];
}
function o(e4) {
  const t7 = e4.toRgba();
  return [t7[0] / 255, t7[1] / 255, t7[2] / 255, t7[3]];
}
function s2(e4) {
  return { kind: "constant", value: [0.1, 0.1, 0.1, 1] };
}
function a3(e4) {
  if (!e4.hasVisualVariables("size"))
    return { kind: "constant", value: [u(e4.trailWidth)] };
  const n2 = e4.getVisualVariablesForType("size")[0], i4 = [], o2 = [];
  let s4;
  if (n2.stops) {
    for (const e5 of n2.stops)
      i4.push(e5.value), o2.push(u(e5.size));
    s4 = n2.stops.length;
  } else
    i4.push(n2.minDataValue, n2.maxDataValue), o2.push(u(n2.minSize), u(n2.maxSize)), s4 = 2;
  return { kind: "ramp", stops: i4, values: o2, count: s4 };
}
function r4(e4) {
  if (!e4.hasVisualVariables("color"))
    return { kind: "constant", value: o(e4.color) };
  const t7 = e4.getVisualVariablesForType("color")[0], n2 = [], i4 = [];
  for (const s4 of t7.stops)
    n2.push(s4.value), Array.prototype.push.apply(i4, o(s4.color));
  return { kind: "ramp", stops: n2, values: i4, count: t7.stops.length };
}
function l3(e4) {
  if (!e4.hasVisualVariables("opacity"))
    return { kind: "constant", value: [1] };
  const t7 = e4.getVisualVariablesForType("opacity")[0], n2 = [], i4 = [];
  for (const o2 of t7.stops)
    n2.push(o2.value), i4.push(o2.opacity);
  return { kind: "ramp", stops: n2, values: i4, count: t7.stops.length };
}
function u2(e4, t7, n2, i4) {
  switch (t7) {
    case "int":
      e4.setUniform1iv(n2, i4);
      break;
    case "float":
      e4.setUniform1fv(n2, i4);
      break;
    case "vec2":
      e4.setUniform2fv(n2, i4);
      break;
    case "vec3":
      e4.setUniform3fv(n2, i4);
      break;
    case "vec4":
      e4.setUniform4fv(n2, i4);
  }
}
function c(e4, t7, n2, i4) {
  "constant" === i4.kind ? u2(e4, n2, `u_${t7}`, i4.value) : (u2(e4, "float", `u_${t7}_stops`, i4.stops), u2(e4, n2, `u_${t7}_values`, i4.values), e4.setUniform1i(`u_${t7}_count`, i4.count));
}
function p(e4, t7) {
  let n2 = true;
  return n2 = n2 && e4.collisions === t7.collisions, n2 = n2 && e4.density === t7.density, n2 = n2 && e4.interpolate === t7.interpolate, n2 = n2 && e4.lineCollisionWidth === t7.lineCollisionWidth, n2 = n2 && e4.lineSpacing === t7.lineSpacing, n2 = n2 && e4.maxTurnAngle === t7.maxTurnAngle, n2 = n2 && e4.minSpeedThreshold === t7.minSpeedThreshold, n2 = n2 && e4.segmentLength === t7.segmentLength, n2 = n2 && e4.smoothing === t7.smoothing, n2 = n2 && e4.velocityScale === t7.velocityScale, n2 = n2 && e4.verticesPerLine === t7.verticesPerLine, n2;
}
function f4(t7, n2) {
  return t7 === n2 || !(!r(t7) || !r(n2)) && t7.equals(n2);
}
function m2(e4, t7) {
  if (!p(e4.simulationSettings, t7.simulationSettings))
    return false;
  if (!f4(e4.timeExtent, t7.timeExtent))
    return false;
  let n2 = true;
  return n2 = n2 && e4.loadImagery === t7.loadImagery, n2 = n2 && e4.createFlowMesh === t7.createFlowMesh, n2 = n2 && e4.color.kind === t7.color.kind, n2 = n2 && e4.opacity.kind === t7.opacity.kind, n2 = n2 && e4.size.kind === t7.size.kind, n2;
}

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Imagery.js
var d = class {
  constructor(t7) {
    this._params = t7, this.animated = false;
  }
  isCompatible(t7) {
    if (!(t7 instanceof d))
      return false;
    if (!f4(this._params.timeExtent, t7._params.timeExtent))
      return false;
    let e4 = true;
    return e4 = e4 && this._params.loadImagery === t7._params.loadImagery, e4 = e4 && this._params.color.kind === t7._params.color.kind, e4 = e4 && this._params.opacity.kind === t7._params.opacity.kind, e4;
  }
  async load(a4, e4) {
    const { extent: r5, size: s4 } = a4;
    f(e4);
    const i4 = await this._params.loadImagery(r5, s4[0], s4[1], this._params.timeExtent, e4);
    return new y2(i4, { color: this._params.color, opacity: this._params.opacity });
  }
  render(t7, a4, r5) {
    const { context: s4 } = t7, { program: n2 } = r5;
    s4.setFaceCullingEnabled(false), s4.setBlendingEnabled(true), s4.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), s4.useProgram(n2), n2.setUniformMatrix3fv("u_dvsMat3", a4.dvsMat3), s4.bindTexture(r5.texture, 0), n2.setUniform1i("u_texture", 0), n2.setUniform1f("u_Min", r5.min), n2.setUniform1f("u_Max", r5.max), c(n2, "color", "vec4", this._params.color), c(n2, "opacity", "float", this._params.opacity), s4.bindVAO(r5.vertexArray), s4.drawArrays(E.TRIANGLE_STRIP, 0, 4);
  }
};
var u3 = /* @__PURE__ */ new Map();
u3.set("a_position", 0), u3.set("a_texcoord", 1);
var w3 = { geometry: [new t2("a_position", 2, C.UNSIGNED_SHORT, 0, 8), new t2("a_texcoord", 2, C.UNSIGNED_SHORT, 4, 8)] };
var x2 = { vsPath: "raster/flow/imagery", fsPath: "raster/flow/imagery", attributes: u3 };
var y2 = class {
  constructor(t7, a4) {
    this._flowData = t7, this._values = a4;
  }
  attach(t7) {
    const { context: a4 } = t7, { width: e4, height: s4 } = this._flowData, i4 = E3.createVertex(a4, F.STATIC_DRAW, new Uint16Array([0, 0, 0, 1, e4, 0, 1, 1, 0, s4, 0, 0, e4, s4, 1, 0])), o2 = new f3(a4, u3, w3, { geometry: i4 }), f9 = [];
    "ramp" === this._values.color.kind && f9.push("vvColor"), "ramp" === this._values.opacity.kind && f9.push("vvOpacity");
    const d6 = t7.painter.materialManager.getProgram(x2, f9);
    let y6 = 1e6, g3 = -1e6;
    for (let r5 = 0; r5 < s4; r5++)
      for (let t8 = 0; t8 < e4; t8++)
        if (0 !== this._flowData.mask[r5 * e4 + t8]) {
          const a5 = this._flowData.data[2 * (r5 * e4 + t8) + 0], s5 = this._flowData.data[2 * (r5 * e4 + t8) + 1], i5 = Math.sqrt(a5 * a5 + s5 * s5);
          y6 = Math.min(y6, i5), g3 = Math.max(g3, i5);
        }
    const A = new Uint8Array(4 * e4 * s4);
    for (let r5 = 0; r5 < s4; r5++)
      for (let t8 = 0; t8 < e4; t8++)
        if (0 !== this._flowData.mask[r5 * e4 + t8]) {
          const a5 = this._flowData.data[2 * (r5 * e4 + t8) + 0], s5 = this._flowData.data[2 * (r5 * e4 + t8) + 1], i5 = (Math.sqrt(a5 * a5 + s5 * s5) - y6) / (g3 - y6);
          A[4 * (r5 * e4 + t8) + 0] = 255 * i5, A[4 * (r5 * e4 + t8) + 1] = 0, A[4 * (r5 * e4 + t8) + 2] = 0, A[4 * (r5 * e4 + t8) + 3] = 255;
        } else
          A[4 * (r5 * e4 + t8) + 0] = 0, A[4 * (r5 * e4 + t8) + 1] = 0, A[4 * (r5 * e4 + t8) + 2] = 0, A[4 * (r5 * e4 + t8) + 3] = 0;
    const E4 = new E2(a4, { pixelFormat: P.RGBA, internalFormat: P.RGBA, samplingMode: L.LINEAR, dataType: G.UNSIGNED_BYTE, wrapMode: D.CLAMP_TO_EDGE, flipped: true, width: e4, height: s4 }, A);
    this.vertexArray = o2, this.program = d6, this.texture = E4, this.min = y6, this.max = g3, this._flowData = null;
  }
  detach() {
    this.vertexArray.dispose(), this.texture.dispose();
  }
  get ready() {
    return this.program.compiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Particles.js
var _ = class {
  constructor(t7) {
    this._params = t7;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(t7) {
    return t7 instanceof _ && m2(this._params, t7._params);
  }
  async load(e4, a4) {
    const { extent: s4, size: r5 } = e4;
    f(a4);
    const i4 = await this._params.loadImagery(s4, r5[0], r5[1], this._params.timeExtent, a4), { vertexData: o2, indexData: n2 } = await this._params.createFlowMesh("Particles", this._params.simulationSettings, i4, a4);
    return new c2(o2, n2, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(t7, e4, s4) {
    const { context: n2 } = t7, { program: m5 } = s4;
    n2.setFaceCullingEnabled(false), n2.setBlendingEnabled(true), n2.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n2.useProgram(m5), m5.setUniform1f("u_time", e4.time), m5.setUniform1f("u_trailLength", this._params.trailLength), m5.setUniform1f("u_flowSpeed", this._params.flowSpeed), m5.setUniform1f("u_featheringSize", this._params.featheringSize), m5.setUniform1f("u_featheringOffset", this._params.featheringOffset), m5.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m5.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m5.setUniform1f("u_decayRate", this._params.decayRate), m5.setUniformMatrix3fv("u_dvsMat3", e4.dvsMat3), m5.setUniformMatrix3fv("u_displayViewMat3", e4.displayViewMat3), c(m5, "color", "vec4", this._params.color), c(m5, "opacity", "float", this._params.opacity), c(m5, "size", "float", this._params.size), n2.bindVAO(s4.vertexArray), n2.drawElements(E.TRIANGLES, s4.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l4 = /* @__PURE__ */ new Map();
l4.set("a_xyts0", 0), l4.set("a_xyts1", 1), l4.set("a_typeIdDurationSeed", 2), l4.set("a_extrudeInfo", 3);
var h2 = { geometry: [new t2("a_xyts0", 4, C.FLOAT, 0, 64), new t2("a_xyts1", 4, C.FLOAT, 16, 64), new t2("a_typeIdDurationSeed", 4, C.FLOAT, 32, 64), new t2("a_extrudeInfo", 4, C.FLOAT, 48, 64)] };
var f5 = { vsPath: "raster/flow/particles", fsPath: "raster/flow/particles", attributes: l4 };
var c2 = class {
  constructor(t7, e4, a4) {
    this._vertexData = t7, this._indexData = e4, this._values = a4;
  }
  attach(t7) {
    const { context: e4 } = t7, a4 = E3.createVertex(e4, F.STATIC_DRAW, this._vertexData), r5 = E3.createIndex(e4, F.STATIC_DRAW, this._indexData), i4 = new f3(e4, l4, h2, { geometry: a4 }, r5), o2 = [];
    "ramp" === this._values.color.kind && o2.push("vvColor"), "ramp" === this._values.opacity.kind && o2.push("vvOpacity"), "ramp" === this._values.size.kind && o2.push("vvSize");
    const p3 = t7.painter.materialManager.getProgram(f5, o2);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.compiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Stack.js
var t5 = class {
  constructor(t7) {
    this._styles = t7;
  }
  get animated() {
    return this._styles.reduce((t7, s4) => t7 || s4.animated, false);
  }
  isCompatible(s4) {
    if (!(s4 instanceof t5))
      return false;
    if (this._styles.length !== s4._styles.length)
      return false;
    const e4 = this._styles.length;
    for (let t7 = 0; t7 < e4; t7++)
      if (!this._styles[t7].isCompatible(s4._styles[t7]))
        return false;
    return true;
  }
  async load(t7, e4) {
    const r5 = await Promise.all(this._styles.map((s4) => s4.load(t7, e4)));
    return new s3(r5);
  }
  render(t7, s4, e4) {
    for (let r5 = 0; r5 < this._styles.length; r5++)
      this._styles[r5].render(t7, s4, e4.resources[r5]);
  }
};
var s3 = class {
  constructor(t7) {
    this.resources = t7;
  }
  attach(t7) {
    for (const s4 of this.resources)
      s4.attach(t7);
  }
  detach() {
    for (const t7 of this.resources)
      t7.detach();
  }
  get ready() {
    return this.resources.reduce((t7, s4) => t7 && s4.ready, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/styles/Streamlines.js
var _2 = class {
  constructor(e4) {
    this._params = e4;
  }
  get animated() {
    return this._params.flowSpeed > 0;
  }
  isCompatible(e4) {
    return e4 instanceof _2 && m2(this._params, e4._params);
  }
  async load(t7, a4) {
    const { extent: s4, size: r5 } = t7;
    f(a4);
    const i4 = await this._params.loadImagery(s4, r5[0], r5[1], this._params.timeExtent, a4), { vertexData: o2, indexData: n2 } = await this._params.createFlowMesh("Streamlines", this._params.simulationSettings, i4, a4);
    return new d2(o2, n2, { color: this._params.color, opacity: this._params.opacity, size: this._params.size });
  }
  render(e4, t7, s4) {
    const { context: n2 } = e4, { program: m5 } = s4;
    n2.setFaceCullingEnabled(false), n2.setBlendingEnabled(true), n2.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), n2.useProgram(m5), m5.setUniform1f("u_time", t7.time), m5.setUniform1f("u_trailLength", this._params.trailLength), m5.setUniform1f("u_flowSpeed", this._params.flowSpeed), m5.setUniform1f("u_featheringSize", this._params.featheringSize), m5.setUniform1f("u_featheringOffset", this._params.featheringOffset), m5.setUniform1f("u_introFade", this._params.introFade ? 1 : 0), m5.setUniform1f("u_fadeToZero", this._params.fadeToZero ? 1 : 0), m5.setUniform1f("u_decayRate", this._params.decayRate), m5.setUniformMatrix3fv("u_dvsMat3", t7.dvsMat3), m5.setUniformMatrix3fv("u_displayViewMat3", t7.displayViewMat3), c(m5, "color", "vec4", this._params.color), c(m5, "opacity", "float", this._params.opacity), c(m5, "size", "float", this._params.size), n2.bindVAO(s4.vertexArray), n2.drawElements(E.TRIANGLES, s4.indexCount, C.UNSIGNED_INT, 0);
  }
};
var l5 = /* @__PURE__ */ new Map();
l5.set("a_positionAndSide", 0), l5.set("a_timeInfo", 1), l5.set("a_extrude", 2), l5.set("a_speed", 3);
var h3 = { geometry: [new t2("a_positionAndSide", 3, C.FLOAT, 0, 36), new t2("a_timeInfo", 3, C.FLOAT, 12, 36), new t2("a_extrude", 2, C.FLOAT, 24, 36), new t2("a_speed", 1, C.FLOAT, 32, 36)] };
var f6 = { vsPath: "raster/flow/streamlines", fsPath: "raster/flow/streamlines", attributes: l5 };
var d2 = class {
  constructor(e4, t7, a4) {
    this._vertexData = e4, this._indexData = t7, this._values = a4;
  }
  attach(e4) {
    const { context: t7 } = e4, a4 = E3.createVertex(t7, F.STATIC_DRAW, this._vertexData), r5 = E3.createIndex(t7, F.STATIC_DRAW, this._indexData), i4 = new f3(t7, l5, h3, { geometry: a4 }, r5), o2 = [];
    "ramp" === this._values.color.kind && o2.push("vvColor"), "ramp" === this._values.opacity.kind && o2.push("vvOpacity"), "ramp" === this._values.size.kind && o2.push("vvSize");
    const p3 = e4.painter.materialManager.getProgram(f6, o2);
    this.vertexArray = i4, this.program = p3, this.indexCount = this._indexData.length, this._vertexData = null, this._indexData = null;
  }
  detach() {
    this.vertexArray.dispose();
  }
  get ready() {
    return this.program.compiled;
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/createFlowStyle.js
var f7 = 4;
var p2 = 1;
var u4 = 0.5;
var y3 = true;
var d3 = true;
var g2 = 2.3;
function w4(w5, h6) {
  const { flowSpeed: j2, trailLength: v2 } = w5, S = n(w5);
  let k = null;
  const x3 = { opacity: l3(w5), size: a3(w5) };
  let I2 = r4(w5);
  if ("none" === w5.background)
    x3.color = I2;
  else {
    "constant" === I2.kind && (I2 = { kind: "ramp", stops: [0, 1], values: [0, 0, 0, 1, I2.value[0], I2.value[1], I2.value[2], I2.value[3]], count: 2 });
    const e4 = { loadImagery: h6.loadImagery, timeExtent: h6.timeExtent, color: I2, opacity: { kind: "constant", value: [1] } };
    k = new d(e4), x3.color = s2();
  }
  const z = { loadImagery: h6.loadImagery, createFlowMesh: h6.createFlowMesh, simulationSettings: S, timeExtent: h6.timeExtent, trailLength: v2, flowSpeed: j2, featheringSize: p2, featheringOffset: u4, introFade: y3, fadeToZero: d3, decayRate: g2, color: x3.color, opacity: x3.opacity, size: x3.size }, E4 = "butt" === w5.trailCap || i2(a3(w5)) <= f7 ? new _2(z) : new _(z);
  return r(k) ? new t5([k, E4]) : E4;
}

// node_modules/@arcgis/core/views/2d/engine/flow/BrushFlow.js
var i3 = class extends t4 {
  constructor() {
    super(...arguments), this._visualState = { time: 0, dvsMat3: e2(), displayViewMat3: e2() };
  }
  dispose() {
  }
  prepareState(t7) {
    const { context: e4 } = t7;
    e4.setColorMask(true, true, true, true), e4.setStencilFunction(I.EQUAL, 0, 255);
  }
  draw(s4, a4) {
    const { requestRender: r5, allowDelayedRender: i4 } = s4, { displayData: o2 } = a4;
    if (t(o2))
      return;
    if ("loaded" === o2.state.name && o2.attach(s4), "attached" !== o2.state.name)
      return;
    const l7 = o2.state.resources;
    i4 && !l7.ready && r(r5) ? r5() : (this._visualState.time = s4.time / 1e3, this._visualState.dvsMat3 = a4.transforms.dvs, this._visualState.displayViewMat3 = s4.state.displayViewMat3, o2.flowStyle.render(s4, this._visualState, l7), o2.flowStyle.animated && r(r5) && r5());
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowContainer.js
var t6 = class extends a2 {
  constructor() {
    super(...arguments), this.flowStyle = null;
  }
  get requiresDedicatedFBO() {
    return false;
  }
  doRender(e4) {
    super.doRender(e4);
  }
  prepareRenderPasses(s4) {
    const t7 = s4.registerRenderPass({ name: "flow", brushes: [i3], target: () => this.children, drawPhase: T.MAP });
    return [...super.prepareRenderPasses(s4), t7];
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayData.js
var e3 = class {
  constructor(t7, e4, s4, a4) {
    this.state = { name: "created" }, this.flowStyle = t7, this.extent = e4, this.size = s4, this.pixelRatio = a4;
  }
  async load() {
    const t7 = new AbortController();
    this.state = { name: "loading", abortController: t7 };
    const e4 = { extent: this.extent, size: this.size, pixelRatio: this.pixelRatio }, s4 = await this.flowStyle.load(e4, t7.signal);
    this.state = { name: "loaded", resources: s4 };
  }
  attach(e4) {
    if ("loaded" !== this.state.name)
      return void s.getLogger("esri.views.2d.engine.flow.FlowDisplayData").error("Only loaded resources can be attached.");
    const s4 = this.state.resources;
    s4.attach(e4), this.state = { name: "attached", resources: s4 };
  }
  detach() {
    if ("loading" === this.state.name)
      return this.state.abortController.abort(), void (this.state = { name: "detached" });
    "attached" === this.state.name && (this.state.resources.detach(), this.state = { name: "detached" });
  }
  update(t7) {
    if (!this.flowStyle.isCompatible(t7.flowStyle))
      return false;
    return !(!this.extent.equals(t7.extent) || this.size[0] !== t7.size[0] || this.size[1] !== t7.size[1] || this.pixelRatio !== t7.pixelRatio) && (this.flowStyle = t7.flowStyle, true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowDisplayObject.js
var m3 = class extends r3 {
  constructor() {
    super(...arguments), this._displayData = null;
  }
  get displayData() {
    return this._displayData;
  }
  set displayData(t7) {
    this._displayData = t7, this.requestRender();
  }
  clear() {
    r(this._displayData) && (this._displayData.detach(), this._displayData = null, this.requestRender());
  }
  setTransform(s4) {
    const { displayData: n2 } = this;
    if (t(n2))
      return;
    const l7 = n2.extent.xmin, m5 = n2.extent.ymax, p3 = [0, 0];
    s4.toScreen(p3, [l7, m5]);
    const c4 = (n2.extent.xmax - n2.extent.xmin) / n2.size[0] / s4.resolution, d6 = m(s4.rotation), { dvs: h6 } = this.transforms;
    l2(h6, [-1, 1, 0]), f2(h6, h6, [2 / (s4.size[0] * s4.pixelRatio), -2 / (s4.size[1] * s4.pixelRatio), 1]), M(h6, h6, [p3[0], p3[1], 0]), h(h6, h6, d6), f2(h6, h6, [c4 * s4.pixelRatio, c4 * s4.pixelRatio, 1]);
  }
  _createTransforms() {
    return { dvs: e2() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/flow/FlowStrategy.js
var h4 = 1.15;
var y4 = class extends v {
  constructor(t7) {
    super(t7), this._flowDisplayObject = new m3(), this._loading = null;
  }
  initialize() {
    this.flowContainer.addChild(this._flowDisplayObject);
  }
  destroy() {
    this._clear(), this.flowContainer.removeAllChildren();
  }
  get updating() {
    return null != this._loading;
  }
  update(t7) {
    const { flowStyle: o2 } = this.flowContainer;
    if (t(o2))
      return void this._clear();
    const { extent: i4, rotation: l7, resolution: n2, pixelRatio: p3 } = t7.state, m5 = u5(i4, l7);
    m5.expand(h4);
    const d6 = [Math.round((m5.xmax - m5.xmin) / n2), Math.round((m5.ymax - m5.ymin) / n2)], y6 = new e3(o2, m5, d6, p3);
    if (r(this._loading)) {
      if (this._loading.update(y6))
        return;
      this._loading.detach(), this._loading = null;
    }
    !t(this._flowDisplayObject.displayData) && this._flowDisplayObject.displayData.update(y6) || (y6.load().then(() => {
      this._flowDisplayObject.clear(), this._flowDisplayObject.displayData = this._loading, this._loading = null;
    }, (t8) => {
      j(t8) || (s.getLogger(this.declaredClass).error("A resource failed to load.", t8), this._loading = null);
    }), this._loading = y6);
  }
  _clear() {
    this._flowDisplayObject.clear(), r(this._loading) && (this._loading.detach(), this._loading = null);
  }
};
e([y()], y4.prototype, "_loading", void 0), e([y()], y4.prototype, "flowContainer", void 0), e([y()], y4.prototype, "updating", null), y4 = e([a("esri.views.2d.engine.flow.FlowStrategy")], y4);
var f8 = y4;
function u5(t7, o2) {
  const e4 = new w({ x: (t7.xmax + t7.xmin) / 2, y: (t7.ymax + t7.ymin) / 2, spatialReference: t7.spatialReference }), s4 = t7.xmax - t7.xmin, r5 = t7.ymax - t7.ymin, a4 = Math.abs(Math.cos(m(o2))), l7 = Math.abs(Math.sin(m(o2))), n2 = a4 * s4 + l7 * r5, c4 = l7 * s4 + a4 * r5, m5 = new w2({ xmin: e4.x - n2 / 2, ymin: e4.y - c4 / 2, xmax: e4.x + n2 / 2, ymax: e4.y + c4 / 2, spatialReference: t7.spatialReference });
  return m5.centerAt(e4), m5;
}

// node_modules/@arcgis/core/views/2d/engine/flow/FlowView2D.js
var d4 = class extends v {
  constructor() {
    super(...arguments), this._loadImagery = (t7, e4, i4, r5, o2) => x(this.layer, t7, e4, i4, r5, o2), this._createFlowMesh = (t7, e4, i4, r5) => this.layer.createFlowMesh({ meshType: t7, flowData: i4, simulationSettings: e4 }, { signal: r5 }), this.attached = false, this.type = "flow", this.timeExtent = null, this.redrawOrRefetch = async () => {
      this._updateVisualization();
    };
  }
  get updating() {
    return !this.attached || this._strategy.updating;
  }
  attach() {
    const { layer: t7 } = this, e4 = () => {
      this._loadImagery = (e5, i4, r5, o2, s4) => x(t7, e5, i4, r5, o2, s4), this._updateVisualization();
    };
    "multidimensionalDefinition" in t7 ? this.addHandles(l(() => t7.multidimensionalDefinition, e4)) : this.addHandles([l(() => t7.mosaicRule, e4), l(() => t7.renderingRule, e4), l(() => t7.definitionExpression, e4)]), this.container = new t6(), this._strategy = new f8({ flowContainer: this.container }), this._updateVisualization();
  }
  detach() {
    var _a;
    this._strategy.destroy(), (_a = this.container) == null ? void 0 : _a.removeAllChildren(), this.container = null, this.removeHandles();
  }
  update(t7) {
    t7.stationary ? this._strategy.update(t7) : this.layerView.requestUpdate();
  }
  hitTest(t7) {
    return new g({ attributes: {}, geometry: t7.clone(), layer: this.layer });
  }
  moveEnd() {
  }
  async doRefresh() {
  }
  _updateVisualization() {
    const t7 = this.layer.renderer;
    if (null == t7 || "flow" !== t7.type)
      return;
    const e4 = w4(t7, { loadImagery: this._loadImagery, createFlowMesh: this._createFlowMesh, timeExtent: this.timeExtent });
    this.container.flowStyle = e4, this.layerView.requestUpdate();
  }
};
e([y()], d4.prototype, "_strategy", void 0), e([y()], d4.prototype, "attached", void 0), e([y()], d4.prototype, "container", void 0), e([y()], d4.prototype, "layer", void 0), e([y()], d4.prototype, "layerView", void 0), e([y()], d4.prototype, "type", void 0), e([y()], d4.prototype, "updating", null), e([y()], d4.prototype, "timeExtent", void 0), d4 = e([a("esri.views.2d.engine.flow.FlowView2D")], d4);
var h5 = d4;

// node_modules/@arcgis/core/views/2d/engine/imagery/BrushVectorField.js
var l6 = new Float32Array([0.27058823529411763, 0.4588235294117647, 0.7098039215686275, 1, 0.396078431372549, 0.5372549019607843, 0.7215686274509804, 1, 0.5176470588235295, 0.6196078431372549, 0.7294117647058823, 1, 0.6352941176470588, 0.7058823529411765, 0.7411764705882353, 1, 0.7529411764705882, 0.8, 0.7450980392156863, 1, 0.8705882352941177, 0.8901960784313725, 0.7490196078431373, 1, 1, 1, 0.7490196078431373, 1, 1, 0.8627450980392157, 0.6313725490196078, 1, 0.9803921568627451, 0.7254901960784313, 0.5176470588235295, 1, 0.9607843137254902, 0.596078431372549, 0.4117647058823529, 1, 0.9294117647058824, 0.4588235294117647, 0.3176470588235294, 1, 0.9098039215686274, 0.08235294117647059, 0.08235294117647059, 1]);
var c3 = { beaufort_ft: l6, beaufort_m: l6, beaufort_km: l6, beaufort_mi: l6, beaufort_kn: new Float32Array([0.1568627450980392, 0.5725490196078431, 0.7803921568627451, 1, 0.34901960784313724, 0.6352941176470588, 0.7294117647058823, 1, 0.5058823529411764, 0.7019607843137254, 0.6705882352941176, 1, 0.6274509803921569, 0.7607843137254902, 0.6078431372549019, 1, 0.7490196078431373, 0.8313725490196079, 0.5411764705882353, 1, 0.8549019607843137, 0.9019607843137255, 0.4666666666666667, 1, 0.9803921568627451, 0.9803921568627451, 0.39215686274509803, 1, 0.9882352941176471, 0.8352941176470589, 0.3254901960784314, 1, 0.9882352941176471, 0.7019607843137254, 0.4, 1, 0.9803921568627451, 0.5529411764705883, 0.20392156862745098, 1, 0.9686274509803922, 0.43137254901960786, 0.16470588235294117, 1, 0.9411764705882353, 0.2784313725490196, 0.11372549019607843, 1]), classified_arrow: new Float32Array([0.2196078431372549, 0.6588235294117647, 0, 1, 0.5450980392156862, 1.2117647058823529, 0, 1, 1, 1, 0, 1, 1, 0.5019607843137255, 0, 1, 1, 0, 0, 1]), ocean_current_m: new Float32Array([0.3058823529411765, 0.10196078431372549, 0.6, 1, 0.7019607843137254, 0.10588235294117647, 0.10196078431372549, 1, 0.792156862745098, 0.5019607843137255, 0.10196078431372549, 1, 0.6941176470588235, 0.6941176470588235, 0.6941176470588235, 1]), ocean_current_kn: new Float32Array([0, 0, 0, 1, 0, 0.1450980392156863, 0.39215686274509803, 1, 0.3058823529411765, 0.10196078431372549, 0.6, 1, 0.592156862745098, 0, 0.39215686274509803, 1, 0.7019607843137254, 0.10588235294117647, 0.10196078431372549, 1, 0.6941176470588235, 0.3058823529411765, 0.10196078431372549, 1, 0.792156862745098, 0.5019607843137255, 0.10196078431372549, 1, 0.6941176470588235, 0.7019607843137254, 0.20392156862745098, 1, 0.6941176470588235, 0.6941176470588235, 0.6941176470588235, 1]), single_arrow: new Float32Array([0, 92 / 255, 230 / 255, 1]), wind_speed: new Float32Array([0, 0, 0, 1]) };
var d5 = [0, 20];
var m4 = class extends t4 {
  constructor() {
    super(...arguments), this._desc = { magdir: { vsPath: "raster/magdir", fsPath: "raster/magdir", attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_offset", 1], ["a_vv", 2]]) }, scalar: { vsPath: "raster/scalar", fsPath: "raster/scalar", attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_offset", 1], ["a_vv", 2]]) } };
  }
  dispose() {
  }
  prepareState({ context: e4 }) {
    e4.setBlendingEnabled(true), e4.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e4.setColorMask(true, true, true, true), e4.setStencilWriteMask(0), e4.setStencilTestEnabled(true), e4.setStencilOp(O.KEEP, O.KEEP, O.REPLACE);
  }
  draw(t7, a4) {
    if (t(a4.source) || 0 === a4.source.validPixelCount)
      return;
    const { context: r5, timeline: o2 } = t7;
    if (o2.begin(this.name), r5.setStencilFunction(I.EQUAL, a4.stencilRef, 255), a4.updateVectorFieldVAO(t7), "scalar" === t7.renderPass) {
      const e4 = a4.vaoData.scalar;
      e4 && this._drawScalars(t7, a4, e4.vao, e4.elementCount);
    } else {
      const e4 = a4.vaoData.magdir;
      e4 && this._drawTriangles(t7, a4, e4.vao, e4.elementCount);
    }
    o2.end(this.name);
  }
  _drawTriangles(e4, a4, r5, o2) {
    const { context: s4, painter: l7, requestRender: m5, allowDelayedRender: f9 } = e4, { symbolizerParameters: u6 } = a4, _3 = u6.dataRange ? ["dataRange"] : [];
    "geographic" === u6.rotationType && _3.push("rotationGeographic");
    const g3 = l7.materialManager.getProgram(this._desc.magdir, _3);
    if (f9 && r(m5) && !g3.compiled)
      return void m5();
    s4.useProgram(g3);
    const { coordScale: p3, opacity: y6, transforms: v2 } = a4;
    g3.setUniform2fv("u_coordScale", p3), g3.setUniform1f("u_opacity", y6), g3.setUniformMatrix3fv("u_dvsMat3", v2.dvs);
    const { style: b2, dataRange: S, rotation: h6, symbolPercentRange: w5 } = u6;
    g3.setUniform4fv("u_colors", c3[b2] || c3.single_arrow), g3.setUniform2fv("u_dataRange", S || d5), g3.setUniform1f("u_rotation", h6), g3.setUniform2fv("u_symbolPercentRange", w5);
    const P2 = this._getSymbolSize(e4, a4);
    g3.setUniform2fv("u_symbolSize", P2), s4.bindVAO(r5), s4.drawElements(E.TRIANGLES, o2, C.UNSIGNED_INT, 0);
  }
  _drawScalars(e4, a4, r5, o2) {
    const { context: s4, painter: l7, requestRender: c4, allowDelayedRender: m5 } = e4, { symbolizerParameters: f9 } = a4, u6 = [];
    "wind_speed" === f9.style ? u6.push("innerCircle") : f9.dataRange && u6.push("dataRange"), "geographic" === f9.rotationType && u6.push("rotationGeographic");
    const _3 = l7.materialManager.getProgram(this._desc.scalar, u6);
    if (m5 && r(c4) && !_3.compiled)
      return void c4();
    s4.useProgram(_3);
    const { coordScale: g3, opacity: p3, transforms: y6 } = a4;
    _3.setUniform2fv("u_coordScale", g3), _3.setUniform1f("u_opacity", p3), _3.setUniformMatrix3fv("u_dvsMat3", y6.dvs);
    const { dataRange: v2, symbolPercentRange: b2 } = f9;
    _3.setUniform2fv("u_dataRange", v2 || d5), _3.setUniform2fv("u_symbolPercentRange", b2);
    const S = this._getSymbolSize(e4, a4);
    _3.setUniform2fv("u_symbolSize", S), s4.bindVAO(r5), s4.drawElements(E.TRIANGLES, o2, C.UNSIGNED_INT, 0);
  }
  _getSymbolSize(e4, t7) {
    const a4 = t7.key ? 2 ** (e4.displayLevel - t7.key.level) : t7.resolution / e4.state.resolution, { symbolTileSize: r5 } = t7.symbolizerParameters;
    return [r5 / (Math.round((t7.width - t7.offset[0]) / r5) * r5) / a4, r5 / (Math.round((t7.height - t7.offset[1]) / r5) * r5) / a4];
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFDisplayObject.js
var y5 = class extends r3 {
  constructor(t7 = null) {
    super(), this._source = null, this._symbolizerParameters = null, this._vaoInvalidated = true, this.coordScale = [1, 1], this.height = null, this.key = null, this.offset = null, this.stencilRef = 0, this.resolution = null, this.pixelRatio = 1, this.x = 0, this.y = 0, this.rotation = 0, this.rawPixelData = null, this.vaoData = null, this.width = null, this.source = t7;
  }
  destroy() {
    var _a, _b;
    r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null);
  }
  get symbolizerParameters() {
    return this._symbolizerParameters;
  }
  set symbolizerParameters(t7) {
    JSON.stringify(this._symbolizerParameters) !== JSON.stringify(t7) && (this._symbolizerParameters = t7, this.invalidateVAO());
  }
  get source() {
    return this._source;
  }
  set source(t7) {
    this._source = t7, this.invalidateVAO();
  }
  invalidateVAO() {
    var _a, _b;
    !this._vaoInvalidated && r(this.vaoData) && ((_a = this.vaoData.magdir) == null ? void 0 : _a.vao.dispose(), (_b = this.vaoData.scalar) == null ? void 0 : _b.vao.dispose(), this.vaoData = null, this._vaoInvalidated = true, this.requestRender());
  }
  updateVectorFieldVAO(s4) {
    if (this._vaoInvalidated) {
      if (this._vaoInvalidated = false, r(this.source) && t(this.vaoData)) {
        const { style: t7 } = this.symbolizerParameters;
        switch (t7) {
          case "beaufort_ft":
          case "beaufort_km":
          case "beaufort_kn":
          case "beaufort_m":
          case "beaufort_mi":
          case "classified_arrow":
          case "ocean_current_kn":
          case "ocean_current_m":
          case "single_arrow":
            {
              const t8 = F2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t8);
              this.vaoData = { magdir: e4 };
            }
            break;
          case "simple_scalar":
            {
              const t8 = D2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t8);
              this.vaoData = { scalar: e4 };
            }
            break;
          case "wind_speed": {
            const t8 = F2(this.source, this.symbolizerParameters), e4 = this._createVectorFieldVAO(s4.context, t8), a4 = D2(this.source, this.symbolizerParameters), r5 = this._createVectorFieldVAO(s4.context, a4);
            this.vaoData = { magdir: e4, scalar: r5 };
          }
        }
      }
      this.ready(), this.requestRender();
    }
  }
  _createTransforms() {
    return { dvs: e2() };
  }
  setTransform(t7) {
    const e4 = r2(this.transforms.dvs), [n2, c4] = t7.toScreenNoRotation([0, 0], [this.x, this.y]), h6 = this.resolution / this.pixelRatio / t7.resolution, m5 = h6 * this.width, u6 = h6 * this.height, d6 = Math.PI * this.rotation / 180;
    M(e4, e4, t3(n2, c4)), M(e4, e4, t3(m5 / 2, u6 / 2)), h(e4, e4, -d6), M(e4, e4, t3(-m5 / 2, -u6 / 2)), b(e4, e4, t3(m5, u6)), i(this.transforms.dvs, t7.displayViewMat3, e4);
  }
  onAttach() {
    this.invalidateVAO();
  }
  onDetach() {
    this.invalidateVAO();
  }
  _createVectorFieldVAO(t7, e4) {
    const { vertexData: s4, indexData: a4 } = e4, r5 = E3.createVertex(t7, F.STATIC_DRAW, new Float32Array(s4)), i4 = E3.createIndex(t7, F.STATIC_DRAW, new Uint32Array(a4)), o2 = ee("vector-field", { geometry: [{ location: 0, name: "a_pos", count: 2, type: C.FLOAT, normalized: false }, { location: 1, name: "a_offset", count: 2, type: C.FLOAT, normalized: false }, { location: 2, name: "a_vv", count: 2, type: C.FLOAT, normalized: false }] });
    return { vao: new f3(t7, o2.attributes, o2.bufferLayouts, { geometry: r5 }, i4), elementCount: a4.length };
  }
};

export {
  h5 as h,
  m4 as m,
  y5 as y
};
//# sourceMappingURL=chunk-DIF7L65F.js.map

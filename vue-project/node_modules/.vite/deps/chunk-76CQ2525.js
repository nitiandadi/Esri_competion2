import {
  o as o3,
  r as r7
} from "./chunk-HPIY7K2R.js";
import {
  W,
  _ as _2
} from "./chunk-NPWYQ752.js";
import {
  E as E2,
  f as f3
} from "./chunk-Y5X2DTPS.js";
import {
  a as a4
} from "./chunk-YNAIRSAG.js";
import {
  s
} from "./chunk-M4BOMPS2.js";
import {
  N,
  u as u2
} from "./chunk-PYN2S3CJ.js";
import {
  u as u4,
  u2 as u5
} from "./chunk-4MYB3ZET.js";
import {
  e as e8,
  h as h3
} from "./chunk-AOWDF277.js";
import {
  a as a3,
  a2 as a5,
  a3 as a6,
  e as e9,
  e2 as e10,
  f as f2,
  i as i2,
  i2 as i3,
  o3 as o5,
  r as r8,
  u as u3
} from "./chunk-WIXENOEZ.js";
import {
  n as n4,
  o as o4
} from "./chunk-AETXSJBI.js";
import {
  r as r5
} from "./chunk-NYEHTF4M.js";
import {
  r as r6
} from "./chunk-S7QT5QV2.js";
import {
  t as t2
} from "./chunk-CCKR7UFK.js";
import {
  C as C2,
  E,
  F
} from "./chunk-DNXRTHCH.js";
import {
  O as O3
} from "./chunk-HGP4MVO6.js";
import {
  e as e6,
  o as o2
} from "./chunk-LIRZ5PLW.js";
import {
  e as e5
} from "./chunk-QEKBHUVW.js";
import {
  e as e7
} from "./chunk-TKZTELJQ.js";
import {
  i
} from "./chunk-FI2SN5P7.js";
import {
  n as n2,
  r as r4
} from "./chunk-HSDJ4PR2.js";
import {
  G,
  O as O2,
  a as a2
} from "./chunk-OJCBSPLX.js";
import {
  n as n3
} from "./chunk-VWOAL3VX.js";
import {
  a,
  h as h2,
  m
} from "./chunk-BF3T2CWA.js";
import {
  O,
  _,
  e2 as e4,
  f,
  n,
  o,
  r as r2,
  u2 as u,
  z
} from "./chunk-PTCP7EIR.js";
import {
  r as r3
} from "./chunk-Z4G4Y7TU.js";
import {
  e,
  e4 as e3,
  l
} from "./chunk-Y54MR3BP.js";
import {
  C
} from "./chunk-TTCQP5LX.js";
import {
  c
} from "./chunk-MKHZ5X6F.js";
import {
  e as e2,
  h,
  r,
  t,
  y
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js
var h4;
!function(h10) {
  h10[h10.Color = 0] = "Color", h10[h10.Depth = 1] = "Depth", h10[h10.Normal = 2] = "Normal", h10[h10.Shadow = 3] = "Shadow", h10[h10.ShadowHighlight = 4] = "ShadowHighlight", h10[h10.ShadowExcludeHighlight = 5] = "ShadowExcludeHighlight", h10[h10.Highlight = 6] = "Highlight", h10[h10.Alpha = 7] = "Alpha", h10[h10.ObjectAndLayerIdColor = 8] = "ObjectAndLayerIdColor", h10[h10.COUNT = 9] = "COUNT";
}(h4 || (h4 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js
var d;
function o6(o24, v6) {
  switch (v6.textureCoordinateType) {
    case d.Default:
      return o24.attributes.add(O3.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), void o24.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
}`);
    case d.Compressed:
      return o24.attributes.add(O3.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), void o24.vertex.code.add(o4`vec2 getUV0() {
return uv0 / 16384.0;
}
void forwardTextureCoordinates() {
vuv0 = getUV0();
}`);
    case d.Atlas:
      return o24.attributes.add(O3.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), o24.attributes.add(O3.UVREGION, "vec4"), o24.varyings.add("vuvRegion", "vec4"), void o24.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`);
    default:
      n3(v6.textureCoordinateType);
    case d.None:
      return void o24.vertex.code.add(o4`void forwardTextureCoordinates() {}`);
    case d.COUNT:
      return;
  }
}
!function(e27) {
  e27[e27.None = 0] = "None", e27[e27.Default = 1] = "Default", e27[e27.Atlas = 2] = "Atlas", e27[e27.Compressed = 3] = "Compressed", e27[e27.COUNT = 4] = "COUNT";
}(d || (d = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js
var e11 = class extends i2 {
  constructor(r19, e27) {
    super(r19, "vec3", a3.Pass, (s6, o24, t14) => s6.setUniform3fv(r19, e27(o24, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function t3(t14) {
  t14.extensions.add("GL_EXT_shader_texture_lod"), t14.extensions.add("GL_OES_standard_derivatives"), t14.fragment.code.add(o4`#ifndef GL_EXT_shader_texture_lod
float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {
float deltaMaxSqr = max(dot(ddx, ddx), dot(ddy, ddy));
return max(0.0, 0.5 * log2(deltaMaxSqr));
}
#endif
vec4 textureAtlasLookup(sampler2D texture, vec2 textureSize, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
#ifdef GL_EXT_shader_texture_lod
return texture2DGradEXT(texture, uvAtlas, dUVdx, dUVdy);
#else
vec2 dUVdxAuto = dFdx(uvAtlas);
vec2 dUVdyAuto = dFdy(uvAtlas);
float mipMapLevel = calcMipMapLevel(dUVdx * textureSize, dUVdy * textureSize);
float autoMipMapLevel = calcMipMapLevel(dUVdxAuto * textureSize, dUVdyAuto * textureSize);
return texture2D(texture, uvAtlas, mipMapLevel - autoMipMapLevel);
#endif
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function a7(a13, s6) {
  switch (a13.include(o6, s6), a13.fragment.code.add(o4`
  struct TextureLookupParameter {
    vec2 uv;
    ${s6.supportsTextureAtlas ? "vec2 size;" : ""}
  } vtc;
  `), s6.textureCoordinateType) {
    case d.Default:
    case d.Compressed:
      return void a13.fragment.code.add(o4`vec4 textureLookup(sampler2D texture, TextureLookupParameter params) {
return texture2D(texture, params.uv);
}`);
    case d.Atlas:
      return a13.include(t3), void a13.fragment.code.add(o4`vec4 textureLookup(sampler2D texture, TextureLookupParameter params) {
return textureAtlasLookup(texture, params.size, params.uv, vuvRegion);
}`);
    default:
      n3(s6.textureCoordinateType);
    case d.None:
    case d.COUNT:
      return;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3DrawUniform.js
var o7 = class extends i2 {
  constructor(r19, o24) {
    super(r19, "vec3", a3.Draw, (e27, s6, t14, i12) => e27.setUniform3fv(r19, o24(s6, t14, i12)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterial.js
var t4 = class {
  constructor(e27) {
    this._material = e27.material, this._techniqueRepository = e27.techniqueRep, this._output = e27.output;
  }
  dispose() {
    this._techniqueRepository.release(this._technique);
  }
  get technique() {
    return this._technique;
  }
  get _stippleTextureRepository() {
    return this._techniqueRepository.constructionContext.stippleTextureRepository;
  }
  ensureTechnique(e27, t14) {
    return this._technique = this._techniqueRepository.releaseAndAcquire(e27, this._material.getConfiguration(this._output, t14), this._technique), this._technique;
  }
  ensureResources(t14) {
    return N.LOADED;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLTextureMaterial.js
var h5 = class extends t4 {
  constructor(t14) {
    super(t14), this._numLoading = 0, this._disposed = false, this._textureRepository = t14.textureRep, this._textureId = t14.textureId, this._acquire(t14.textureId, (t15) => this._texture = t15), this._acquire(t14.normalTextureId, (t15) => this._textureNormal = t15), this._acquire(t14.emissiveTextureId, (t15) => this._textureEmissive = t15), this._acquire(t14.occlusionTextureId, (t15) => this._textureOcclusion = t15), this._acquire(t14.metallicRoughnessTextureId, (t15) => this._textureMetallicRoughness = t15);
  }
  dispose() {
    this._texture = y(this._texture), this._textureNormal = y(this._textureNormal), this._textureEmissive = y(this._textureEmissive), this._textureOcclusion = y(this._textureOcclusion), this._textureMetallicRoughness = y(this._textureMetallicRoughness), this._disposed = true;
  }
  ensureResources(t14) {
    return 0 === this._numLoading ? N.LOADED : N.LOADING;
  }
  get textureBindParameters() {
    return new o8(r(this._texture) ? this._texture.glTexture : null, r(this._textureNormal) ? this._textureNormal.glTexture : null, r(this._textureEmissive) ? this._textureEmissive.glTexture : null, r(this._textureOcclusion) ? this._textureOcclusion.glTexture : null, r(this._textureMetallicRoughness) ? this._textureMetallicRoughness.glTexture : null);
  }
  updateTexture(e27) {
    (t(this._texture) || e27 !== this._texture.id) && (this._texture = y(this._texture), this._textureId = e27, this._acquire(this._textureId, (t14) => this._texture = t14));
  }
  _acquire(e27, r19) {
    if (t(e27))
      return void r19(null);
    const u9 = this._textureRepository.acquire(e27);
    if (C(u9))
      return ++this._numLoading, void u9.then((e28) => {
        if (this._disposed)
          return y(e28), void r19(null);
        r19(e28);
      }).finally(() => --this._numLoading);
    r19(u9);
  }
};
var o8 = class extends n4 {
  constructor(t14 = null, e27 = null, s6 = null, i12 = null, r19 = null) {
    super(), this.texture = t14, this.textureNormal = e27, this.textureEmissive = s6, this.textureOcclusion = i12, this.textureMetallicRoughness = r19;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var m2 = r6(0, 0.6, 0.2);
var d2;
!function(e27) {
  e27[e27.Disabled = 0] = "Disabled", e27[e27.Normal = 1] = "Normal", e27[e27.Schematic = 2] = "Schematic", e27[e27.Water = 3] = "Water", e27[e27.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e27[e27.Terrain = 5] = "Terrain", e27[e27.TerrainWithWater = 6] = "TerrainWithWater", e27[e27.COUNT = 7] = "COUNT";
}(d2 || (d2 = {}));
function x(e27, l8) {
  const m6 = e27.fragment, p5 = l8.hasMetallicRoughnessTexture || l8.hasEmissionTexture || l8.hasOcclusionTexture;
  if (l8.pbrMode === d2.Normal && p5 && e27.include(a7, l8), l8.pbrMode !== d2.Schematic)
    if (l8.pbrMode !== d2.Disabled) {
      if (l8.pbrMode === d2.Normal) {
        m6.code.add(o4`vec3 mrr;
vec3 emission;
float occlusion;`);
        const e28 = l8.supportsTextureAtlas ? l8.hasWebGL2Context ? e10.None : e10.Size : e10.None, s6 = l8.pbrTextureBindType;
        l8.hasMetallicRoughnessTexture && (m6.uniforms.add(s6 === a3.Pass ? u3("texMetallicRoughness", (e29) => e29.textureMetallicRoughness, e28) : u4("texMetallicRoughness", (e29) => e29.textureMetallicRoughness, e28)), m6.code.add(o4`void applyMetallnessAndRoughness(TextureLookupParameter params) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, params).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), l8.hasEmissionTexture && (m6.uniforms.add(s6 === a3.Pass ? u3("texEmission", (e29) => e29.textureEmissive, e28) : u4("texEmission", (e29) => e29.textureEmissive, e28)), m6.code.add(o4`void applyEmission(TextureLookupParameter params) {
emission *= textureLookup(texEmission, params).rgb;
}`)), l8.hasOcclusionTexture ? (m6.uniforms.add(s6 === a3.Pass ? u3("texOcclusion", (e29) => e29.textureOcclusion, e28) : u4("texOcclusion", (e29) => e29.textureOcclusion, e28)), m6.code.add(o4`void applyOcclusion(TextureLookupParameter params) {
occlusion *= textureLookup(texOcclusion, params).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : m6.code.add(o4`float getBakedOcclusion() { return 1.0; }`), m6.uniforms.add(s6 === a3.Pass ? [new e11("emissionFactor", (e29) => e29.emissiveFactor), new e11("mrrFactors", (e29) => e29.mrrFactors)] : [new o7("emissionFactor", (e29) => e29.emissiveFactor), new o7("mrrFactors", (e29) => e29.mrrFactors)]), m6.code.add(o4`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;
      ${p5 ? o4`vtc.uv = vuv0;` : ""}
      ${l8.hasMetallicRoughnessTextureTransform ? o4`vtc.uv = metallicRoughnessUV;` : ""}
      ${l8.hasMetallicRoughnessTexture ? l8.supportsTextureAtlas ? o4`
                vtc.size = ${r8(l8, "texMetallicRoughness")};
                applyMetallnessAndRoughness(vtc);` : o4`applyMetallnessAndRoughness(vtc);` : ""}
      ${l8.hasEmissiveTextureTransform ? o4`vtc.uv = emissiveUV;` : ""}
      ${l8.hasEmissionTexture ? l8.supportsTextureAtlas ? o4`
                vtc.size = ${r8(l8, "texEmission")};
                applyEmission(vtc);` : o4`applyEmission(vtc);` : ""}
      ${l8.hasOcclusionTextureTransform ? o4`vtc.uv = occlusionUV;` : ""}
      ${l8.hasOcclusionTexture ? l8.supportsTextureAtlas ? o4`
                vtc.size = ${r8(l8, "texOcclusion")};
                applyOcclusion(vtc);` : o4`applyOcclusion(vtc);` : ""}
    }
  `);
      }
    } else
      m6.code.add(o4`float getBakedOcclusion() { return 1.0; }`);
  else
    m6.code.add(o4`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DecodeNormal.glsl.js
function o9(o24) {
  const f9 = o4`vec3 decodeNormal(vec2 f) {
float z = 1.0 - abs(f.x) - abs(f.y);
return vec3(f + sign(f) * min(z, 0.0), z);
}`;
  o24.vertex.code.add(f9);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js
function i4(i12, d8) {
  switch (d8.normalType) {
    case a8.CompressedAttribute:
      i12.include(o9), i12.attributes.add(O3.NORMALCOMPRESSED, "vec2"), i12.vertex.code.add(o4`vec3 normalModel() {
return decodeNormal(normalCompressed);
}`);
      break;
    case a8.Attribute:
      i12.attributes.add(O3.NORMAL, "vec3"), i12.vertex.code.add(o4`vec3 normalModel() {
return normal;
}`);
      break;
    case a8.ScreenDerivative:
      i12.extensions.add("GL_OES_standard_derivatives"), i12.fragment.code.add(o4`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`);
      break;
    default:
      n3(d8.normalType);
    case a8.COUNT:
    case a8.Ground:
  }
}
var a8;
!function(e27) {
  e27[e27.Attribute = 0] = "Attribute", e27[e27.CompressedAttribute = 1] = "CompressedAttribute", e27[e27.Ground = 2] = "Ground", e27[e27.ScreenDerivative = 3] = "ScreenDerivative", e27[e27.COUNT = 4] = "COUNT";
}(a8 || (a8 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o10(o24) {
  o24.attributes.add(O3.POSITION, "vec3"), o24.vertex.code.add(o4`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js
var e12 = class extends i2 {
  constructor(r19, e27) {
    super(r19, "mat4", a3.Pass, (s6, o24, t14) => s6.setUniformMatrix4fv(r19, e27(o24, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl.js
function c2({ code: c10 }, i12) {
  i12.doublePrecisionRequiresObfuscation ? c10.add(o4`vec3 dpPlusFrc(vec3 a, vec3 b) {
return mix(a, a + b, vec3(notEqual(b, vec3(0))));
}
vec3 dpMinusFrc(vec3 a, vec3 b) {
return mix(vec3(0), a - b, vec3(notEqual(a, b)));
}
vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = dpPlusFrc(hiA, hiB);
vec3 e = dpMinusFrc(t1, hiA);
vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
return t1 + t2;
}`) : c10.add(o4`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = hiA + hiB;
vec3 e = t1 - hiA;
vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
return t1 + t2;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js
var o11 = class extends i2 {
  constructor(r19, o24) {
    super(r19, "mat3", a3.Draw, (e27, s6, t14) => e27.setUniformMatrix3fv(r19, o24(s6, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3PassUniform.js
var e13 = class extends i2 {
  constructor(r19, e27) {
    super(r19, "mat3", a3.Pass, (s6, o24, t14) => s6.setUniformMatrix3fv(r19, e27(o24, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function F2(r19, o24) {
  r19.include(o10);
  const e27 = r19.vertex;
  e27.include(c2, o24), r19.varyings.add("vPositionWorldCameraRelative", "vec3"), r19.varyings.add("vPosition_view", "vec3"), e27.uniforms.add([new e11("transformWorldFromViewTH", (r20) => r20.transformWorldFromViewTH), new e11("transformWorldFromViewTL", (r20) => r20.transformWorldFromViewTL), new e13("transformViewFromCameraRelativeRS", (r20) => r20.transformViewFromCameraRelativeRS), new e12("transformProjFromView", (r20) => r20.transformProjFromView), new o11("transformWorldFromModelRS", (r20) => r20.transformWorldFromModelRS), new o7("transformWorldFromModelTH", (r20) => r20.transformWorldFromModelTH), new o7("transformWorldFromModelTL", (r20) => r20.transformWorldFromModelTL)]), e27.code.add(o4`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e27.code.add(o4`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o24.spherical ? o4`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : o4`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r19.fragment.uniforms.add(new e11("transformWorldFromViewTL", (r20) => r20.transformWorldFromViewTL)), e27.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r19.fragment.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var c3 = class extends n4 {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n(), this.transformWorldFromViewTL = n(), this.transformViewFromCameraRelativeRS = e5(), this.transformProjFromView = e6();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function c4(o24, a13) {
  switch (a13.normalType) {
    case a8.Attribute:
    case a8.CompressedAttribute:
      o24.include(i4, a13), o24.varyings.add("vNormalWorld", "vec3"), o24.varyings.add("vNormalView", "vec3"), o24.vertex.uniforms.add([new o11("transformNormalGlobalFromModel", (r19) => r19.transformNormalGlobalFromModel), new e13("transformNormalViewFromGlobal", (r19) => r19.transformNormalViewFromGlobal)]), o24.vertex.code.add(o4`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case a8.Ground:
      o24.include(F2, a13), o24.varyings.add("vNormalWorld", "vec3"), o24.vertex.code.add(o4`
        void forwardNormal() {
          vNormalWorld = ${a13.spherical ? o4`normalize(vPositionWorldCameraRelative);` : o4`vec3(0.0, 0.0, 1.0);`}
        }
        `);
      break;
    case a8.ScreenDerivative:
      o24.vertex.code.add(o4`void forwardNormal() {}`);
      break;
    default:
      n3(a13.normalType);
    case a8.COUNT:
  }
}
var f4 = class extends c3 {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e5();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js
var o12 = 0.1;
var t5 = 1e-3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t6(e27) {
  e27.varyings.add("linearDepth", "float");
}
function i5(e27) {
  e27.vertex.uniforms.add(new e9("nearFar", (e28, r19) => r19.camera.nearFar));
}
function n6(e27) {
  e27.vertex.code.add(o4`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function d3(a13, d8) {
  const { vertex: s6 } = a13;
  switch (d8.output) {
    case h4.Color:
      if (d8.receiveShadows)
        return t6(a13), void s6.code.add(o4`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case h4.Depth:
    case h4.Shadow:
    case h4.ShadowHighlight:
    case h4.ShadowExcludeHighlight:
      return a13.include(F2, d8), t6(a13), i5(a13), n6(a13), void s6.code.add(o4`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s6.code.add(o4`void forwardLinearDepth() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e14(e27) {
  e27.vertex.code.add(o4`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js
function u6(s6, i12) {
  H(s6, i12, [new o7("slicePlaneOrigin", (e27, s7) => v(i12, e27, s7)), new o7("slicePlaneBasis1", (s7, a13) => {
    var _a;
    return B(i12, s7, a13, (_a = e2(a13.slicePlane)) == null ? void 0 : _a.basis1);
  }), new o7("slicePlaneBasis2", (s7, a13) => {
    var _a;
    return B(i12, s7, a13, (_a = e2(a13.slicePlane)) == null ? void 0 : _a.basis2);
  })]);
}
function H(e27, s6, i12) {
  if (!s6.hasSlicePlane) {
    const i13 = o4`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;
    return s6.hasSliceInVertexProgram && e27.vertex.code.add(i13), void e27.fragment.code.add(i13);
  }
  e27.extensions.add("GL_OES_standard_derivatives"), s6.hasSliceInVertexProgram && e27.vertex.uniforms.add(i12), e27.fragment.uniforms.add(i12);
  const a13 = o4`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`, o24 = o4`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`, c10 = s6.hasSliceHighlight ? o4`
        ${o24}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      ` : o4`#define highlightSlice(_color_, _pos_) (_color_)`;
  s6.hasSliceInVertexProgram && e27.vertex.code.add(a13), e27.fragment.code.add(a13), e27.fragment.code.add(c10);
}
function g(e27, s6, i12) {
  return e27.instancedDoublePrecision ? o(S, i12.camera.viewInverseTransposeMatrix[3], i12.camera.viewInverseTransposeMatrix[7], i12.camera.viewInverseTransposeMatrix[11]) : s6.slicePlaneLocalOrigin;
}
function I(e27, s6) {
  return r(e27) ? e4(L, s6.origin, e27) : s6.origin;
}
function b(e27, s6, o24) {
  return e27.hasSliceTranslatedView ? r(s6) ? i(G2, o24.camera.viewMatrix, s6) : o24.camera.viewMatrix : null;
}
function v(e27, a13, o24) {
  if (t(o24.slicePlane))
    return f;
  const r19 = g(e27, a13, o24), l8 = I(r19, o24.slicePlane), t14 = b(e27, r19, o24);
  return r(t14) ? O(L, l8, t14) : l8;
}
function B(e27, a13, o24, t14) {
  if (t(t14) || t(o24.slicePlane))
    return f;
  const f9 = g(e27, a13, o24), d8 = I(f9, o24.slicePlane), _4 = b(e27, f9, o24);
  return r(_4) ? (u(w, t14, d8), O(L, d8, _4), O(w, w, _4), e4(w, w, L)) : t14;
}
var S = n();
var L = n();
var w = n();
var G2 = e6();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js
function r9(r19, t14) {
  if (n6(r19), t14.hasModelTransformation)
    return r19.vertex.code.add(o4`vec4 transformPositionWithDepth(mat4 proj, mat4 view, mat4 model, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * (model * vec4(pos, 1.0));
depth = calculateLinearDepth(nearFar, eye.z);
return proj * eye;
}`), void r19.vertex.code.add(o4`vec4 transformPosition(mat4 proj, mat4 view, mat4 model, vec3 pos) {
return proj * (view * (model * vec4(pos, 1.0)));
}`);
  r19.vertex.code.add(o4`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`), r19.vertex.code.add(o4`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js
var o13 = class extends i2 {
  constructor(r19, o24) {
    super(r19, "mat4", a3.Draw, (e27, s6, t14) => e27.setUniformMatrix4fv(r19, o24(s6, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js
function c5(r19, e27) {
  e27.instancedDoublePrecision ? r19.constants.add("cameraPosition", "vec3", f) : r19.uniforms.add(new o7("cameraPosition", (r20, e28) => o(f5, e28.camera.viewInverseTransposeMatrix[3] - r20.origin[0], e28.camera.viewInverseTransposeMatrix[7] - r20.origin[1], e28.camera.viewInverseTransposeMatrix[11] - r20.origin[2])));
}
function v2(e27, i12) {
  if (!i12.instancedDoublePrecision)
    return void e27.uniforms.add([new e12("proj", (r19, e28) => e28.camera.projectionMatrix), new o13("view", (e28, a13) => i(w2, a13.camera.viewMatrix, e28.origin)), new o7("localOrigin", (r19) => r19.origin)]);
  const o24 = (r19) => o(f5, r19.camera.viewInverseTransposeMatrix[3], r19.camera.viewInverseTransposeMatrix[7], r19.camera.viewInverseTransposeMatrix[11]);
  e27.uniforms.add([new e12("proj", (r19, e28) => e28.camera.projectionMatrix), new e12("view", (e28, a13) => i(w2, a13.camera.viewMatrix, o24(a13))), new e11("localOrigin", (r19, e28) => o24(e28))]);
}
var w2 = e7();
var f5 = n();
function d4(r19) {
  r19.uniforms.add(new e12("viewNormal", (r20, e27) => e27.camera.viewInverseTransposeMatrix));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js
var t7 = class extends n4 {
  constructor() {
    super(), this._key = "", this._keyDirty = false, this._parameterBits = this._parameterBits ? this._parameterBits.map(() => 0) : [], this._parameterNames || (this._parameterNames = []);
  }
  get key() {
    return this._keyDirty && (this._keyDirty = false, this._key = String.fromCharCode.apply(String, this._parameterBits)), this._key;
  }
  snapshot() {
    const e27 = this._parameterNames, t14 = { key: this.key };
    for (const r19 of e27)
      t14[r19] = this[r19];
    return t14;
  }
};
function r10(e27 = {}) {
  return (t14, r19) => {
    if (t14._parameterNames = t14._parameterNames ?? [], t14._parameterNames.push(r19), null != e27.constValue)
      Object.defineProperty(t14, r19, { get: () => e27.constValue });
    else {
      const s6 = t14._parameterNames.length - 1, a13 = e27.count || 2, i12 = Math.ceil(Math.log2(a13)), o24 = t14._parameterBits ?? [0];
      let h10 = 0;
      for (; o24[h10] + i12 > 16; )
        h10++, h10 >= o24.length && o24.push(0);
      t14._parameterBits = o24;
      const n17 = o24[h10], m6 = (1 << i12) - 1 << n17;
      o24[h10] += i12, Object.defineProperty(t14, r19, { get() {
        return this[s6];
      }, set(e28) {
        if (this[s6] !== e28 && (this[s6] = e28, this._keyDirty = true, this._parameterBits[h10] = this._parameterBits[h10] & ~m6 | +e28 << n17 & m6, "number" != typeof e28 && "boolean" != typeof e28))
          throw new Error("Configuration value for " + r19 + " must be boolean or number, got " + typeof e28);
      } });
    }
  };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var v3 = class extends t7 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false;
  }
};
function p(e27, i12) {
  i12.instanced && i12.instancedDoublePrecision && (e27.attributes.add(O3.MODELORIGINHI, "vec3"), e27.attributes.add(O3.MODELORIGINLO, "vec3"), e27.attributes.add(O3.MODEL, "mat3"), e27.attributes.add(O3.MODELNORMAL, "mat3"));
  const c10 = e27.vertex;
  i12.instancedDoublePrecision && (c10.include(c2, i12), c10.uniforms.add(new o7("viewOriginHi", (e28, i13) => o3(o(b2, i13.camera.viewInverseTransposeMatrix[3], i13.camera.viewInverseTransposeMatrix[7], i13.camera.viewInverseTransposeMatrix[11]), b2))), c10.uniforms.add(new o7("viewOriginLo", (e28, i13) => r7(o(b2, i13.camera.viewInverseTransposeMatrix[3], i13.camera.viewInverseTransposeMatrix[7], i13.camera.viewInverseTransposeMatrix[11]), b2)))), c10.code.add(o4`
    vec3 calculateVPos() {
      ${i12.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `), c10.code.add(o4`
    vec3 subtractOrigin(vec3 _pos) {
      ${i12.instancedDoublePrecision ? o4`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), c10.code.add(o4`
    vec3 dpNormal(vec4 _normal) {
      ${i12.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `), i12.output === h4.Normal && (d4(c10), c10.code.add(o4`
    vec3 dpNormalView(vec4 _normal) {
      ${i12.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `)), i12.hasVertexTangents && c10.code.add(o4`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i12.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `);
}
e([r10()], v3.prototype, "instancedDoublePrecision", void 0);
var b2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl.js
function e15(e27) {
  e27.vertex.code.add(o4`
    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {
      float symbolAlpha = 0.0;

      const float maxTint = 85.0;
      const float maxReplace = 170.0;
      const float scaleAlpha = 3.0;

      if (symbolColor.a > maxReplace) {
        colorMixMode = ${o4.int(r5.Multiply)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);
      } else if (symbolColor.a > maxTint) {
        colorMixMode = ${o4.int(r5.Replace)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);
      } else if (symbolColor.a > 0.0) {
        colorMixMode = ${o4.int(r5.Tint)};
        symbolAlpha = scaleAlpha * symbolColor.a;
      } else {
        colorMixMode = ${o4.int(r5.Multiply)};
        symbolAlpha = 0.0;
      }

      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js
var e16 = class extends i2 {
  constructor(r19, e27) {
    super(r19, "int", a3.Pass, (s6, o24, i12) => s6.setUniform1i(r19, e27(o24, i12)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObjectType.js
var e17;
!function(e27) {
  e27[e27.Layer = 0] = "Layer", e27[e27.Object = 1] = "Object", e27[e27.Mesh = 2] = "Mesh", e27[e27.Line = 3] = "Line", e27[e27.Point = 4] = "Point", e27[e27.Material = 5] = "Material", e27[e27.Texture = 6] = "Texture", e27[e27.COUNT = 7] = "COUNT";
}(e17 || (e17 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function l3(e27) {
  return Math.abs(e27 * e27 * e27);
}
function s2(e27, t14, a13) {
  const i12 = a13.parameters, r19 = a13.paddingPixelsOverride;
  return x2.scale = Math.min(i12.divisor / (t14 - i12.offset), 1), x2.factor = l3(e27), x2.minPixelSize = i12.minPixelSize, x2.paddingPixels = r19, x2;
}
function c6(e27, t14) {
  return 0 === e27 ? t14.minPixelSize : t14.minPixelSize * (1 + 2 * t14.paddingPixels / e27);
}
function o14(t14, a13) {
  return Math.max(h2(t14 * a13.scale, t14, a13.factor), c6(t14, a13));
}
function m3(e27, t14, a13, i12) {
  return o14(e27, s2(t14, a13, i12));
}
var h6 = { curvatureDependent: { min: { curvature: m(10), tiltAngle: m(12), scaleFallOffFactor: 0.5 }, max: { curvature: m(70), tiltAngle: m(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var x2 = { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
var b3 = a2();
function x3(t14, n17, e27, o24, i12, r19) {
  if (t14.visible)
    if (t14.boundingInfo) {
      s(t14.type === e17.Mesh);
      const s6 = n17.tolerance;
      g2(t14.boundingInfo, e27, o24, s6, i12, r19);
    } else {
      const n18 = t14.indices.get(O3.POSITION), s6 = t14.vertexAttributes.get(O3.POSITION);
      y2(e27, o24, 0, n18.length / 3, n18, s6, void 0, i12, r19);
    }
}
var d5 = n();
function g2(t14, n17, i12, r19, s6, c10) {
  if (t(t14))
    return;
  const f9 = O4(n17, i12, d5);
  if (G(b3, t14.bbMin), O2(b3, t14.bbMax), r(s6) && s6.applyToAabb(b3), V(b3, n17, f9, r19)) {
    const { primitiveIndices: e27, indices: o24, position: f10 } = t14, l8 = e27 ? e27.length : o24.length / 3;
    if (l8 > U) {
      const e28 = t14.getChildren();
      if (void 0 !== e28) {
        for (const t15 of e28)
          g2(t15, n17, i12, r19, s6, c10);
        return;
      }
    }
    y2(n17, i12, 0, l8, o24, f10, e27, s6, c10);
  }
}
var M = n();
function y2(t14, n17, e27, i12, r19, s6, c10, f9, l8) {
  if (c10)
    return j(t14, n17, e27, i12, r19, s6, c10, f9, l8);
  const { data: a13, stride: u9 } = s6, m6 = t14[0], p5 = t14[1], h10 = t14[2], b5 = n17[0] - m6, x5 = n17[1] - p5, d8 = n17[2] - h10;
  for (let g5 = e27, y3 = 3 * e27; g5 < i12; ++g5) {
    let t15 = u9 * r19[y3++], n18 = a13[t15++], e28 = a13[t15++], i13 = a13[t15];
    t15 = u9 * r19[y3++];
    let s7 = a13[t15++], c11 = a13[t15++], j3 = a13[t15];
    t15 = u9 * r19[y3++];
    let v6 = a13[t15++], T2 = a13[t15++], O5 = a13[t15];
    r(f9) && ([n18, e28, i13] = f9.applyToVertex(n18, e28, i13, g5), [s7, c11, j3] = f9.applyToVertex(s7, c11, j3, g5), [v6, T2, O5] = f9.applyToVertex(v6, T2, O5, g5));
    const V3 = s7 - n18, L4 = c11 - e28, N3 = j3 - i13, A4 = v6 - n18, P4 = T2 - e28, S3 = O5 - i13, E6 = x5 * S3 - P4 * d8, U2 = d8 * A4 - S3 * b5, W3 = b5 * P4 - A4 * x5, k = V3 * E6 + L4 * U2 + N3 * W3;
    if (Math.abs(k) <= Number.EPSILON)
      continue;
    const B2 = m6 - n18, C3 = p5 - e28, z2 = h10 - i13, H2 = B2 * E6 + C3 * U2 + z2 * W3;
    if (k > 0) {
      if (H2 < 0 || H2 > k)
        continue;
    } else if (H2 > 0 || H2 < k)
      continue;
    const R = C3 * N3 - L4 * z2, Y2 = z2 * V3 - N3 * B2, q2 = B2 * L4 - V3 * C3, w4 = b5 * R + x5 * Y2 + d8 * q2;
    if (k > 0) {
      if (w4 < 0 || H2 + w4 > k)
        continue;
    } else if (w4 > 0 || H2 + w4 < k)
      continue;
    const D2 = (A4 * R + P4 * Y2 + S3 * q2) / k;
    if (D2 >= 0) {
      l8(D2, I2(V3, L4, N3, A4, P4, S3, M), g5, false);
    }
  }
}
function j(t14, n17, e27, i12, r19, s6, c10, f9, l8) {
  const { data: a13, stride: u9 } = s6, m6 = t14[0], p5 = t14[1], h10 = t14[2], b5 = n17[0] - m6, x5 = n17[1] - p5, d8 = n17[2] - h10;
  for (let g5 = e27; g5 < i12; ++g5) {
    const t15 = c10[g5];
    let n18 = 3 * t15, e28 = u9 * r19[n18++], i13 = a13[e28++], s7 = a13[e28++], y3 = a13[e28];
    e28 = u9 * r19[n18++];
    let j3 = a13[e28++], v6 = a13[e28++], T2 = a13[e28];
    e28 = u9 * r19[n18];
    let O5 = a13[e28++], V3 = a13[e28++], L4 = a13[e28];
    r(f9) && ([i13, s7, y3] = f9.applyToVertex(i13, s7, y3, g5), [j3, v6, T2] = f9.applyToVertex(j3, v6, T2, g5), [O5, V3, L4] = f9.applyToVertex(O5, V3, L4, g5));
    const N3 = j3 - i13, A4 = v6 - s7, P4 = T2 - y3, S3 = O5 - i13, E6 = V3 - s7, U2 = L4 - y3, W3 = x5 * U2 - E6 * d8, k = d8 * S3 - U2 * b5, B2 = b5 * E6 - S3 * x5, C3 = N3 * W3 + A4 * k + P4 * B2;
    if (Math.abs(C3) <= Number.EPSILON)
      continue;
    const z2 = m6 - i13, H2 = p5 - s7, R = h10 - y3, Y2 = z2 * W3 + H2 * k + R * B2;
    if (C3 > 0) {
      if (Y2 < 0 || Y2 > C3)
        continue;
    } else if (Y2 > 0 || Y2 < C3)
      continue;
    const q2 = H2 * P4 - A4 * R, w4 = R * N3 - P4 * z2, D2 = z2 * A4 - N3 * H2, F3 = b5 * q2 + x5 * w4 + d8 * D2;
    if (C3 > 0) {
      if (F3 < 0 || Y2 + F3 > C3)
        continue;
    } else if (F3 > 0 || Y2 + F3 < C3)
      continue;
    const G4 = (S3 * q2 + E6 * w4 + U2 * D2) / C3;
    if (G4 >= 0) {
      l8(G4, I2(N3, A4, P4, S3, E6, U2, M), t15, false);
    }
  }
}
var v4 = n();
var T = n();
function I2(t14, n17, e27, o24, c10, f9, l8) {
  return o(v4, t14, n17, e27), o(T, o24, c10, f9), _(l8, v4, T), z(l8, l8), l8;
}
function O4(t14, n17, e27) {
  return o(e27, 1 / (n17[0] - t14[0]), 1 / (n17[1] - t14[1]), 1 / (n17[2] - t14[2]));
}
function V(t14, n17, e27, o24) {
  return L2(t14, n17, e27, o24, 1 / 0);
}
function L2(t14, n17, e27, o24, i12) {
  const r19 = (t14[0] - o24 - n17[0]) * e27[0], s6 = (t14[3] + o24 - n17[0]) * e27[0];
  let c10 = Math.min(r19, s6), f9 = Math.max(r19, s6);
  const l8 = (t14[1] - o24 - n17[1]) * e27[1], a13 = (t14[4] + o24 - n17[1]) * e27[1];
  if (f9 = Math.min(f9, Math.max(l8, a13)), f9 < 0)
    return false;
  if (c10 = Math.max(c10, Math.min(l8, a13)), c10 > f9)
    return false;
  const u9 = (t14[2] - o24 - n17[2]) * e27[2], m6 = (t14[5] + o24 - n17[2]) * e27[2];
  return f9 = Math.min(f9, Math.max(u9, m6)), !(f9 < 0) && (c10 = Math.max(c10, Math.min(u9, m6)), !(c10 > f9) && c10 < i12);
}
function N2(t14, e27, i12, r19, s6) {
  let c10 = (i12.screenLength || 0) * t14.pixelRatio;
  r(s6) && (c10 = m3(c10, r19, e27, s6));
  const f9 = c10 * Math.tan(0.5 * t14.fovY) / (0.5 * t14.fullHeight);
  return a(f9 * e27, i12.minWorldLength || 0, null != i12.maxWorldLength ? i12.maxWorldLength : 1 / 0);
}
function A(t14, n17) {
  const e27 = n17 ? A(n17) : {};
  for (const o24 in t14) {
    let n18 = t14[o24];
    n18 && n18.forEach && (n18 = S2(n18)), null == n18 && o24 in e27 || (e27[o24] = n18);
  }
  return e27;
}
function P(n17, e27) {
  let o24 = false;
  for (const i12 in e27) {
    const r19 = e27[i12];
    void 0 !== r19 && (Array.isArray(r19) ? null === n17[i12] ? (n17[i12] = r19.slice(), o24 = true) : c(n17[i12], r19) && (o24 = true) : n17[i12] !== r19 && (o24 = true, n17[i12] = r19));
  }
  return o24;
}
function S2(t14) {
  const n17 = [];
  return t14.forEach((t15) => n17.push(t15)), n17;
}
var E3 = { multiply: 1, ignore: 2, replace: 3, tint: 4 };
var U = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i6(i12, t14) {
  t14.hasSymbolColors ? (i12.include(e15), i12.attributes.add(O3.SYMBOLCOLOR, "vec4"), i12.varyings.add("colorMixMode", "mediump float"), i12.vertex.code.add(o4`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i12.fragment.uniforms.add(new e16("colorMixMode", (o24) => E3[o24.colorMixMode])), i12.vertex.code.add(o4`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js
function e18(e27, d8) {
  d8.hasVertexColors ? (e27.attributes.add(O3.COLOR, "vec4"), e27.varyings.add("vColor", "vec4"), e27.vertex.code.add(o4`void forwardVertexColor() { vColor = color; }`), e27.vertex.code.add(o4`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : e27.vertex.code.add(o4`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js
function c7(e27) {
  e27.vertex.code.add(o4`float screenSizePerspectiveMinSize(float size, vec4 factor) {
float nonZeroSize = 1.0 - step(size, 0.0);
return (
factor.z * (
1.0 +
nonZeroSize *
2.0 * factor.w / (
size + (1.0 - nonZeroSize)
)
)
);
}`), e27.vertex.code.add(o4`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`), e27.vertex.code.add(o4`vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {
return vec4(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z,
params.w
);
}`), e27.vertex.code.add(o4`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {
return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));
}`), e27.vertex.code.add(o4`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`), e27.vertex.code.add(o4`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {
return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / max(1e-5, size.y), 1.0), size, factor.y);
}`), e27.vertex.code.add(o4`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`);
}
function i7(e27) {
  e27.uniforms.add(new e8("screenSizePerspectiveAlignment", (e28) => o15(e28.screenSizePerspectiveAlignment || e28.screenSizePerspective)));
}
function o15(a13) {
  return r3(n7, a13.parameters.divisor, a13.parameters.offset, a13.parameters.minPixelSize, a13.paddingPixelsOverride);
}
var n7 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js
function a9(e27, r19) {
  const c10 = e27.vertex;
  r19.hasVerticalOffset ? (f6(c10), r19.hasScreenSizePerspective && (e27.include(c7), i7(c10), c5(e27.vertex, r19)), c10.code.add(o4`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${r19.spherical ? o4`vec3 worldNormal = normalize(worldPos + localOrigin);` : o4`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${r19.hasScreenSizePerspective ? o4`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : o4`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)) : c10.code.add(o4`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);
}
var i8 = n2();
function f6(r19) {
  r19.uniforms.add(new e8("verticalOffset", (r20, t14) => {
    const { minWorldLength: l8, maxWorldLength: o24, screenLength: c10 } = r20.verticalOffset, s6 = Math.tan(0.5 * t14.camera.fovY) / (0.5 * t14.camera.fullViewport[3]), a13 = t14.camera.pixelRatio || 1;
    return r3(i8, c10 * a13, s6, l8, o24);
  }));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e19 = class extends i2 {
  constructor(r19, e27, o24) {
    super(r19, "vec4", a3.Pass, (s6, o25, t14) => s6.setUniform4fv(r19, e27(o25, t14)), o24);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js
var o16 = class extends i2 {
  constructor(r19, o24, e27) {
    super(r19, "float", a3.Pass, (s6, e28, t14) => s6.setUniform1fv(r19, o24(e28, t14)), e27);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObject.js
var r11 = class {
  constructor() {
    this.id = e3();
  }
  unload() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations.js
var E4 = /* @__PURE__ */ new Map([[O3.POSITION, 0], [O3.NORMAL, 1], [O3.UV0, 2], [O3.COLOR, 3], [O3.SIZE, 4], [O3.TANGENT, 4], [O3.AUXPOS1, 5], [O3.SYMBOLCOLOR, 5], [O3.AUXPOS2, 6], [O3.FEATUREATTRIBUTE, 6], [O3.INSTANCEFEATUREATTRIBUTE, 6], [O3.INSTANCECOLOR, 7], [O3.OBJECTANDLAYERIDCOLOR, 7], [O3.OBJECTANDLAYERIDCOLOR_INSTANCED, 7], [O3.MODEL, 8], [O3.MODELNORMAL, 12], [O3.MODELORIGINHI, 11], [O3.MODELORIGINLO, 15]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var h7 = class extends r11 {
  constructor(e27, t14) {
    super(), this.type = e17.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._insertOrder = 0, this._vertexAttributeLocations = E4, this._pp0 = r2(0, 0, 1), this._pp1 = r2(0, 0, 0), this._parameters = A(e27, t14), this.validateParameters(this._parameters);
  }
  dispose() {
  }
  get parameters() {
    return this._parameters;
  }
  update(e27) {
    return false;
  }
  setParameters(e27, r19 = true) {
    P(this._parameters, e27) && (this.validateParameters(this._parameters), r19 && this.parametersChanged());
  }
  validateParameters(e27) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e27) {
    e27 !== this._visible && (this._visible = e27, this.parametersChanged());
  }
  shouldRender(e27) {
    return this.isVisible() && this.isVisibleForOutput(e27.output) && 0 != (this.renderOccluded & e27.renderOccludedMask);
  }
  isVisibleForOutput(e27) {
    return true;
  }
  get renderOccluded() {
    return this.parameters.renderOccluded;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e27) {
    e27 !== this._renderPriority && (this._renderPriority = e27, this.parametersChanged());
  }
  get insertOrder() {
    return this._insertOrder;
  }
  set insertOrder(e27) {
    e27 !== this._insertOrder && (this._insertOrder = e27, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    r(this.repository) && this.repository.materialChanged(this);
  }
  intersectDraped(e27, r19, t14, s6, i12, a13) {
    return this._pp0[0] = this._pp1[0] = s6[0], this._pp0[1] = this._pp1[1] = s6[1], this.intersect(e27, r19, t14, this._pp0, this._pp1, i12);
  }
};
var c8;
!function(e27) {
  e27[e27.Occlude = 1] = "Occlude", e27[e27.Transparent = 2] = "Transparent", e27[e27.OccludeAndTransparent = 4] = "OccludeAndTransparent", e27[e27.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e27[e27.Opaque = 16] = "Opaque";
}(c8 || (c8 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var o17 = 8;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js
function s3(s6, n17) {
  n17.hasVvInstancing && (n17.vvSize || n17.vvColor) && s6.attributes.add(O3.INSTANCEFEATUREATTRIBUTE, "vec4");
  const l8 = s6.vertex;
  n17.vvSize ? (l8.uniforms.add(new e11("vvSizeMinSize", (e27) => e27.vvSizeMinSize)), l8.uniforms.add(new e11("vvSizeMaxSize", (e27) => e27.vvSizeMaxSize)), l8.uniforms.add(new e11("vvSizeOffset", (e27) => e27.vvSizeOffset)), l8.uniforms.add(new e11("vvSizeFactor", (e27) => e27.vvSizeFactor)), l8.uniforms.add(new e13("vvSymbolRotationMatrix", (e27) => e27.vvSymbolRotationMatrix)), l8.uniforms.add(new e11("vvSymbolAnchor", (e27) => e27.vvSymbolAnchor)), l8.code.add(o4`vec3 vvScale(vec4 _featureAttribute) {
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), l8.code.add(o4`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);
        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);
      }

      ${n17.hasVvInstancing ? o4`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }` : ""}
    `)) : l8.code.add(o4`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`), n17.vvColor ? (l8.constants.add("vvColorNumber", "int", o17), n17.hasVvInstancing && l8.uniforms.add([new o16("vvColorValues", (e27) => e27.vvColorValues, o17), new e19("vvColorColors", (e27) => e27.vvColorColors, o17)]), l8.code.add(o4`
      vec4 vvGetColor(vec4 featureAttribute, float values[vvColorNumber], vec4 colors[vvColorNumber]) {
        float value = featureAttribute.y;
        if (value <= values[0]) {
          return colors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (values[i] >= value) {
            float f = (value - values[i-1]) / (values[i] - values[i-1]);
            return mix(colors[i-1], colors[i], f);
          }
        }
        return colors[vvColorNumber - 1];
      }

      ${n17.hasVvInstancing ? o4`
      vec4 vvColor() {
        return vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);
      }` : ""}
    `)) : l8.code.add(o4`vec4 vvColor() { return vec4(1.0); }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlphaBlend.glsl.js
function d6(d8) {
  d8.fragment.code.add(o4`
    #define discardOrAdjustAlpha(color) { if (color.a < ${o4.float(t5)}) { discard; } }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s4(a13, e27) {
  l4(a13, e27, new o5("textureAlphaCutoff", (a14) => a14.textureAlphaCutoff));
}
function l4(e27, r19, s6) {
  const t14 = e27.fragment;
  switch (r19.alphaDiscardMode !== u2.Mask && r19.alphaDiscardMode !== u2.MaskBlend || t14.uniforms.add(s6), r19.alphaDiscardMode) {
    case u2.Blend:
      return e27.include(d6);
    case u2.Opaque:
      t14.code.add(o4`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case u2.Mask:
      t14.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case u2.MaskBlend:
      e27.fragment.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js
function d7(d8, t14) {
  const a13 = t14.output === h4.ObjectAndLayerIdColor, n17 = t14.objectAndLayerIdColorInstanced;
  a13 && (d8.varyings.add("objectAndLayerIdColorVarying", "vec4"), n17 ? d8.attributes.add(O3.OBJECTANDLAYERIDCOLOR_INSTANCED, "vec4") : d8.attributes.add(O3.OBJECTANDLAYERIDCOLOR, "vec4")), d8.vertex.code.add(o4`
     void forwardObjectAndLayerIdColor() {
      ${a13 ? n17 ? o4`objectAndLayerIdColorVarying = objectAndLayerIdColor_instanced * 0.003921568627451;` : o4`objectAndLayerIdColorVarying = objectAndLayerIdColor * 0.003921568627451;` : o4``} }`), d8.fragment.code.add(o4`
      void outputObjectAndLayerIdColor() {
        ${a13 ? o4`gl_FragColor = objectAndLayerIdColorVarying;` : o4``} }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function o18(o24, l8) {
  switch (o24.fragment.include(a5), l8.output) {
    case h4.Shadow:
    case h4.ShadowHighlight:
    case h4.ShadowExcludeHighlight:
      o24.extensions.add("GL_OES_standard_derivatives"), o24.fragment.code.add(o4`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`);
      break;
    case h4.Depth:
      o24.fragment.code.add(o4`void outputDepth(float _linearDepth) {
gl_FragColor = float2rgba(_linearDepth);
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js
var g3 = r4(1, 1, 0, 1);
var i9 = r4(1, 0, 1, 1);
function a10(e27, a13) {
  e27.fragment.uniforms.add(u3("depthTex", (e28, o24) => o24.highlightDepthTexture, a13.hasWebGL2Context ? e10.None : e10.InvSize)), e27.fragment.constants.add("occludedHighlightFlag", "vec4", g3).add("unoccludedHighlightFlag", "vec4", i9), e27.fragment.code.add(o4`
    void outputHighlight() {
      vec3 fragCoord = gl_FragCoord.xyz;

      float sceneDepth = ${i3(a13, "depthTex", "fragCoord.xy")}.x;
      if (fragCoord.z > sceneDepth + 5e-7) {
        gl_FragColor = occludedHighlightFlag;
      }
      else {
        gl_FragColor = unoccludedHighlightFlag;
      }
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function b4(b5, O5) {
  const { vertex: w4, fragment: C3 } = b5, T2 = O5.hasModelTransformation;
  T2 && w4.uniforms.add(new e12("model", (e27) => r(e27.modelTransformation) ? e27.modelTransformation : o2));
  const V3 = O5.hasColorTexture && O5.alphaDiscardMode !== u2.Opaque;
  switch (O5.output) {
    case h4.Depth:
    case h4.Shadow:
    case h4.ShadowHighlight:
    case h4.ShadowExcludeHighlight:
    case h4.ObjectAndLayerIdColor:
      v2(w4, O5), b5.include(r9, O5), b5.include(o6, O5), b5.include(s3, O5), b5.include(o18, O5), b5.include(u6, O5), b5.include(d7, O5), i5(b5), b5.varyings.add("depth", "float"), V3 && C3.uniforms.add(new f2("tex", (o24) => o24.texture)), w4.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPositionWithDepth(proj, view, ${T2 ? "model," : ""} vpos, nearFar, depth);
            forwardTextureCoordinates();
            forwardObjectAndLayerIdColor();
          }
        `), b5.include(s4, O5), C3.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${V3 ? o4`
                    vec4 texColor = texture2D(tex, ${O5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${O5.output === h4.ObjectAndLayerIdColor ? o4`outputObjectAndLayerIdColor();` : o4`outputDepth(depth);`}
          }
        `);
      break;
    case h4.Normal:
      v2(w4, O5), b5.include(r9, O5), b5.include(i4, O5), b5.include(c4, O5), b5.include(o6, O5), b5.include(s3, O5), V3 && C3.uniforms.add(new f2("tex", (o24) => o24.texture)), b5.varyings.add("vPositionView", "vec3"), w4.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            ${O5.normalType === a8.Attribute ? o4`
            vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : ""}
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, ${T2 ? "model," : ""} vpos);
            forwardTextureCoordinates();
          }
        `), b5.include(u6, O5), b5.include(s4, O5), C3.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${V3 ? o4`
                    vec4 texColor = texture2D(tex, ${O5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${O5.normalType === a8.ScreenDerivative ? o4`
                vec3 normal = screenDerivativeNormal(vPositionView);` : o4`
                vec3 normal = normalize(vNormalWorld);
                if (gl_FrontFacing == false) normal = -normal;`}
            gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
          }
        `);
      break;
    case h4.Highlight:
      v2(w4, O5), b5.include(r9, O5), b5.include(o6, O5), b5.include(s3, O5), V3 && C3.uniforms.add(new f2("tex", (o24) => o24.texture)), w4.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, ${T2 ? "model," : ""} vpos);
            forwardTextureCoordinates();
          }
        `), b5.include(u6, O5), b5.include(s4, O5), b5.include(a10, O5), C3.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${V3 ? o4`
                    vec4 texColor = texture2D(tex, ${O5.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexBufferLayouts.js
var n9 = [new t2(O3.POSITION, 3, C2.FLOAT, 0, 12)];
var w3 = [new t2(O3.POSITION, 3, C2.FLOAT, 0, 20), new t2(O3.UV0, 2, C2.FLOAT, 12, 20)];
var I3 = [new t2(O3.POSITION, 3, C2.FLOAT, 0, 32), new t2(O3.NORMAL, 3, C2.FLOAT, 12, 32), new t2(O3.UV0, 2, C2.FLOAT, 24, 32)];
var r12 = [new t2(O3.POSITION, 3, C2.FLOAT, 0, 16), new t2(O3.COLOR, 4, C2.UNSIGNED_BYTE, 12, 16)];
var t8 = [new t2(O3.POSITION, 2, C2.FLOAT, 0, 8)];
var A2 = [new t2(O3.POSITION, 2, C2.FLOAT, 0, 16), new t2(O3.UV0, 2, C2.FLOAT, 8, 16)];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/VertexArrayObject.js
var r13 = class extends f3 {
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/glUtil3D.js
function f7(i12, m6 = t8, T2 = E4, l8 = -1, u9 = 1) {
  let f9 = null;
  if (m6 === A2)
    f9 = new Float32Array([l8, l8, 0, 0, u9, l8, 1, 0, l8, u9, 0, 1, u9, u9, 1, 1]);
  else
    f9 = new Float32Array([l8, l8, u9, l8, l8, u9, u9, u9]);
  return new r13(i12, T2, { geometry: m6 }, { geometry: E2.createVertex(i12, F.STATIC_DRAW, f9) });
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t9 = class {
  constructor(t14, o24) {
    this._module = t14, this._loadModule = o24;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var e21 = class {
  constructor(i12, t14, e27) {
    this.release = e27, this.initializeConfiguration(i12, t14), this._configuration = t14.snapshot(), this._program = this.initializeProgram(i12), this._pipeline = this.initializePipeline(i12.rctx.capabilities);
  }
  destroy() {
    this._program = h(this._program), this._pipeline = this._configuration = null;
  }
  reload(t14) {
    h(this._program), this._program = this.initializeProgram(t14), this._pipeline = this.initializePipeline(t14.rctx.capabilities);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  bindPipelineState(i12, t14 = null, e27) {
    i12.setPipelineState(this.getPipelineState(t14, e27));
  }
  ensureAttributeLocations(i12) {
    this.program.assertCompatibleVertexAttributeLocations(i12);
  }
  get primitiveType() {
    return E.TRIANGLES;
  }
  getPipelineState(i12, t14) {
    return this._pipeline;
  }
  initializeConfiguration(i12, t14) {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var o19 = class {
  constructor(t14, e27, o24) {
    this._context = t14, this._locations = o24, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = t14.programCache.acquire(e27.generate("vertex"), e27.generate("fragment"), o24), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = e27.generateBind(a3.Pass, this), this.bindDraw = e27.generateBind(a3.Draw, this), this._fragmentUniforms = a4() ? e27.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t14, e27) {
    this._glProgram.setUniform1i(t14, e27 ? 1 : 0);
  }
  setUniform1i(t14, e27) {
    this._glProgram.setUniform1i(t14, e27);
  }
  setUniform1f(t14, e27) {
    this._glProgram.setUniform1f(t14, e27);
  }
  setUniform2fv(t14, e27) {
    this._glProgram.setUniform2fv(t14, e27);
  }
  setUniform3fv(t14, e27) {
    this._glProgram.setUniform3fv(t14, e27);
  }
  setUniform4fv(t14, e27) {
    this._glProgram.setUniform4fv(t14, e27);
  }
  setUniformMatrix3fv(t14, e27) {
    this._glProgram.setUniformMatrix3fv(t14, e27);
  }
  setUniformMatrix4fv(t14, e27) {
    this._glProgram.setUniformMatrix4fv(t14, e27);
  }
  setUniform1fv(t14, e27) {
    this._glProgram.setUniform1fv(t14, e27);
  }
  setUniform1iv(t14, e27) {
    this._glProgram.setUniform1iv(t14, e27);
  }
  setUniform2iv(t14, e27) {
    this._glProgram.setUniform3iv(t14, e27);
  }
  setUniform3iv(t14, e27) {
    this._glProgram.setUniform3iv(t14, e27);
  }
  setUniform4iv(t14, e27) {
    this._glProgram.setUniform4iv(t14, e27);
  }
  assertCompatibleVertexAttributeLocations(t14) {
    t14.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(e27, r19) {
    if (t(r19) || null == r19.glName) {
      const t14 = this._textures.get(e27);
      return t14 && (this._context.bindTexture(null, t14.unit), this._freeTextureUnit(t14), this._textures.delete(e27)), null;
    }
    let i12 = this._textures.get(e27);
    return null == i12 ? (i12 = this._allocTextureUnit(r19), this._textures.set(e27, i12)) : i12.texture = r19, this._context.useProgram(this), this.setUniform1i(e27, i12.unit), this._context.bindTexture(r19, i12.unit), i12.unit;
  }
  rebindTextures() {
    this._context.useProgram(this), this._textures.forEach((t14, e27) => {
      this._context.bindTexture(t14.texture, t14.unit), this.setUniform1i(e27, t14.unit);
    }), r(this._fragmentUniforms) && this._fragmentUniforms.forEach((t14) => {
      "sampler2D" !== t14.type && "samplerCube" !== t14.type || this._textures.has(t14.name) || console.error(`Texture sampler ${t14.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t14) {
    return { texture: t14, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t14) {
    this._freeTextureUnits.push(t14.unit);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOBlurTechnique.js
var l5 = class extends e21 {
  initializeProgram(r19) {
    return new o19(r19.rctx, l5.shader.get().build(), E4);
  }
  initializePipeline() {
    return W({ colorWrite: _2 });
  }
};
l5.shader = new t9(u5, () => import("./SSAOBlur.glsl-STTPS4HS.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOTechnique.js
var l6 = class extends e21 {
  initializeProgram(e27) {
    return new o19(e27.rctx, l6.shader.get().build(), E4);
  }
  initializePipeline() {
    return W({ colorWrite: _2 });
  }
};
l6.shader = new t9(h3, () => import("./SSAO.glsl-6MVKCTH3.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOHelper.js
var q = 2;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function n12(n17, a13) {
  const i12 = n17.fragment;
  a13.receiveAmbientOcclusion ? (i12.uniforms.add(u3("ssaoTex", (e27, r19) => r19.ssaoHelper.colorTexture, a13.hasWebGL2Context ? e10.None : e10.InvSize)), i12.constants.add("blurSizePixelsInverse", "float", 1 / q), i12.code.add(o4`
      float evaluateAmbientOcclusionInverse() {
        vec2 ssaoTextureSizeInverse = ${r8(a13, "ssaoTex", true)};
        return texture2D(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).a;
      }

      float evaluateAmbientOcclusion() {
        return 1.0 - evaluateAmbientOcclusionInverse();
      }
    `)) : i12.code.add(o4`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function o22(n17) {
  n17.uniforms.add(new e11("mainLightDirection", (i12, n18) => n18.lighting.mainLight.direction));
}
function a11(n17) {
  n17.uniforms.add(new e11("mainLightIntensity", (i12, n18) => n18.lighting.mainLight.intensity));
}
function e23(i12, t14) {
  t14.useLegacyTerrainShading ? i12.uniforms.add(new o5("lightingFixedFactor", (i13, n17) => n17.lighting.noonFactor * (1 - n17.lighting.globalFactor))) : i12.constants.add("lightingFixedFactor", "float", 0);
}
function r15(i12, n17) {
  const r19 = i12.fragment;
  o22(r19), a11(r19), e23(r19, n17), r19.code.add(o4`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, mainLightDirection), 0.0, 1.0);
dotVal = mix(dotVal, 1.0, lightingFixedFactor);
return mainLightIntensity * ((1.0 - shadowing) * dotVal);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t11(t14) {
  const a13 = t14.fragment.code;
  a13.add(o4`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a13.add(o4`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a13.add(o4`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js
function t12(t14) {
  t14.vertex.code.add(o4`const float PI = 3.141592653589793;`), t14.fragment.code.add(o4`const float PI = 3.141592653589793;
const float LIGHT_NORMALIZATION = 1.0 / PI;
const float INV_PI = 0.3183098861837907;
const float HALF_PI = 1.570796326794897;`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n13(n17, r19) {
  const l8 = n17.fragment.code;
  n17.include(t12), r19.pbrMode !== d2.Normal && r19.pbrMode !== d2.Schematic && r19.pbrMode !== d2.Terrain && r19.pbrMode !== d2.TerrainWithWater || (l8.add(o4`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l8.add(o4`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), r19.pbrMode !== d2.Normal && r19.pbrMode !== d2.Schematic || (n17.include(t11), l8.add(o4`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l8.add(o4`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l8.add(o4`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l8.add(o4`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m5(n17, g5) {
  const m6 = n17.fragment, o24 = void 0 !== g5.lightingSphericalHarmonicsOrder ? g5.lightingSphericalHarmonicsOrder : 2;
  0 === o24 ? (m6.uniforms.add(new e11("lightingAmbientSH0", (n18, t14) => o(a12, t14.lighting.sh.r[0], t14.lighting.sh.g[0], t14.lighting.sh.b[0]))), m6.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o24 ? (m6.uniforms.add([new e8("lightingAmbientSH_R", (i12, n18) => r3(r16, n18.lighting.sh.r[0], n18.lighting.sh.r[1], n18.lighting.sh.r[2], n18.lighting.sh.r[3])), new e8("lightingAmbientSH_G", (i12, n18) => r3(r16, n18.lighting.sh.g[0], n18.lighting.sh.g[1], n18.lighting.sh.g[2], n18.lighting.sh.g[3])), new e8("lightingAmbientSH_B", (i12, n18) => r3(r16, n18.lighting.sh.b[0], n18.lighting.sh.b[1], n18.lighting.sh.b[2], n18.lighting.sh.b[3]))]), m6.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o24 && (m6.uniforms.add([new e11("lightingAmbientSH0", (n18, t14) => o(a12, t14.lighting.sh.r[0], t14.lighting.sh.g[0], t14.lighting.sh.b[0])), new e8("lightingAmbientSH_R1", (i12, n18) => r3(r16, n18.lighting.sh.r[1], n18.lighting.sh.r[2], n18.lighting.sh.r[3], n18.lighting.sh.r[4])), new e8("lightingAmbientSH_G1", (i12, n18) => r3(r16, n18.lighting.sh.g[1], n18.lighting.sh.g[2], n18.lighting.sh.g[3], n18.lighting.sh.g[4])), new e8("lightingAmbientSH_B1", (i12, n18) => r3(r16, n18.lighting.sh.b[1], n18.lighting.sh.b[2], n18.lighting.sh.b[3], n18.lighting.sh.b[4])), new e8("lightingAmbientSH_R2", (i12, n18) => r3(r16, n18.lighting.sh.r[5], n18.lighting.sh.r[6], n18.lighting.sh.r[7], n18.lighting.sh.r[8])), new e8("lightingAmbientSH_G2", (i12, n18) => r3(r16, n18.lighting.sh.g[5], n18.lighting.sh.g[6], n18.lighting.sh.g[7], n18.lighting.sh.g[8])), new e8("lightingAmbientSH_B2", (i12, n18) => r3(r16, n18.lighting.sh.b[5], n18.lighting.sh.b[6], n18.lighting.sh.b[7], n18.lighting.sh.b[8]))]), m6.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g5.pbrMode !== d2.Normal && g5.pbrMode !== d2.Schematic || m6.code.add(o4`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a12 = n();
var r16 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js
var s5 = class extends i2 {
  constructor(o24, s6) {
    super(o24, "bool", a3.Pass, (r19, e27, t14) => r19.setUniform1b(o24, s6(e27, t14)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
var P3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var _3 = 0.4;
var p3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function h8(n17) {
  n17.constants.add("ambientBoostFactor", "float", _3);
}
function u8(n17) {
  n17.uniforms.add(new o5("lightingGlobalFactor", (n18, i12) => i12.lighting.globalFactor));
}
function p4(g5, p5) {
  const v6 = g5.fragment;
  switch (g5.include(n12, p5), p5.pbrMode !== d2.Disabled && g5.include(n13, p5), g5.include(m5, p5), g5.include(t12), v6.code.add(o4`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${p5.pbrMode === d2.Disabled ? "" : "const vec3 GROUND_REFLECTANCE = vec3(0.2);"}
  `), h8(v6), u8(v6), o22(v6), v6.code.add(o4`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${p5.spherical ? o4`normalize(vPosWorld)` : o4`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a11(v6), v6.code.add(o4`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), p5.pbrMode) {
    case d2.Disabled:
    case d2.WaterOnIntegratedMesh:
    case d2.Water:
      g5.include(r15, p5), v6.code.add(o4`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)
{
vec3 mainLighting = evaluateMainLighting(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case d2.Normal:
    case d2.Schematic:
      v6.code.add(o4`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);
inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v6.code.add(o4`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p5.useFillLights ? v6.uniforms.add(new s5("hasFillLights", (n17, i12) => i12.enableFillLights)) : v6.constants.add("hasFillLights", "bool", false), v6.code.add(o4`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
vec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v6.uniforms.add([new o5("lightingSpecularStrength", (n17, i12) => i12.lighting.mainLight.specularStrength), new o5("lightingEnvironmentStrength", (n17, i12) => i12.lighting.mainLight.environmentStrength)]), v6.code.add(o4`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
inputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;
inputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v6.code.add(o4`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${p5.pbrMode === d2.Schematic ? o4`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : o4`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case d2.Terrain:
    case d2.TerrainWithWater:
      g5.include(r15, p5), v6.code.add(o4`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
      break;
    default:
      n3(p5.pbrMode);
    case d2.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js
function n16(n17, o24) {
  o24.hasMultipassTerrain && (n17.fragment.include(a6), n17.fragment.uniforms.add(new f2("terrainDepthTexture", (e27, r19) => r19.multipassTerrain.linearDepthTexture)), n17.fragment.uniforms.add(new e9("nearFar", (e27, r19) => r19.camera.nearFar)), n17.fragment.uniforms.add(new e9("inverseViewport", (e27, r19) => r19.inverseViewport)), n17.fragment.code.add(o4`
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){
      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, nearFar);
      if(fragmentDepth ${o24.cullAboveGround ? ">" : "<="} terrainDepth){
        discard;
      }
    }
  `));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var o23 = class extends i2 {
  constructor(r19, o24, s6) {
    super(r19, "mat4", a3.Draw, (e27, s7, t14) => e27.setUniformMatrix4fv(r19, o24(s7, t14)), s6);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var e25 = class extends i2 {
  constructor(r19, e27, o24) {
    super(r19, "mat4", a3.Pass, (s6, o25, t14) => s6.setUniformMatrix4fv(r19, e27(o25, t14)), o24);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function h9(e27, a13) {
  a13.receiveShadows && (e27.fragment.uniforms.add(new e25("shadowMapMatrix", (e28, a14) => a14.shadowMap.getShadowMapMatrices(e28.origin), 4)), f8(e27, a13));
}
function v5(e27, a13) {
  a13.receiveShadows && (e27.fragment.uniforms.add(new o23("shadowMapMatrix", (e28, a14) => a14.shadowMap.getShadowMapMatrices(e28.origin), 4)), f8(e27, a13));
}
function f8(e27, i12) {
  const d8 = e27.fragment;
  d8.include(a5), d8.uniforms.add([...u3("shadowMapTex", (e28, a13) => a13.shadowMap.depthTexture, i12.hasWebGL2Context ? e10.None : e10.Size), new e16("numCascades", (e28, a13) => a13.shadowMap.numCascades), new e8("cascadeDistances", (e28, a13) => a13.shadowMap.cascadeDistances)]), d8.code.add(o4`
    int chooseCascade(float depth, out mat4 mat) {
      vec4 distance = cascadeDistances;

      // choose correct cascade
      int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;

      mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];

      return i;
    }

    vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
      vec4 lv = mat * vec4(_vpos, 1.0);
      lv.xy /= lv.w;
      return 0.5 * lv.xyz + vec3(0.5);
    }

    vec2 cascadeCoordinates(int i, vec3 lvpos) {
      return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + 0.5 * lvpos.xy;
    }

    float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {
      return rgba2float(texture2D(_depthTex, uv));
    }

    float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {
      return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
    }

    float filterShadow(vec2 uv, vec3 lvpos, float textureSize, sampler2D _depthTex) {
      float halfPixelSize = 0.5 / textureSize;

      // filter, offset by half pixels
      vec2 st = fract((vec2(halfPixelSize) + uv) * textureSize);

      float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);
      float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);
      float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);
      float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);

      return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
    }

    float readShadowMap(const in vec3 _vpos, float _linearDepth) {
      mat4 mat;
      int i = chooseCascade(_linearDepth, mat);

      if (i >= numCascades) { return 0.0; }

      vec3 lvpos = lightSpacePosition(_vpos, mat);

      // vertex completely outside? -> no shadow
      if (lvpos.z >= 1.0) { return 0.0; }
      if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }

      // calc coord in cascade texture
      vec2 uv = cascadeCoordinates(i, lvpos);

      vec2 textureSize = ${r8(i12, "shadowMapTex")};

      return filterShadow(uv, lvpos, textureSize.x, shadowMapTex);
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js
function e26(e27) {
  e27.code.add(o4`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i11(i12) {
  i12.include(e26), i12.code.add(o4`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${o4.int(r5.Multiply)}) {
        return allMixed;
      }
      if (mode == ${o4.int(r5.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(r5.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${o4.int(r5.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(r5.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  r11 as r,
  e17 as e,
  E4 as E,
  f7 as f,
  h4 as h,
  d,
  o6 as o,
  a7 as a,
  e11 as e2,
  h5 as h2,
  d2,
  x,
  x3 as x2,
  N2 as N,
  h7 as h3,
  c8 as c,
  i4 as i,
  a8 as a2,
  o10 as o2,
  e13 as e3,
  e12 as e4,
  c4 as c2,
  f4 as f2,
  o12 as o3,
  t5 as t,
  t9 as t2,
  e21 as e5,
  o19 as o4,
  d3,
  e14 as e6,
  u6 as u,
  r9 as r2,
  c5 as c3,
  v2 as v,
  t7 as t3,
  r10 as r3,
  p,
  i6 as i2,
  e18 as e7,
  a9 as a3,
  s3 as s,
  s4 as s2,
  b4 as b,
  n12 as n,
  o22 as o5,
  a11 as a4,
  n13 as n2,
  h8 as h4,
  u8 as u2,
  p4 as p2,
  n16 as n3,
  h9 as h5,
  v5 as v2,
  i11 as i3
};
//# sourceMappingURL=chunk-76CQ2525.js.map

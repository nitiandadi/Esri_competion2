import {
  g
} from "./chunk-JY25JIWS.js";
import {
  ee
} from "./chunk-EQM2LWO7.js";
import "./chunk-OSLJAK5K.js";
import "./chunk-PY5ZEMWR.js";
import "./chunk-MXRYGWSY.js";
import "./chunk-5Y2E66SG.js";
import "./chunk-33DQ3DIB.js";
import {
  o
} from "./chunk-AWGMYJGH.js";
import "./chunk-JLELSJK5.js";
import "./chunk-2E4SJPYR.js";
import "./chunk-CEQ74MRR.js";
import "./chunk-U34LDFXK.js";
import "./chunk-Y5TO5CEM.js";
import "./chunk-BKGJHAJX.js";
import "./chunk-V2OTMPXZ.js";
import "./chunk-OEIEPNC6.js";
import {
  j as j3
} from "./chunk-TE3PC254.js";
import {
  t as t3
} from "./chunk-3IDKVHSA.js";
import "./chunk-QARU3EBQ.js";
import "./chunk-PXPM76YN.js";
import "./chunk-6XE2FUT4.js";
import {
  S,
  c as c4,
  f as f4,
  x as x3
} from "./chunk-CKJU52SK.js";
import "./chunk-2JB37XX2.js";
import {
  c as c5,
  s as s2,
  t as t4
} from "./chunk-D4SYZIFV.js";
import {
  a as a2
} from "./chunk-WL7ITUMO.js";
import "./chunk-CP43AUSV.js";
import "./chunk-2VRWGZDB.js";
import "./chunk-5JG6YWQJ.js";
import "./chunk-7Q77X7UJ.js";
import {
  It,
  at,
  ht
} from "./chunk-NOYTM57S.js";
import "./chunk-OPQ632ST.js";
import "./chunk-U6GC73UT.js";
import {
  x
} from "./chunk-TEBHEW3L.js";
import "./chunk-QF2PMVYK.js";
import {
  e as e3
} from "./chunk-BRWDGS6Y.js";
import "./chunk-L6EWR437.js";
import {
  g as g2
} from "./chunk-HZKQDRDV.js";
import {
  r as r3,
  x as x2
} from "./chunk-CVSP2FBZ.js";
import "./chunk-UNUPXPO6.js";
import "./chunk-OF6BJKPA.js";
import {
  c as c3,
  d as d2
} from "./chunk-PELFA5QO.js";
import {
  d,
  j as j2
} from "./chunk-FAK3SJAD.js";
import "./chunk-FFJQJQND.js";
import "./chunk-YMSHUIGU.js";
import "./chunk-EPJSBV4J.js";
import "./chunk-RCZJUTGU.js";
import "./chunk-REIXEATJ.js";
import "./chunk-YEFLZ2OV.js";
import "./chunk-W42YI6TX.js";
import "./chunk-ICG3HFWD.js";
import "./chunk-XP5MC636.js";
import "./chunk-MYKXVBXI.js";
import "./chunk-TM5UW7VI.js";
import "./chunk-WVLEGBEW.js";
import {
  U,
  j,
  l
} from "./chunk-FXMJJBXP.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-LVRAFE6T.js";
import "./chunk-Y3KJPDCE.js";
import {
  E,
  c as c2,
  f as f3,
  u,
  y as y2
} from "./chunk-LSUFI7PR.js";
import "./chunk-YT74S35I.js";
import "./chunk-U5I7FQWJ.js";
import "./chunk-M3KO43BW.js";
import "./chunk-JT54I3AY.js";
import "./chunk-TNTTCGVB.js";
import "./chunk-DC3QI5ZE.js";
import "./chunk-EGHLQERQ.js";
import "./chunk-YMLMMCYX.js";
import "./chunk-I2U7UK6N.js";
import {
  n as n2
} from "./chunk-FQ7L63IU.js";
import "./chunk-YHZVWABO.js";
import "./chunk-WATRS3LJ.js";
import "./chunk-CPUYSXBP.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-7FMLQXIT.js";
import "./chunk-B6GJAETG.js";
import "./chunk-FC74MT6E.js";
import {
  L,
  f2,
  w2
} from "./chunk-H2ENCYR3.js";
import "./chunk-SVHG5VY2.js";
import "./chunk-S47644HM.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-DLM7WQKI.js";
import {
  a2 as a,
  e as e2,
  n2 as n,
  t2,
  v2 as v,
  y3 as y
} from "./chunk-7GTATSRF.js";
import "./chunk-MTJ2HM2W.js";
import {
  r as r2
} from "./chunk-PXVSWY3C.js";
import {
  A,
  f,
  w
} from "./chunk-QLY5H3XF.js";
import {
  s
} from "./chunk-UG2OEDEE.js";
import {
  c
} from "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import {
  p
} from "./chunk-PR6SXADK.js";
import {
  i
} from "./chunk-MGJMBJDY.js";
import {
  e,
  r,
  t
} from "./chunk-WHB7G7RI.js";
import "./chunk-DFKQJ226.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationAlignment.js
function r4(e5 = false, t7) {
  if (e5) {
    const { elevationInfo: e6, alignPointsInFeatures: s4, spatialReference: n5 } = t7;
    return new l2(e6, s4, n5);
  }
  return new c6();
}
var c6 = class {
  async alignCandidates(e5, t7) {
    return e5;
  }
  notifyElevationSourceChange() {
  }
};
var h = 1024;
var l2 = class {
  constructor(t7, s4, n5) {
    this._elevationInfo = t7, this._alignPointsInFeatures = s4, this.spatialReference = n5, this._alignmentsCache = new e3(h), this._cacheVersion = 0, this._metersPerVerticalUnit = L(n5);
  }
  async alignCandidates(e5, t7) {
    const n5 = this._elevationInfo;
    return r(n5) && "absolute-height" === n5.mode && !n5.featureExpressionInfo ? (this._alignAbsoluteElevationCandidates(e5, n5), e5) : this._alignComputedElevationCandidates(e5, t7);
  }
  notifyElevationSourceChange() {
    this._alignmentsCache.clear(), this._cacheVersion++;
  }
  _alignAbsoluteElevationCandidates(e5, t7) {
    const { offset: s4, unit: o4 } = t7;
    if (t(s4))
      return;
    const i4 = s4 * (r3(o4 ?? "meters") / this._metersPerVerticalUnit);
    for (const n5 of e5)
      switch (n5.type) {
        case "edge":
          n5.start.z += i4, n5.end.z += i4;
          continue;
        case "vertex":
          n5.target.z += i4;
          continue;
      }
  }
  async _alignComputedElevationCandidates(e5, s4) {
    const n5 = /* @__PURE__ */ new Map();
    for (const o4 of e5)
      r2(n5, o4.objectId, p2).push(o4);
    const [i4, a5, r8] = this._prepareQuery(n5), c9 = await this._alignPointsInFeatures(i4, s4);
    f(s4);
    if (r8 !== this._cacheVersion)
      return this._alignComputedElevationCandidates(e5, s4);
    this._applyCacheAndResponse(i4, c9, a5);
    const { drapedObjectIds: h2, failedObjectIds: l3 } = c9, d4 = [];
    for (const t7 of e5) {
      const { objectId: e6 } = t7;
      h2.has(e6) && "edge" === t7.type && (t7.draped = true), l3.has(e6) || d4.push(t7);
    }
    return d4;
  }
  _prepareQuery(e5) {
    const t7 = [], s4 = [];
    for (const [n5, o4] of e5) {
      const e6 = [];
      for (const t8 of o4)
        this._addToQueriesOrCachedResult(n5, t8.target, e6, s4), "edge" === t8.type && (this._addToQueriesOrCachedResult(n5, t8.start, e6, s4), this._addToQueriesOrCachedResult(n5, t8.end, e6, s4));
      0 !== e6.length && t7.push({ objectId: n5, points: e6 });
    }
    return [t7, s4, this._cacheVersion];
  }
  _addToQueriesOrCachedResult(e5, t7, n5, o4) {
    const i4 = u2(e5, t7), a5 = this._alignmentsCache.get(i4);
    r(a5) ? o4.push(new d3(t7, a5)) : n5.push(t7);
  }
  _applyCacheAndResponse(e5, { elevations: t7, drapedObjectIds: s4, failedObjectIds: n5 }, o4) {
    for (const r8 of o4)
      r8.apply();
    let i4 = 0;
    const a5 = this._alignmentsCache;
    for (const { objectId: r8, points: c9 } of e5) {
      if (n5.has(r8)) {
        i4 += c9.length;
        continue;
      }
      const e6 = !s4.has(r8);
      for (const s5 of c9) {
        const n6 = u2(r8, s5), o5 = t7[i4++];
        s5.z = o5, e6 && a5.put(n6, o5, 1);
      }
    }
  }
};
var d3 = class {
  constructor(e5, t7) {
    this.point = e5, this.z = t7;
  }
  apply() {
    this.point.z = this.z;
  }
};
function u2(e5, { x: t7, y: s4, z: n5 }) {
  return `${e5}-${t7}-${s4}-${n5 ?? 0}}`;
}
function p2() {
  return [];
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationFilter.js
var t5 = class {
  filter(t7, n5) {
    return n5;
  }
  notifyElevationSourceChange() {
  }
};
var n3 = class {
  filter(t7, n5) {
    const { point: r8, distance: c9 } = t7, { z: i4 } = r8;
    if (!(null != i4))
      return n5;
    if (0 === n5.length)
      return n5;
    const o4 = s3(c9), u4 = this._updateCandidatesTo3D(n5, r8, o4).filter(e4);
    return u4.sort(a3), u4;
  }
  _updateCandidatesTo3D(t7, n5, e5) {
    for (const r8 of t7)
      switch (r8.type) {
        case "edge":
          c7(r8, n5, e5);
          continue;
        case "vertex":
          o2(r8, n5, e5);
          continue;
      }
    return t7;
  }
};
function e4(t7) {
  return t7.distance <= 1;
}
function r5(e5 = false) {
  return e5 ? new n3() : new t5();
}
function c7(t7, n5, { x: e5, y: r8, z: c9 }) {
  const { start: o4, end: s4, target: a5 } = t7;
  t7.draped || i2(a5, n5, o4, s4);
  const u4 = (n5.x - a5.x) / e5, d4 = (n5.y - a5.y) / r8, f5 = (n5.z - a5.z) / c9;
  t7.distance = Math.sqrt(u4 * u4 + d4 * d4 + f5 * f5);
}
function i2(t7, n5, e5, r8) {
  const c9 = r8.x - e5.x, i4 = r8.y - e5.y, o4 = r8.z - e5.z, s4 = c9 * c9 + i4 * i4 + o4 * o4, a5 = (n5.x - e5.x) * c9 + (n5.y - e5.y) * i4 + o4 * (n5.z - e5.z), u4 = Math.min(1, Math.max(0, a5 / s4)), d4 = e5.x + c9 * u4, f5 = e5.y + i4 * u4, x6 = e5.z + o4 * u4;
  t7.x = d4, t7.y = f5, t7.z = x6;
}
function o2(t7, n5, { x: e5, y: r8, z: c9 }) {
  const { target: i4 } = t7, o4 = (n5.x - i4.x) / e5, s4 = (n5.y - i4.y) / r8, a5 = (n5.z - i4.z) / c9, u4 = Math.sqrt(o4 * o4 + s4 * s4 + a5 * a5);
  t7.distance = u4;
}
function s3(t7) {
  return "number" == typeof t7 ? { x: t7, y: t7, z: t7 } : t7;
}
function a3(t7, n5) {
  return t7.distance - n5.distance;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/symbologySnappingCandidates.js
function n4(t7 = false, e5) {
  return t7 ? new i3(e5) : new c8();
}
var c8 = class {
  async fetch() {
    return [];
  }
  notifySymbologyChange() {
  }
};
var r6 = 1024;
var i3 = class {
  constructor(t7) {
    this._getSymbologyCandidates = t7, this._candidatesCache = new e3(r6), this._cacheVersion = 0;
  }
  async fetch(e5, o4) {
    if (0 === e5.length)
      return [];
    const n5 = [], c9 = [], r8 = this._candidatesCache;
    for (const s4 of e5) {
      const e6 = a4(s4), o5 = r8.get(e6);
      if (o5)
        for (const s5 of o5)
          c9.push(p(s5));
      else
        n5.push(s4), r8.put(e6, [], 1);
    }
    if (0 === n5.length)
      return c9;
    const i4 = this._cacheVersion, { candidates: h2, sourceCandidateIndices: d4 } = await this._getSymbologyCandidates(n5, o4);
    f(o4);
    if (i4 !== this._cacheVersion)
      return this.fetch(e5, o4);
    const f5 = [], { length: g3 } = h2;
    for (let s4 = 0; s4 < g3; ++s4) {
      const e6 = h2[s4], o5 = a4(n5[d4[s4]]), c10 = r8.get(o5);
      c10.push(e6), r8.put(o5, c10, c10.length), f5.push(p(e6));
    }
    return c9.concat(f5);
  }
  notifySymbologyChange() {
    this._candidatesCache.clear(), this._cacheVersion++;
  }
};
function a4(t7) {
  switch (t7.type) {
    case "vertex": {
      const { objectId: e5, target: s4 } = t7, n5 = `${e5}-vertex-${s4.x}-${s4.y}-${s4.z ?? 0}`;
      return c(n5).toString();
    }
    case "edge": {
      const { objectId: e5, start: s4, end: n5 } = t7, c9 = `${e5}-edge-${s4.x}-${s4.y}-${s4.z ?? 0}-to-${n5.x}-${n5.y}-${n5.z ?? 0}`;
      return c(c9).toString();
    }
    default:
      return "";
  }
}

// node_modules/@arcgis/core/core/AsyncSequence.js
var r7 = class extends v {
  constructor() {
    super(...arguments), this.updating = false, this._pending = [];
  }
  push(s4, t7) {
    this._pending.push({ promise: s4, callback: t7 }), 1 === this._pending.length && this._process();
  }
  _process() {
    if (!this._pending.length)
      return void (this.updating = false);
    this.updating = true;
    const s4 = this._pending[0];
    s4.promise.then((t7) => s4.callback(t7)).catch(() => {
    }).then(() => {
      this._pending.shift(), this._process();
    });
  }
};
e2([y()], r7.prototype, "updating", void 0), r7 = e2([a("esri.core.AsyncSequence")], r7);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var o3 = class {
  constructor(t7, e5) {
    this.data = t7, this.resolution = e5, this.state = { type: u3.CREATED }, this.alive = true;
  }
  process(t7) {
    switch (this.state.type) {
      case u3.CREATED:
        return this.state = this._gotoFetchCount(this.state, t7), this.state.task.promise.then(t7.resume, t7.resume);
      case u3.FETCH_COUNT:
        break;
      case u3.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t7), this.state.task.promise.then(t7.resume, t7.resume);
      case u3.FETCH_FEATURES:
        break;
      case u3.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t7);
      case u3.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case u3.CREATED:
      case u3.FETCH_COUNT:
        return 0;
      case u3.FETCHED_COUNT:
        return this.state.featureCount;
      case u3.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case u3.FETCHED_FEATURES:
        return this.state.features.length;
      case u3.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case u3.CREATED:
        return "created";
      case u3.FETCH_COUNT:
        return "fetch-count";
      case u3.FETCHED_COUNT:
        return "fetched-count";
      case u3.FETCH_FEATURES:
        return "fetch-features";
      case u3.FETCHED_FEATURES:
        return "fetched-features";
      case u3.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s4, a5) {
    return { type: u3.FETCH_COUNT, previous: s4, task: j2(async (t7) => {
      const s5 = await d(a5.fetchCount(this, t7));
      this.state.type === u3.FETCH_COUNT && (this.state = this._gotoFetchedCount(this.state, s5.ok ? s5.value : 1 / 0));
    }) };
  }
  _gotoFetchedCount(t7, e5) {
    return { type: u3.FETCHED_COUNT, featureCount: e5, previous: t7 };
  }
  _gotoFetchFeatures(s4, a5) {
    return { type: u3.FETCH_FEATURES, previous: s4, task: j2(async (t7) => {
      const r8 = await d(a5.fetchFeatures(this, s4.featureCount, t7));
      this.state.type === u3.FETCH_FEATURES && (this.state = this._gotoFetchedFeatures(this.state, r8.ok ? r8.value : []));
    }) };
  }
  _gotoFetchedFeatures(t7, e5) {
    return { type: u3.FETCHED_FEATURES, previous: t7, features: e5 };
  }
  _goToDone(t7, e5) {
    return e5.finish(this, t7.features), { type: u3.DONE, previous: t7 };
  }
  reset() {
    const t7 = this.state;
    switch (this.state = { type: u3.CREATED }, t7.type) {
      case u3.CREATED:
      case u3.FETCHED_COUNT:
      case u3.FETCHED_FEATURES:
      case u3.DONE:
        break;
      case u3.FETCH_COUNT:
      case u3.FETCH_FEATURES:
        t7.task.abort();
    }
  }
  intersects(t7) {
    return !(!t(t7) && this.data.extent) || (c2(t7, T), E(this.data.extent, T));
  }
};
var u3;
!function(t7) {
  t7[t7.CREATED = 0] = "CREATED", t7[t7.FETCH_COUNT = 1] = "FETCH_COUNT", t7[t7.FETCHED_COUNT = 2] = "FETCHED_COUNT", t7[t7.FETCH_FEATURES = 3] = "FETCH_FEATURES", t7[t7.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t7[t7.DONE = 5] = "DONE";
}(u3 || (u3 = {}));
var T = u();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var C = class extends d2 {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  set filter(e5) {
    const t7 = this._get("filter"), i4 = this._filterProperties(e5);
    JSON.stringify(t7) !== JSON.stringify(i4) && this._set("filter", i4);
  }
  set customParameters(e5) {
    const t7 = this._get("customParameters");
    JSON.stringify(t7) !== JSON.stringify(e5) && this._set("customParameters", e5);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e5) {
    const t7 = this._get("tileInfo");
    t7 !== e5 && (r(e5) && r(t7) && JSON.stringify(e5) === JSON.stringify(t7) || (this._set("tileInfo", e5), this.store.tileInfo = e5));
  }
  set tileSize(e5) {
    this._get("tileSize") !== e5 && this._set("tileSize", e5);
  }
  get updating() {
    return this.updatingExcludingEdits || this._pendingEdits.updating;
  }
  get updatingExcludingEdits() {
    return this.updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e5) {
    super(e5), this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._pendingEdits = new r7(), this._pendingEditsAbortController = new AbortController();
  }
  initialize() {
    this._initializeFetchExtent(), this.updatingHandles.add(() => this._configuration, () => this.refresh()), this.updatingHandles.add(() => this.tilesOfInterest, (e5, i4) => {
      i(e5, i4, ({ id: e6 }, { id: t7 }) => e6 === t7) || this._process();
    }, U);
  }
  destroy() {
    this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._pendingEditsAbortController.abort(), this._pendingEditsAbortController = null;
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._process();
  }
  applyEdits(e5) {
    this._pendingEdits.push(e5, async (e6) => {
      if (0 === e6.addedFeatures.length && 0 === e6.updatedFeatures.length && 0 === e6.deletedFeatures.length)
        return;
      for (const [, i4] of this._pendingTiles)
        i4.reset();
      const t7 = { ...e6, deletedFeatures: e6.deletedFeatures.map(({ objectId: e7, globalId: t8 }) => e7 && -1 !== e7 ? e7 : this._lookupObjectIdByGlobalId(t8)) };
      await this.updatingHandles.addPromise(this.store.processEdits(t7, (e7, t8) => this._queryFeaturesById(e7, t8), this._pendingEditsAbortController.signal)), this._processPendingTiles();
    });
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g2(this.url))
      return;
    const e5 = j2(async (e6) => {
      var _a;
      try {
        const t7 = await x3(this.url, new x({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: !!this.capabilities.query.supportsCacheHint || void 0 }), { query: this._configuration.customParameters, signal: e6 });
        this.store.extent = w2.fromJSON((_a = t7.data) == null ? void 0 : _a.extent);
      } catch (t7) {
        w(t7), s.getLogger(this.declaredClass).warn("Failed to fetch data extent", t7);
      }
    });
    this.updatingHandles.addPromise(e5.promise.then(() => this._process())), this.handles.add(n(() => e5.abort()));
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e5) => e5.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const [, e5] of this._pendingTiles)
      e5.alive = false;
  }
  _createPendingTiles() {
    const e5 = this._collectMissingTilesInfo();
    if (this._setAvailability(t(e5) ? 1 : e5.coveredArea / e5.fullArea), !t(e5))
      for (const { data: t7, resolution: i4 } of e5.missingTiles) {
        const e6 = this._pendingTiles.get(t7.id);
        e6 ? (e6.resolution = i4, e6.alive = true) : this._createPendingTile(t7, i4);
      }
  }
  _collectMissingTilesInfo() {
    let e5 = null;
    for (let t7 = this.tilesOfInterest.length - 1; t7 >= 0; t7--) {
      const i4 = this.tilesOfInterest[t7], s4 = this.store.process(i4, (e6, t8) => this._verifyTileComplexity(e6, t8));
      t(e5) ? e5 = s4 : e5.prepend(s4);
    }
    return e5;
  }
  _deletePendingTiles() {
    for (const [, e5] of this._pendingTiles)
      e5.alive || this._deletePendingTile(e5);
  }
  _processPendingTiles() {
    const e5 = { fetchCount: (e6, t7) => this._fetchCount(e6, t7), fetchFeatures: (e6, t7, i4) => this._fetchFeatures(e6, t7, i4), finish: (e6, t7) => this._finishPendingTile(e6, t7), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e5))
      for (const [, t7] of this._pendingTiles)
        this._verifyTileComplexity(this.store.getFeatureCount(t7.data), t7.resolution) && this.updatingHandles.addPromise(t7.process(e5));
  }
  _verifyTileComplexity(e5, t7) {
    return this._verifyVertexComplexity(e5) && this._verifyFeatureDensity(e5, t7);
  }
  _verifyVertexComplexity(e5) {
    return e5 * this._minimumVerticesPerFeature < x4;
  }
  _verifyFeatureDensity(e5, t7) {
    if (t(this.tileInfo))
      return false;
    const i4 = this.tileSize * t7;
    return e5 * (j4 / (i4 * i4)) < w3;
  }
  _ensureFetchAllCounts(e5) {
    let t7 = true;
    for (const [, i4] of this._pendingTiles)
      i4.state.type < u3.FETCHED_COUNT && this.updatingHandles.addPromise(i4.process(e5)), i4.state.type <= u3.FETCH_COUNT && (t7 = false);
    return t7;
  }
  _finishPendingTile(e5, t7) {
    this.store.add(e5.data, t7), this._deletePendingTile(e5), this._updateAvailability();
  }
  _updateAvailability() {
    const e5 = this._collectMissingTilesInfo();
    this._setAvailability(t(e5) ? 1 : e5.coveredArea / e5.fullArea);
  }
  _setAvailability(e5) {
    this._set("availability", e5);
  }
  _createPendingTile(e5, t7) {
    const i4 = new o3(e5, t7);
    return this._pendingTiles.set(e5.id, i4), i4;
  }
  _deletePendingTile(e5) {
    e5.reset(), this._pendingTiles.delete(e5.data.id);
  }
  async _fetchCount(e5, t7) {
    return this.store.fetchCount(e5.data, this.url, this._createCountQuery(e5), { query: this.customParameters, timeout: S2, signal: t7 });
  }
  async _fetchFeatures(e5, t7, i4) {
    let s4 = 0;
    const r8 = [];
    let o4 = 0, n5 = t7;
    for (; ; ) {
      const a5 = this._createFeaturesQuery(e5), l3 = this._setPagingParameters(a5, s4, n5), { features: c9, exceededTransferLimit: d4 } = await this._queryFeatures(a5, i4);
      l3 && (s4 += e(a5.num)), o4 += c9.length;
      for (const e6 of c9)
        r8.push(e6);
      if (n5 = t7 - o4, !l3 || !d4 || n5 <= 0)
        return r8;
    }
  }
  _filterProperties(e5) {
    return t(e5) ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e5.where || "1=1", timeExtent: e5.timeExtent, gdbVersion: e5.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e5) {
    const t7 = this.globalIdField, i4 = this.objectIdField;
    if (t(t7))
      throw new Error("Expected globalIdField to be defined");
    let s4 = null;
    if (this.store.featureStore.forEach((r8) => {
      e5 === r8.attributes[t7] && (s4 = r8.objectId ?? r8.attributes[i4]);
    }), t(s4))
      throw new Error(`Expected to find a feature with globalId ${e5}`);
    return s4;
  }
  _queryFeaturesById(e5, t7) {
    const i4 = this._createFeaturesQuery();
    return i4.objectIds = e5, this._queryFeatures(i4, t7);
  }
  _queryFeatures(e5, t7) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e5, t7) : this._queryFeaturesJSON(e5, t7);
  }
  async _queryFeaturesPBF(e5, t7) {
    const { sourceSpatialReference: i4 } = this, { data: s4 } = await f4(this.url, e5, new a2({ sourceSpatialReference: i4 }), { query: this._configuration.customParameters, timeout: S2, signal: t7 });
    return ht(s4);
  }
  async _queryFeaturesJSON(e5, t7) {
    const { sourceSpatialReference: i4 } = this, { data: s4 } = await c4(this.url, e5, i4, { query: this._configuration.customParameters, timeout: S2, signal: t7 });
    return at(s4, this.objectIdField);
  }
  _createCountQuery(e5) {
    const t7 = this._createBaseQuery(e5);
    return this.capabilities.query.supportsCacheHint && (t7.cacheHint = true), t7;
  }
  _createFeaturesQuery(e5 = null) {
    const t7 = this._createBaseQuery(e5);
    return t7.outFields = this.globalIdField ? [this.globalIdField, this.objectIdField] : [this.objectIdField], t7.returnGeometry = true, r(e5) && (this.capabilities.query.supportsResultType ? t7.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t7.cacheHint = true)), t7;
  }
  _createBaseQuery(e5) {
    const t7 = new x({ returnZ: this.hasZ, returnM: false, geometry: r(this.tileInfo) && r(e5) ? f3(e5.data.extent, this.tileInfo.spatialReference) : void 0 }), i4 = this._configuration.filter;
    return r(i4) && (t7.where = i4.where, t7.gdbVersion = i4.gdbVersion, t7.timeExtent = i4.timeExtent), t7.outSpatialReference = this.spatialReference, t7;
  }
  _setPagingParameters(e5, t7, i4) {
    if (!this.capabilities.query.supportsPagination)
      return false;
    const { supportsMaxRecordCountFactor: s4, supportsCacheHint: r8, tileMaxRecordCount: o4, maxRecordCount: n5, supportsResultType: a5 } = this.capabilities.query, l3 = s4 ? x.MAX_MAX_RECORD_COUNT_FACTOR : 1, u4 = l3 * ((a5 || r8) && o4 ? o4 : n5 || E2);
    return e5.start = t7, s4 ? (e5.maxRecordCountFactor = Math.min(l3, Math.ceil(i4 / u4)), e5.num = Math.min(i4, e5.maxRecordCountFactor * u4)) : e5.num = Math.min(i4, u4), true;
  }
};
e2([y({ constructOnly: true })], C.prototype, "url", void 0), e2([y({ constructOnly: true })], C.prototype, "objectIdField", void 0), e2([y({ constructOnly: true })], C.prototype, "globalIdField", void 0), e2([y({ constructOnly: true })], C.prototype, "capabilities", void 0), e2([y({ constructOnly: true })], C.prototype, "sourceSpatialReference", void 0), e2([y({ constructOnly: true })], C.prototype, "spatialReference", void 0), e2([y({ constructOnly: true })], C.prototype, "store", void 0), e2([y({ readOnly: true })], C.prototype, "_minimumVerticesPerFeature", null), e2([y()], C.prototype, "filter", null), e2([y()], C.prototype, "customParameters", null), e2([y({ readOnly: true })], C.prototype, "_configuration", null), e2([y()], C.prototype, "tileInfo", null), e2([y()], C.prototype, "tileSize", null), e2([y()], C.prototype, "tilesOfInterest", void 0), e2([y({ readOnly: true })], C.prototype, "updating", null), e2([y({ readOnly: true })], C.prototype, "updatingExcludingEdits", null), e2([y({ readOnly: true })], C.prototype, "availability", void 0), e2([y()], C.prototype, "hasZ", null), C = e2([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], C);
var E2 = 2e3;
var S2 = 6e5;
var x4 = 1e6;
var j4 = 25;
var w3 = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t6 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t7, e5) {
    this.delete(t7), this._store.set(t7, e5), this._byteSize += e5.byteSize;
  }
  delete(t7) {
    const e5 = this._store.get(t7);
    return !!this._store.delete(t7) && (null != e5 && (this._byteSize -= e5.byteSize), true);
  }
  get(t7) {
    return this._used(t7), this._store.get(t7);
  }
  has(t7) {
    return this._used(t7), this._store.has(t7);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t7, e5) {
    for (const [s4, r8] of this._store) {
      if (this._byteSize <= t7)
        break;
      this.delete(s4), e5(r8);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t7) {
    const e5 = this._store.get(t7);
    e5 && (this._store.delete(t7), this._store.set(t7, e5));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var v2 = class extends v {
  constructor(e5) {
    super(e5), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * s2.MEGABYTES, this._tileBounds = new o(), this._tiles = new t6(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u();
  }
  add(e5, t7) {
    const s4 = [];
    for (const i4 of t7)
      this._referenceFeature(i4.objectId) === x5.ADDED && s4.push(i4);
    this._addTileStorage(e5, new Set(t7.map((e6) => e6.objectId)), C2(t7)), this.featureStore.addMany(s4), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e6) => this._removeTileStorage(e6));
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e5, t7, s4) {
    return this._processEditsDelete(e5.deletedFeatures.concat(e5.updatedFeatures)), this._processEditsRefetch(e5.addedFeatures.concat(e5.updatedFeatures), t7, s4);
  }
  _addTileStorage(e5, t7, s4) {
    const i4 = e5.id;
    this._tiles.set(i4, new T2(e5, t7, s4)), this._tileBounds.set(i4, e5.extent), this._tileFeatureCounts.set(i4, t7.size);
  }
  _remove({ id: e5 }) {
    const t7 = this._tiles.get(e5);
    t7 && this._removeTileStorage(t7);
  }
  _removeTileStorage(e5) {
    const t7 = [];
    for (const i4 of e5.objectIds)
      this._unreferenceFeature(i4) === x5.REMOVED && t7.push(i4);
    this.featureStore.removeManyById(t7);
    const s4 = e5.data.id;
    this._tiles.delete(s4), this._tileBounds.delete(s4);
  }
  _processEditsDelete(e5) {
    this.featureStore.removeManyById(e5);
    for (const [, t7] of this._tiles) {
      for (const s4 of e5)
        t7.objectIds.delete(s4);
      this._tileFeatureCounts.set(t7.data.id, t7.objectIds.size);
    }
    for (const t7 of e5)
      this._refCounts.delete(t7);
  }
  async _processEditsRefetch(e5, t7, s4) {
    const i4 = (await t7(e5, s4)).features, { hasZ: r8, hasM: n5 } = this.featureStore;
    for (const l3 of i4) {
      const e6 = It(this._tmpBoundingRect, l3.geometry, r8, n5);
      t(e6) || this._tileBounds.forEachInBounds(e6, (e7) => {
        const t8 = this._tiles.get(e7);
        this.featureStore.add(l3);
        const s5 = l3.objectId;
        t8.objectIds.has(s5) || (t8.objectIds.add(s5), this._referenceFeature(s5), this._tileFeatureCounts.set(t8.data.id, t8.objectIds.size));
      });
    }
  }
  process(e5, t7 = () => true) {
    if (t(this.tileInfo) || !e5.extent || r(this.extent) && !E(c2(this.extent, this._tmpBoundingRect), e5.extent))
      return new I(e5);
    if (this._tiles.has(e5.id))
      return new I(e5);
    const s4 = this._createTileTree(e5, this.tileInfo);
    return this._simplify(s4, t7, null, 0, 1), this._collectMissingTiles(e5, s4, this.tileInfo);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e5 }) => ({ data: e5, featureCount: this._tileFeatureCounts.get(e5.id) || 0 }));
  }
  getFeatureCount(e5) {
    return this._tileFeatureCounts.get(e5.id) ?? 0;
  }
  async fetchCount(e5, t7, s4, i4) {
    const r8 = this._tileFeatureCounts.get(e5.id);
    if (null != r8)
      return r8;
    const o4 = await S(t7, s4, i4);
    return this._tileFeatureCounts.set(e5.id, o4.data.count), o4.data.count;
  }
  _createTileTree(e5, t7) {
    const s4 = new F(e5.level, e5.row, e5.col);
    return t7.updateTileInfo(s4, j3.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e5.extent, (i4) => {
      var _a;
      const r8 = (_a = this._tiles.get(i4)) == null ? void 0 : _a.data;
      r8 && this._tilesAreRelated(e5, r8) && this._populateChildren(s4, r8, t7, this._tileFeatureCounts.get(r8.id) || 0);
    }), s4;
  }
  _tilesAreRelated(e5, t7) {
    if (!e5 || !t7)
      return false;
    if (e5.level === t7.level)
      return e5.row === t7.row && e5.col === t7.col;
    const s4 = e5.level < t7.level, i4 = s4 ? e5 : t7, r8 = s4 ? t7 : e5, o4 = 1 << r8.level - i4.level;
    return Math.floor(r8.row / o4) === i4.row && Math.floor(r8.col / o4) === i4.col;
  }
  _populateChildren(e5, t7, s4, i4) {
    const r8 = t7.level - e5.level - 1;
    if (r8 < 0)
      return void (e5.isLeaf = true);
    const o4 = t7.row >> r8, l3 = t7.col >> r8, a5 = e5.row << 1, c9 = l3 - (e5.col << 1) + (o4 - a5 << 1), h2 = e5.children[c9];
    if (r(h2))
      this._populateChildren(h2, t7, s4, i4);
    else {
      const r9 = new F(e5.level + 1, o4, l3);
      s4.updateTileInfo(r9, j3.ExtrapolateOptions.POWER_OF_TWO), e5.children[c9] = r9, this._populateChildren(r9, t7, s4, i4);
    }
  }
  _simplify(e5, t7, s4, i4, r8) {
    const o4 = r8 * r8;
    if (e5.isLeaf)
      return t7(this.getFeatureCount(e5), r8) ? 0 : (this._remove(e5), r(s4) && (s4.children[i4] = null), o4);
    const l3 = r8 / 2, a5 = l3 * l3;
    let c9 = 0;
    for (let h2 = 0; h2 < e5.children.length; h2++) {
      const s5 = e5.children[h2];
      c9 += r(s5) ? this._simplify(s5, t7, e5, h2, l3) : a5;
    }
    return 0 === c9 ? this._mergeChildren(e5) : 1 - c9 / o4 < w4 && (this._purge(e5), r(s4) && (s4.children[i4] = null), c9 = o4), c9;
  }
  _mergeChildren(e5) {
    const t7 = /* @__PURE__ */ new Set();
    let s4 = 0;
    this._forEachLeaf(e5, (e6) => {
      const i4 = this._tiles.get(e6.id);
      if (i4) {
        s4 += i4.byteSize;
        for (const e7 of i4.objectIds)
          t7.has(e7) || (t7.add(e7), this._referenceFeature(e7));
        this._remove(e6);
      }
    }), this._addTileStorage(e5, t7, s4), e5.isLeaf = true, e5.children[0] = e5.children[1] = e5.children[2] = e5.children[3] = null, this._tileFeatureCounts.set(e5.id, t7.size);
  }
  _forEachLeaf(e5, t7) {
    for (const s4 of e5.children)
      t(s4) || (s4.isLeaf ? t7(s4) : this._forEachLeaf(s4, t7));
  }
  _purge(e5) {
    if (!t(e5))
      if (e5.isLeaf)
        this._remove(e5);
      else
        for (let t7 = 0; t7 < e5.children.length; t7++) {
          const s4 = e5.children[t7];
          this._purge(s4), e5.children[t7] = null;
        }
  }
  _collectMissingTiles(e5, t7, s4) {
    const i4 = new j5(s4, e5, this.extent);
    return this._collectMissingTilesRecurse(t7, i4, 1), i4.info;
  }
  _collectMissingTilesRecurse(e5, t7, s4) {
    if (e5.isLeaf)
      return;
    if (!e5.hasChildren)
      return void t7.addMissing(e5.level, e5.row, e5.col, s4);
    const i4 = s4 / 2;
    for (let r8 = 0; r8 < e5.children.length; r8++) {
      const s5 = e5.children[r8];
      t(s5) ? t7.addMissing(e5.level + 1, (e5.row << 1) + ((2 & r8) >> 1), (e5.col << 1) + (1 & r8), i4) : this._collectMissingTilesRecurse(s5, t7, i4);
    }
  }
  _referenceFeature(e5) {
    const t7 = (this._refCounts.get(e5) || 0) + 1;
    return this._refCounts.set(e5, t7), 1 === t7 ? x5.ADDED : x5.UNCHANGED;
  }
  _unreferenceFeature(e5) {
    const t7 = (this._refCounts.get(e5) || 0) - 1;
    return 0 === t7 ? (this._refCounts.delete(e5), x5.REMOVED) : (t7 > 0 && this._refCounts.set(e5, t7), x5.UNCHANGED);
  }
  get test() {
    return { tiles: Array.from(this._tiles.values()).map((e5) => `${e5.data.id}:[${Array.from(e5.objectIds)}]`), featureReferences: Array.from(this._refCounts.keys()).map((e5) => `${e5}:${this._refCounts.get(e5)}`) };
  }
};
function C2(e5) {
  return e5.reduce((e6, t7) => e6 + E3(t7), 0);
}
function E3(e5) {
  return 32 + S3(e5.geometry) + t4(e5.attributes);
}
function S3(e5) {
  if (t(e5))
    return 0;
  const t7 = c5(e5.lengths, 4);
  return 32 + c5(e5.coords, 8) + t7;
}
e2([y({ constructOnly: true })], v2.prototype, "featureStore", void 0), e2([y()], v2.prototype, "tileInfo", void 0), e2([y()], v2.prototype, "extent", void 0), e2([y()], v2.prototype, "maximumByteSize", void 0), v2 = e2([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], v2);
var T2 = class {
  constructor(e5, t7, s4) {
    this.data = e5, this.objectIds = t7, this.byteSize = s4;
  }
};
var F = class {
  constructor(e5, t7, s4) {
    this.level = e5, this.row = t7, this.col = s4, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (r(this.children[0]) || r(this.children[1]) || r(this.children[2]) || r(this.children[3]));
  }
};
var I = class {
  constructor(e5, t7 = []) {
    this.missingTiles = t7, this.fullArea = 0, this.coveredArea = 0, this.fullArea = y2(e5.extent), this.coveredArea = this.fullArea;
  }
  prepend(e5) {
    this.missingTiles = e5.missingTiles.concat(this.missingTiles), this.coveredArea += e5.coveredArea, this.fullArea += e5.fullArea;
  }
};
var j5 = class {
  constructor(e5, t7, s4) {
    this._tileInfo = e5, this._extent = null, this.info = new I(t7), r(s4) && (this._extent = c2(s4));
  }
  addMissing(e5, t7, s4, i4) {
    const r8 = new t3(null, e5, t7, s4);
    this._tileInfo.updateTileInfo(r8, j3.ExtrapolateOptions.POWER_OF_TWO), t(r8.extent) || r(this._extent) && !E(this._extent, r8.extent) || (this.info.missingTiles.push({ data: r8, resolution: i4 }), this.info.coveredArea -= y2(r8.extent));
  }
};
var w4 = 0.18751;
var x5;
!function(e5) {
  e5[e5.ADDED = 0] = "ADDED", e5[e5.REMOVED = 1] = "REMOVED", e5[e5.UNCHANGED = 2] = "UNCHANGED";
}(x5 || (x5 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w5 = class extends n2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = A(), this._elevationAligner = r4(), this._elevationFilter = r5(), this._symbologyCandidatesFetcher = n4(), this._handles = new t2(), this._updatingHandles = new c3(), this._editsUpdatingHandles = new c3(), this._pendingApplyEdits = /* @__PURE__ */ new Map(), this._alignPointsInFeatures = async (e5, t7) => {
      const i4 = { points: e5 }, s4 = await this.remoteClient.invoke("alignElevation", i4, { signal: t7 });
      return f(t7), s4;
    }, this._getSymbologyCandidates = async (e5, t7) => {
      const i4 = { candidates: e5, spatialReference: this._spatialReference.toJSON() }, s4 = await this.remoteClient.invoke("getSymbologyCandidates", i4, { signal: t7 });
      return f(t7), s4;
    };
  }
  get updating() {
    return this.updatingExcludingEdits || this._editsUpdatingHandles.updating || this._featureFetcher.updating;
  }
  get updatingExcludingEdits() {
    return this._featureFetcher.updatingExcludingEdits || this._isInitializing || this._updatingHandles.updating;
  }
  destroy() {
    var _a, _b, _c, _d;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear(), (_d = this._handles) == null ? void 0 : _d.destroy();
  }
  async setup(e5) {
    if (this.destroyed)
      return { result: {} };
    const { geometryType: t7, objectIdField: i4, timeInfo: r8, fields: n5 } = e5.serviceInfo, { hasZ: o4 } = e5, d4 = f2.fromJSON(e5.spatialReference);
    this._spatialReference = d4, this._featureStore = new g({ ...e5.serviceInfo, hasZ: o4, hasM: false }), this._queryEngine = new ee({ spatialReference: e5.spatialReference, featureStore: this._featureStore, geometryType: t7, fields: n5, hasZ: o4, hasM: false, objectIdField: i4, timeInfo: r8 }), this._featureFetcher = new C({ store: new v2({ featureStore: this._featureStore }), url: e5.serviceInfo.url, objectIdField: e5.serviceInfo.objectIdField, globalIdField: e5.serviceInfo.globalIdField, capabilities: e5.serviceInfo.capabilities, spatialReference: d4, sourceSpatialReference: f2.fromJSON(e5.serviceInfo.spatialReference) });
    const p3 = "3d" === e5.configuration.viewType;
    return this._elevationAligner = r4(p3, { elevationInfo: r(e5.elevationInfo) ? x2.fromJSON(e5.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures, spatialReference: d4 }), this._elevationFilter = r5(p3), this._handles.add([l(() => this._featureFetcher.availability, (e6) => this.emit("notify-availability", { availability: e6 }), U), l(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e5.configuration);
  }
  async configure(e5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e5), { result: {} };
  }
  async fetchCandidates(e5, t7) {
    await this._whenSetup.promise, f(t7);
    const i4 = E4(e5), r8 = r(t7) ? t7.signal : null, a5 = await this._queryEngine.executeQueryForSnapping(i4, r8);
    f(r8);
    const o4 = await this._elevationAligner.alignCandidates(a5.candidates, r8);
    f(r8);
    const l3 = await this._symbologyCandidatesFetcher.fetch(o4, r8);
    f(r8);
    const d4 = 0 === l3.length ? o4 : o4.concat(l3);
    return { result: { candidates: this._elevationFilter.filter(i4, d4) } };
  }
  async updateTiles(e5, t7) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), f(t7), this._featureFetcher.tileSize = e5.tileSize, this._featureFetcher.tilesOfInterest = e5.tiles, this._featureFetcher.tileInfo = r(e5.tileInfo) ? j3.fromJSON(e5.tileInfo) : null, j6;
  }
  async refresh(e5, t7) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), f(t7), this._featureFetcher.refresh(), j6;
  }
  async whenNotUpdating(e5, t7) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), f(t7), await j(() => !this.updatingExcludingEdits, t7), f(t7), j6;
  }
  async getDebugInfo(e5, t7) {
    return f(t7), { result: this._featureFetcher.debugInfo };
  }
  async beginApplyEdits(e5, t7) {
    this._updatingHandles.addPromise(this._whenSetup.promise), f(t7);
    const i4 = A();
    return this._pendingApplyEdits.set(e5.id, i4), this._featureFetcher.applyEdits(i4.promise), this._editsUpdatingHandles.addPromise(i4.promise), j6;
  }
  async endApplyEdits(e5, t7) {
    const i4 = this._pendingApplyEdits.get(e5.id);
    return i4 && i4.resolve(e5.edits), f(t7), j6;
  }
  async notifyElevationSourceChange(e5, t7) {
    return this._elevationAligner.notifyElevationSourceChange(), j6;
  }
  async notifySymbologyChange(e5, t7) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), j6;
  }
  async setSymbologySnappingSupported(e5) {
    return this._symbologyCandidatesFetcher = n4(e5, this._getSymbologyCandidates), j6;
  }
  _updateFeatureFetcherConfiguration(e5) {
    this._featureFetcher.filter = r(e5.filter) ? x.fromJSON(e5.filter) : null, this._featureFetcher.customParameters = e5.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
e2([y({ readOnly: true })], w5.prototype, "updating", null), e2([y({ readOnly: true })], w5.prototype, "updatingExcludingEdits", null), e2([y()], w5.prototype, "_isInitializing", void 0), w5 = e2([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w5);
var b = w5;
function E4(e5) {
  return { point: e5.point, mode: e5.mode, distance: e5.distance, types: e5.types, query: r(e5.filter) ? e5.filter : { where: "1=1" } };
}
var j6 = { result: {} };
export {
  b as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-6NW4VGAD.js.map

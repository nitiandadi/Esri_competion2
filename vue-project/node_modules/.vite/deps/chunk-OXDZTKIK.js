import {
  r as r2
} from "./chunk-C6SENRFO.js";
import {
  l as l2,
  n as n2
} from "./chunk-LYEEAWXU.js";
import {
  f
} from "./chunk-223SE4BY.js";
import {
  K,
  W
} from "./chunk-63WRUMNA.js";
import {
  x
} from "./chunk-23AC3IC7.js";
import {
  E as E3
} from "./chunk-GKD7ZY5C.js";
import {
  B,
  C,
  D as D3,
  E as E2,
  F,
  G as G2,
  H,
  M as M2,
  N,
  O,
  P as P2,
  R,
  ct,
  o as o2
} from "./chunk-RRNRSHX3.js";
import {
  D as D2,
  G,
  L,
  M,
  P,
  V,
  Y
} from "./chunk-4M3AMTD4.js";
import {
  n
} from "./chunk-NWZTRS6O.js";
import {
  o as o3,
  s as s4
} from "./chunk-77E52HT5.js";
import {
  e as e2
} from "./chunk-MZ267CZB.js";
import {
  i,
  s as s3
} from "./chunk-PRXITTX7.js";
import {
  D
} from "./chunk-WTKFW2TD.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  E,
  b,
  e,
  g,
  l,
  o,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/AttributeStoreView.js
var B2 = s.getLogger("esri.views.2d.engine.webgl.AttributeStoreView");
var V2 = n2(l2, B2);
var L2 = class {
  constructor(t2, e3, i3) {
    this._texture = null, this._lastTexture = null, this._fbos = {}, this.texelSize = 4;
    const { buffer: s5, pixelType: r4, textureOnly: a } = t2, h2 = W(r4);
    this.shared = i3, this.pixelType = r4, this.size = e3, this.textureOnly = a, a || (this.data = new h2(e(s5))), this._resetRange();
  }
  destroy() {
    o(this._texture, (t2) => t2.dispose());
    for (const t2 in this._fbos)
      o(this._fbos[t2], (e3) => {
        "0" === t2 && e3.detachColorTexture(), e3.dispose();
      }), this._fbos[t2] = null;
    this._texture = null;
  }
  get _textureDesc() {
    return { target: M.TEXTURE_2D, wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: this.pixelType, samplingMode: L.NEAREST, width: this.size, height: this.size };
  }
  setData(t2, e3, i3) {
    const s5 = f(t2), r4 = e(this.data), a = s5 * this.texelSize + e3;
    !r4 || a >= r4.length || (r4[a] = i3, this.dirtyStart = Math.min(this.dirtyStart, s5), this.dirtyEnd = Math.max(this.dirtyEnd, s5));
  }
  getData(t2, e3) {
    if (t(this.data))
      return null;
    const s5 = f(t2) * this.texelSize + e3;
    return !this.data || s5 >= this.data.length ? null : this.data[s5];
  }
  getTexture(t2) {
    return l(this._texture, () => this._initTexture(t2));
  }
  getFBO(t2, e3 = 0) {
    if (t(this._fbos[e3])) {
      const i3 = { colorTarget: Y.TEXTURE, depthStencilTarget: V.NONE }, s5 = 0 === e3 ? this.getTexture(t2) : this._textureDesc;
      this._fbos[e3] = new x(t2, i3, s5);
    }
    return this._fbos[e3];
  }
  get locked() {
    return !(this.pixelType !== G.UNSIGNED_BYTE || !this.shared || this.textureOnly || !has("esri-atomics") || !this.data) && 1 === Atomics.load(this.data, 0);
  }
  get hasDirty() {
    const t2 = this.dirtyStart;
    return this.dirtyEnd >= t2;
  }
  updateTexture(e3, i3) {
    if (!this.locked) {
      try {
        const i4 = this.dirtyStart, s5 = this.dirtyEnd;
        if (!this.hasDirty)
          return;
        this._resetRange();
        const r4 = e(this.data).buffer, a = this.getTexture(e3), h2 = 4, n3 = (i4 - i4 % this.size) / this.size, o4 = (s5 - s5 % this.size) / this.size, u = n3, l3 = this.size, p = o4, x2 = n3 * this.size * h2, _2 = (l3 + p * this.size) * h2 - x2, g2 = W(this.pixelType), c = new g2(r4, x2 * g2.BYTES_PER_ELEMENT, _2), T = this.size, f2 = p - u + 1;
        if (f2 > this.size)
          return void B2.error(new s2("mapview-webgl", "Out-of-bounds index when updating AttributeData"));
        a.updateData(0, 0, u, T, f2, c);
      } catch (s5) {
      }
      i3();
    }
  }
  update(t2) {
    const { data: e3, start: i3, end: s5 } = t2;
    if (r(e3) && r(this.data)) {
      const s6 = this.data, r4 = i3 * this.texelSize;
      for (let i4 = 0; i4 < e3.length; i4++) {
        const a = 1 << i4 % this.texelSize;
        t2.layout & a && (s6[r4 + i4] = e3[i4]);
      }
    }
    this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, s5);
  }
  resize(t2, e3) {
    const i3 = this.size;
    if (this.size = e3, this.textureOnly)
      return void (i3 !== this.size && (this._lastTexture = this._texture, this._texture = null));
    const s5 = W(this.pixelType);
    this.destroy(), this.data = new s5(e(t2.buffer));
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
  _initTexture(t2) {
    const e3 = new E3(t2, this._textureDesc, l(this.data, void 0));
    if (r(this._lastTexture) && this._fbos[0]) {
      const i3 = this._lastTexture.descriptor.width, s5 = this._lastTexture.descriptor.height, r4 = this._lastTexture.descriptor.dataType, a = this._lastTexture.descriptor.pixelFormat, d = this.getFBO(t2), h2 = K(r4), n3 = new (W(r4))(new ArrayBuffer(i3 * s5 * h2 * this.texelSize)), o4 = t2.getBoundFramebufferObject(), { x: u, y: l3, width: p, height: x2 } = t2.getViewport();
      t2.bindFramebuffer(d), d.readPixels(0, 0, i3, s5, a, r4, n3), e3.updateData(0, 0, 0, 2 * i3, s5 / 2, n3), t2.setViewport(u, l3, p, x2), t2.bindFramebuffer(o4);
    }
    return this.destroy(), this._texture = e3, this._texture;
  }
};
var G3 = class {
  constructor(t2) {
    this._onUpdate = t2, this._initialized = false, this._forceNextUpload = false, this._locked = false;
  }
  initialize(t2) {
    const { blocks: e3, shared: a, size: d } = t2;
    if (this.shared = a, this.size = d, V2("Initializing AttributeStoreView", t2), t(this._data))
      this._data = E(e3, (t3) => new L2(t3, d, a));
    else
      for (let s5 = 0; s5 < this._data.length; s5++) {
        const t3 = this._data[s5], h2 = e3[s5];
        r(h2) && (t(t3) ? this._data[s5] = new L2(h2, d, a) : t3.resize(h2, d));
      }
    this._initialized = true;
  }
  destroy() {
    o(this._data, (t2) => E(t2, (t3) => t3.destroy())), o(this._defaultTexture, (t2) => t2.dispose());
  }
  isEmpty() {
    const t2 = this._data;
    return t(t2);
  }
  isUpdating() {
    const t2 = r(this._pendingAttributeUpdate), e3 = t2;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStoreView ${e3}
  -> hasPendingUpdate ${t2}`), e3;
  }
  getBlock(t2) {
    if (t(this._data))
      return null;
    return this._data[t2];
  }
  setLabelMinZoom(t2, e3) {
    this.setData(t2, 0, 1, e3);
  }
  getLabelMinZoom(t2) {
    return this.getData(t2, 0, 1, 255);
  }
  getFilterFlags(t2) {
    return this.getData(t2, 0, 0, 0);
  }
  getVVSize(t2) {
    return this.getData(t2, P2, 0, 0);
  }
  getData(t2, e3, s5, a) {
    if (!this._data)
      return 0;
    const h2 = e(this._data)[e3];
    if (t(h2))
      return 0;
    const n3 = h2.getData(t2, s5);
    return r(n3) ? n3 : a;
  }
  setData(t2, e3, i3, s5) {
    const r4 = e(this._data)[e3];
    e(r4).setData(t2, i3, s5);
  }
  lockTextureUpload() {
    this._locked = true;
  }
  unlockTextureUpload() {
    this._locked = false;
  }
  forceTextureUpload() {
    this._forceNextUpload = true;
  }
  async requestUpdate(e3) {
    if (this._pendingAttributeUpdate)
      return void B2.error(new s2("mapview-webgl", "Tried to update attribute data with a pending update"));
    const i3 = D();
    return V2("AttributeStoreView Update Requested", e3), this._pendingAttributeUpdate = { data: e3, resolver: i3 }, this._onUpdate(), i3.promise;
  }
  update() {
    if (this._initialized && r(this._pendingAttributeUpdate)) {
      has("esri-2d-update-debug") && console.debug("AttributeStoreView::update");
      const { data: t2, resolver: e3 } = this._pendingAttributeUpdate, i3 = e(this._data);
      for (let s5 = 0; s5 < t2.blocks.length; s5++) {
        const e4 = t2.blocks[s5], r4 = i3[s5];
        o(r4, (t3) => o(e4, (e5) => {
          V2(`Updating block ${s5}`, e5), t3.update(e5);
        }));
      }
      this._pendingAttributeUpdate = null, e3(), this._onUpdate();
    }
  }
  bindTextures(t2, e3 = true) {
    const i3 = this._getDefaultTexture(t2);
    if (!this._initialized)
      return t2.bindTexture(i3, B), void (e3 && (t2.bindTexture(i3, C), t2.bindTexture(i3, D3), t2.bindTexture(i3, E2), t2.bindTexture(i3, F), t2.bindTexture(i3, G2), t2.bindTexture(i3, H)));
    const s5 = e(this._data);
    this._locked && !this._forceNextUpload || (b(s5, (e4) => e4.updateTexture(t2, () => this._onUpdate())), this._forceNextUpload = false), t2.bindTexture(g(s5[M2], i3, (e4) => e4.getTexture(t2)), B), e3 && (t2.bindTexture(g(s5[O], i3, (e4) => e4.getTexture(t2)), H), t2.bindTexture(g(s5[N], i3, (e4) => e4.getTexture(t2)), C), t2.bindTexture(g(s5[P2], i3, (e4) => e4.getTexture(t2)), D3), t2.bindTexture(g(s5[R], i3, (e4) => e4.getTexture(t2)), E2), t2.bindTexture(g(s5[F], i3, (e4) => e4.getTexture(t2)), F), t2.bindTexture(g(s5[G2], i3, (e4) => e4.getTexture(t2)), G2));
  }
  _getDefaultTexture(t2) {
    if (t(this._defaultTexture)) {
      const e3 = { wrapMode: D2.CLAMP_TO_EDGE, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, width: 1, height: 1 };
      this._defaultTexture = new E3(t2, e3, new Uint8Array(4));
    }
    return this._defaultTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLTile.js
var h = class {
  acquire(s5) {
    return { refCount: 1, version: -1, labelMat2d: n(), tileMat3: e2(), dvs: e2() };
  }
  release(s5) {
  }
};
var m = class extends r2 {
  constructor(s5, t2, r4, e3) {
    super(s5, t2, r4, e3, o2, o2);
  }
  destroy() {
    super.destroy(), this._transforms && m.TransformCache.release(this.key.hash);
  }
  setTransform(i3) {
    const o4 = this.resolution / i3.resolution, n3 = this.transforms.tileMat3, [h2, m2] = i3.toScreenNoRotation([0, 0], [this.x, this.y]), c = this.width / this.rangeX * o4, f2 = this.height / this.rangeY * o4;
    s3(n3, c, 0, 0, 0, f2, 0, h2, m2, 1), i(this.transforms.dvs, i3.displayViewMat3, n3);
    const d = this.transforms.labelMat2d, l3 = window.devicePixelRatio, u = s4(n(), c * l3, 0, 0, f2 * l3, h2 * l3, m2 * l3);
    o3(d, i3.viewMat2d, u);
  }
  _createTransforms() {
    return m.TransformCache.acquire(this.key.hash);
  }
};
m.TransformCache = new h();

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/DisplayRecordReader.js
var r3 = 2147483647;
var i2 = class {
  constructor(t2) {
    this._head = t2, this._cursor = t2;
  }
  static from(t2, e3 = 0, s5 = t2.byteLength / _.BYTES_PER_RECORD - e3) {
    const r4 = new _(new Int32Array(t2, e3 * _.BYTES_PER_RECORD, s5 * _.ELEMENTS_PER_RECORD));
    return new i2(r4);
  }
  size() {
    let t2 = this._cursor, e3 = 0;
    for (; t2; )
      e3 += t2.size(), t2 = t2._link;
    return e3;
  }
  get id() {
    return this._cursor.id;
  }
  set id(t2) {
    this._cursor.id = t2;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  set materialKey(t2) {
    this._cursor.materialKey = t2;
  }
  get insertAfter() {
    return this._cursor.insertAfter;
  }
  get indexFrom() {
    return this._cursor.indexFrom;
  }
  set indexFrom(t2) {
    this._cursor.indexFrom = t2;
  }
  get indexCount() {
    return this._cursor.indexCount;
  }
  set indexCount(t2) {
    this._cursor.indexCount = t2;
  }
  get vertexFrom() {
    return this._cursor.vertexFrom;
  }
  set vertexFrom(t2) {
    this._cursor.vertexFrom = t2;
  }
  get vertexCount() {
    return this._cursor.vertexCount;
  }
  set vertexCount(t2) {
    this._cursor.vertexCount = t2;
  }
  get sortKey() {
    return this._cursor.sortKey;
  }
  set sortKey(t2) {
    this._cursor.sortKey = t2;
  }
  get index() {
    return this._cursor._indexStart + this._cursor._index;
  }
  seekIndex(t2) {
    let e3 = t2;
    for (this._cursor = this._head; this._cursor; ) {
      const t3 = this._cursor.size();
      if (e3 < t3)
        return this._cursor._index = e3, true;
      e3 -= t3, this._cursor = this._cursor._link;
    }
    return false;
  }
  forEach(t2) {
    const e3 = this.getCursor();
    for (; e3.next(); )
      t2(e3);
  }
  link(t2) {
    if (!this._head)
      return void (this._head = t2._head);
    let e3 = this._head;
    for (; e3._link; )
      e3 = e3._link;
    e3._link = t2._head, e3._link._indexStart = e3._indexStart + e3.size();
  }
  getCursor() {
    return this.copy();
  }
  lookup(t2) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t2); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  copy() {
    var _a;
    const t2 = new i2((_a = this._head) == null ? void 0 : _a.copy());
    if (!t2._head)
      return t2;
    let e3 = t2._head, s5 = t2._head._link;
    for (; s5; )
      e3._link = s5.copy(), e3 = s5, s5 = e3._link;
    return t2;
  }
  next() {
    return !!this._cursor && (!!this._cursor.next() || !!this._cursor._link && (this._cursor = this._cursor._link, this.next()));
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  delete(e3) {
    let s5 = this._head, r4 = null;
    for (; s5; ) {
      if (s5.delete(e3))
        return s5.isEmpty() && (r(r4) && (r4._link = s5._link), s5 === this._head && (this._head = s5._link), s5 === this._cursor && (this._cursor = s5._link)), true;
      r4 = s5, s5 = s5._link;
    }
    return false;
  }
};
i2.ELEMENTS_PER_RECORD = ct, i2.BYTES_PER_RECORD = i2.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;
var _ = class {
  constructor(t2) {
    this._link = null, this._index = -1, this._indexStart = 0, this._packedRecordsF32 = null, this._deletedCount = 0, this._offsets = { instance: null }, this._packedRecords = t2;
  }
  static from(t2, e3 = 0, s5 = t2.byteLength / this.BYTES_PER_RECORD - e3) {
    return new _(new Int32Array(t2, e3 * this.BYTES_PER_RECORD, s5 * this.ELEMENTS_PER_RECORD));
  }
  delete(t2) {
    const e3 = this._index, s5 = this.lookup(t2);
    if (s5)
      for (this.id = r3, ++this._deletedCount; this.next() && this.id === t2; )
        this.id = r3, ++this._deletedCount;
    return this._index = e3, s5;
  }
  isEmpty() {
    return this._deletedCount === this.size();
  }
  link(t2) {
    this._link ? this._link.link(t2) : this._link = t2;
  }
  lookup(t2) {
    if (t(this._offsets.instance)) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t3 = this.copy();
      t3._index = -1;
      let e3 = 0;
      for (; t3.next(); )
        t3.id !== e3 && (this._offsets.instance.set(t3.id, t3._index), e3 = t3.id);
    }
    if (!this._offsets.instance.has(t2))
      return false;
    const s5 = this._index;
    return this._index = this._offsets.instance.get(t2), this.id !== r3 || (this._index = s5, false);
  }
  get id() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD];
  }
  set id(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD] = t2;
  }
  get materialKey() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1];
  }
  set materialKey(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 1] = t2;
  }
  get insertAfter() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 2];
  }
  get indexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3];
  }
  set indexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 3] = t2;
  }
  get indexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4];
  }
  set indexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 4] = t2;
  }
  get vertexFrom() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5];
  }
  set vertexFrom(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 5] = t2;
  }
  get vertexCount() {
    return this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6];
  }
  set vertexCount(t2) {
    this._packedRecords[this._index * _.ELEMENTS_PER_RECORD + 6] = t2;
  }
  get sortKey() {
    return this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7];
  }
  set sortKey(t2) {
    this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _.ELEMENTS_PER_RECORD + 7] = t2;
  }
  get index() {
    return this._index;
  }
  size() {
    return this._packedRecords.length / _.ELEMENTS_PER_RECORD;
  }
  next() {
    for (; ++this._index < this.size() && this.id === r3; )
      ;
    return this._index < this.size();
  }
  peekId() {
    const t2 = (this._index + 1) * _.ELEMENTS_PER_RECORD;
    return t2 >= this._packedRecords.length ? 0 : this._packedRecords[t2];
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t2 = new _(this._packedRecords);
    return t2._indexStart = this._indexStart, t2._link = this._link, t2._index = this._index, t2._offsets = this._offsets, t2._deletedCount = this._deletedCount, t2;
  }
};
_.ELEMENTS_PER_RECORD = ct, _.BYTES_PER_RECORD = _.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;

export {
  m,
  i2 as i,
  G3 as G
};
//# sourceMappingURL=chunk-OXDZTKIK.js.map

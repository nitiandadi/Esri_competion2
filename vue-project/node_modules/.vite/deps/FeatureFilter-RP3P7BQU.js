import {
  p
} from "./chunk-6U4EQTTA.js";
import "./chunk-BZHNKPDE.js";
import "./chunk-WZIJLPDJ.js";
import "./chunk-QE6RY3R6.js";
import {
  n,
  v
} from "./chunk-FLFW4GNA.js";
import "./chunk-OGEJGMAT.js";
import {
  J
} from "./chunk-PQDIOR7M.js";
import "./chunk-7BJCYBN2.js";
import "./chunk-VQUDNY75.js";
import "./chunk-QDIJO3T2.js";
import "./chunk-6WFGRBCZ.js";
import "./chunk-SXVHYYSN.js";
import "./chunk-VOUOLBXG.js";
import "./chunk-KGJHWKNE.js";
import "./chunk-X7NPMCZZ.js";
import "./chunk-CFTD44JM.js";
import "./chunk-MI7FJDLG.js";
import "./chunk-E4FSIE7C.js";
import "./chunk-IN3HJEU7.js";
import "./chunk-KQSNRPAM.js";
import "./chunk-2YEIG5KK.js";
import "./chunk-RZLXFQKV.js";
import "./chunk-UBZEFQ76.js";
import "./chunk-D5KVII6M.js";
import "./chunk-G3ZCYHOR.js";
import "./chunk-FI2SN5P7.js";
import "./chunk-HNMSCBZJ.js";
import "./chunk-43D3HGVY.js";
import "./chunk-OJCBSPLX.js";
import {
  u
} from "./chunk-EMRZKKP3.js";
import "./chunk-MKMLHQNH.js";
import "./chunk-PHPHIDTF.js";
import "./chunk-P6SQPYDS.js";
import "./chunk-YXFIF2O5.js";
import "./chunk-E4MAG7OK.js";
import "./chunk-YVQV6YXG.js";
import "./chunk-3KALZGFA.js";
import "./chunk-OJKTPYH5.js";
import {
  x
} from "./chunk-DXGYZ4HI.js";
import "./chunk-CKHNR7DG.js";
import "./chunk-FY3NCRRH.js";
import "./chunk-CIPSOFMY.js";
import "./chunk-3U7SS7RC.js";
import "./chunk-UHF3OUQV.js";
import "./chunk-6U5BQYRW.js";
import "./chunk-LUOENZ4F.js";
import "./chunk-QGRPG4XS.js";
import {
  c
} from "./chunk-M73MMEC7.js";
import "./chunk-A5CTLI5A.js";
import "./chunk-WUBKNERF.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-GLDJLPWH.js";
import "./chunk-GMLVDTS4.js";
import "./chunk-G7CHVXDR.js";
import "./chunk-OAZLVZFS.js";
import "./chunk-CPSZPA6H.js";
import "./chunk-Y54MR3BP.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-JY6H6KI3.js";
import "./chunk-TTCQP5LX.js";
import {
  s,
  s2
} from "./chunk-C2WY74GI.js";
import "./chunk-MCOYI7PX.js";
import "./chunk-EL4OGCJC.js";
import "./chunk-XPATKIHO.js";
import "./chunk-MKHZ5X6F.js";
import {
  t
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/whereUtils.js
var t2 = s.getLogger("esri.views.2d.layers.features.support.whereUtils");
var a = { getAttribute: (e, r) => e.field(r) };
async function s3(r, s4) {
  const n2 = await import("./WhereClause-WFUPYY4E.js");
  try {
    const o = n2.WhereClause.create(r, s4);
    if (!o.isStandardized) {
      const r2 = new s2("mapview - bad input", "Unable to apply filter's definition expression, as expression is not standardized.", o);
      t2.error(r2);
    }
    return (e) => {
      const r2 = e.readArcadeFeature();
      return o.testFeature(r2, a);
    };
  } catch (o) {
    return t2.warn("mapview-bad-where-clause", "Encountered an error when evaluating where clause", r), (e) => true;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureFilter.js
var m = 1;
var _ = 2;
var p2 = class {
  constructor(t3) {
    this._geometryBounds = u(), this._idToVisibility = /* @__PURE__ */ new Map(), this._serviceInfo = t3;
  }
  get hash() {
    return this._hash;
  }
  check(t3) {
    return this._applyFilter(t3);
  }
  clear() {
    const t3 = this._resetAllHiddenIds();
    return this.update(), { show: t3, hide: [] };
  }
  invalidate() {
    this._idToVisibility.forEach((t3, e) => {
      this._idToVisibility.set(e, 0);
    });
  }
  setKnownIds(t3) {
    for (const e of t3)
      this._idToVisibility.set(e, m);
  }
  setTrue(t3) {
    const e = [], i = [], s4 = new Set(t3);
    return this._idToVisibility.forEach((t4, r) => {
      const o = !!(this._idToVisibility.get(r) & m), h = s4.has(r);
      !o && h ? e.push(r) : o && !h && i.push(r), this._idToVisibility.set(r, h ? m | _ : 0);
    }), { show: e, hide: i };
  }
  createQuery() {
    const { geometry: t3, spatialRel: e, where: i, timeExtent: s4, objectIds: r } = this;
    return x.fromJSON({ geometry: t3, spatialRel: e, where: i, timeExtent: s4, objectIds: r });
  }
  async update(t3, e) {
    this._hash = JSON.stringify(t3);
    const i = await J(t3, null, e);
    await Promise.all([this._setGeometryFilter(i), this._setIdFilter(i), this._setAttributeFilter(i), this._setTimeFilter(i)]);
  }
  async _setAttributeFilter(t3) {
    if (!t3 || !t3.where)
      return this._clause = null, void (this.where = null);
    this._clause = await s3(t3.where, this._serviceInfo.fieldsIndex), this.where = t3.where;
  }
  _setIdFilter(t3) {
    this._idsToShow = t3 && t3.objectIds && new Set(t3.objectIds), this._idsToHide = t3 && t3.hiddenIds && new Set(t3.hiddenIds), this.objectIds = t3 && t3.objectIds;
  }
  async _setGeometryFilter(t3) {
    if (!t3 || !t3.geometry)
      return this._spatialQueryOperator = null, this.geometry = null, void (this.spatialRel = null);
    const e = t3.geometry, i = t3.spatialRel || "esriSpatialRelIntersects", s4 = await v(i, e, this._serviceInfo.geometryType, this._serviceInfo.hasZ, this._serviceInfo.hasM);
    c(this._geometryBounds, e), this._spatialQueryOperator = s4, this.geometry = e, this.spatialRel = i;
  }
  _setTimeFilter(i) {
    if (this.timeExtent = this._timeOperator = null, i && i.timeExtent)
      if (this._serviceInfo.timeInfo)
        this.timeExtent = i.timeExtent, this._timeOperator = n(this._serviceInfo.timeInfo, i.timeExtent, p);
      else {
        const s4 = new s2("feature-layer-view:time-filter-not-available", "Unable to apply time filter, as layer doesn't have time metadata.", i.timeExtent);
        s.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(s4);
      }
  }
  _applyFilter(t3) {
    return this._filterByGeometry(t3) && this._filterById(t3) && this._filterByTime(t3) && this._filterByExpression(t3);
  }
  _filterByExpression(t3) {
    return !this.where || this._clause(t3);
  }
  _filterById(t3) {
    return (!this._idsToHide || !this._idsToHide.size || !this._idsToHide.has(t3.getObjectId())) && (!this._idsToShow || !this._idsToShow.size || this._idsToShow.has(t3.getObjectId()));
  }
  _filterByGeometry(t3) {
    if (!this.geometry)
      return true;
    const e = t3.readHydratedGeometry();
    return !!e && this._spatialQueryOperator(e);
  }
  _filterByTime(t3) {
    return !!t(this._timeOperator) || this._timeOperator(t3);
  }
  _resetAllHiddenIds() {
    const t3 = [];
    return this._idToVisibility.forEach((e, i) => {
      e & m || (this._idToVisibility.set(i, m), t3.push(i));
    }), t3;
  }
};
export {
  p2 as default
};
//# sourceMappingURL=FeatureFilter-RP3P7BQU.js.map

import {
  N,
  T as T2,
  Z,
  Z2,
  f as f2,
  m,
  o,
  q,
  s as s3
} from "./chunk-2GEZASFW.js";
import {
  pn
} from "./chunk-VST6PURP.js";
import {
  g
} from "./chunk-SBDA5A2W.js";
import "./chunk-HKEMCUCV.js";
import "./chunk-BKXAUKK2.js";
import "./chunk-ZIIXXFNY.js";
import "./chunk-7ZZ5ZHW5.js";
import "./chunk-6GNTIFZ2.js";
import {
  T
} from "./chunk-ZSQJBVGI.js";
import "./chunk-ZZVUJ6NV.js";
import "./chunk-JD46HKMJ.js";
import "./chunk-PCX62T5O.js";
import {
  A,
  Ae,
  B,
  C,
  D,
  F2 as F,
  G,
  J,
  L,
  R,
  V,
  Y,
  ce,
  e as e2,
  j,
  le,
  n,
  ne,
  r,
  re,
  s,
  s3 as s2,
  te,
  v,
  z
} from "./chunk-Z5QOEV22.js";
import "./chunk-VQUDNY75.js";
import "./chunk-2FPASXXN.js";
import {
  e,
  t,
  u
} from "./chunk-QDIJO3T2.js";
import "./chunk-UZM66DAH.js";
import "./chunk-CFTD44JM.js";
import "./chunk-MI7FJDLG.js";
import "./chunk-2LQUYG3Y.js";
import "./chunk-3ZOUEUIN.js";
import "./chunk-NOYFNECX.js";
import "./chunk-7HK5OJHH.js";
import "./chunk-OXCMSIKI.js";
import "./chunk-G3ZCYHOR.js";
import "./chunk-4ZMXDH56.js";
import "./chunk-EOI6A2XM.js";
import "./chunk-5W2WWLX7.js";
import "./chunk-CXHYHUY6.js";
import "./chunk-CXBJMCKT.js";
import "./chunk-ULOJUU6K.js";
import "./chunk-3CXPBSW5.js";
import "./chunk-UZTIVDTR.js";
import "./chunk-33RBBVRO.js";
import "./chunk-II3EAW7L.js";
import "./chunk-JU2WP2RZ.js";
import "./chunk-NI6ENKKR.js";
import "./chunk-6XDV3BWZ.js";
import "./chunk-W3UIP6CW.js";
import "./chunk-CHJGFW3N.js";
import "./chunk-IMKS3PQX.js";
import "./chunk-PEP3ZFMY.js";
import "./chunk-MQUNEV3K.js";
import "./chunk-WVICJPEU.js";
import "./chunk-TZBBKXOW.js";
import "./chunk-YMGINT43.js";
import "./chunk-2WLZX6A7.js";
import "./chunk-M7CMZTD6.js";
import "./chunk-ERJGVLTB.js";
import {
  f2 as f,
  p3 as p
} from "./chunk-T5VSOT6T.js";
import "./chunk-OHZM2VYI.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-E4M4B5ZQ.js";
import "./chunk-JATK7CEQ.js";
import "./chunk-74TXAD7S.js";
import "./chunk-HIRLBWV3.js";
import "./chunk-AFQAO5F4.js";
import "./chunk-OA5ES74L.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-RLEMMDH4.js";
import "./chunk-6ZUWLK7F.js";
import "./chunk-YVZY5LDV.js";
import "./chunk-H32MMKAJ.js";
import "./chunk-MKHZ5X6F.js";
import "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
function q2(e3) {
  return e3 && "function" == typeof e3.then;
}
var W = 100;
async function V2(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.arguments.length; r2++)
    n2.push(await J2(e3, t2.arguments[r2]));
  return n2;
}
async function _(e3, t2, n2) {
  if (true === t2.preparsed)
    return n2(e3, null, t2.arguments);
  return n2(e3, t2, await V2(e3, t2));
}
var Y2 = class extends r {
  constructor(e3, t2) {
    super(), this.definition = null, this.context = null, this.definition = e3, this.context = t2;
  }
  createFunction(e3) {
    return (...t2) => {
      const n2 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeReference: this.context.timeReference ? this.context.timeReference : null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e3.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n2.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, null);
      return Pe(this.definition, n2, t2, null);
    };
  }
  call(e3, t2) {
    return H(e3, t2, (n2, a, i) => {
      const l = { spatialReference: e3.spatialReference, services: e3.services, console: e3.console, libraryResolver: e3.libraryResolver, exports: e3.exports, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: {}, abortSignal: e3.abortSignal, globalScope: e3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 } };
      if (l.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, t2);
      return Pe(this.definition, l, i, t2);
    });
  }
  marshalledCall(e3, t2, n2, r2) {
    return r2(e3, t2, async (o2, a, i) => {
      const l = { spatialReference: e3.spatialReference, globalScope: n2.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, libraryResolver: e3.libraryResolver, exports: e3.exports, console: e3.console, abortSignal: e3.abortSignal, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: {} };
      return i = i.map((t3) => !C(t3) || t3 instanceof s ? t3 : n(t3, e3, r2)), n(await Pe(this.definition, l, i, t2), n2, r2);
    });
  }
};
var z2 = class extends s2 {
  constructor(e3) {
    super(e3);
  }
  async global(e3) {
    const t2 = this.executingContext.globalScope[e3.toLowerCase()];
    if (t2.valueset || (t2.value = await J2(this.executingContext, t2.node), t2.valueset = true), C(t2.value) && !(t2.value instanceof s)) {
      const e4 = new s();
      e4.fn = t2.value, e4.parameterEvaluator = H, e4.context = this.executingContext, t2.value = e4;
    }
    return t2.value;
  }
  setGlobal(e3, t2) {
    if (C(t2))
      throw new t(null, e.AssignModuleFunction, null);
    this.executingContext.globalScope[e3.toLowerCase()] = { value: t2, valueset: true, node: null };
  }
  hasGlobal(e3) {
    return void 0 === this.executingContext.exports[e3] && (e3 = e3.toLowerCase()), void 0 !== this.executingContext.exports[e3];
  }
  async loadModule(e3) {
    let n2 = e3.spatialReference;
    null == n2 && (n2 = new f({ wkid: 102100 })), this.moduleScope = Ge({}, e3.customfunctions, e3.timeReference), this.executingContext = { spatialReference: n2, services: e3.services, libraryResolver: new s3(e3.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e3.abortSignal || null === e3.abortSignal ? { aborted: false } : e3.abortSignal, globalScope: this.moduleScope, console: e3.console ? e3.console : Te, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: null, depthCounter: { depth: 1 } }, await J2(this.executingContext, this.source.syntax);
  }
};
async function H(e3, t2, n2) {
  if (true === t2.preparsed) {
    const r3 = n2(e3, null, t2.arguments);
    return q2(r3), r3;
  }
  const r2 = n2(e3, t2, await V2(e3, t2));
  return q2(r2), r2;
}
async function J2(e3, t2, n2) {
  if (t2.breakpoint && true !== n2) {
    const n3 = t2.breakpoint();
    return await n3, J2(e3, t2, true);
  }
  try {
    switch (t2 == null ? void 0 : t2.type) {
      case "VariableDeclarator":
        return await xe(e3, t2);
      case "ImportDeclaration":
        return await ve(e3, t2);
      case "ExportNamedDeclaration":
        return await be(e3, t2);
      case "VariableDeclaration":
        return await Se(e3, t2, 0);
      case "BlockStatement":
      case "Program":
        return await he(e3, t2);
      case "FunctionDeclaration":
        return await ye(e3, t2);
      case "ReturnStatement":
        return await ge(e3, t2);
      case "IfStatement":
        return await de(e3, t2);
      case "ExpressionStatement":
        return await we(e3, t2);
      case "UpdateExpression":
        return await ue(e3, t2);
      case "AssignmentExpression":
        return await pe(e3, t2);
      case "ForStatement":
        return await ne2(e3, t2);
      case "WhileStatement":
        return await Z3(e3, t2);
      case "ForInStatement":
        return await ce2(e3, t2);
      case "BreakStatement":
        return D;
      case "EmptyStatement":
        return R;
      case "ContinueStatement":
        return F;
      case "TemplateElement":
        return await Le(e3, t2);
      case "TemplateLiteral":
        return await Ne(e3, t2);
      case "Identifier":
        return await Me(e3, t2);
      case "MemberExpression":
        return await Re(e3, t2);
      case "Literal":
        return t2.value;
      case "CallExpression":
        return await je(e3, t2);
      case "UnaryExpression":
        return await Ie(e3, t2);
      case "BinaryExpression":
        return await Ce(e3, t2);
      case "LogicalExpression":
        return await Ae2(e3, t2);
      case "ArrayExpression":
        return await Fe(e3, t2);
      case "ObjectExpression":
        return await Q(e3, t2);
      case "Property":
        return await X(e3, t2);
      default:
        throw new t(e3, e.Unrecognised, t2);
    }
  } catch (i) {
    throw u(e3, t2, i);
  }
}
async function Q(e3, t2) {
  const a = [];
  for (let n2 = 0; n2 < t2.properties.length; n2++)
    a[n2] = await J2(e3, t2.properties[n2]);
  const i = {}, l = /* @__PURE__ */ new Map();
  for (let n2 = 0; n2 < a.length; n2++) {
    const s5 = a[n2];
    if (C(s5.value))
      throw new t(e3, e.NoFunctionInDictionary, t2);
    if (false === v(s5.key))
      throw new t(e3, e.KeyMustBeString, t2);
    let c = s5.key.toString();
    const u2 = c.toLowerCase();
    l.has(u2) ? c = l.get(u2) : l.set(u2, c), s5.value === R ? i[c] = null : i[c] = s5.value;
  }
  const s4 = new T(i);
  return s4.immutable = false, s4;
}
async function X(e3, t2) {
  const n2 = await J2(e3, t2.value);
  if ("Identifier" === t2.key.type)
    return { key: t2.key.name, value: n2 };
  return { key: await J2(e3, t2.key), value: n2 };
}
async function Z3(e3, t2) {
  const n2 = { testResult: true, lastAction: R };
  if (n2.testResult = await J2(e3, t2.test), false === n2.testResult)
    return R;
  if (true !== n2.testResult)
    throw new t(e3, e.BooleanConditionRequired, t2);
  for (; true === n2.testResult && (n2.lastAction = await J2(e3, t2.body), n2.lastAction !== D) && !(n2.lastAction instanceof A); )
    if (n2.testResult = await J2(e3, t2.test), true !== n2.testResult && false !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
  return n2.lastAction instanceof A ? n2.lastAction : R;
}
async function $(e3, t2, n2) {
  const r2 = await J2(e3, t2.body);
  return n2.lastAction = r2, n2.lastAction === D || n2.lastAction instanceof A ? (n2.testResult = false, n2) : null !== t2.update ? (await J2(e3, t2.update), n2) : n2;
}
async function ee(e3, t2, n2) {
  var _a;
  if (null !== t2.test) {
    const a = await J2(e3, t2.test);
    if (true === ((_a = e3.abortSignal) == null ? void 0 : _a.aborted))
      throw new t(e3, e.Cancelled, t2);
    if (n2.testResult = a, false === n2.testResult)
      return n2;
    if (true !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
    return $(e3, t2, n2);
  }
  return $(e3, t2, n2);
}
function te2(e3, t2, n2, r2, o2, a) {
  try {
    ee(e3, t2, n2).then(() => {
      try {
        true === n2.testResult ? ++a > W ? (a = 0, setTimeout(() => {
          te2(e3, t2, n2, r2, o2, a);
        }, 0)) : te2(e3, t2, n2, r2, o2, a) : n2.lastAction instanceof A ? r2(n2.lastAction) : r2(R);
      } catch (i) {
        o2(i);
      }
    }, (e4) => {
      o2(e4);
    });
  } catch (i) {
    o2(i);
  }
}
function ne2(e3, t2) {
  try {
    return null !== t2.init ? J2(e3, t2.init).then(() => new Promise((n2, r2) => {
      te2(e3, t2, { testResult: true, lastAction: R }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    })) : new Promise((n2, r2) => {
      te2(e3, t2, { testResult: true, lastAction: R }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    });
  } catch (n2) {
    return Promise.reject(n2);
  }
}
function re2(e3, t2, n2, r2, o2, a, i, l, s4, c) {
  try {
    if (r2 <= a)
      return void l(R);
    o2.value = "k" === i ? n2[a] : a, J2(e3, t2.body).then((u2) => {
      try {
        u2 instanceof A ? l(u2) : u2 === D ? l(R) : ++c > W ? (c = 0, setTimeout(() => {
          re2(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
        }, 0)) : re2(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
      } catch (f3) {
        s4(f3);
      }
    }, (e4) => {
      s4(e4);
    });
  } catch (u2) {
    s4(u2);
  }
}
function oe(e3, t2, n2, r2, o2, a, i, l, s4) {
  try {
    if (n2.length() <= o2)
      return void i(R);
    r2.value = "k" === a ? n2.get(o2) : o2, J2(e3, t2.body).then((c) => {
      c instanceof A ? i(c) : c === D ? i(R) : ++s4 > W ? (s4 = 0, setTimeout(() => {
        oe(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
      }, 0)) : oe(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
function ae(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(R);
    re2(e3, t2, n2, n2.length, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function ie(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(R);
    oe(e3, t2, n2, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function le2(e3, t2, n2, r2, o2) {
  try {
    ae(e3, t2, n2.keys(), r2, o2, "k");
  } catch (a) {
    r2.reject(a);
  }
}
function se(e3, t2, n2, r2, o2, a, l, s4) {
  try {
    e3.next().then((c) => {
      try {
        if (null === c)
          a(R);
        else {
          const u2 = g.createFromGraphicLikeObject(c.geometry, c.attributes, r2, t2.timeReference);
          u2._underlyingGraphic = c, o2.value = u2;
          J2(t2, n2.body).then((i) => {
            try {
              i === D ? a(R) : i instanceof A ? a(i) : ++s4 > W ? (s4 = 0, setTimeout(() => {
                se(e3, t2, n2, r2, o2, a, l, s4);
              }, 0)) : se(e3, t2, n2, r2, o2, a, l, s4);
            } catch (c2) {
              l(c2);
            }
          }, (e4) => {
            l(e4);
          });
        }
      } catch (u2) {
        l(u2);
      }
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
async function ce2(e3, t2) {
  return new Promise((a, i) => {
    J2(e3, t2.right).then((l) => {
      try {
        let s4 = null;
        s4 = "VariableDeclaration" === t2.left.type ? J2(e3, t2.left) : Promise.resolve(), s4.then(() => {
          try {
            let s5 = "";
            if ("VariableDeclaration" === t2.left.type) {
              const e4 = t2.left.declarations[0].id;
              "Identifier" === e4.type && (s5 = e4.name);
            } else
              "Identifier" === t2.left.type && (s5 = t2.left.name);
            if (!s5)
              throw new t(e3, e.InvalidIdentifier, t2);
            s5 = s5.toLowerCase();
            let c = null;
            if (null != e3.localScope && void 0 !== e3.localScope[s5] && (c = e3.localScope[s5]), null === c && void 0 !== e3.globalScope[s5] && (c = e3.globalScope[s5]), null === c)
              return void i(new t(e3, e.InvalidIdentifier, t2));
            J(l) || v(l) ? ae(e3, t2, l, { reject: i, resolve: a }, c) : V(l) ? ie(e3, t2, l, { reject: i, resolve: a }, c) : l instanceof T || z(l) ? le2(e3, t2, l, { reject: i, resolve: a }, c) : G(l) ? se(l.iterator(e3.abortSignal), e3, t2, l, c, (e4) => {
              a(e4);
            }, (e4) => {
              i(e4);
            }, 0) : ae(e3, t2, [], { reject: i, resolve: a }, c);
          } catch (s5) {
            i(s5);
          }
        }, i);
      } catch (s4) {
        i(s4);
      }
    }, i);
  });
}
async function ue(e3, t2) {
  const a = t2.argument;
  if ("MemberExpression" === a.type) {
    const i2 = { t: null }, l2 = await J2(e3, a.object);
    let s4 = null;
    i2.t = l2, true === a.computed ? s4 = await J2(e3, a.property) : "Identifier" === a.property.type && (s4 = a.property.name);
    const c = i2.t;
    let u2;
    if (J(c)) {
      if (!Y(s4))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (s4 < 0 && (s4 = c.length + s4), s4 < 0 || s4 >= c.length)
        throw new t(e3, e.OutOfBounds, t2);
      u2 = le(c[s4]), c[s4] = "++" === t2.operator ? u2 + 1 : u2 - 1;
    } else if (c instanceof T) {
      if (false === v(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = le(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else if (c instanceof z2) {
      if (false === v(s4))
        throw new t(e3, e.ModuleAccessorMustBeString, t2);
      if (true !== c.hasGlobal(s4))
        throw new t(e3, e.ModuleExportNotFound, t2);
      u2 = le(await c.global(s4)), c.setGlobal(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else {
      if (!z(c))
        throw V(c) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === v(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = le(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    }
    return false === t2.prefix ? u2 : "++" === t2.operator ? u2 + 1 : u2 - 1;
  }
  const i = "Identifier" === t2.argument.type ? t2.argument.name.toLowerCase() : "";
  if (!i)
    throw new t(e3, e.InvalidIdentifier, t2);
  let l;
  if (null != e3.localScope && void 0 !== e3.localScope[i])
    return l = le(e3.localScope[i].value), e3.localScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  if (void 0 !== e3.globalScope[i])
    return l = le(e3.globalScope[i].value), e3.globalScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  throw new t(e3, e.InvalidIdentifier, t2);
}
function fe(e3, t2, n2, a, i) {
  switch (t2) {
    case "=":
      return e3 === R ? null : e3;
    case "/=":
      return le(n2) / le(e3);
    case "*=":
      return le(n2) * le(e3);
    case "-=":
      return le(n2) - le(e3);
    case "+=":
      return v(n2) || v(e3) ? re(n2) + re(e3) : le(n2) + le(e3);
    case "%=":
      return le(n2) % le(e3);
    default:
      throw new t(i, e.UnsupportedOperator, a);
  }
}
async function pe(e3, t2) {
  const a = t2.left;
  if ("MemberExpression" === a.type) {
    const i2 = await J2(e3, a.object);
    let l = null;
    if (true === a.computed)
      l = await J2(e3, a.property);
    else {
      if ("Identifier" !== a.property.type)
        throw new t(e3, e.InvalidIdentifier, t2);
      l = a.property.name;
    }
    const s4 = await J2(e3, t2.right);
    if (J(i2)) {
      if (!Y(l))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (l < 0 && (l = i2.length + l), l < 0 || l > i2.length)
        throw new t(e3, e.OutOfBounds, t2);
      if (l === i2.length) {
        if ("=" !== t2.operator)
          throw new t(e3, e.OutOfBounds, t2);
        i2[l] = fe(s4, t2.operator, i2[l], t2, e3);
      } else
        i2[l] = fe(s4, t2.operator, i2[l], t2, e3);
    } else if (i2 instanceof T) {
      if (false === v(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === i2.hasField(l))
        i2.setField(l, fe(s4, t2.operator, i2.field(l), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: l });
        i2.setField(l, fe(s4, t2.operator, null, t2, e3));
      }
    } else if (i2 instanceof z2) {
      if (false === v(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== i2.hasGlobal(l))
        throw new t(e3, e.ModuleExportNotFound, t2);
      i2.setGlobal(l, fe(s4, t2.operator, await i2.global(l), t2, e3));
    } else {
      if (!z(i2))
        throw V(i2) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === v(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === i2.hasField(l))
        i2.setField(l, fe(s4, t2.operator, i2.field(l), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: l });
        i2.setField(l, fe(s4, t2.operator, null, t2, e3));
      }
    }
    return R;
  }
  const i = a.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[i]) {
    const n2 = await J2(e3, t2.right);
    return e3.localScope[i] = { value: fe(n2, t2.operator, e3.localScope[i].value, t2, e3), valueset: true, node: t2.right }, R;
  }
  if (void 0 !== e3.globalScope[i]) {
    const n2 = await J2(e3, t2.right);
    return e3.globalScope[i] = { value: fe(n2, t2.operator, e3.globalScope[i].value, t2, e3), valueset: true, node: t2.right }, R;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function we(e3, t2) {
  if ("AssignmentExpression" === t2.expression.type)
    return J2(e3, t2.expression);
  if ("CallExpression" === t2.expression.type) {
    const n3 = await J2(e3, t2.expression);
    return n3 === R ? R : new j(n3);
  }
  const n2 = await J2(e3, t2.expression);
  return n2 === R ? R : new j(n2);
}
async function de(e3, t2) {
  const n2 = await J2(e3, t2.test);
  if (true === n2)
    return J2(e3, t2.consequent);
  if (false === n2)
    return null !== t2.alternate ? J2(e3, t2.alternate) : R;
  throw new t(e3, e.BooleanConditionRequired, t2);
}
async function he(e3, t2) {
  return me(e3, t2, 0);
}
async function me(e3, t2, n2) {
  if (n2 >= t2.body.length)
    return R;
  const r2 = await J2(e3, t2.body[n2]);
  return r2 instanceof A || r2 === D || r2 === F || n2 === t2.body.length - 1 ? r2 : me(e3, t2, n2 + 1);
}
async function ge(e3, t2) {
  if (null === t2.argument)
    return new A(R);
  const n2 = await J2(e3, t2.argument);
  return new A(n2);
}
async function ye(e3, t2) {
  const n2 = t2.id.name.toLowerCase();
  return e3.globalScope[n2] = { valueset: true, node: null, value: new Y2(t2, e3) }, R;
}
async function ve(e3, t2) {
  var _a, _b;
  const n2 = t2.specifiers[0].local.name.toLowerCase(), r2 = e3.libraryResolver.loadLibrary(n2);
  let o2 = null;
  return ((_a = e3.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(r2.uri)) ? o2 = e3.libraryResolver._moduleSingletons.get(r2.uri) : (o2 = new z2(r2), await o2.loadModule(e3), (_b = e3.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(r2.uri, o2)), e3.globalScope[n2] = { value: o2, valueset: true, node: t2 }, R;
}
async function be(e3, t2) {
  if (await J2(e3, t2.declaration), "FunctionDeclaration" === t2.declaration.type)
    e3.exports[t2.declaration.id.name.toLowerCase()] = "function";
  else if ("VariableDeclaration" === t2.declaration.type)
    for (const n2 of t2.declaration.declarations)
      e3.exports[n2.id.name.toLowerCase()] = "variable";
  return R;
}
async function Se(e3, t2, n2) {
  return n2 >= t2.declarations.length ? R : (await J2(e3, t2.declarations[n2]), n2 === t2.declarations.length - 1 || await Se(e3, t2, n2 + 1), R);
}
async function xe(e3, t2) {
  let n2 = null;
  if (n2 = null === t2.init ? null : await J2(e3, t2.init), null !== e3.localScope) {
    if (n2 === R && (n2 = null), "Identifier" !== t2.id.type)
      throw new t(e3, e.InvalidIdentifier, t2);
    const a2 = t2.id.name.toLowerCase();
    return null != e3.localScope && (e3.localScope[a2] = { value: n2, valueset: true, node: t2.init }), R;
  }
  if ("Identifier" !== t2.id.type)
    throw new t(e3, e.InvalidIdentifier, t2);
  const a = t2.id.name.toLowerCase();
  return n2 === R && (n2 = null), e3.globalScope[a] = { value: n2, valueset: true, node: t2.init }, R;
}
async function Re(e3, t2) {
  const a = await J2(e3, t2.object);
  if (null === a)
    throw new t(e3, e.MemberOfNull, t2);
  if (false === t2.computed) {
    if ("Identifier" === t2.property.type) {
      if (a instanceof T || z(a))
        return a.field(t2.property.name);
      if (a instanceof p)
        return q(a, t2.property.name, e3, t2);
      if (a instanceof z2) {
        if (!a.hasGlobal(t2.property.name))
          throw new t(e3, e.InvalidIdentifier, t2);
        return a.global(t2.property.name);
      }
      throw new t(e3, e.InvalidMemberAccessKey, t2);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  let i = await J2(e3, t2.property);
  if (a instanceof T || z(a)) {
    if (v(i))
      return a.field(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof z2) {
    if (v(i))
      return a.global(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof p) {
    if (v(i))
      return q(a, i, e3, t2);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (J(a)) {
    if (Y(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (V(a)) {
    if (Y(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length() + i), i >= a.length() || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a.get(i);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (v(a)) {
    if (Y(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  throw new t(e3, e.InvalidMemberAccessKey, t2);
}
async function Ie(e3, t2) {
  const n2 = await J2(e3, t2.argument);
  if (L(n2)) {
    if ("!" === t2.operator)
      return !n2;
    if ("-" === t2.operator)
      return -1 * le(n2);
    if ("+" === t2.operator)
      return 1 * le(n2);
    if ("~" === t2.operator)
      return ~le(n2);
    throw new t(e3, e.UnsupportedUnaryOperator, t2);
  }
  if ("-" === t2.operator)
    return -1 * le(n2);
  if ("+" === t2.operator)
    return 1 * le(n2);
  if ("~" === t2.operator)
    return ~le(n2);
  throw new t(e3, e.UnsupportedUnaryOperator, t2);
}
async function Fe(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.elements.length; r2++)
    n2.push(await J2(e3, t2.elements[r2]));
  for (let a = 0; a < n2.length; a++) {
    if (C(n2[a]))
      throw new t(e3, e.NoFunctionInArray, t2);
    n2[a] === R && (n2[a] = null);
  }
  return n2;
}
async function Ce(e3, t2) {
  const n2 = [];
  n2[0] = await J2(e3, t2.left), n2[1] = await J2(e3, t2.right);
  const a = n2[0], i = n2[1];
  switch (t2.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ae(le(a), le(i), t2.operator);
    case "==":
      return te(a, i);
    case "!=":
      return !te(a, i);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return ne(a, i, t2.operator);
    case "+":
      return v(a) || v(i) ? re(a) + re(i) : le(a) + le(i);
    case "-":
      return le(a) - le(i);
    case "*":
      return le(a) * le(i);
    case "/":
      return le(a) / le(i);
    case "%":
      return le(a) % le(i);
    default:
      throw new t(e3, e.UnsupportedOperator, t2);
  }
}
async function Ae2(e3, t2) {
  const n2 = await J2(e3, t2.left);
  let a = null;
  if (!L(n2))
    throw new t(e3, e.LogicalExpressionOnlyBoolean, t2);
  switch (t2.operator) {
    case "||":
      if (true === n2)
        return n2;
      if (a = await J2(e3, t2.right), L(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    case "&&":
      if (false === n2)
        return n2;
      if (a = await J2(e3, t2.right), L(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    default:
      throw new t(e3, e.LogicExpressionOrAnd, t2);
  }
}
async function Me(e3, t2) {
  const n2 = t2.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[n2]) {
    const t3 = e3.localScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J2(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  if (void 0 !== e3.globalScope[n2]) {
    const t3 = e3.globalScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J2(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function je(e3, t2) {
  if ("MemberExpression" === t2.callee.type) {
    const n2 = await J2(e3, t2.callee.object);
    if (!(n2 instanceof z2))
      throw new t(e3, e.FuncionNotFound, t2);
    const a = false === t2.callee.computed ? t2.callee.property.name : await J2(e3, t2.callee.property);
    if (!n2.hasGlobal(a))
      throw new t(e3, e.FuncionNotFound, t2);
    const i = await n2.global(a);
    if (!C(i))
      throw new t(e3, e.CallNonFunction, t2);
    return i.call(e3, t2);
  }
  if ("Identifier" !== t2.callee.type)
    throw new t(e3, e.FuncionNotFound, t2);
  if (null != e3.localScope && void 0 !== e3.localScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.localScope[t2.callee.name.toLowerCase()];
    if (C(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  if (void 0 !== e3.globalScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.globalScope[t2.callee.name.toLowerCase()];
    if (C(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  throw new t(e3, e.FuncionNotFound, t2);
}
async function Le(e3, t2) {
  return t2.value ? t2.value.cooked : "";
}
function ke(e3, t2, n2) {
  if (C(e3))
    throw new t(t2, e.NoFunctionInTemplateLiteral, n2);
  return e3;
}
async function Ne(e3, t2) {
  const n2 = [];
  for (let a = 0; a < t2.expressions.length; a++) {
    const r3 = await J2(e3, t2.expressions[a]);
    n2[a] = re(r3);
  }
  let r2 = "", o2 = 0;
  for (const a of t2.quasis)
    if (r2 += a.value ? a.value.cooked : "", false === a.tail) {
      r2 += n2[o2] ? ke(n2[o2], e3, t2) : "", o2++;
    }
  return r2;
}
var Oe = {};
async function Ee(e3, t2, n2, r2) {
  const o2 = await J2(e3, t2.arguments[n2]);
  if (te(o2, r2))
    return J2(e3, t2.arguments[n2 + 1]);
  const a = t2.arguments.length - n2;
  return 1 === a ? J2(e3, t2.arguments[n2]) : 2 === a ? null : 3 === a ? J2(e3, t2.arguments[n2 + 2]) : Ee(e3, t2, n2 + 2, r2);
}
async function Be(e3, t2, n2, a) {
  if (true === a)
    return J2(e3, t2.arguments[n2 + 1]);
  if (3 === t2.arguments.length - n2)
    return J2(e3, t2.arguments[n2 + 2]);
  const i = await J2(e3, t2.arguments[n2 + 2]);
  if (false === L(i))
    throw new t(e3, e.ModuleExportNotFound, t2.arguments[n2 + 2]);
  return Be(e3, t2, n2 + 2, i);
}
async function Pe(e3, t2, n2, a) {
  const i = e3.body;
  if (n2.length !== e3.params.length)
    throw new t(t2, e.WrongNumberOfParameters, null);
  for (let r2 = 0; r2 < n2.length; r2++) {
    const o2 = e3.params[r2];
    "Identifier" === o2.type && null != t2.localScope && (t2.localScope[o2.name.toLowerCase()] = { d: null, value: n2[r2], valueset: true, node: null });
  }
  const l = await J2(t2, i);
  if (l instanceof A)
    return l.value;
  if (l === D)
    throw new t(t2, e.UnexpectedToken, a);
  if (l === F)
    throw new t(t2, e.UnexpectedToken, a);
  return l instanceof j ? l.value : l;
}
T2(Oe, _), Z2(Oe, _), N(Oe, _), Z(Oe, _), f2(Oe, _), pn({ functions: Oe, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: _, standardFunctionAsync: H }), Oe.iif = async function(e3, t2) {
  B(null === t2.arguments ? [] : t2.arguments, 3, 3, e3, t2);
  const n2 = await J2(e3, t2.arguments[0]);
  if (false === L(n2))
    throw new t(e3, e.BooleanConditionRequired, t2);
  return J2(e3, n2 ? t2.arguments[1] : t2.arguments[2]);
}, Oe.decode = async function(e3, t2) {
  if (t2.arguments.length < 2)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (2 === t2.arguments.length)
    return J2(e3, t2.arguments[1]);
  if ((t2.arguments.length - 1) % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  return Ee(e3, t2, 1, await J2(e3, t2.arguments[0]));
}, Oe.when = async function(e3, t2) {
  if (t2.arguments.length < 3)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (t2.arguments.length % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  const n2 = await J2(e3, t2.arguments[0]);
  if (false === L(n2))
    throw new t(e3, e.BooleanConditionRequired, t2.arguments[0]);
  return Be(e3, t2, 0, n2);
};
var Ke = { fixSpatialReference: ce, parseArguments: V2, standardFunction: _, standardFunctionAsync: H, evaluateIdentifier: Me };
for (const Ve in Oe)
  Oe[Ve] = { value: new e2(Oe[Ve]), valueset: true, node: null };
var De = function() {
};
function Ge(e3, t2, r2) {
  const o2 = new De();
  null == e3 && (e3 = {}), null == t2 && (t2 = {});
  const a = new T({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a.immutable = false, o2.textformatting = { value: a, valueset: true, node: null };
  for (const n2 in t2)
    o2[n2] = { value: new e2(t2[n2]), native: true, valueset: true, node: null };
  for (const n2 in e3)
    e3[n2] && "esri.Graphic" === e3[n2].declaredClass ? o2[n2] = { value: g.createFromGraphic(e3[n2], r2), valueset: true, node: null } : o2[n2] = { value: e3[n2], valueset: true, node: null };
  return o2;
}
function Te(e3) {
  console.log(e3);
}
De.prototype = Oe, De.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, De.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Ue = Ke;
function qe(e3) {
  const t2 = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: _, standardFunctionAsync: H, evaluateIdentifier: Me };
  for (let n2 = 0; n2 < e3.length; n2++)
    e3[n2].registerFunctions(t2);
  for (const n2 in t2.functions)
    Oe[n2] = { value: new e2(t2.functions[n2]), valueset: true, node: null }, De.prototype[n2] = Oe[n2];
  for (let n2 = 0; n2 < t2.signatures.length; n2++)
    o(t2.signatures[n2], "async");
}
async function We(e3, n2) {
  let a = n2.spatialReference;
  null == a && (a = new f({ wkid: 102100 }));
  let i = null;
  e3.usesModules && (i = new s3(/* @__PURE__ */ new Map(), e3.loadedModules));
  const l = Ge(n2.vars, n2.customfunctions, n2.timeReference), s4 = { spatialReference: a, services: n2.services, exports: {}, libraryResolver: i, abortSignal: void 0 === n2.abortSignal || null === n2.abortSignal ? { aborted: false } : n2.abortSignal, globalScope: l, console: n2.console ? n2.console : Te, timeReference: n2.timeReference ?? null, lrucache: n2.lrucache, interceptor: n2.interceptor, localScope: null, depthCounter: { depth: 1 } };
  let c = await J2(s4, e3);
  if (c instanceof A && (c = c.value), c instanceof j && (c = c.value), c === R && (c = null), c === D)
    throw new t(s4, e.IllegalResult, null);
  if (c === F)
    throw new t(s4, e.IllegalResult, null);
  if (C(c))
    throw new t(s4, e.IllegalResult, null);
  return c;
}
qe([m]);
export {
  We as executeScript,
  qe as extend,
  Ue as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-FHCOL37S.js.map

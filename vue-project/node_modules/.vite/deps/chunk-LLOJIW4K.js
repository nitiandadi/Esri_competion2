import {
  i as i7,
  n as n4
} from "./chunk-QX7RONCE.js";
import {
  c as c2
} from "./chunk-AZEN5UFW.js";
import {
  S as S2,
  a as a3,
  f as f5,
  g,
  i as i2,
  i2 as i6,
  pe2 as pe
} from "./chunk-5BAT5OP4.js";
import {
  c as c3,
  i as i4,
  r as r4
} from "./chunk-B3A3THPO.js";
import {
  C,
  N,
  O,
  P,
  U,
  Z,
  b,
  f as f4,
  w as w2
} from "./chunk-R3MRUDAD.js";
import {
  a as a2,
  c,
  i as i5,
  n as n2,
  o as o6,
  r as r5,
  s as s4
} from "./chunk-R6XKQWZ7.js";
import {
  f as f2,
  p as p2
} from "./chunk-223SE4BY.js";
import {
  G,
  R,
  k as k2,
  o as o7,
  u as u2
} from "./chunk-63WRUMNA.js";
import {
  w,
  x
} from "./chunk-O2JKCGK6.js";
import {
  E,
  S
} from "./chunk-WAPZ634R.js";
import {
  e as e6,
  t as t3
} from "./chunk-MSPZCZRZ.js";
import {
  e as e4,
  i as i3,
  o as o5
} from "./chunk-RURSJOSG.js";
import {
  o as o4
} from "./chunk-TFWV44LH.js";
import {
  X,
  at,
  ct as ct2,
  et,
  f,
  ft,
  gt,
  ht,
  i,
  j as j2,
  k,
  lt,
  mt,
  nt,
  o as o3,
  pt,
  rt,
  st,
  vt,
  wt
} from "./chunk-RRNRSHX3.js";
import {
  n
} from "./chunk-NWZTRS6O.js";
import {
  e as e5,
  f as f3,
  h
} from "./chunk-77E52HT5.js";
import {
  e as e3
} from "./chunk-34FJTA26.js";
import {
  n as n3,
  t as t4
} from "./chunk-DUEDINK5.js";
import {
  t as t5
} from "./chunk-UTGANG7C.js";
import {
  r as r3,
  z
} from "./chunk-JGIZLXNQ.js";
import {
  Pt,
  ct
} from "./chunk-XXDTEEJA.js";
import {
  t as t2
} from "./chunk-U6GC73UT.js";
import {
  r as r2,
  s as s3,
  y
} from "./chunk-2CREJO6O.js";
import {
  e as e2
} from "./chunk-YEBACBC7.js";
import {
  o as o2,
  u
} from "./chunk-BQXNXAP2.js";
import {
  a
} from "./chunk-JT54I3AY.js";
import {
  o as o8
} from "./chunk-CT6YILLI.js";
import {
  D,
  j,
  p
} from "./chunk-WTKFW2TD.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  e,
  l,
  o,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i8 = /* @__PURE__ */ new Map();
function t6(r14, t10, c10) {
  const { indicesPerRecord: s7, multiplier: o13, verticesPerRecord: d7 } = i8.get(r14);
  return { recordBytes: c10 * ct2 * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o13 * s7 * c10 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o13 * d7 * c10 * t10 };
}
i8.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i8.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i8.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t7 = 1.25;
var e7 = class {
  get length() {
    return this._pos;
  }
  constructor(t10, e12) {
    this._pos = 0;
    const r14 = e12 ? this._roundToNearest(e12, t10.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r14), this._buffer = new t10(this._array), this._ctor = t10, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t10, e12) {
    const r14 = Math.round(t10);
    return r14 + (e12 - r14 % e12);
  }
  _ensureSize(e12) {
    if (this._pos + e12 >= this._buffer.length) {
      const r14 = this._roundToNearest((this._array.byteLength + e12 * this._buffer.BYTES_PER_ELEMENT) * t7, this._buffer.BYTES_PER_ELEMENT), s7 = new ArrayBuffer(r14), i12 = new this._ctor(s7);
      i12.set(this._buffer, 0), this._array = s7, this._buffer = i12, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t10) {
    this._ensureSize(t10);
  }
  writeF32(t10) {
    this._ensureSize(1);
    const e12 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t10, this._pos++, e12;
  }
  push(t10) {
    this._ensureSize(1);
    const e12 = this._pos;
    return this._buffer[this._pos++] = t10, e12;
  }
  writeFixed(t10) {
    this._buffer[this._pos++] = t10;
  }
  setValue(t10, e12) {
    this._buffer[t10] = e12;
  }
  i1616Add(t10, e12, r14) {
    this._i16View[2 * t10] += e12, this._i16View[2 * t10 + 1] += r14;
  }
  getValue(t10) {
    return this._buffer[t10];
  }
  incr(t10) {
    if (this._buffer.length < t10)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t10]++;
  }
  decr(t10) {
    this._buffer[t10]--;
  }
  writeRegion(t10) {
    this._ensureSize(t10.length);
    const e12 = this._pos;
    return this._buffer.set(t10, this._pos), this._pos += t10.length, e12;
  }
  writeManyFrom(t10, e12, r14) {
    this._ensureSize(r14 - e12);
    for (let s7 = e12; s7 !== r14; s7++)
      this.writeFixed(t10._buffer[s7]);
  }
  buffer() {
    const t10 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t10;
  }
  toArray() {
    const t10 = this._array, e12 = [];
    for (let r14 = 0; r14 < t10.byteLength / 4; r14++)
      e12.push(t10[r14]);
    return e12;
  }
  seek(t10) {
    this._pos = t10;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r6 = class {
  constructor(e12, r14, i12) {
    this._start = { index: 0, vertex: 0 };
    const h6 = t6(e12, r14, i12), c10 = r14 / 4;
    this.geometryType = e12, this._records = new e7(Int32Array, h6.recordBytes), this._indices = new e7(Uint32Array, h6.indexBytes), this._vertices = new e7(Uint32Array, h6.vertexBytes), this._metrics = new e7(Float32Array, 0), this._strideInt = c10;
  }
  serialize(e12) {
    const t10 = this._records.buffer(), s7 = this._indices.buffer(), r14 = this._vertices.buffer(), i12 = this._metrics.length ? this._metrics.buffer() : null, h6 = 4 * this._strideInt;
    return e12.push(t10, s7, r14), { stride: h6, records: t10, indices: s7, vertices: r14, metrics: i12 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / ct2;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e12) {
    this._vertices.ensureSize(e12);
  }
  indexEnsureSize(e12) {
    this._indices.ensureSize(e12);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e12, t10, s7, r14, i12, h6, c10, n9) {
    this._records.push(e12), this._records.push(t10 ?? 0), this._records.push(s7), this._records.push(r14), this._records.push(i12), this._records.push(h6), this._records.push(c10), this._records.writeF32(n9);
  }
  writeIndex(e12) {
    this._indices.push(e12);
  }
  writeVertex(e12) {
    this._vertices.push(e12);
  }
  writeVertexF32(e12) {
    this._vertices.writeF32(e12);
  }
  copyLastFrom(t10, s7, r14) {
    const i12 = t10._records.length - ct2, h6 = t10._records.getValue(i12), c10 = t10._records.getValue(i12 + 1), n9 = t10._records.getValue(i12 + 2), _4 = t10._records.getValue(i12 + 4), d7 = t10._records.getValue(i12 + 6), o13 = t10._records.getValue(i12 + 7), u13 = this._vertices.length, l6 = (t10._start.vertex - this._vertices.length) / this._strideInt, g12 = this._indices.length, p9 = this.vertexCount;
    for (let e12 = t10._start.index; e12 !== t10._indices.length; e12++) {
      const s8 = t10._indices.getValue(e12);
      this._indices.push(s8 - l6);
    }
    for (let e12 = t10._start.vertex; e12 !== t10._vertices.length; e12++) {
      const s8 = t10._vertices.getValue(e12);
      this._vertices.push(s8);
    }
    for (let e12 = u13; e12 <= this._vertices.length; e12 += this._strideInt)
      this._vertices.i1616Add(e12, s7, r14);
    this._records.push(h6), this._records.push(c10), this._records.push(n9), this._records.push(g12), this._records.push(_4), this._records.push(p9), this._records.push(d7), this._records.push(o13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u3 = 1;
var c4 = 2;
var o9 = 4;
var _ = 8;
var l2 = 16;
var d = 32;
var g2 = 64;
var p3 = 128;
function x2(e12) {
  switch (e12) {
    case u3:
    case _:
    case d:
      return -1;
    case c4:
    case g2:
      return 0;
    case o9:
    case l2:
    case p3:
      return 1;
  }
}
function m(e12) {
  switch (e12) {
    case u3:
    case c4:
    case o9:
      return -1;
    case _:
    case l2:
      return 0;
    case d:
    case g2:
    case p3:
      return 1;
  }
}
var f6 = u3 | _ | d;
var y2 = o9 | l2 | p3;
var w3 = u3 | c4 | o9;
var v = d | g2 | p3;
var E2 = class {
  constructor(e12, t10, r14, i12, s7, n9 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t10, this.tileKey = e12, this._hasAggregate = i12, this._pixelBufferEnabled = s7, this._version = n9, this._symbologyType = r14;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t10) {
    const r14 = [];
    return r14.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i12, s7) => {
      const n9 = 1 << s7, a7 = x2(n9), u13 = m(n9), c10 = o4(new e3(this.tileKey), a7, u13, t10), o13 = this._serializeTileVertexData(this.tileKey, c10.id, i12.vertexData);
      o13.message.bufferIds = i12.displayIds, r14.push(o13);
    }), r14;
  }
  _serializeTileVertexData(e12, t10, r14) {
    var _a, _b, _c, _d, _e;
    const i12 = new Array();
    return { message: { tileKeyOrigin: e12, tileKey: t10, data: { [E.MARKER]: (_a = r14.get(E.MARKER)) == null ? void 0 : _a.serialize(i12), [E.FILL]: (_b = r14.get(E.FILL)) == null ? void 0 : _b.serialize(i12), [E.LINE]: (_c = r14.get(E.LINE)) == null ? void 0 : _c.serialize(i12), [E.TEXT]: (_d = r14.get(E.TEXT)) == null ? void 0 : _d.serialize(i12), [E.LABEL]: (_e = r14.get(E.LABEL)) == null ? void 0 : _e.serialize(i12) }, version: this._version }, transferList: i12 };
  }
  featureStart(e12, t10) {
    this._current.insertAfter = e12, this._current.sortKey = t10;
  }
  featureEnd() {
  }
  recordStart(e12, t10, r14, i12) {
    this._current.writer = this._getVertexWriter(r14), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i12, this._current.id = e12, this._current.materialKey = t10, this._current.geometryType = r14, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e12) {
    this._current.writer.vertexEnsureSize(e12);
  }
  indexEnsureSize(e12) {
    this._current.writer.indexEnsureSize(e12);
  }
  vertexBounds(e12, t10, r14, i12) {
    this._current.bufferingEnabled && this._addOverlap(e12, t10, r14, i12);
  }
  vertexWrite(e12) {
    this._current.writer.writeVertex(e12);
  }
  vertexWriteF32(e12) {
    this._current.writer.writeVertexF32(e12);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e12) {
    this._current.writer.writeIndex(e12);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e12, t10, r14, n9, a7, h6, u13, c10) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o13 = this._current.writer.metricWriter;
    o13.push(f2(e12)), o13.push(t10), o13.push(r14), o13.push(n9), o13.push(a7), o13.push(h6), o13.push(u13), o13.push(c10), o13.push(255), this._current.metricBoxLenPointer = o13.push(0);
  }
  metricEnd() {
    const e12 = this._current.writer.metricWriter;
    0 === e12.getValue(this._current.metricBoxLenPointer) && e12.seek(e12.length - 10);
  }
  metricBoxWrite(e12, t10, r14, i12) {
    const s7 = this._current.writer.metricWriter;
    s7.incr(this._current.metricBoxLenPointer), s7.push(0), s7.push(0), s7.push(e12), s7.push(t10), s7.push(r14), s7.push(i12);
  }
  recordEnd() {
    const e12 = this._current.vertStart, r14 = this._current.writer.vertexCount - e12;
    if (!r14)
      return false;
    this.hasRecords = true;
    const i12 = this._current.indexStart, h6 = this._current.writer.indexCount - i12;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i12, h6, e12, r14, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u13 = this._current.writer;
    for (let s7 = 0; s7 < 8; s7++) {
      const e13 = 1 << s7;
      if (!!(this._current.overlaps & e13)) {
        this._data.neighbors[s7] || (this._data.neighbors[s7] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r15 = this._data.neighbors[s7], i13 = this._current.geometryType;
        if (!r15.vertexData.has(i13)) {
          const e14 = R(i13, this._symbologyType).geometry, s8 = new r6(i13, e14, ht);
          r15.vertexData.set(i13, s8);
        }
        const h7 = r15.vertexData.get(this._current.geometryType), c10 = 8, o13 = 512 * -x2(e13) * c10, _4 = 512 * -m(e13) * c10;
        h7 == null ? void 0 : h7.copyLastFrom(u13, o13, _4), r15.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e12, t10, i12, s7) {
    const n9 = 255 ^ ((e12 < 0 + i12 ? y2 : e12 >= o3 - i12 ? f6 : y2 | f6) | (t10 < 0 + s7 ? v : t10 >= o3 - s7 ? w3 : v | w3));
    this._current.overlaps |= n9;
  }
  _getVertexWriter(e12) {
    if (!this._data.self.has(e12)) {
      const t10 = this._data.self, r14 = R(e12, this._symbologyType).geometry;
      t10.set(e12, new r6(e12, r14, this.hint.records));
    }
    return this._data.self.get(e12);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function n5(n9) {
  if (null == n9)
    return [];
  const r14 = new Array(n9.length);
  for (let t10 = 0; t10 < n9.length; t10++)
    r14[t10] = n9.charCodeAt(t10);
  return r14;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n6 = 0;
var o10 = 100;
function t8(n9, o13, t10) {
  return n9[0] = o13[0] - t10[0], n9[1] = o13[1] - t10[1], n9;
}
function i9(n9, o13) {
  return Math.sqrt(n9 * n9 + o13 * o13);
}
function r7(n9) {
  const o13 = i9(n9[0], n9[1]);
  n9[0] /= o13, n9[1] /= o13;
}
function u4(n9, o13) {
  return i9(n9[0] - o13[0], n9[1] - o13[1]);
}
function c5(n9) {
  return "function" == typeof n9;
}
function e8(n9 = 2) {
  return 1 / Math.max(n9, 1);
}
function x3(t10, i12) {
  return [!!(t10 == null ? void 0 : t10.minScale) && i12.scaleToZoom(t10.minScale) || n6, !!(t10 == null ? void 0 : t10.maxScale) && i12.scaleToZoom(t10.maxScale) || o10];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e9(e12, t10, r14, i12, u13, o13, l6) {
  D2 = 0;
  const f13 = (i12 - r14) * o13, p9 = u13 && u13.length, c10 = p9 ? (u13[0] - r14) * o13 : f13;
  let v6, s7, h6, d7, Z4, a7 = n7(t10, r14, i12, 0, c10, o13, true);
  if (a7 && a7.next !== a7.prev) {
    if (p9 && (a7 = y3(t10, r14, i12, u13, a7, o13)), f13 > 80 * o13) {
      v6 = h6 = t10[0 + r14 * o13], s7 = d7 = t10[1 + r14 * o13];
      for (let e13 = o13; e13 < c10; e13 += o13) {
        const n9 = t10[e13 + r14 * o13], x8 = t10[e13 + 1 + r14 * o13];
        v6 = Math.min(v6, n9), s7 = Math.min(s7, x8), h6 = Math.max(h6, n9), d7 = Math.max(d7, x8);
      }
      Z4 = Math.max(h6 - v6, d7 - s7), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x4(a7, e12, o13, v6, s7, Z4, l6, 0);
  }
}
function n7(e12, n9, t10, x8, r14, i12, l6) {
  let y8;
  if (l6 === Z2(e12, n9, t10, x8, r14, i12) > 0)
    for (let o13 = x8; o13 < r14; o13 += i12)
      y8 = u5(o13 + n9 * i12, e12[o13 + n9 * i12], e12[o13 + 1 + n9 * i12], y8);
  else
    for (let o13 = r14 - i12; o13 >= x8; o13 -= i12)
      y8 = u5(o13 + n9 * i12, e12[o13 + n9 * i12], e12[o13 + 1 + n9 * i12], y8);
  return y8 && M(y8, y8.next) && (o11(y8), y8 = y8.next), y8;
}
function t9(e12, n9 = e12) {
  if (!e12)
    return e12;
  let t10, x8 = e12;
  do {
    if (t10 = false, x8.steiner || !M(x8, x8.next) && 0 !== s5(x8.prev, x8, x8.next))
      x8 = x8.next;
    else {
      if (o11(x8), x8 = n9 = x8.prev, x8 === x8.next)
        break;
      t10 = true;
    }
  } while (t10 || x8 !== n9);
  return n9;
}
function x4(e12, n9, u13, l6, y8, f13, p9, v6) {
  if (!e12)
    return;
  !v6 && f13 && (e12 = c6(e12, l6, y8, f13));
  let s7 = e12;
  for (; e12.prev !== e12.next; ) {
    const c10 = e12.prev, h6 = e12.next;
    if (f13 ? i10(e12, l6, y8, f13) : r8(e12))
      n9.push(c10.index / u13 + p9), n9.push(e12.index / u13 + p9), n9.push(h6.index / u13 + p9), o11(e12), e12 = h6.next, s7 = h6.next;
    else if ((e12 = h6) === s7) {
      v6 ? 1 === v6 ? x4(e12 = b2(e12, n9, u13, p9), n9, u13, l6, y8, f13, p9, 2) : 2 === v6 && g3(e12, n9, u13, l6, y8, f13, p9) : x4(t9(e12), n9, u13, l6, y8, f13, p9, 1);
      break;
    }
  }
}
function r8(e12) {
  const n9 = e12.prev, t10 = e12, x8 = e12.next;
  if (s5(n9, t10, x8) >= 0)
    return false;
  let r14 = e12.next.next;
  const i12 = r14;
  let u13 = 0;
  for (; r14 !== e12.prev && (0 === u13 || r14 !== i12); ) {
    if (u13++, a4(n9.x, n9.y, t10.x, t10.y, x8.x, x8.y, r14.x, r14.y) && s5(r14.prev, r14, r14.next) >= 0)
      return false;
    r14 = r14.next;
  }
  return true;
}
function i10(e12, n9, t10, x8) {
  const r14 = e12.prev, i12 = e12, u13 = e12.next;
  if (s5(r14, i12, u13) >= 0)
    return false;
  const o13 = r14.x < i12.x ? r14.x < u13.x ? r14.x : u13.x : i12.x < u13.x ? i12.x : u13.x, l6 = r14.y < i12.y ? r14.y < u13.y ? r14.y : u13.y : i12.y < u13.y ? i12.y : u13.y, y8 = r14.x > i12.x ? r14.x > u13.x ? r14.x : u13.x : i12.x > u13.x ? i12.x : u13.x, f13 = r14.y > i12.y ? r14.y > u13.y ? r14.y : u13.y : i12.y > u13.y ? i12.y : u13.y, p9 = z2(o13, l6, n9, t10, x8), c10 = z2(y8, f13, n9, t10, x8);
  let v6 = e12.prevZ, h6 = e12.nextZ;
  for (; v6 && v6.z >= p9 && h6 && h6.z <= c10; ) {
    if (v6 !== e12.prev && v6 !== e12.next && a4(r14.x, r14.y, i12.x, i12.y, u13.x, u13.y, v6.x, v6.y) && s5(v6.prev, v6, v6.next) >= 0)
      return false;
    if (v6 = v6.prevZ, h6 !== e12.prev && h6 !== e12.next && a4(r14.x, r14.y, i12.x, i12.y, u13.x, u13.y, h6.x, h6.y) && s5(h6.prev, h6, h6.next) >= 0)
      return false;
    h6 = h6.nextZ;
  }
  for (; v6 && v6.z >= p9; ) {
    if (v6 !== e12.prev && v6 !== e12.next && a4(r14.x, r14.y, i12.x, i12.y, u13.x, u13.y, v6.x, v6.y) && s5(v6.prev, v6, v6.next) >= 0)
      return false;
    v6 = v6.prevZ;
  }
  for (; h6 && h6.z <= c10; ) {
    if (h6 !== e12.prev && h6 !== e12.next && a4(r14.x, r14.y, i12.x, i12.y, u13.x, u13.y, h6.x, h6.y) && s5(h6.prev, h6, h6.next) >= 0)
      return false;
    h6 = h6.nextZ;
  }
  return true;
}
function u5(e12, n9, t10, x8) {
  const r14 = q.create(e12, n9, t10);
  return x8 ? (r14.next = x8.next, r14.prev = x8, x8.next.prev = r14, x8.next = r14) : (r14.prev = r14, r14.next = r14), r14;
}
function o11(e12) {
  e12.next.prev = e12.prev, e12.prev.next = e12.next, e12.prevZ && (e12.prevZ.nextZ = e12.nextZ), e12.nextZ && (e12.nextZ.prevZ = e12.prevZ);
}
function l3(e12) {
  let n9 = e12, t10 = e12;
  do {
    (n9.x < t10.x || n9.x === t10.x && n9.y < t10.y) && (t10 = n9), n9 = n9.next;
  } while (n9 !== e12);
  return t10;
}
function y3(e12, t10, x8, r14, i12, u13) {
  const o13 = new Array();
  for (let y8 = 0, f13 = r14.length; y8 < f13; y8++) {
    const i13 = n7(e12, t10, x8, r14[y8] * u13, y8 < f13 - 1 ? r14[y8 + 1] * u13 : x8 * u13, u13, false);
    i13 === i13.next && (i13.steiner = true), o13.push(l3(i13));
  }
  o13.sort(m2);
  for (const n9 of o13)
    i12 = f7(n9, i12);
  return i12;
}
function f7(e12, n9) {
  const x8 = p4(e12, n9);
  if (!x8)
    return n9;
  const r14 = j3(x8, e12);
  return t9(r14, r14.next), t9(x8, x8.next);
}
function p4(e12, n9) {
  let t10 = n9;
  const x8 = e12.x, r14 = e12.y;
  let i12, u13 = -1 / 0;
  do {
    if (r14 <= t10.y && r14 >= t10.next.y && t10.next.y !== t10.y) {
      const e13 = t10.x + (r14 - t10.y) * (t10.next.x - t10.x) / (t10.next.y - t10.y);
      if (e13 <= x8 && e13 > u13) {
        if (u13 = e13, e13 === x8) {
          if (r14 === t10.y)
            return t10;
          if (r14 === t10.next.y)
            return t10.next;
        }
        i12 = t10.x < t10.next.x ? t10 : t10.next;
      }
    }
    t10 = t10.next;
  } while (t10 !== n9);
  if (!i12)
    return null;
  if (x8 === u13)
    return i12.prev;
  const o13 = i12, l6 = i12.x, y8 = i12.y;
  let f13, p9 = 1 / 0;
  for (t10 = i12.next; t10 !== o13; )
    x8 >= t10.x && t10.x >= l6 && x8 !== t10.x && a4(r14 < y8 ? x8 : u13, r14, l6, y8, r14 < y8 ? u13 : x8, r14, t10.x, t10.y) && (f13 = Math.abs(r14 - t10.y) / (x8 - t10.x), (f13 < p9 || f13 === p9 && t10.x > i12.x) && w4(t10, e12) && (i12 = t10, p9 = f13)), t10 = t10.next;
  return i12;
}
function c6(e12, n9, t10, x8) {
  let r14;
  for (; r14 !== e12; r14 = r14.next) {
    if (r14 = r14 || e12, null === r14.z && (r14.z = z2(r14.x, r14.y, n9, t10, x8)), r14.prev.next !== r14 || r14.next.prev !== r14)
      return r14.prev.next = r14, r14.next.prev = r14, c6(e12, n9, t10, x8);
    r14.prevZ = r14.prev, r14.nextZ = r14.next;
  }
  return e12.prevZ.nextZ = null, e12.prevZ = null, v2(e12);
}
function v2(e12) {
  let n9, t10 = 1;
  for (; ; ) {
    let x8, r14 = e12;
    e12 = null, n9 = null;
    let i12 = 0;
    for (; r14; ) {
      i12++, x8 = r14;
      let u13 = 0;
      for (; u13 < t10 && x8; u13++)
        x8 = x8.nextZ;
      let o13 = t10;
      for (; u13 > 0 || o13 > 0 && x8; ) {
        let t11;
        0 === u13 ? (t11 = x8, x8 = x8.nextZ, o13--) : 0 !== o13 && x8 ? r14.z <= x8.z ? (t11 = r14, r14 = r14.nextZ, u13--) : (t11 = x8, x8 = x8.nextZ, o13--) : (t11 = r14, r14 = r14.nextZ, u13--), n9 ? n9.nextZ = t11 : e12 = t11, t11.prevZ = n9, n9 = t11;
      }
      r14 = x8;
    }
    if (n9.nextZ = null, t10 *= 2, i12 < 2)
      return e12;
  }
}
function s5(e12, n9, t10) {
  return (n9.y - e12.y) * (t10.x - n9.x) - (n9.x - e12.x) * (t10.y - n9.y);
}
function h2(e12, n9, t10, x8) {
  return !!(M(e12, n9) && M(t10, x8) || M(e12, x8) && M(t10, n9)) || s5(e12, n9, t10) > 0 != s5(e12, n9, x8) > 0 && s5(t10, x8, e12) > 0 != s5(t10, x8, n9) > 0;
}
function d2(e12, n9) {
  let t10 = e12;
  do {
    if (t10.index !== e12.index && t10.next.index !== e12.index && t10.index !== n9.index && t10.next.index !== n9.index && h2(t10, t10.next, e12, n9))
      return true;
    t10 = t10.next;
  } while (t10 !== e12);
  return false;
}
function Z2(e12, n9, t10, x8, r14, i12) {
  let u13 = 0;
  for (let o13 = x8, l6 = r14 - i12; o13 < r14; o13 += i12)
    u13 += (e12[l6 + n9 * i12] - e12[o13 + n9 * i12]) * (e12[o13 + 1 + n9 * i12] + e12[l6 + 1 + n9 * i12]), l6 = o13;
  return u13;
}
function a4(e12, n9, t10, x8, r14, i12, u13, o13) {
  return (r14 - u13) * (n9 - o13) - (e12 - u13) * (i12 - o13) >= 0 && (e12 - u13) * (x8 - o13) - (t10 - u13) * (n9 - o13) >= 0 && (t10 - u13) * (i12 - o13) - (r14 - u13) * (x8 - o13) >= 0;
}
function w4(e12, n9) {
  return s5(e12.prev, e12, e12.next) < 0 ? s5(e12, n9, e12.next) >= 0 && s5(e12, e12.prev, n9) >= 0 : s5(e12, n9, e12.prev) < 0 || s5(e12, e12.next, n9) < 0;
}
function z2(e12, n9, t10, x8, r14) {
  return (e12 = 1431655765 & ((e12 = 858993459 & ((e12 = 252645135 & ((e12 = 16711935 & ((e12 = 32767 * (e12 - t10) * r14) | e12 << 8)) | e12 << 4)) | e12 << 2)) | e12 << 1)) | (n9 = 1431655765 & ((n9 = 858993459 & ((n9 = 252645135 & ((n9 = 16711935 & ((n9 = 32767 * (n9 - x8) * r14) | n9 << 8)) | n9 << 4)) | n9 << 2)) | n9 << 1)) << 1;
}
function M(e12, n9) {
  return e12.x === n9.x && e12.y === n9.y;
}
function m2(e12, n9) {
  return e12.x - n9.x;
}
function b2(e12, n9, t10, x8) {
  let r14 = e12;
  do {
    const i12 = r14.prev, u13 = r14.next.next;
    !M(i12, u13) && h2(i12, r14, r14.next, u13) && w4(i12, u13) && w4(u13, i12) && (n9.push(i12.index / t10 + x8), n9.push(r14.index / t10 + x8), n9.push(u13.index / t10 + x8), o11(r14), o11(r14.next), r14 = e12 = u13), r14 = r14.next;
  } while (r14 !== e12);
  return r14;
}
function g3(e12, n9, r14, i12, u13, o13, l6) {
  let y8 = e12;
  do {
    let e13 = y8.next.next;
    for (; e13 !== y8.prev; ) {
      if (y8.index !== e13.index && k3(y8, e13)) {
        let f13 = j3(y8, e13);
        return y8 = t9(y8, y8.next), f13 = t9(f13, f13.next), x4(y8, n9, r14, i12, u13, o13, l6, 0), void x4(f13, n9, r14, i12, u13, o13, l6, 0);
      }
      e13 = e13.next;
    }
    y8 = y8.next;
  } while (y8 !== e12);
}
function k3(e12, n9) {
  return e12.next.index !== n9.index && e12.prev.index !== n9.index && !d2(e12, n9) && w4(e12, n9) && w4(n9, e12) && A(e12, n9);
}
function A(e12, n9) {
  let t10 = e12, x8 = false;
  const r14 = (e12.x + n9.x) / 2, i12 = (e12.y + n9.y) / 2;
  do {
    t10.y > i12 != t10.next.y > i12 && t10.next.y !== t10.y && r14 < (t10.next.x - t10.x) * (i12 - t10.y) / (t10.next.y - t10.y) + t10.x && (x8 = !x8), t10 = t10.next;
  } while (t10 !== e12);
  return x8;
}
function j3(e12, n9) {
  const t10 = q.create(e12.index, e12.x, e12.y), x8 = q.create(n9.index, n9.x, n9.y), r14 = e12.next, i12 = n9.prev;
  return e12.next = n9, n9.prev = e12, t10.next = r14, r14.prev = t10, x8.next = t10, t10.prev = x8, i12.next = x8, x8.prev = i12, x8;
}
var q = class {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e12, n9, t10) {
    const x8 = D2 < B.length ? B[D2++] : new q();
    return x8.index = e12, x8.x = n9, x8.y = t10, x8.prev = null, x8.next = null, x8.z = null, x8.prevZ = null, x8.nextZ = null, x8.steiner = false, x8;
  }
};
var B = new Array();
var C2 = 8096;
var D2 = 0;
for (let E4 = 0; E4 < C2; E4++)
  B.push(new q());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var f8 = 1e-5;
var c7 = new e6(0, 0, 0, 1, 0);
var u6 = new e6(0, 0, 0, 1, 0);
function h3(t10, e12, n9) {
  let o13 = 0;
  for (let r14 = 1; r14 < n9; r14++) {
    const n10 = t10[2 * (e12 + r14 - 1)], s7 = t10[2 * (e12 + r14 - 1) + 1];
    o13 += (t10[2 * (e12 + r14)] - n10) * (t10[2 * (e12 + r14) + 1] + s7);
  }
  return o13;
}
function g4(t10, e12, n9, o13, r14) {
  let s7 = 0;
  const l6 = 2;
  for (let i12 = n9; i12 < o13; i12 += 3) {
    const n10 = (t10[i12] - r14) * l6, o14 = (t10[i12 + 1] - r14) * l6, f13 = (t10[i12 + 2] - r14) * l6;
    s7 += Math.abs((e12[n10] - e12[f13]) * (e12[o14 + 1] - e12[n10 + 1]) - (e12[n10] - e12[o14]) * (e12[f13 + 1] - e12[n10 + 1]));
  }
  return s7;
}
function a5(t10, e12) {
  const { coords: n9, lengths: o13, hasIndeterminateRingOrder: r14 } = e12, s7 = 0, l6 = t10;
  if (r14)
    return false;
  let c10 = 0;
  for (let u13 = 0; u13 < o13.length; ) {
    let t11 = u13, e13 = o13[u13], r15 = h3(n9, c10, e13);
    const a7 = [];
    for (; ++t11 < o13.length; ) {
      const s8 = o13[t11], l7 = h3(n9, c10 + e13, s8);
      if (!(l7 > 0))
        break;
      r15 += l7, a7.push(c10 + e13), e13 += s8;
    }
    const m6 = l6.length;
    e9(l6, n9, c10, c10 + e13, a7, 2, s7);
    const p9 = g4(l6, n9, m6, l6.length, s7), d7 = Math.abs(r15);
    if (Math.abs((p9 - d7) / Math.max(1e-7, d7)) > f8)
      return l6.length = 0, false;
    u13 = t11, c10 += e13;
  }
  return true;
}
function p5(t10) {
  const { coords: e12, lengths: o13 } = t10, { buffer: r14 } = r4(e12, o13);
  return r14;
}
function d3(t10, e12, n9) {
  let o13 = 0;
  for (let r14 = 0; r14 < t10.lengths.length; r14++) {
    const s7 = t10.lengths[r14];
    for (let r15 = 0; r15 < s7; r15++) {
      const s8 = t10.coords[2 * (r15 + o13)], l6 = t10.coords[2 * (r15 + o13) + 1];
      if (s8 < e12 || s8 > n9 || l6 < e12 || l6 > n9)
        return true;
    }
    o13 += s7;
  }
  return false;
}
function b3(e12, n9) {
  if (t(e12))
    return null;
  if (!d3(e12, -128, o3 + 128))
    return e12;
  c7.setPixelMargin(n9), c7.reset(t3.Polygon);
  let o13 = 0;
  for (let t10 = 0; t10 < e12.lengths.length; t10++) {
    const n10 = e12.lengths[t10];
    let r14 = e12.coords[2 * (0 + o13)], s7 = e12.coords[2 * (0 + o13) + 1];
    c7.moveTo(r14, s7);
    for (let t11 = 1; t11 < n10; t11++)
      r14 = e12.coords[2 * (t11 + o13)], s7 = e12.coords[2 * (t11 + o13) + 1], c7.lineTo(r14, s7);
    c7.close(), o13 += n10;
  }
  const i12 = c7.result(false);
  if (!i12)
    return null;
  const f13 = [], u13 = [];
  for (const t10 of i12) {
    let e13 = 0;
    for (const n10 of t10)
      u13.push(n10.x), u13.push(n10.y), e13++;
    f13.push(e13);
  }
  return new t2(f13, u13);
}
function x5(t10, e12) {
  u6.setPixelMargin(e12);
  const n9 = u6, o13 = -e12, s7 = o3 + e12;
  let i12 = [], f13 = false, c10 = 0;
  for (; c10 < t10.length; ) {
    const e13 = [], l6 = t10[c10];
    if (!l6)
      return null;
    n9.reset(t3.LineString);
    let [u13, h6] = l6[0];
    if (f13)
      n9.moveTo(u13, h6);
    else {
      if (u13 < o13 || u13 > s7 || h6 < o13 || h6 > s7) {
        f13 = true;
        continue;
      }
      e13.push({ x: u13, y: h6 });
    }
    let g12 = false;
    const a7 = l6.length;
    for (let t11 = 1; t11 < a7; ++t11)
      if (u13 += l6[t11][0], h6 += l6[t11][1], f13)
        n9.lineTo(u13, h6);
      else {
        if (u13 < o13 || u13 > s7 || h6 < o13 || h6 > s7) {
          g12 = true;
          break;
        }
        e13.push({ x: u13, y: h6 });
      }
    if (g12)
      f13 = true;
    else {
      if (f13) {
        const t11 = n9.resultWithStarts();
        if (t11)
          for (const e14 of t11)
            i12.push(e14);
      } else
        i12.push({ line: e13, start: 0 });
      c10++, f13 = false;
    }
  }
  return i12 = i12.filter((t11) => t11.line.length > 1), 0 === i12.length ? null : i12;
}
c7.setExtent(o3), u6.setExtent(o3);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var m3 = 8;
var x6 = 16;
var p6 = 65535;
var f9 = (r14) => class extends r14 {
  constructor(...e12) {
    super(...e12), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e12, t10, i12, r15) {
    this._writeGeometry(e12, t10, i12, r15);
  }
  _initializeTessellator(e12) {
    const i12 = C.load(this._materialKey), r15 = w2.load(this._materialKey), s7 = this._tessellationOptions, h6 = i12.vvSizeFieldStops || i12.vvSizeMinMaxValue || i12.vvSizeScaleStops || i12.vvSizeUnitValue, d7 = this.tessellationProperties._halfWidth < X && !e12 && !h6;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s7.wrapDistance = p6, s7.textured = this._isDashed || this._hasPattern, s7.offset = this.tessellationProperties.offset, s7.halfWidth = this.tessellationProperties._halfWidth;
    const m6 = d7 ? 0 : 1, x8 = O(r15) ? v3 : _2;
    this._lineTessellator = new c3(x8(this.tessellationProperties, m6, m6), u7(this.tessellationProperties), d7);
  }
  _write(e12, t10, i12, r15) {
    const s7 = "esriGeometryPoint" === t10.geometryType;
    e12.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, s7), this._writeGeometry(e12, t10, r15, s7), e12.recordEnd();
  }
  _writeGeometry(t10, i12, r15, s7) {
    const o13 = r15 ?? i12.readLegacyGeometryForDisplay(), n9 = this._getLines(o13, s7);
    t(n9) || this._writeVertices(t10, i12, n9);
  }
  _getLines(t10, i12) {
    if (t(t10))
      return null;
    const r15 = t10.paths || t10.rings;
    if (t(r15))
      return null;
    return x5(r15, i12 ? 256 : 16);
  }
  _writeVertices(e12, t10, i12) {
    const r15 = t10.getDisplayId(), s7 = e12.vertexCount(), o13 = this.tessellationProperties, h6 = this._tessellationOptions;
    o13.out = e12, o13.id = r15, o13.indexCount = 0, o13.vertexCount = 0, o13.offset = s7, h6.capType = this._capType, h6.joinType = this._joinType;
    const d7 = w2.load(this._materialKey);
    this.tessellationProperties.key = O(d7) ? d7 : C.load(this._materialKey);
    for (const { line: n9, start: l6 } of i12)
      h6.initialDistance = l6 % p6, this._lineTessellator.tessellate(n9, h6);
  }
};
var _2 = (e12, t10, i12) => (o13, n9, l6, a7, h6, d7, p9, f13, _4, v6, u13) => {
  const c10 = w(u13, Math.ceil(x6 * e12._halfWidth)), y8 = x(Math.round(x6 * p9), Math.round(x6 * f13), Math.round(x6 * _4), Math.round(x6 * v6)), W3 = x(x6 * h6, x6 * d7, 0, e12._bitset), M5 = e12.out;
  return M5.vertexBounds(o13, n9, t10, i12), M5.vertexWrite(w(m3 * o13, m3 * n9)), M5.vertexWrite(e12.id), M5.vertexWrite(e12._fillColor), M5.vertexWrite(y8), M5.vertexWrite(c10), M5.vertexWrite(e12._tl), M5.vertexWrite(e12._br), M5.vertexWrite(W3), M5.vertexWrite(w(Math.ceil(x6 * e12._halfReferenceWidth), 0)), M5.vertexWrite(e12.minMaxZoom), M5.vertexEnd(), e12.offset + e12.vertexCount++;
};
var v3 = (e12, t10, i12) => (o13, n9, l6, a7, d7, p9, f13, _4, v6, u13, c10) => {
  const y8 = w(x6 * e12._halfWidth, x6 * e12._halfReferenceWidth), W3 = x(x6 * f13 + 128, x6 * _4 + 128, x6 * v6 + 128, x6 * u13 + 128), M5 = e12.out, P4 = e12._bitset << 24 | e12.id;
  M5.vertexBounds(o13, n9, t10, i12), M5.vertexWrite(w(m3 * o13, m3 * n9)), M5.vertexWrite(P4), M5.vertexWrite(e12._fillColor);
  const T = b(e12.key);
  return T || (M5.vertexWrite(0), M5.vertexWrite(0)), M5.vertexWrite(0), M5.vertexWrite(y8), M5.vertexWrite(W3), T || M5.vertexWrite(e12.minMaxZoom), M5.vertexEnd(), e12.offset + e12.vertexCount++;
};
var u7 = (e12) => (t10, i12, r14) => {
  const s7 = e12.out;
  s7.indexWrite(t10), s7.indexWrite(i12), s7.indexWrite(r14), e12.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r10 = class {
  constructor() {
    this._materialKey = null;
  }
  bindFeature(e12, t10, r14) {
  }
  write(r14, s7, i12, f13) {
    var _a;
    if (t(this._effects) || 0 === ((_a = this._effects) == null ? void 0 : _a.length))
      return this._write(r14, s7, f13);
    const c10 = f5.executeEffects(this._effects, s7.readLegacyGeometryForDisplay(), r14.tileKey, f13.geometryEngine);
    let o13 = f5.next(c10);
    for (; o13; )
      this._write(r14, s7, f13, o13), o13 = f5.next(c10);
  }
  _write(e12, t10, r14, s7) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = class extends f9(r10) {
  constructor(e12, t10, i12, r14, s7, o13, p9, f13, d7, y8, S5, _4, j6, g12, w9, K2, P4, x8, b7, O2) {
    super();
    const T = C.load(e12);
    t10 && (T.sdf = t10.sdf, T.pattern = true, T.textureBinding = t10.textureBinding), this._capType = r14, this._joinType = s7, this._miterLimitCosine = e8(o13), this.tessellationProperties._fillColor = p9, this.tessellationProperties._tl = f13, this.tessellationProperties._br = d7, this._hasPattern = y8, this._isDashed = S5, this._zOrder = P4, this._effects = x8, this._minMaxZoom = w(Math.round(b7 * at), Math.round(O2 * at)), this._materialKey = T.data;
    const M5 = (j6 ? nt : 0) | (g12 ? mt : 0) | (_4 ? lt : 0) | (w9 ? gt : 0);
    this.tessellationProperties._bitset = M5, this.tessellationProperties._halfWidth = 0.5 * i12, this.tessellationProperties._halfReferenceWidth = 0.5 * K2, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e12, r14, l6) {
    const n9 = e12.color, a7 = e12.scaleFactor || 1, m6 = !!e12.dashTemplate;
    let c10 = e12.cap;
    m6 && c10 === e4.ROUND && (c10 = e4.SQUARE);
    const p9 = e12.join, f13 = u(e12.width) * a7, u13 = u(e12.referenceWidth), d7 = u(e12.miterLimit), y8 = n9 && o7(n9) || 0, [L3, _4] = x3(e12.scaleInfo, l6), j6 = false;
    if (!r14)
      return new K(e12.materialKey, r14, f13, c10, p9, d7, y8, 0, 0, false, m6, e12.scaleDash ?? false, e12.colorLocked ?? false, j6, e12.sampleAlphaOnly, u13, e12.zOrder, e12.effects, L3, _4);
    const { rect: g12, width: w9, height: P4 } = r14, x8 = g12.x + et, b7 = g12.y + et, O2 = x8 + w9, T = b7 + P4, M5 = w(x8, b7), W3 = w(O2, T), z5 = false;
    return new K(e12.materialKey, r14, f13, c10, p9, d7, y8, M5, W3, true, m6, e12.scaleDash ?? false, e12.colorLocked ?? false, z5, e12.sampleAlphaOnly, u13, e12.zOrder, e12.effects, L3, _4);
  }
  static fromFillOutline(e12) {
    var _a;
    const t10 = w2.load(e12.materialKey);
    return O(t10) && e12.outline && "esriSLSSolid" === ((_a = e12.outline) == null ? void 0 : _a.style) ? K.fromSimpleLine({ hash: "", materialKey: e12.materialKey, ...e12.outline }, null, true) : null;
  }
  static fromSimpleLine(e12, i12, s7 = false) {
    const { color: l6 } = e12, n9 = "esriSLSSolid" !== e12.style && "esriSLSNull" !== e12.style, a7 = k2(e12.cap || "round"), m6 = G(e12.join || "round");
    let c10 = l6 && "esriSLSNull" !== e12.style && u2(l6) || 0;
    "esriSLSNull" === e12.style && (c10 = 0);
    const u13 = u(e12.width), d7 = e12.miterLimit;
    if (!i12)
      return new K(e12.materialKey, i12, u13, a7, m6, d7, c10, 0, 0, false, n9, true, false, s7, false, u13, 0, null, n6, o10);
    const { rect: y8, width: L3, height: S5 } = i12, g12 = y8.x + et, w9 = y8.y + et, P4 = g12 + L3, x8 = w9 + S5, b7 = w(g12, w9), O2 = w(P4, x8);
    return new K(e12.materialKey, i12, u13, a7, m6, d7, c10, b7, O2, true, n9, true, false, s7, false, u13, 0, null, n6, o10);
  }
  static fromPictureLineSymbol(t10, i12, r14, s7) {
    return s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var f10 = 100;
var u8 = 1;
var _3 = (_4) => class extends _4 {
  constructor(...e12) {
    super(...e12), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e12) {
    this._lineTemplate = K.fromFillOutline(e12);
  }
  _write(t10, r14, i12, s7) {
    const o13 = "esriGeometryPoint" === r14.geometryType, m6 = w2.load(this._materialKey);
    t10.recordStart(r14.getDisplayId(), this._materialKey, this.geometryType, o13), this._writeGeometry(t10, r14, m6, s7, o13), O(m6) && r(this._lineTemplate) && this._lineTemplate.writeGeometry(t10, r14, s7, o13), t10.recordEnd();
  }
  _writeGeometry(e12, r14, i12, s7, o13) {
    const m6 = this._getGeometry(r14, s7, o13);
    if (t(m6))
      return;
    const l6 = [];
    if (!(m6.maxLength > f10) && !this.forceLibtess && a5(l6, m6))
      return void (l6.length && this._writeVertices(e12, r14, m6.coords, m6.lengths, i12, l6));
    const n9 = p5(m6);
    this._writeVertices(e12, r14, n9, [n9.length / 2], i12);
  }
  _writeVertex(e12, t10, r14, i12, s7, l6) {
    const n9 = w(u8 * i12, u8 * s7);
    if (e12.vertexBounds(i12, s7, 0, 0), e12.vertexWrite(n9), e12.vertexWrite(t10), r14.symbologyType === S.DOT_DENSITY)
      e12.vertexWriteF32(1 / Math.abs(l6.readGeometryArea()));
    else {
      e12.vertexWrite(this.fillColor);
      const t11 = b(r14);
      t11 || (e12.vertexWrite(this.tl), e12.vertexWrite(this.br)), e12.vertexWrite(this.aux21), e12.vertexWrite(this.aux22), e12.vertexWrite(this.aux3), t11 || e12.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e12, t10, r14, i12, s7, o13) {
    const m6 = t10.getDisplayId(), n9 = this._bitset << 24 | m6, a7 = i12.reduce((e13, t11) => e13 + t11), h6 = R(s7.geometryType, s7.symbologyType).geometry / 4, y8 = e12.vertexCount();
    e12.vertexEnsureSize(h6 * a7);
    let p9 = 0;
    if (o13)
      for (const l6 of o13) {
        const i13 = r14[2 * l6], o14 = r14[2 * l6 + 1];
        this._writeVertex(e12, n9, s7, i13, o14, t10), p9++;
      }
    else
      for (let l6 = 0; l6 < r14.length; l6 += 2) {
        const i13 = Math.round(r14[l6]), o14 = Math.round(r14[l6 + 1]);
        this._writeVertex(e12, n9, s7, i13, o14, t10), p9++;
      }
    e12.indexEnsureSize(p9);
    for (let l6 = 0; l6 < p9; l6++)
      e12.indexWrite(l6 + y8);
  }
  _getGeometry(e12, t10, s7) {
    const o13 = t10 ? Pt(ct(t10), 2) : e12.readGeometryForDisplay();
    if (!o13)
      return null;
    return b3(o13, s7 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i11 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r11 = class extends r10 {
  constructor(e12) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e12;
  }
  analyze(e12, s7, r14, n9, o13) {
    if (o13 && 0 === o13.length)
      return null;
    const l6 = o13 && o13.length > 0, m6 = s7.readLegacyFeature(), c10 = s7.getObjectId(), h6 = this._materialCache, u13 = this._cimLayer.materialHash;
    if (!u13)
      return i11.error("A Dynamic mesh template must have a material hash value or function!"), Promise.reject(null);
    const p9 = "function" == typeof u13 ? u13(m6, r14, n9, c10) : u13, g12 = h6.get(p9);
    if (null != g12)
      return Promise.resolve(g12);
    const y8 = this._ongoingMaterialRequestMap.get(p9);
    if (y8)
      return y8;
    const M5 = this._cimLayer, d7 = pe(M5.cim, this._cimLayer.materialOverrides);
    d7.mosaicHash = p9;
    const { type: f13, url: _4 } = M5, b7 = { cim: d7, type: f13, mosaicHash: p9, url: _4, size: null, dashTemplate: null, text: null, fontName: null, objectId: c10, animatedSymbolProperties: null };
    switch (f13) {
      case "marker":
        b7.size = t5(M5.size, m6, r14, n9), b7.animatedSymbolProperties = t5(M5.animatedSymbolProperties, m6, r14, n9);
        break;
      case "line":
        b7.dashTemplate = M5.dashTemplate;
        break;
      case "text":
        b7.text = t5(M5.text, m6, r14, n9), b7.fontName = t5(M5.fontName, m6, r14, n9);
    }
    const L3 = e12.getMosaicItem(b7, o13).then((e13) => (l6 || (this._ongoingMaterialRequestMap.delete(p9), h6.set(p9, e13)), e13)).catch((e13) => (this._ongoingMaterialRequestMap.delete(p9), i11.error(".analyze()", e13.message), null));
    return l6 || this._ongoingMaterialRequestMap.set(p9, L3), L3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e10(e12, n9) {
  if (e12 && "name" in e12) {
    const o13 = e12;
    return n9 && n9.error(new s2(o13.name, o13.message, o13.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var M2 = 128;
var g5 = class extends _3(r11) {
  constructor(l6, f13, m6) {
    var _a;
    if (super(l6), this._minMaxZoom = w(Math.round(f13 * at), Math.round(m6 * at)), c5(l6.color)) {
      const t10 = (t11, e12, i12) => {
        const o13 = l6.color(t11, e12, i12);
        return o13 && o7(o13) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t10);
    } else {
      const t10 = l6.color;
      this.fillColor = t10 && o7(t10) || 0;
    }
    const _4 = "CIMMarkerPlacementInsidePolygon" === ((_a = l6.cim.placement) == null ? void 0 : _a.type) && l6.cim.placement.shiftOddRows ? 2 : 1, y8 = l6.height;
    if (c5(y8)) {
      const t10 = (t11, e12, s7) => y8(t11, e12, s7) * _4;
      this._dynamicPropertyMap.set("_height", t10);
    } else
      this._height = (y8 || 0) * _4;
    const d7 = l6.offsetX;
    if (c5(d7)) {
      const t10 = (t11, s7, i12) => u(d7(t11, s7, i12));
      this._dynamicPropertyMap.set("_offsetX", t10);
    } else
      this._offsetX = u(d7 || 0);
    const u13 = l6.offsetY;
    if (c5(u13)) {
      const t10 = (t11, s7, i12) => u(-u13(t11, s7, i12));
      this._dynamicPropertyMap.set("_offsetY", t10);
    } else
      this._offsetY = u(-u13 || 0);
    const M5 = l6.scaleX;
    c5(M5) ? this._dynamicPropertyMap.set("_scaleX", M5) : this._scaleX = M5 || 1;
    const g12 = l6.angle;
    if (c5(g12)) {
      const t10 = (t11, e12, s7) => c2(g12(t11, e12, s7));
      this._dynamicPropertyMap.set("_angle", t10);
    } else
      this._angle = c2(g12) || 0;
    if (r(l6.effects)) {
      const t10 = l6.effects;
      c5(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._cimFillLayer = l6, this._bitset = (l6.colorLocked ? nt : 0) | (l6.applyRandomOffset ? vt : 0) | (l6.sampleAlphaOnly ? gt : 0) | (l6.hasUnresolvedReplacementColor ? wt : 0), this._fillMaterialKey = l6.materialKey;
  }
  static fromCIMFill(t10, e12) {
    const [s7, i12] = x3(t10.scaleInfo, e12);
    return new g5(t10, s7, i12);
  }
  bindFeature(t10, s7, i12) {
    const o13 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, e12) => {
      this[e12] = t11(o13, s7, i12);
    });
    const r14 = w2.load(this._fillMaterialKey), a7 = this._materialCache, n9 = (0, this._cimFillLayer.materialHash)(o13, s7, i12), c10 = a7.get(n9);
    let p9 = null;
    if (c10 && e10(c10.spriteMosaicItem) && (p9 = c10.spriteMosaicItem), p9) {
      const { rect: t11, width: s8, height: i13 } = p9, o14 = t11.x + et, a8 = t11.y + et, n10 = o14 + s8, c11 = a8 + i13;
      let m6 = Math.round(u(this._height));
      m6 <= 0 && (m6 = c11 - a8);
      let _4 = Math.round(u(this._height / i13 * s8 || 0));
      _4 <= 0 && (_4 = n10 - o14);
      const y8 = this._scaleX, d7 = 1;
      this.tl = w(o14, a8), this.br = w(n10, c11), this.aux21 = w(_4, m6), this.aux22 = w(this._offsetX, this._offsetY), this.aux3 = x(y8 * M2, d7 * M2, this._angle, 0), r14.sdf = p9.sdf, r14.pattern = true, r14.textureBinding = p9.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux21 = 0, this.aux22 = 0, this.aux3 = 0, r14.sdf = false, r14.pattern = false, r14.textureBinding = 0;
    this._materialKey = r14.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var y4 = class extends f9(r11) {
  constructor(a7, n9, p9) {
    super(a7), this._minMaxZoom = w(Math.round(n9 * at), Math.round(p9 * at)), this._cimLineLayer = a7;
    let _4 = 0;
    c5(a7.width) || (_4 = 0.5 * u(a7.width));
    const f13 = (t10, i12, s7) => c5(a7.width) ? 0.5 * u(a7.width(t10, i12, s7)) : _4;
    this._dynamicPropertyMap.set("_halfWidth", f13), c5(a7.cap) ? this._dynamicPropertyMap.set("_capType", a7.cap) : this._capType = a7.cap, c5(a7.join) ? this._dynamicPropertyMap.set("_joinType", a7.join) : this._joinType = a7.join;
    const d7 = a7.color;
    if (c5(d7)) {
      const t10 = (t11, e12, s7) => o7(d7(t11, e12, s7));
      this._dynamicPropertyMap.set("_fillColor", t10);
    } else
      this._fillColor = d7 && o7(d7) || 0;
    const y8 = a7.miterLimit;
    if (c5(y8)) {
      const t10 = (t11, e12, i12) => e8(y8(t11, e12, i12));
      this._dynamicPropertyMap.set("_miterLimitCosine", t10);
    } else
      this._miterLimitCosine = e8(y8);
    if (r(a7.effects)) {
      const t10 = a7.effects;
      c5(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._scaleFactor = a7.scaleFactor || 1, this._isDashed = null != a7.dashTemplate;
    const P4 = a7.colorLocked ? nt : 0, u13 = a7.scaleDash ? lt : 0, j6 = a7.sampleAlphaOnly ? gt : 0;
    this.tessellationProperties._bitset = P4 | u13 | j6, this._materialKey = a7.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t10, e12) {
    const [i12, s7] = x3(t10.scaleInfo, e12);
    return new y4(t10, i12, s7);
  }
  bindFeature(t10, e12, i12) {
    const s7 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, r15) => {
      this[r15] = t11(s7, e12, i12);
    }), this._halfWidth *= this._scaleFactor;
    const r14 = this._materialCache, o13 = (0, this._cimLineLayer.materialHash)(s7, e12, i12), l6 = r14.get(o13);
    let c10 = null;
    if (l6 && e10(l6.spriteMosaicItem) && (c10 = l6.spriteMosaicItem), c10) {
      this._hasPattern = true;
      const { rect: t11, width: e13, height: i13 } = c10, s8 = t11.x + et, r15 = t11.y + et, o14 = s8 + e13, l7 = r15 + i13;
      this.tessellationProperties._tl = w(s8, r15), this.tessellationProperties._br = w(o14, l7);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m6 = C.load(this._materialKey);
    c10 && (m6.sdf = c10.sdf, m6.pattern = true, m6.textureBinding = c10.textureBinding), this._materialKey = m6.data;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e11 = class {
  static getPlacement(e12, o13, s7, c10, n9) {
    const m6 = g(o13);
    if (!m6)
      return null;
    const u13 = a3(e12);
    return m6.execute(u13, o13, s7, c10, n9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g6 = 3.14159265359 / 180;
var y5 = 8;
var u9 = (u13) => class extends u13 {
  constructor(...t10) {
    super(...t10), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._allowBorrowing = true, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this._offsets = { xUpperLeft: 0, yUpperLeft: 0, xUpperRight: 0, yUpperRight: 0, xBottomLeft: 0, yBottomLeft: 0, xBottomRight: 0, yBottomRight: 0 }, this.geometryType = E.MARKER;
  }
  _write(t10, e12, i12, r14) {
    const s7 = e12.getDisplayId();
    t10.recordStart(s7, this._materialKey, this.geometryType, true), this._writeGeometry(t10, e12, s7, i12, r14), t10.recordEnd();
  }
  _writeGeometry(i12, r14, s7, o13, h6) {
    if (r(this._markerPlacement))
      return this._writePlacedMarkers(i12, r14, o13, h6);
    if (this._allowBorrowing = true, !h6 && "esriGeometryPoint" === r14.geometryType) {
      const t10 = r14.getX(), e12 = r14.getY();
      if (!i12.hasAggregates && i12.hasPixelBufferEnabled && (t10 < 0 || t10 >= 513 || e12 < 0 || e12 >= 513))
        return;
      return this._writeVertices(i12, s7, this._getPos(t10, e12), t10, e12);
    }
    const n9 = h6 ? Pt(ct(h6), 2) : "esriGeometryPolygon" === r14.geometryType ? r14.readCentroid() : r14.readGeometryForDisplay();
    if (!t(n9)) {
      if (n9.isPoint) {
        const [t10, e12] = n9.coords;
        if (!i12.hasAggregates && i12.hasPixelBufferEnabled && (t10 < 0 || t10 >= 512 || e12 < 0 || e12 >= 512))
          return;
        return this._writeVertices(i12, s7, this._getPos(t10, e12), t10, e12);
      }
      n9.forEachVertex((t10, e12) => {
        const r15 = 2 * o3;
        t10 < -r15 || t10 >= r15 || e12 < -r15 || e12 >= r15 || this._writeVertices(i12, s7, this._getPos(t10, e12), t10, e12);
      });
    }
  }
  _writePlacedMarkers(t10, e12, s7, o13) {
    const n9 = o13 ?? e12.readLegacyGeometryForDisplay(), f13 = e11.getPlacement(n9, e(this._markerPlacement), u(1), t10.tileKey, s7.geometryEngine);
    if (!f13)
      return;
    this._allowBorrowing = "esriGeometryPolygon" !== e12.geometryType;
    const a7 = e12.getDisplayId(), m6 = n3(), _4 = n(), p9 = -128, c10 = 640;
    let v6 = f13.next();
    for (; null != v6; ) {
      const e13 = v6.tx, i12 = -v6.ty;
      e13 >= p9 && e13 <= c10 && i12 >= p9 && i12 <= c10 && (this._applyTransformation(_4, m6, -v6.getAngle() / g6), this._writeVertices(t10, a7, this._getPos(e13, i12), e13, i12)), v6 = f13.next();
    }
  }
  _writeVertices(t10, e12, i12, r14, s7) {
    const o13 = N.load(this._materialKey);
    return o13.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t10, e12, i12) : this._writeMarkerVertices(t10, e12, o13, i12, r14, s7);
  }
  _writeMarkerVertices(t10, e12, i12, r14, s7, o13) {
    const h6 = i12.vvRotation, n9 = t10.vertexCount();
    let f13 = this._computedWidth * this._vertexBoundsScaleX, a7 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t11 = Math.max(f13, a7);
      f13 = t11, a7 = t11;
    }
    if (h6) {
      const t11 = Math.max(this.xOffset, this.yOffset);
      f13 += t11, a7 += t11;
    }
    this._allowBorrowing && t10.vertexBounds(s7 + this.xOffset, o13 - this.yOffset, f13, a7), t10.vertexWrite(r14), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(this._texUpperLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e12), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r14), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(this._texUpperRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e12), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r14), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(this._texBottomLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e12), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r14), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(this._texBottomRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e12), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), this._writeIndices(t10, n9);
  }
  _writeHeatmapVertices(t10, e12, i12) {
    const r14 = t10.vertexCount();
    t10.vertexWrite(i12), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(e12), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(e12), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(e12), t10.vertexEnd(), t10.vertexWrite(i12), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(e12), t10.vertexEnd(), this._writeIndices(t10, r14);
  }
  _writeIndices(t10, e12) {
    t10.indexWrite(e12 + 0), t10.indexWrite(e12 + 1), t10.indexWrite(e12 + 2), t10.indexWrite(e12 + 1), t10.indexWrite(e12 + 3), t10.indexWrite(e12 + 2);
  }
  _applyTransformation(t10, e12, i12 = 0) {
    f3(t10, t4(this.xOffset, -this.yOffset)), null != this.angle && this.angle + i12 !== 0 && e5(t10, t10, g6 * (this.angle + i12));
    const r14 = this._computedWidth, h6 = this._computedHeight, x8 = -(0.5 + this._anchorX) * r14, m6 = -(0.5 - this._anchorY) * h6;
    r3(e12, x8, m6), z(e12, e12, t10), this._offsetUpperLeft = w(16 * e12[0], 16 * e12[1]), this._offsets.xUpperLeft = e12[0], this._offsets.yUpperLeft = e12[1], r3(e12, x8 + r14, m6), z(e12, e12, t10), this._offsetUpperRight = w(16 * e12[0], 16 * e12[1]), this._offsets.xUpperRight = e12[0], this._offsets.yUpperRight = e12[1], r3(e12, x8, m6 + h6), z(e12, e12, t10), this._offsetBottomLeft = w(16 * e12[0], 16 * e12[1]), this._offsets.xBottomLeft = e12[0], this._offsets.yBottomLeft = e12[1], r3(e12, x8 + r14, m6 + h6), z(e12, e12, t10), this._offsetBottomRight = w(16 * e12[0], 16 * e12[1]), this._offsets.xBottomRight = e12[0], this._offsets.yBottomRight = e12[1];
  }
  _getPos(t10, e12) {
    return w(Math.round(y5 * t10), Math.round(y5 * e12));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var g7 = n3();
var k4 = n();
var P2 = class extends u9(r11) {
  constructor(t10, e12, o13) {
    super(t10), this._cimMarkerLayer = t10, this._minMaxZoom = w(Math.round(e12 * at), Math.round(o13 * at));
    const a7 = t10.color;
    if (c5(a7)) {
      const t11 = (t12, e13, i12) => o7(a7(t12, e13, i12));
      this._dynamicPropertyMap.set("_fillColor", t11);
    } else
      this._fillColor = o7(a7);
    const n9 = t10.outlineColor;
    if (c5(n9)) {
      const t11 = (t12, e13, i12) => o7(n9(t12, e13, i12));
      this._dynamicPropertyMap.set("_outlineColor", t11);
    } else
      this._outlineColor = o7(n9);
    const f13 = t10.size;
    if (c5(f13)) {
      const t11 = (t12, e13, i12) => u(f13(t12, e13, i12));
      this._dynamicPropertyMap.set("_size", t11);
    } else
      this._size = u(f13) || 0;
    const _4 = t10.scaleX;
    c5(_4) ? this._dynamicPropertyMap.set("_scaleX", _4) : this._scaleX = _4;
    const y8 = t10.offsetX;
    if (c5(y8)) {
      const t11 = (t12, e13, i12) => u(y8(t12, e13, i12));
      this._dynamicPropertyMap.set("xOffset", t11);
    } else
      this.xOffset = u(y8) || 0;
    const d7 = t10.offsetY;
    if (c5(d7)) {
      const t11 = (t12, e13, i12) => u(d7(t12, e13, i12));
      this._dynamicPropertyMap.set("yOffset", t11);
    } else
      this.yOffset = u(d7) || 0;
    const M5 = t10.outlineWidth;
    if (c5(M5)) {
      const t11 = (t12, e13, i12) => u(M5(t12, e13, i12));
      this._dynamicPropertyMap.set("_outlineWidth", t11);
    } else
      this._outlineWidth = u(M5) || 0;
    const u13 = t10.rotation;
    if (c5(u13) ? this._dynamicPropertyMap.set("_angle", u13) : this._angle = u13 || 0, r(t10.effects)) {
      const e13 = t10.effects;
      c5(e13) ? this._dynamicPropertyMap.set("_effects", e13) : this._effects = e13;
    }
    if (r(t10.markerPlacement)) {
      const e13 = t10.markerPlacement;
      c5(e13) ? this._dynamicPropertyMap.set("_markerPlacement", e13) : this._markerPlacement = e13;
    }
    this._scaleFactor = l(t10.scaleFactor, 1), this._bitSet = (t10.alignment === i3.MAP ? 1 : 0) | (t10.colorLocked ? 1 : 0) << 1 | (t10.scaleSymbolsProportionally ? 1 : 0) << 3, this._materialKey = t10.materialKey;
  }
  static fromCIMMarker(t10, e12) {
    const [i12, s7] = x3(t10.scaleInfo, e12);
    return new P2(t10, i12, s7);
  }
  bindFeature(i12, s7, o13) {
    const a7 = i12.readLegacyFeature(), h6 = i12.getObjectId();
    this._dynamicPropertyMap.forEach((t10, e12) => {
      this[e12] = t10(a7, s7, o13);
    });
    const c10 = this._cimMarkerLayer.materialHash, m6 = "function" == typeof c10 ? c10(a7, s7, o13, h6) : c10, p9 = this._materialCache.get(m6);
    if (!p9 || !e10(p9.spriteMosaicItem) || !p9.spriteMosaicItem)
      return void s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const y8 = p9.spriteMosaicItem, d7 = this._cimMarkerLayer.sizeRatio, M5 = y8.width / y8.height * this._scaleX, P4 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle;
    let L3 = this._size, x8 = L3 * M5;
    const j6 = this.xOffset, b7 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const O2 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u(this._cimMarkerLayer.frameHeight) : 1, w9 = this._outlineWidth * O2, z5 = u(this._cimMarkerLayer.referenceSize);
    let W3 = 0, C5 = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (W3 = u(F2.x) / (this._size * M5), C5 = u(F2.y) / this._size) : (W3 = F2.x, C5 = F2.y)), this._anchorX = W3, this._anchorY = C5, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * x8), 255)), Math.round(Math.min(Math.sqrt(128 * L3), 255)), Math.round(Math.min(Math.sqrt(128 * w9), 255)), Math.round(Math.min(Math.sqrt(128 * z5), 255))), this.angle = P4;
    const I = Math.round(64 * d7);
    this._bitestAndDistRatio = w(this._bitSet, I);
    const K2 = y8.rect.x + et, X2 = y8.rect.y + et, B4 = K2 + y8.width, R2 = X2 + y8.height;
    this._texUpperLeft = w(K2, X2), this._texUpperRight = w(B4, X2), this._texBottomLeft = w(K2, R2), this._texBottomRight = w(B4, R2);
    const S5 = N.load(this._materialKey);
    S5.sdf = y8.sdf, S5.pattern = true, S5.textureBinding = y8.textureBinding, this._materialKey = S5.data, x8 *= d7, L3 *= d7, x8 *= this._scaleFactor, L3 *= this._scaleFactor, x8 *= y8.rect.width / y8.width, L3 *= y8.rect.height / y8.height, this._computedWidth = x8, this._computedHeight = L3, this._applyTransformation(k4, g7), this.xOffset = j6, this.yOffset = b7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var u10 = 8;
var g8 = w(4, 4);
var m4 = w(4, 2);
var f11 = w(4, 6);
var y6 = [m4, m4, f11, f11];
var p7 = [m4, f11, m4, f11];
var v4 = [f11, f11, g8, g8];
var w5 = [g8, g8, f11, f11];
var W = [f11, g8, f11, g8];
var B2 = [g8, f11, g8, f11];
var b4 = (m6) => class extends m6 {
  constructor(...e12) {
    super(...e12), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(t10, r14) {
    t10 && t10.length ? this._shapingInfo = o(t10, (e12) => S2(e12, r14, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: f * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM, hasBackground: !!this._backgroundColor, borderLineSize: this._borderLineSize })) : this._shapingInfo = null;
  }
  _write(e12, t10, r14, i12) {
    const o13 = t10.getDisplayId();
    this._writeGeometry(e12, t10, o13, r14, i12);
  }
  _writeGeometry(e12, i12, o13, h6, a7) {
    const d7 = this._shapingInfo;
    if (t(d7))
      return;
    if (r(this._textPlacement)) {
      const t10 = a7 ?? i12.readLegacyGeometryForDisplay();
      return this._writePlacedText(e12, o13, t10, d7, h6);
    }
    const x8 = a7 ? Pt(ct(a7), 2) : "esriGeometryPolygon" === i12.geometryType ? i12.readCentroid() : i12.readGeometryForDisplay();
    if (!t(x8)) {
      if (x8.isPoint) {
        const [t10, r14] = x8.coords;
        if (!e12.hasAggregates && e12.hasPixelBufferEnabled && (t10 < 0 || t10 >= 512 || r14 < 0 || r14 >= 512))
          return;
        return this._writeGlyphs(e12, o13, { x: t10, y: r14 }, d7);
      }
      x8.forEachVertex((t10, r14) => this._writeGlyphs(e12, o13, { x: t10, y: r14 }, d7));
    }
  }
  _writePlacedText(e12, t10, r14, s7, n9) {
    const a7 = e(this._textPlacement), d7 = e11.getPlacement(r14, a7, u(1), e12.tileKey, n9.geometryEngine);
    if (!d7)
      return;
    let x8 = d7.next();
    for (; null != x8; ) {
      const r15 = -x8.getAngle();
      s7.setRotation(r15);
      const i12 = x8.tx, o13 = -x8.ty;
      i12 < 0 || i12 >= 512 || o13 < 0 || o13 >= 512 ? x8 = d7.next() : (this._writeGlyphs(e12, t10, { x: i12, y: o13 }, s7), s7.setRotation(-r15), x8 = d7.next());
    }
  }
  _writeGlyphs(e12, t10, r14, i12) {
    const o13 = U.load(this._materialKey), s7 = w(Math.round(u10 * r14.x), Math.round(u10 * r14.y)), n9 = this._vertexBoundsScale, { bounds: h6, background: a7, glyphs: d7 } = i12;
    d7.length > 0 && (this._borderLineColor || this._backgroundColor) && (o13.textureBinding = d7[0].textureBinding, e12.recordStart(t10, o13.data, this.geometryType, true), this._writeBackgroundGeometry(e12, t10, r14, h6, a7), e12.recordEnd());
    const x8 = 2 * Math.max(h6.width, h6.height);
    for (const c10 of i12.glyphs)
      o13.textureBinding = c10.textureBinding, e12.recordStart(t10, o13.data, this.geometryType, true), e12.vertexBounds(r14.x + h6.x + this._xOffset, r14.y + h6.y - this._yOffset, x8 * n9, x8 * n9), this._writeVertices(e12, t10, s7, c10), e12.recordEnd();
  }
  _writeGlyph(e12, t10, r14, i12, o13) {
    const s7 = U.load(this._materialKey), n9 = w(Math.round(u10 * r14), Math.round(u10 * i12));
    s7.textureBinding = o13.textureBinding, e12.recordStart(t10, s7.data, this.geometryType, true);
    const h6 = o13.bounds, a7 = this._vertexBoundsScale;
    e12.vertexBounds(r14 + h6.x * a7, i12 + h6.y * a7, h6.width * a7, h6.height * a7), this._writeVertices(e12, t10, n9, o13), e12.recordEnd();
  }
  _writeVertices(e12, t10, r14, i12) {
    const o13 = e12.vertexCount();
    this._writeVertexCommon(e12, t10, r14, i12), e12.vertexWrite(i12.offsets.upperLeft), e12.vertexWrite(i12.texcoords.upperLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t10, r14, i12), e12.vertexWrite(i12.offsets.upperRight), e12.vertexWrite(i12.texcoords.upperRight), e12.vertexEnd(), this._writeVertexCommon(e12, t10, r14, i12), e12.vertexWrite(i12.offsets.lowerLeft), e12.vertexWrite(i12.texcoords.lowerLeft), e12.vertexEnd(), this._writeVertexCommon(e12, t10, r14, i12), e12.vertexWrite(i12.offsets.lowerRight), e12.vertexWrite(i12.texcoords.lowerRight), e12.vertexEnd(), e12.indexWrite(o13 + 0), e12.indexWrite(o13 + 1), e12.indexWrite(o13 + 2), e12.indexWrite(o13 + 1), e12.indexWrite(o13 + 3), e12.indexWrite(o13 + 2);
  }
  _writeVertexCommon(e12, t10, r14, i12) {
    const o13 = this._color, s7 = this._haloColor, n9 = x(0, 0, this._referenceSize, this._bitset), h6 = x(0, 0, this._size, this._haloSize);
    e12.vertexWrite(r14), e12.vertexWrite(t10), e12.vertexWrite(o13), e12.vertexWrite(s7), e12.vertexWrite(h6), e12.vertexWrite(n9), e12.vertexWrite(this._minMaxZoom);
  }
  _writeBackgroundVertex(e12, t10, r14, i12, o13, s7) {
    const n9 = x(0, 1, this._referenceSize, this._bitset), h6 = x(0, 0, this._size, this._haloSize), a7 = x(0, 0, 0, 0);
    e12.vertexWrite(r14), e12.vertexWrite(t10), e12.vertexWrite(i12), e12.vertexWrite(a7), e12.vertexWrite(h6), e12.vertexWrite(n9), e12.vertexWrite(this._minMaxZoom), e12.vertexWrite(o13), e12.vertexWrite(s7), e12.vertexEnd();
  }
  _writeBackgroundQuad(e12, t10, r14, i12, o13, s7) {
    const n9 = e12.vertexCount();
    this._writeBackgroundVertex(e12, t10, r14, i12, o13.upperLeft, s7[0]), this._writeBackgroundVertex(e12, t10, r14, i12, o13.upperRight, s7[1]), this._writeBackgroundVertex(e12, t10, r14, i12, o13.lowerLeft, s7[2]), this._writeBackgroundVertex(e12, t10, r14, i12, o13.lowerRight, s7[3]), e12.indexWrite(n9 + 0), e12.indexWrite(n9 + 1), e12.indexWrite(n9 + 2), e12.indexWrite(n9 + 1), e12.indexWrite(n9 + 3), e12.indexWrite(n9 + 2);
  }
  _writeBackgroundGeometry(e12, t10, r14, i12, o13) {
    const s7 = w(Math.round(u10 * r14.x), Math.round(u10 * r14.y)), { x: n9, y: h6, width: a7, height: d7 } = i12, x8 = 2 * Math.max(a7, d7);
    if (e12.vertexBounds(r14.x + n9 + this._xOffset, r14.y + h6 - this._yOffset, x8 * this._vertexBoundsScale, x8 * this._vertexBoundsScale), this._backgroundColor) {
      const r15 = [g8, g8, g8, g8];
      this._writeBackgroundQuad(e12, t10, s7, this._backgroundColor, o13.main, r15);
    }
    if (this._borderLineColor || this._backgroundColor) {
      const r15 = !!this._borderLineColor && !!this._borderLineSize && this._borderLineSize > 0, [i13, n10, h7, a8, d8] = r15 ? [y6, y6, p7, p7, this._borderLineColor] : [v4, w5, W, B2, this._backgroundColor];
      this._writeBackgroundQuad(e12, t10, s7, d8, o13.top, i13), this._writeBackgroundQuad(e12, t10, s7, d8, o13.bot, n10), this._writeBackgroundQuad(e12, t10, s7, d8, o13.left, h7), this._writeBackgroundQuad(e12, t10, s7, d8, o13.right, a8);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var d4 = 5;
function M3(t10, e12, i12, s7) {
  return "string" == typeof t10.text ? t10.text : "function" == typeof t10.text ? t10.text(e12, i12, s7) ?? "" : "";
}
var g9 = class extends b4(r11) {
  constructor(e12, o13, r14) {
    super(e12), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w(Math.round(o13 * at), Math.round(r14 * at));
    const n9 = e12.scaleFactor || 1;
    this._cimTextLayer = e12;
    const _4 = e12.color;
    if (c5(_4)) {
      const t10 = (t11, e13, i12) => o7(_4(t11, e13, i12));
      this._dynamicPropertyMap.set("_color", t10);
    } else
      this._color = o7(_4);
    const f13 = e12.outlineColor;
    if (c5(f13)) {
      const t10 = (t11, e13, i12) => o7(f13(t11, e13, i12));
      this._dynamicPropertyMap.set("_haloColor", t10);
    } else
      this._haloColor = o7(f13);
    let y8;
    c5(e12.size) || (y8 = Math.min(Math.round(u(e12.size * e12.sizeRatio)), 127));
    const p9 = (t10, s7, o14) => c5(e12.size) ? Math.min(Math.round(u(e12.size(t10, s7, o14) * e12.sizeRatio)), 127) : y8;
    if (this._dynamicPropertyMap.set("_size", p9), c5(e12.outlineSize)) {
      const t10 = (t11, s7, o14) => Math.min(Math.floor(d4 * u(e12.outlineSize(t11, s7, o14) * e12.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", t10);
    } else
      this._haloSize = Math.min(Math.floor(d4 * u(e12.outlineSize * e12.sizeRatio)), 127);
    let M5;
    c5(e12.offsetX) || (M5 = Math.round(u(e12.offsetX * e12.sizeRatio)));
    const g12 = (t10, s7, o14) => c5(e12.offsetX) ? Math.round(u(e12.offsetX(t10, s7, o14) * e12.sizeRatio)) : M5;
    let u13;
    this._dynamicPropertyMap.set("_xOffset", g12), c5(e12.offsetY) || (u13 = Math.round(u(e12.offsetY * e12.sizeRatio)));
    const z5 = (t10, s7, o14) => c5(e12.offsetY) ? Math.round(u(e12.offsetY(t10, s7, o14) * e12.sizeRatio)) : u13;
    if (this._dynamicPropertyMap.set("_yOffset", z5), c5(e12.angle) ? this._dynamicPropertyMap.set("_angle", e12.angle) : this._angle = e12.angle, c5(e12.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", e12.horizontalAlignment) : this._horizontalAlignment = e12.horizontalAlignment, c5(e12.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", e12.verticalAlignment) : this._verticalAlignment = e12.verticalAlignment, r(e12.effects)) {
      const t10 = e12.effects;
      c5(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    if (r(e12.markerPlacement)) {
      const t10 = e12.markerPlacement;
      c5(t10) ? this._dynamicPropertyMap.set("_markerPlacement", t10) : this._textPlacement = t10;
    }
    c5(e12.text) ? this._dynamicPropertyMap.set("_text", e12.text) : this._text = e12.text, this._backgroundColor = e12.backgroundColor && o7(e12.backgroundColor), this._borderLineColor = e12.borderLineColor && o7(e12.borderLineColor), this._borderLineSize = e12.borderLineWidth, this._scaleFactor = n9;
    const x8 = Math.min(Math.round(u(e12.referenceSize * e12.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * x8)), this._materialKey = e12.materialKey;
    const P4 = P.load(this._materialKey);
    P4.sdf = true, this._bitset = (e12.alignment === i3.MAP ? 1 : 0) | (e12.colorLocked ? 1 : 0) << 1, this._materialKey = P4.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t10, e12) {
    const [i12, s7] = x3(t10.scaleInfo, e12);
    return new g9(t10, i12, s7);
  }
  async analyze(t10, e12, i12, s7) {
    const o13 = e12.readLegacyFeature(), r14 = M3(this._cimTextLayer, o13, i12, s7), a7 = await super.analyze(t10, e12, i12, s7, n5(r14));
    return a7 && a7.glyphMosaicItems && this._textToGlyphs.set(r14, a7.glyphMosaicItems), a7;
  }
  bindFeature(t10, i12, s7) {
    const a7 = t10.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t11, e12) => {
      this[e12] = t11(a7, i12, s7);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / j2, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r5(l(this._horizontalAlignment, "center")), this._yAlignD = n2(l(this._verticalAlignment, "baseline"));
    const l6 = this._textToGlyphs.get(this._text) ?? [];
    this.bindTextInfo(l6, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var j4 = 128;
var w6 = class extends _3(r10) {
  constructor(t10, e12, l6, i12, o13, r14, s7, a7, m6, f13, d7, p9, y8, x8, M5, j6) {
    super(), this._effects = x8;
    const w9 = w2.load(t10);
    e12 && (w9.sdf = e12.sdf, w9.pattern = true, w9.textureBinding = e12.textureBinding), this.fillColor = l6, this.tl = i12, this.br = o13, this.aux21 = w(r14, s7), this.aux22 = w(a7, m6), this.aux3 = x(f13, d7, p9, 0), this._bitset = y8, this._minMaxZoom = w(Math.round(M5 * at), Math.round(j6 * at)), this._materialKey = w9.data;
  }
  static fromCIMFill(e12, n9, m6) {
    const h6 = e12.color, u13 = h6 && o7(h6) || 0, p9 = e12.materialKey, [y8, x8] = x3(e12.scaleInfo, m6), M5 = (e12.colorLocked ? nt : 0) | (e12.applyRandomOffset ? vt : 0) | (e12.sampleAlphaOnly ? gt : 0) | (e12.hasUnresolvedReplacementColor ? wt : 0);
    if (!n9)
      return new w6(p9, null, u13, 0, 0, 0, 0, 0, 0, 0, 0, 0, M5, e12.effects, y8, x8);
    const { rect: g12, width: F2, height: K2 } = n9, _4 = e12.scaleX || 1, b7 = g12.x + et, L3 = g12.y + et, C5 = b7 + F2, T = L3 + K2, A3 = u(e12.height);
    let B4 = _4 * A3;
    "CIMHatchFill" === e12.cim.type && (B4 *= F2 / K2);
    let G4 = Math.round(A3);
    G4 <= 0 && (G4 = T - L3);
    let I = Math.round(B4);
    I <= 0 && (I = C5 - b7);
    const R2 = u(e12.offsetX || 0), S5 = u(-e12.offsetY || 0), U2 = w(b7, L3), O2 = w(C5, T);
    return new w6(p9, n9, u13, U2, O2, I, G4, R2, S5, j4, j4, c2(e12.angle), M5, e12.effects, y8, x8);
  }
  static fromSimpleFill(t10, l6, o13 = false) {
    const { color: r14 } = t10, s7 = r14 && "esriSFSNull" !== t10.style && u2(r14) || 0, n9 = o13 ? nt : 0, m6 = t10.materialKey;
    let f13;
    if (l6) {
      const { rect: t11, width: e12, height: i12, pixelRatio: o14 } = l6, r15 = t11.x + et, h6 = t11.y + et, u13 = r15 + e12, d7 = h6 + i12, x8 = w(r15, h6), M5 = w(u13, d7);
      f13 = new w6(m6, l6, s7, x8, M5, e12 / o14, i12 / o14, 0, 0, j4, j4, 0, n9, null, n6, o10);
    } else
      f13 = new w6(m6, null, s7, 0, 0, 0, 0, 0, 0, 0, 0, 0, n9, null, n6, o10);
    return f13._maybeAddLineTemplate(t10), f13;
  }
  static fromPictureFill(e12, l6, o13 = false) {
    const r14 = i, { rect: s7, width: n9, height: f13 } = l6, h6 = s7.x + et, u13 = s7.y + et, d7 = h6 + n9, x8 = u13 + f13, M5 = w(h6, u13), g12 = w(d7, x8), F2 = Math.round(u(e12.width)), K2 = Math.round(u(e12.height)), _4 = u(e12.xoffset), b7 = u(-e12.yoffset), L3 = e12.materialKey, C5 = o13 ? nt : 0, T = new w6(L3, l6, r14, M5, g12, F2, K2, _4, b7, j4 * e12.xscale, j4 * e12.yscale, 0, C5, null, n6, o10);
    return T._maybeAddLineTemplate(e12), T;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var b5 = class extends u9(r10) {
  constructor(t10, e12, r14, a7, n9, p9, S5, g12, V, z5, B4, b7, k7, L3, R2, j6, w9, C5, P4, E4, U2, A3, T) {
    super(), this.angle = a7, this.height = S5, this.width = p9, this.xOffset = e12 * P4, this.yOffset = r14 * P4, this._markerPlacement = E4, this._effects = U2, this._anchorX = j6, this._anchorY = w9, this._minMaxZoom = w(Math.round(A3 * at), Math.round(T * at));
    const v6 = (L3 === i3.MAP ? rt : pt) | (B4 ? nt : 0) | (k7 ? st : 0) | (b7 ? ft : 0), K2 = R2 && R2.sdf, W3 = N.load(t10);
    W3.sdf = K2, W3.pattern = true, W3.textureBinding = R2.textureBinding, this._materialKey = W3.data, this._fillColor = n9, this._outlineColor = V, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p9), 255)), Math.round(Math.min(Math.sqrt(128 * S5), 255)), Math.round(Math.min(Math.sqrt(128 * z5), 255)), Math.round(Math.min(Math.sqrt(128 * g12), 255)));
    const X2 = R2.rect.x + et, q2 = R2.rect.y + et, Y = X2 + R2.width, H = q2 + R2.height;
    this._offsets.xUpperLeft = X2, this._offsets.yUpperLeft = q2, this._offsets.xUpperRight = Y, this._offsets.yUpperRight = q2, this._offsets.xBottomLeft = X2, this._offsets.yBottomLeft = H, this._offsets.xBottomRight = Y, this._offsets.yBottomRight = H, W3.symbologyType === S.PIE_CHART ? (this._texUpperLeft = w(0, 1), this._texUpperRight = w(1, 1), this._texBottomLeft = w(0, 0), this._texBottomRight = w(1, 0)) : (this._texUpperLeft = w(X2, q2), this._texUpperRight = w(Y, q2), this._texBottomLeft = w(X2, H), this._texBottomRight = w(Y, H)), p9 *= C5, S5 *= C5, p9 *= P4, S5 *= P4;
    const I = Math.round(64 * C5);
    this._bitestAndDistRatio = w(v6, I), this._computedWidth = p9, this._computedHeight = S5;
    const N2 = n3(), O2 = n();
    this._applyTransformation(O2, N2);
  }
  static fromCIMMarker(o13, s7, r14) {
    const n9 = s7 && s7.width || 1, h6 = s7 && s7.height || 1, m6 = o13.size, l6 = n9 / h6 * o13.scaleX, f13 = o13.scaleSymbolsProportionally && o13.frameHeight ? m6 / o13.frameHeight : 1, c10 = o7(o13.color), u13 = o7(o13.outlineColor), d7 = u(m6), p9 = d7 * l6, x8 = u(o13.offsetX || 0), M5 = u(o13.offsetY || 0), y8 = u(o13.outlineWidth || 0) * f13, _4 = o13.alignment || i3.SCREEN, g12 = u(o13.referenceSize), [V, z5] = x3(o13.scaleInfo, r14);
    let B4 = o13.rotation || 0;
    o13.rotateClockwise || (B4 = -B4);
    let k7 = 0, L3 = 0;
    const R2 = o13.anchorPoint;
    R2 && (o13.isAbsoluteAnchorPoint ? m6 && (k7 = R2.x / (m6 * l6), L3 = R2.y / m6) : (k7 = R2.x, L3 = R2.y));
    const j6 = new b5(o13.materialKey, x8, M5, B4, c10, p9, d7, g12, u13, y8, o13.colorLocked, o13.scaleSymbolsProportionally, false, _4, s7, k7, L3, o13.sizeRatio, l(o13.scaleFactor, 1), o13.markerPlacement, o13.effects, V, z5);
    return j6._vertexBoundsScaleX = o13.maxVVSize ? o13.maxVVSize / p9 : 1, j6._vertexBoundsScaleY = o13.maxVVSize ? o13.maxVVSize / d7 : 1, j6;
  }
  static fromPictureMarker(t10, o13) {
    const s7 = Math.round(u(t10.width)), r14 = Math.round(u(t10.height)), a7 = i, n9 = Math.round(u(t10.xoffset || 0)), h6 = Math.round(u(t10.yoffset || 0)), m6 = new b5(t10.materialKey, n9, h6, t10.angle, a7, s7, r14, r14, 0, 0, false, false, false, i3.SCREEN, o13, 0, 0, 1, 1, null, null, n6, o10);
    return m6._vertexBoundsScaleX = t10.maxVVSize ? t10.maxVVSize / t10.width : 1, m6._vertexBoundsScaleY = t10.maxVVSize ? t10.maxVVSize / t10.height : 1, m6;
  }
  static fromSimpleMarker(t10, o13) {
    const s7 = u2(t10.color), r14 = Math.round(u(t10.size)), a7 = r14, h6 = Math.round(u(t10.xoffset || 0)), m6 = Math.round(u(t10.yoffset || 0)), l6 = t10.style, f13 = t10.outline, c10 = 0 | ((f13 == null ? void 0 : f13.color) && u2(f13.color)), u13 = 0 | ((f13 == null ? void 0 : f13.width) && Math.round(u(f13.width))), d7 = new b5(t10.materialKey, h6, m6, t10.angle, s7, r14, a7, a7, c10, u13, false, false, "esriSMSCross" === l6 || "esriSMSX" === l6, i3.SCREEN, o13, 0, 0, 126 / 64, 1, null, null, n6, o10);
    return d7.boundsType = "esriSMSCircle" === l6 ? "circle" : "square", d7._vertexBoundsScaleX = t10.maxVVSize ? t10.maxVVSize / t10.size : 1, d7._vertexBoundsScaleY = t10.maxVVSize ? t10.maxVVSize / t10.size : 1, d7;
  }
  static fromLineSymbolMarker(t10, o13) {
    const s7 = u2(t10.color), a7 = 6, h6 = Math.round(u(a7 * t10.lineWidth)), m6 = h6, l6 = "cross" === t10.style || "x" === t10.style;
    let f13;
    switch (t10.placement) {
      case "begin-end":
        f13 = o5.Both;
        break;
      case "begin":
        f13 = o5.JustBegin;
        break;
      case "end":
        f13 = o5.JustEnd;
        break;
      default:
        f13 = o5.None;
    }
    const c10 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: f13, offsetAlongLine: 0 }, u13 = new b5(t10.materialKey, 0, 0, 0, s7, h6, m6, m6 / a7, s7, l6 ? Math.round(u(t10.lineWidth)) : 0, false, false, l6, i3.MAP, o13, 0, 0, 126 / 64, 1, c10, null, n6, o10);
    return u13.boundsType = "circle" === t10.style ? "circle" : "square", u13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var z3 = 5;
var g10 = class extends b4(r10) {
  constructor(e12, l6, a7, d7, _4, u13, b7, x8, g12, C5, M5, p9, S5, j6, L3, y8, T, V, k7, A3, v6, I, K2, R2) {
    super(), this._xOffset = u(S5), this._yOffset = u(j6), this._decoration = C5 || "none", this._backgroundColor = I, this._borderLineColor = K2, this._borderLineSize = R2, this._color = _4, this._haloColor = u13, this._haloSize = Math.min(Math.floor(z3 * u(o2(a7))), 127), this._size = Math.min(Math.round(u(l6)), 127);
    const W3 = Math.min(Math.round(u(d7 || l6)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * W3)), this._scale = this._size / j2, this._angle = p9, this._justify = s4(b7 || "center"), this._xAlignD = r5(b7 || "center"), this._yAlignD = n2(x8 || "baseline"), this._baseline = "baseline" === (x8 || "baseline"), this._bitset = (g12 === i3.MAP ? 1 : 0) | (M5 ? 1 : 0) << 1;
    const B4 = U.load(e12);
    B4.sdf = true, this._materialKey = B4.data, this._lineWidth = u(L3) || 512, this._lineHeight = y8 || 1, this._textPlacement = T, this._effects = V, this._isCIM = k7 ?? false, this._minMaxZoom = w(Math.round(A3 * at), Math.round(v6 * at));
  }
  static fromText(o13, t10) {
    var _a, _b;
    const r14 = (_a = o13.font) == null ? void 0 : _a.size, n9 = new g10(o13.materialKey, r14, o13.haloSize || 0, r14, o13.color && u2(o13.color) || 0, o13.haloColor && u2(o13.haloColor) || 0, o13.horizontalAlignment, o13.verticalAlignment, i3.SCREEN, (_b = o13.font) == null ? void 0 : _b.decoration, false, o13.angle || 0, o13.xoffset || 0, o13.yoffset || 0, o13.lineWidth || 0, o13.lineHeight || 0, null, null, false, n6, o10, o13.backgroundColor && u2(o13.backgroundColor), o13.borderLineColor && u2(o13.borderLineColor), o13.borderLineSize), [, s7] = i2(o13.text);
    return n9.bindTextInfo(t10 ?? [], s7), n9._vertexBoundsScale = o13.maxVVSize && r14 ? o13.maxVVSize / r14 : 1, n9;
  }
  static fromCIMText(o13, t10, i12) {
    const r14 = o13.scaleFactor || 1, n9 = o13.size * o13.sizeRatio * r14, [s7, l6] = x3(o13.scaleInfo, i12), m6 = new g10(o13.materialKey, n9, o13.outlineSize * o13.sizeRatio, o13.referenceSize, o7(o13.color), o7(o13.outlineColor), o13.horizontalAlignment, o13.verticalAlignment, o13.alignment, o13.decoration, o13.colorLocked ?? false, o13.angle, o13.offsetX * o13.sizeRatio * r14, o13.offsetY * o13.sizeRatio * r14, 512, 1, o13.markerPlacement, o13.effects, true, s7, l6, o13.backgroundColor ? o7(o13.backgroundColor) : void 0, o13.borderLineColor ? o7(o13.borderLineColor) : void 0, o13.borderLineWidth), [, h6] = i2(o13.text);
    return m6.bindTextInfo(t10, h6), m6._vertexBoundsScale = o13.maxVVSize ? o13.maxVVSize / n9 : 1, m6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r12 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = D();
  }
  release() {
    const e12 = this._resolver;
    this._resolver = null, e12 == null ? void 0 : e12.resolve();
  }
};
async function s6(e12, r14, s7) {
  try {
    await e12.acquire(), await r14(s7), e12.release();
  } catch (t10) {
    throw e12.release(), t10;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S3 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w7 = { sortKey: null, templates: new Array() };
var k5 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C3 = { ...r2, hash: JSON.stringify(r2), materialKey: f4(E.MARKER, k5) };
var L = { ...s3, hash: JSON.stringify(s3), materialKey: f4(E.LINE, k5) };
var b6 = { ...y, hash: JSON.stringify(y), materialKey: f4(E.FILL, k5) };
function E3(e12, t10) {
  const r14 = e12.length;
  return e12.push(null), t10.then((t11) => e12[r14] = t11), e12;
}
function G2(e12) {
  return null != e12 && !!(1 & e12);
}
function j5(e12) {
  return "worker:port-closed" === e12.name;
}
var x7 = class {
  constructor(e12, t10) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r12(), this._fetchResource = e12, this._tileInfo = t10;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e12, t10, r14 = null) {
    this._initErrorTemplates();
    const s7 = e12.hash, i12 = this._symbolToTemplate.get(s7);
    if (null != i12)
      return i12;
    const a7 = new Array(), o13 = { sortKey: r14, templates: a7 };
    t10 && this._createMeshTemplates(a7, t10, true), this._createMeshTemplates(a7, e12, false);
    const l6 = this._createGroupId("expanded-cim" === e12.type && F(e12));
    return this._idToTemplateGroup.set(l6, o13), this._symbolToTemplate.set(s7, l6), l6;
  }
  getTemplateGroup(e12) {
    return this._idToTemplateGroup.get(e12) ?? w7;
  }
  getDynamicTemplateGroup(e12) {
    return this._idToTemplateGroup.has(e12) ? (G2(e12) || S3.error("mapview-template-store", `Id ${e12} does not refer to a dynamic template`), this._idToTemplateGroup.get(e12)) : w7;
  }
  getMosaicItem(e12, t10) {
    const r14 = this._createTemplateId(), s7 = new Promise((e13) => this._idToResolver.set(r14, e13));
    return this._fetchQueue.push({ symbol: e12, id: r14, glyphIds: t10 }), s7;
  }
  finalize(e12) {
    return this._fetchQueue.length || this._lock.isHeld() ? s6(this._lock, this._fetchAllQueuedResources.bind(this), e12) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b6, false), marker: this._createMeshTemplates([], C3, false), line: this._createMeshTemplates([], L, false) });
  }
  _fetchAllQueuedResources(t10) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s7 = this._fetchQueue, i12 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i12).then(() => this._fetchResource(s7, t10).then((e12) => {
      for (const { id: t11, mosaicItem: r14 } of e12) {
        this._idToResolver.get(t11)(r14), this._idToResolver.delete(t11);
      }
    })).catch((t11) => {
      j(t11) ? this._fetchQueue = this._fetchQueue.concat(s7) : j5(t11) || S3.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t11));
    });
  }
  _createGroupId(e12) {
    return this._idCounter++ << 1 | (e12 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e12);
    return e10(t10, S3) ? b5.fromSimpleMarker(e12, t10) : this._markerError;
  }
  async _createPMS(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e12);
    return e10(t10, S3) ? b5.fromPictureMarker(e12, t10) : this._markerError;
  }
  async _createSFS(e12, t10) {
    const { spriteMosaicItem: r14 } = await this.getMosaicItem(e12);
    return e10(r14, S3) ? w6.fromSimpleFill(e12, r14, t10) : this._fillError;
  }
  async _createPFS(e12, t10) {
    const { spriteMosaicItem: r14 } = await this.getMosaicItem(e12);
    return e10(r14, S3) ? w6.fromPictureFill(e12, r14, t10) : this._fillError;
  }
  async _createSLS(e12, t10) {
    const { spriteMosaicItem: r14 } = await this.getMosaicItem(e12);
    return e10(r14, S3) ? K.fromSimpleLine(e12, r14) : this._lineError;
  }
  async _createLMS(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e12);
    return e10(t10, S3) ? b5.fromLineSymbolMarker(e12, t10) : this._markerError;
  }
  async _createTS(e12) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(e12);
    return g10.fromText(e12, t10 ?? []);
  }
  async _createCIMText(e12) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(n4(e12), n5(e12.text));
    return e10(t10, S3) ? g10.fromCIMText(e12, t10, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n4(e12));
    return e10(t10, S3) ? w6.fromCIMFill(e12, t10, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n4(e12));
    return e10(t10, S3) ? K.fromCIMLine(e12, t10, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e12) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n4(e12));
    return e10(t10, S3) ? b5.fromCIMMarker(e12, t10, this._tileInfo) : this._markerError;
  }
  async _createCIM(e12) {
    const t10 = e12.templateHash;
    let r14 = this._cimTemplateCache.get(t10);
    if (null != r14)
      return r14;
    switch (e12.type) {
      case "marker":
        r14 = await this._createCIMMarker(e12);
        break;
      case "line":
        r14 = await this._createCIMLine(e12);
        break;
      case "fill":
        r14 = await this._createCIMFill(e12);
        break;
      case "text":
        r14 = await this._createCIMText(e12);
    }
    return this._cimTemplateCache.set(t10, r14), r14;
  }
  async _createDynamicCIM(e12) {
    const t10 = e12.templateHash;
    let r14 = this._cimTemplateCache.get(t10);
    if (null != r14)
      return r14;
    switch (e12.type) {
      case "marker":
        r14 = P2.fromCIMMarker(e12, this._tileInfo);
        break;
      case "line":
        r14 = y4.fromCIMLine(e12, this._tileInfo);
        break;
      case "fill":
        r14 = g5.fromCIMFill(e12, this._tileInfo);
        break;
      case "text":
        r14 = g9.fromCIMText(e12, this._tileInfo);
    }
    return this._cimTemplateCache.set(t10, r14), r14;
  }
  _createPrimitiveMeshTemplates(e12, t10, r14) {
    switch (t10.type) {
      case "esriSMS":
        return E3(e12, this._createSMS(t10));
      case "esriPMS":
        return E3(e12, this._createPMS(t10));
      case "esriSFS":
        return E3(e12, this._createSFS(t10, r14));
      case "line-marker":
        return E3(e12, this._createLMS(t10));
      case "esriPFS":
        return E3(e12, this._createPFS(t10, r14));
      case "esriSLS":
        return E3(e12, this._createSLS(t10, false));
      case "esriTS":
        return E3(e12, this._createTS(t10));
      default:
        return S3.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e12;
    }
  }
  _createMeshTemplates(e12, t10, r14) {
    if (t10.type.includes("3d"))
      return S3.error("3D symbols are not supported with MapView"), e12;
    if ("expanded-cim" === t10.type) {
      for (const r15 of t10.layers)
        "function" == typeof r15.materialHash ? E3(e12, this._createDynamicCIM(r15)) : E3(e12, this._createCIM(r15));
      return e12;
    }
    if ("composite-symbol" === t10.type) {
      for (const s7 of t10.layers)
        this._createPrimitiveMeshTemplates(e12, s7, r14);
      return e12;
    }
    return "cim" === t10.type || "label" === t10.type || "web-style" === t10.type ? e12 : this._createPrimitiveMeshTemplates(e12, t10, r14);
  }
};
var F = (e12) => {
  if (!e12.layers)
    return false;
  for (const t10 of e12.layers)
    if ("function" == typeof t10.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function r13(t10, e12) {
  return t10[e12 + 1];
}
function h4(t10) {
  return t10.length - 1;
}
function a6(t10) {
  let e12 = 0;
  for (let s7 = 0; s7 < h4(t10); s7++)
    e12 += d5(t10, s7);
  return e12;
}
function d5(t10, e12, s7 = 1) {
  const [n9, i12] = r13(t10, e12);
  return Math.sqrt(n9 * n9 + i12 * i12) * s7;
}
var c8 = class {
  constructor(t10, e12, s7, n9, i12) {
    this._segments = t10, this._index = e12, this._distance = s7, this._xStart = n9, this._yStart = i12, this._done = false;
  }
  static create(t10) {
    return new c8(t10, 0, 0, t10[0][0], t10[0][1]);
  }
  clone() {
    return new c8(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t10) {
    return this._index === t10._index || t10._index === this._index - 1 && (0 === this._distance || 1 === t10._distance) || t10._index === this._index + 1 && (1 === this._distance || 0 === t10._distance);
  }
  leq(t10) {
    return this._index < t10._index || this._index === t10._index && this._distance <= t10._distance;
  }
  geq(t10) {
    return this._index > t10._index || this._index === t10._index && this._distance >= t10._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t10 = this.dy, e12 = (0 * t10 + -1 * -this.dx) / (1 * this.length);
    let s7 = Math.acos(e12);
    return t10 > 0 && (s7 = 2 * Math.PI - s7), s7;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t10, dy: e12 } = this;
    return Math.sqrt(t10 * t10 + e12 * e12);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < h4(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t10, e12) {
    const s7 = this.backwardLength;
    if (t10 <= s7)
      return this._distance = (s7 - t10) / this.length, this;
    let n9 = this.backwardLength;
    for (; this.prev(); ) {
      if (n9 + this.length > t10)
        return this._seekBackwards(t10 - n9);
      n9 += this.length;
    }
    return this._distance = 0, e12 ? this : null;
  }
  seek(t10, e12 = false) {
    if (t10 < 0)
      return this._seekBackwards(Math.abs(t10), e12);
    if (t10 <= this.remainingLength)
      return this._distance = (this.backwardLength + t10) / this.length, this;
    let s7 = this.remainingLength;
    for (; this.next(); ) {
      if (s7 + this.length > t10)
        return this.seek(t10 - s7, e12);
      s7 += this.length;
    }
    return this._distance = 1, e12 ? this : null;
  }
};
function u11(t10, e12, s7, n9 = true) {
  const i12 = a6(t10), r14 = c8.create(t10), h6 = i12 / 2;
  if (!n9)
    return r14.seek(h6), void s7(r14.clone(), 0, h6 + 0 * e12, i12);
  const d7 = Math.max((i12 - e12) / 2, 0), u13 = Math.floor(d7 / e12), o13 = h6 - u13 * e12;
  r14.seek(o13);
  for (let a7 = -u13; a7 <= u13; a7++)
    r14.x < 512 && r14.x >= 0 && r14.y < 512 && r14.y >= 0 && s7(r14.clone(), a7, h6 + a7 * e12, i12), r14.seek(e12);
}
function l4(t10, e12) {
  const s7 = e12;
  for (let n9 = 0; n9 < t10.length; n9++) {
    let e13 = t10[n9];
    const i12 = [];
    i12.push(e13[0]);
    for (let t11 = 1; t11 < e13.length; t11++) {
      let [s8, n10] = i12[t11 - 1];
      s8 += e13[t11][0], n10 += e13[t11][1], i12.push([s8, n10]);
    }
    g11(i12, s7);
    const r14 = [];
    r14.push(i12[0]);
    for (let t11 = 1; t11 < i12.length; t11++) {
      const [e14, s8] = i12[t11 - 1], [n10, h6] = i12[t11], a7 = Math.round(n10 - e14), d7 = Math.round(h6 - s8);
      r14.push([a7, d7]);
    }
    t10[n9] = r14, e13 = r14;
  }
  return t10;
}
function g11(t10, e12) {
  const r14 = 1e-6;
  if (e12 <= 0)
    return;
  const h6 = t10.length;
  if (h6 < 3)
    return;
  const a7 = [];
  let d7 = 0;
  a7.push(0);
  for (let n9 = 1; n9 < h6; n9++)
    d7 += u4(t10[n9], t10[n9 - 1]), a7.push(d7);
  e12 = Math.min(e12, 0.2 * d7);
  const c10 = [];
  c10.push(t10[0][0]), c10.push(t10[0][1]);
  const u13 = t10[h6 - 1][0], o13 = t10[h6 - 1][1], _4 = t8([0, 0], t10[0], t10[1]);
  r7(_4), t10[0][0] += e12 * _4[0], t10[0][1] += e12 * _4[1], t8(_4, t10[h6 - 1], t10[h6 - 2]), r7(_4), t10[h6 - 1][0] += e12 * _4[0], t10[h6 - 1][1] += e12 * _4[1];
  for (let s7 = 1; s7 < h6; s7++)
    a7[s7] += e12;
  a7[h6 - 1] += e12;
  const l6 = 0.5 * e12;
  for (let s7 = 1; s7 < h6 - 1; s7++) {
    let n9 = 0, i12 = 0, d8 = 0;
    for (let h7 = s7 - 1; h7 >= 0 && !(a7[h7 + 1] < a7[s7] - l6); h7--) {
      const c11 = l6 + a7[h7 + 1] - a7[s7], u14 = a7[h7 + 1] - a7[h7], o14 = a7[s7] - a7[h7] < l6 ? 1 : c11 / u14;
      if (Math.abs(o14) < r14)
        break;
      const _5 = o14 * o14, g12 = o14 * c11 - 0.5 * _5 * u14, x8 = o14 * u14 / e12, f13 = t10[h7 + 1], y8 = t10[h7][0] - f13[0], k7 = t10[h7][1] - f13[1];
      n9 += x8 / g12 * (f13[0] * o14 * c11 + 0.5 * _5 * (c11 * y8 - u14 * f13[0]) - _5 * o14 * u14 * y8 / 3), i12 += x8 / g12 * (f13[1] * o14 * c11 + 0.5 * _5 * (c11 * k7 - u14 * f13[1]) - _5 * o14 * u14 * k7 / 3), d8 += x8;
    }
    for (let c11 = s7 + 1; c11 < h6 && !(a7[c11 - 1] > a7[s7] + l6); c11++) {
      const h7 = l6 - a7[c11 - 1] + a7[s7], u14 = a7[c11] - a7[c11 - 1], o14 = a7[c11] - a7[s7] < l6 ? 1 : h7 / u14;
      if (Math.abs(o14) < r14)
        break;
      const _5 = o14 * o14, g12 = o14 * h7 - 0.5 * _5 * u14, x8 = o14 * u14 / e12, f13 = t10[c11 - 1], y8 = t10[c11][0] - f13[0], k7 = t10[c11][1] - f13[1];
      n9 += x8 / g12 * (f13[0] * o14 * h7 + 0.5 * _5 * (h7 * y8 - u14 * f13[0]) - _5 * o14 * u14 * y8 / 3), i12 += x8 / g12 * (f13[1] * o14 * h7 + 0.5 * _5 * (h7 * k7 - u14 * f13[1]) - _5 * o14 * u14 * k7 / 3), d8 += x8;
    }
    c10.push(n9 / d8), c10.push(i12 / d8);
  }
  c10.push(u13), c10.push(o13);
  for (let s7 = 0, n9 = 0; s7 < h6; s7++)
    t10[s7][0] = c10[n9++], t10[s7][1] = c10[n9++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var L2 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var S4 = (t10, i12 = "mapview-labeling") => L2.error(new s2(i12, t10));
var v5 = 1;
var P3 = 0;
var w8 = 4;
var M4 = 25;
function Z3(e12, t10) {
  const o13 = !!e12.minScale && t10.scaleToZoom(e12.minScale) || 0;
  return a(o13, 0, 25.5);
}
function k6(e12, t10) {
  const o13 = !!e12.maxScale && t10.scaleToZoom(e12.maxScale) || 255;
  return a(o13, 0, 25.5);
}
function A2(e12) {
  const t10 = /* @__PURE__ */ new Map();
  return (i12) => (t10.has(i12) || t10.set(i12, e12(i12)), t10.get(i12));
}
var B3 = A2((e12) => {
  let t10 = 0;
  if (0 === e12)
    return 1 / 0;
  for (; !(e12 % 2); )
    t10++, e12 /= 2;
  return t10;
});
var z4 = (e12) => Math.floor(127 * e12 + 127);
var C4 = (e12) => Math.floor(10 * e12);
var W2 = (e12) => Math.round(e12 * (254 / 360));
var G3 = class extends g10 {
  constructor(e12, t10, i12, o13) {
    var _a, _b, _c;
    super(e12, (_a = i12.font) == null ? void 0 : _a.size, i12.haloSize || 0, (_b = i12.font) == null ? void 0 : _b.size, i12.color && u2(i12.color) || 0, i12.haloColor && u2(i12.haloColor) || 0, i12.horizontalAlignment, i12.verticalAlignment, i5(t10.labelPlacement) ? i3.MAP : i3.SCREEN, (_c = i12.font) == null ? void 0 : _c.decoration, false, i12.angle || 0, i12.xoffset, i12.yoffset, i12.lineWidth, i12.lineHeight, null, null, false, null, null, i12.backgroundColor && u2(i12.backgroundColor), i12.borderLineColor && u2(i12.borderLineColor), i12.borderLineSize), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = t10.allowOverrun ?? false, this._repeatLabel = t10.repeatLabel ?? true, this._labelPosition = t10.labelPosition ?? "curved";
    const r14 = Z3(t10, o13), s7 = k6(t10, o13), a7 = t10.labelPlacement, [m6, _4] = a2(a7);
    this._xAlignD = m6, this._yAlignD = _4, this._minZoom = r14, this._maxZoom = s7, this._minBackgroundZoom = r14, this._maxBackgroundZoom = s7, this._refPlacementPadding = u(i12.haloSize) + k, this._repeatLabelDistance = t10.repeatLabelDistance ? u(t10.repeatLabelDistance) : 128;
    const u13 = Z.load(e12);
    u13.sdf = true, this._materialKey = u13.data;
  }
  static fromLabelClass(e12, t10) {
    if ("esriServerLinePlacementCenterAlong" === e12.labelPlacement) {
      const t11 = e12.symbol;
      t11.xoffset = 0, t11.yoffset = 0, t11.angle = 0, t11.font.decoration = "none";
    }
    return new G3(e12.materialKey, e12, e12.symbol, t10);
  }
  get _shapedBox() {
    return e(this._shapingInfo).bounds;
  }
  setZoomLevel(e12) {
    this._zoomLevel = e12;
  }
  bindReferenceTemplate(e12) {
    let t10 = c(this._xAlignD), i12 = o6(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, t(e12))
      return void (this._refSymbolAndPlacementOffset = x(0, 0, z4(t10), z4(i12)));
    if ("circle" === e12.boundsType && (t10 || i12)) {
      const e13 = Math.sqrt(t10 * t10 + i12 * i12);
      t10 /= e13, i12 /= e13;
    }
    const o13 = Math.max(e12.height, e12.width), n9 = this._refPlacementPadding * w8;
    this._refSymbolAndPlacementOffset = x(n9, o13, z4(t10), z4(i12)), this._referenceSize = o13, this._refPlacementDirX = t10, this._refPlacementDirY = i12, this._refOffsetX = e12.xOffset, this._refOffsetY = e12.yOffset;
  }
  _write(e12, t10) {
    if (t(this._shapingInfo))
      return;
    const i12 = this._shapingInfo, o13 = t10.getDisplayId(), n9 = "esriGeometryPolygon" === t10.geometryType ? t10.readLegacyCentroid() : t10.readLegacyGeometry();
    if (n9)
      switch (this._current = { out: e12, inId: o13, inShaping: i12, zoomLevel: this._zoomLevel }, "esriGeometryPolyline" === t10.geometryType && "curved" === this._labelPosition && (this._borderLineColor || this._backgroundColor) && L2.warnOnce("TextSymbol properties 'borderLineColor', 'borderLineSize', and 'backgroundColor' are not supported in curved labels"), t10.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(n9);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(n9);
          break;
        default:
          S4(`Geometry of type ${t10.geometryType} is not supported`);
      }
  }
  _isVisible(e12, t10) {
    const i12 = C4(this._current.zoomLevel);
    return C4(e12) <= i12 && i12 <= C4(t10);
  }
  _placePointLabels(e12) {
    const { out: t10, inId: i12, inShaping: o13 } = this._current;
    this._writeGlyphs(t10, i12, e12, o13);
  }
  _placeLineLabels(e12) {
    const t10 = l4(e12.paths, this._current.inShaping.bounds.width), i12 = this._placeSubdivGlyphs.bind(this), o13 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << v5);
    for (const r14 of t10)
      u11(r14, o13, i12, this._repeatLabel);
  }
  _placeSubdivGlyphs(e12, t10, i12, o13) {
    const r14 = B3(t10), n9 = this._shapedBox.width / (1 << v5), s7 = Math.sqrt(this._repeatLabelDistance) / (1 << v5), a7 = Math.min(i12, o13 - i12), l6 = this._current.inShaping.isMultiline ? M4 : Math.log2(a7 / (s7 + n9 / 2)), h6 = 0 === t10 ? l6 : Math.min(r14, l6), c10 = Math.max(this._minZoom, this._current.zoomLevel + v5 - h6), m6 = this._current.zoomLevel - c10, _4 = this._shapedBox.width / 2 * 2 ** m6;
    this._current.inShaping.isMultiline ? 0 === t10 && this._placeStraight(e12, c10) : this._allowOverrun && m6 < 0 ? this._placeStraightAlong(e12, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e12, c10) : "curved" === this._labelPosition && this._placeCurved(e12, c10, _4);
  }
  _placeStraight(e12, t10) {
    const { out: i12, inId: o13, inShaping: r14 } = this._current, n9 = Math.ceil(e12.angle * (180 / Math.PI) % 360), s7 = Math.ceil((e12.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = W2(n9), this._writeGlyphs(i12, o13, e12, r14, t10), this._outLineLabelAngle = W2(s7), this._writeGlyphs(i12, o13, e12, r14, t10);
  }
  _placeCurved(e12, t10, i12) {
    const { out: o13, inId: r14 } = this._current;
    o13.metricStart(r14, t10, e12.x, e12.y, 0, 0, 0, 0);
    const n9 = e12.clone(), s7 = e12.angle * (180 / Math.PI) % 360, a7 = (e12.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = W2(s7), this._placeFirst(n9, t10, 1), this._placeBack(e12, n9, t10, i12, 1), this._placeForward(e12, n9, t10, i12, 1), this._outLineLabelAngle = W2(a7), this._placeFirst(n9, t10, 0), this._placeBack(e12, n9, t10, i12, 0), this._placeForward(e12, n9, t10, i12, 0), o13.metricEnd();
  }
  _placeStraightAlong(e12, t10) {
    const { out: i12, inId: o13, inShaping: r14 } = this._current;
    i12.metricStart(o13, t10, e12.x, e12.y, 0, 0, 0, 0);
    const n9 = e12.clone(), l6 = e12.angle * (180 / Math.PI) % 360, h6 = (e12.angle * (180 / Math.PI) + 180) % 360, c10 = r14.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor);
    if (this._maxBackgroundZoom = M4, this._minBackgroundZoom = Math.max(t10, 0), c10) {
      const t11 = Z.load(this._materialKey);
      t11.textureBinding = r14.glyphs[0].textureBinding;
      const n10 = h(n(), -e12.angle), [c11, m6] = r14.shapeBackground(n10);
      this._outLineLabelAngle = W2(l6), i12.recordStart(o13, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i12, o13, e12, c11, m6), i12.recordEnd(), this._outLineLabelAngle = W2(h6), i12.recordStart(o13, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i12, o13, e12, c11, m6), i12.recordEnd();
    }
    this._outLineLabelAngle = W2(l6), this._placeFirst(n9, t10, 1, true), this._outLineLabelAngle = W2(h6), this._placeFirst(n9, t10, 0, true), i12.metricEnd();
  }
  _placeBack(e12, t10, i12, o13, r14) {
    const n9 = e12.clone();
    let s7 = e12.backwardLength + P3;
    for (; n9.prev() && !(s7 >= o13); )
      this._placeOnSegment(n9, t10, s7, i12, -1, r14), s7 += n9.length + P3;
  }
  _placeForward(e12, t10, i12, o13, r14) {
    const n9 = e12.clone();
    let s7 = e12.remainingLength + P3;
    for (; n9.next() && !(s7 >= o13); )
      this._placeOnSegment(n9, t10, s7, i12, 1, r14), s7 += n9.length + P3;
  }
  _placeFirst(e12, t10, i12, o13 = false) {
    const r14 = e12, n9 = this._current.inShaping, s7 = n9.glyphs, a7 = this._current.zoomLevel, { out: l6, inId: h6 } = this._current;
    for (const c10 of s7) {
      const s8 = c10.x > n9.bounds.x ? i12 : 1 - i12, m6 = s8 * e12.remainingLength + (1 - s8) * e12.backwardLength, _4 = Math.abs(c10.x + c10.width / 2 - n9.bounds.x), g12 = Math.max(0, a7 + Math.log2(_4 / (m6 + P3))), d7 = Math.max(t10, o13 ? 0 : g12);
      if (c10.maxZoom = M4, c10.angle = e12.angle + (1 - i12) * Math.PI, c10.minZoom = d7, this._writeGlyph(l6, h6, r14.x, r14.y, c10), i12 && this._isVisible(c10.minZoom, c10.maxZoom)) {
        const e13 = c10.bounds;
        l6.metricBoxWrite(e13.center[0], e13.center[1], e13.width, e13.height);
      }
    }
  }
  _placeOnSegment(e12, t10, i12, o13, r14, n9) {
    const s7 = this._current.inShaping.glyphs, { out: a7, inId: l6 } = this._current, h6 = this._current.inShaping, c10 = this._current.zoomLevel, m6 = e12.dx / e12.length, _4 = e12.dy / e12.length, g12 = { x: e12.x + i12 * -r14 * m6, y: e12.y + i12 * -r14 * _4 };
    for (const d7 of s7) {
      const s8 = d7.x > h6.bounds.x ? n9 : 1 - n9;
      if (!(s8 && 1 === r14 || !s8 && -1 === r14))
        continue;
      const m7 = Math.abs(d7.x + d7.width / 2 - h6.bounds.x), _5 = Math.max(0, c10 + Math.log2(m7 / i12) - 0.1), f13 = Math.max(o13, c10 + Math.log2(m7 / (i12 + e12.length + P3)));
      if (0 !== _5 && (d7.angle = e12.angle + (1 - n9) * Math.PI, d7.minZoom = f13, d7.maxZoom = _5, this._writeGlyph(a7, l6, g12.x, g12.y, d7), n9 && this._isVisible(d7.minZoom, d7.maxZoom))) {
        const i13 = d7.bounds, o14 = e12.x - t10.x, r15 = e12.y - t10.y;
        a7.metricBoxWrite(i13.center[0] + o14, i13.center[1] + r15, i13.width, i13.height);
      }
    }
  }
  _writeGlyphs(e12, t10, i12, o13, r14 = this._minZoom) {
    if (i12.x < 0 || i12.x >= 512 || i12.y < 0 || i12.y >= 512)
      return;
    if (o13.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor)) {
      const r15 = Z.load(this._materialKey);
      r15.textureBinding = o13.glyphs[0].textureBinding, e12.recordStart(t10, r15.data, this.geometryType, true), this._writeBackgroundGeometry(e12, t10, i12, o13.bounds, o13.background), e12.recordEnd();
    }
    const n9 = i12.x + this._refOffsetX, s7 = i12.y - this._refOffsetY;
    for (const c10 of o13.glyphs)
      c10.minZoom = r14, c10.maxZoom = this._maxZoom, this._writeGlyph(e12, t10, n9, s7, c10);
    const a7 = this._refPlacementDirX, l6 = this._refPlacementDirY, h6 = o13.boundsT;
    e12.metricStart(t10, r14, n9, s7, a7, l6, this._referenceSize, this._materialKey), e12.metricBoxWrite(h6.center[0], h6.center[1], h6.width, h6.height), e12.metricEnd();
  }
  _writeVertexCommon(e12, t10, i12, o13) {
    const r14 = this._color, n9 = this._haloColor, s7 = x(0, 0, this._size, this._haloSize), a7 = Math.max(o13.minZoom, this._minZoom), l6 = Math.min(o13.maxZoom, this._maxZoom), h6 = x(C4(a7), C4(l6), this._outLineLabelAngle, 0);
    e12.vertexWrite(i12), e12.vertexWrite(t10), e12.vertexWrite(r14), e12.vertexWrite(n9), e12.vertexWrite(s7), e12.vertexWrite(this._refSymbolAndPlacementOffset), e12.vertexWrite(h6);
  }
  _writeBackgroundVertex(e12, t10, i12, o13, r14, n9) {
    const s7 = x(0, 0, this._size, this._haloSize), a7 = x(0, 0, 0, 0), l6 = x(C4(this._minBackgroundZoom), C4(this._maxBackgroundZoom), this._outLineLabelAngle, 1);
    e12.vertexWrite(i12), e12.vertexWrite(t10), e12.vertexWrite(o13), e12.vertexWrite(a7), e12.vertexWrite(s7), e12.vertexWrite(this._refSymbolAndPlacementOffset), e12.vertexWrite(l6), e12.vertexWrite(r14), e12.vertexWrite(n9), e12.vertexEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var n8 = class {
  constructor(e12, t10, r14) {
    this._loadPromise = i4(), this._geometryType = e12, this._idField = t10, this._templateStore = r14;
  }
  update(t10, r14) {
    r(t10.mesh.labels) && (this._labelTemplates = this._createLabelTemplates(t10.mesh.labels, r14)), this._schema = t10;
  }
  _createLabelTemplates(e12, t10) {
    const r14 = /* @__PURE__ */ new Map();
    if ("simple" === e12.type) {
      for (const s7 of e12.classes) {
        const e13 = G3.fromLabelClass(s7, t10);
        r14.set(s7.index, e13);
      }
      return r14;
    }
    for (const s7 in e12.classes) {
      const i12 = e12.classes[s7];
      for (const e13 of i12) {
        const s8 = G3.fromLabelClass(e13, t10);
        r14.set(e13.index, s8);
      }
    }
    return r14;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(t10, s7, o13, l6, n9, m6, p9) {
    if (p(p9))
      return;
    let f13;
    "dictionary" === (o13 == null ? void 0 : o13.type) && (f13 = await o13.analyze(this._idField, t10.copy(), s7, n9, m6, p9));
    let c10 = 0;
    for (; t10.next(); ) {
      let r14 = null;
      if (r14 = f13 ? f13[c10++] : r(l6) && p2(t10.getDisplayId()) && 1 !== t10.readAttribute("cluster_count") ? l6.match(this._idField, t10, this._geometryType, n9, m6) : o13.match(this._idField, t10, this._geometryType, n9, m6), t10.setGroupId(r14), G2(r14)) {
        const e12 = this._templateStore.getDynamicTemplateGroup(r14).templates;
        for (const r15 of e12)
          r15 && r15.analyze && r15.analyze(this._templateStore, t10, n9, m6);
      }
    }
    return await this._loadPromise, this._templateStore.finalize(p9);
  }
  async analyzeGraphics(e12, t10, s7, i12, o13, l6) {
    if (p(l6))
      return;
    const n9 = e12.getCursor();
    for (s7 && await s7.analyze(this._idField, n9.copy(), t10, i12, o13, l6); n9.next(); ) {
      let e13 = n9.getGroupId();
      if (null != e13 && -1 !== e13 || (e13 = s7 == null ? void 0 : s7.match(this._idField, n9, n9.geometryType, i12, o13), n9.setGroupId(e13)), G2(e13)) {
        const t11 = this._templateStore.getDynamicTemplateGroup(e13).templates;
        for (const e14 of t11)
          e14 && e14.analyze && e14.analyze(this._templateStore, n9, i12, o13);
      }
      n9.setGroupId(e13);
    }
    return await this._loadPromise, this._templateStore.finalize(l6);
  }
  writeGraphic(e12, t10, r14, s7) {
    const i12 = t10.getGroupId(), o13 = t10.getDisplayId(), l6 = this._templateStore.getTemplateGroup(i12);
    if (e12.featureStart(t10.insertAfter, 0), null != o13) {
      if (G2(i12))
        for (const e13 of l6.templates)
          e13 && e13.bindFeature(t10, null, null);
      if (l6) {
        for (const i13 of l6.templates)
          i13 && i13.write(e12, t10, r14, s7);
        e12.featureEnd();
      }
    }
  }
  writeCursor(t10, r14, s7, i12, o13, l6, n9) {
    const m6 = r14.getGroupId(), p9 = r14.getDisplayId(), f13 = this._templateStore.getTemplateGroup(m6), c10 = f13.templates, d7 = this._getSortKeyValue(r14, f13);
    if (t10.featureStart(0, d7), null != p9 && c10) {
      if (G2(m6))
        for (const e12 of c10)
          e12.bindFeature(r14, s7, i12);
      for (const e12 of c10)
        e12.write(t10, r14, o13, n9);
      if (r(l6) && t10.hasRecords) {
        const e12 = l6 && this._findLabelRef(c10);
        this._writeLabels(t10, r14, l6, e12, o13, n9);
      }
      t10.featureEnd();
    }
  }
  _getSortKeyValue(e12, r14) {
    const s7 = this._schema.mesh.sortKey;
    if (t(s7))
      return 0;
    let i12 = 0;
    return i12 = true === s7.byRenderer && null != r14.sortKey ? r14.sortKey : null != s7.fieldIndex ? e12.getComputedNumericAtIndex(s7.fieldIndex) : null != s7.field ? e12.readAttribute(s7.field) : e12.readAttribute(this._idField), i12 *= "asc" === s7.order ? 1 : -1, null == i12 || isNaN(i12) ? 0 : i12;
  }
  _findLabelRef(e12) {
    for (const t10 of e12)
      if (t10 instanceof b5)
        return t10;
    return null;
  }
  _writeLabels(t10, r14, s7, i12, o13, l6) {
    for (const a7 of s7)
      if (r(a7) && a7) {
        const { glyphs: e12, rtl: s8, index: n9 } = a7, m6 = this._labelTemplates.get(n9);
        if (!m6)
          continue;
        m6.setZoomLevel(o13), m6.bindReferenceTemplate(i12), m6.bindTextInfo(e12, s8), m6.write(t10, r14, null, l6);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var l5 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function o12(e12, t10, s7, r14) {
  switch (e12.type) {
    case "simple":
    case "heatmap":
      return u12.fromBasicRenderer(e12, t10, s7, r14);
    case "map":
      return d6.fromUVRenderer(e12, t10, s7, r14);
    case "interval":
      return m5.fromCBRenderer(e12, t10, s7, r14);
    case "dictionary":
      return y7.fromDictionaryRenderer(e12, t10, s7, r14);
    case "pie-chart":
      return c9.fromPieChartRenderer(e12, t10, s7, r14);
    case "subtype":
      return c9.fromSubtypes(e12, t10, s7, r14);
  }
}
var u12 = class {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e12, t10, s7, r14) {
    const i12 = new u12();
    if (e12.symbol) {
      const a7 = await i7(e12.symbol, s7, r14), l6 = t10.createTemplateGroup(a7, null);
      i12.setDefault(l6);
    }
    return i12;
  }
  static async fromPieChartRenderer(e12, t10, s7, r14) {
    const i12 = new u12();
    if (e12.markerSymbol) {
      const a7 = await i7(e12.markerSymbol, s7, r14);
      let l6;
      e12.fillSymbol && (l6 = await i7(e12.fillSymbol, s7, r14));
      const o13 = t10.createTemplateGroup(a7, l6);
      i12.setDefault(o13);
    }
    return i12;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e12) {
    this._defaultResult = e12;
  }
  match(e12, t10, s7, r14, i12) {
    return this.getDefault();
  }
  async analyze(e12, t10, s7, r14, i12, a7) {
    return null;
  }
};
var c9 = class extends u12 {
  constructor(e12, t10) {
    super(), this._subMatchers = e12, this._subtypeField = t10;
  }
  static async fromSubtypes(e12, t10, s7, r14) {
    const i12 = /* @__PURE__ */ new Map(), a7 = [];
    for (const n9 in e12.renderers) {
      const l6 = parseInt(n9, 10), u13 = o12(e12.renderers[n9], t10, s7, r14).then((e13) => i12.set(l6, e13));
      a7.push(u13);
    }
    return await Promise.all(a7), new c9(i12, e12.subtypeField);
  }
  match(e12, t10, s7, r14, i12) {
    const a7 = t10.readAttribute(this._subtypeField), n9 = this._subMatchers.get(a7);
    return n9 ? n9.match(e12, t10, s7, r14, i12) : null;
  }
};
var m5 = class extends u12 {
  constructor(e12, t10, s7, r14) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t10, this._fieldIndex = r14, this._field = e12, this._normalizationInfo = s7;
  }
  static async fromCBRenderer(e12, t10, s7, r14) {
    const { isMaxInclusive: i12, normalizationField: a7, normalizationTotal: l6, normalizationType: o13 } = e12, u13 = e12.field, c10 = new m5(u13, i12, { normalizationField: a7, normalizationTotal: l6, normalizationType: o13 }, e12.fieldIndex), d7 = await i7(e12.backgroundFillSymbol, s7, r14);
    await Promise.all(e12.intervals.map(async (e13) => {
      const i13 = await i7(e13.symbol, s7, r14), a8 = await t10.createTemplateGroup(i13, d7), l7 = { min: e13.min, max: e13.max };
      c10.add(l7, a8);
    }));
    const h6 = await i7(e12.defaultSymbol, s7, r14);
    if (h6) {
      const e13 = await t10.createTemplateGroup(h6, d7);
      c10.setDefault(e13);
    }
    return c10;
  }
  add(e12, t10) {
    this._intervals.push({ interval: e12, result: t10 }), this._intervals.sort((e13, t11) => e13.interval.min - t11.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e12, t10, s7, r14, i12) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a7 = null != this._fieldIndex ? t10.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t10);
    if (null == a7 || isNaN(a7) || a7 === 1 / 0 || a7 === -1 / 0)
      return this.getDefault();
    for (let n9 = 0; n9 < this._intervals.length; n9++) {
      const { interval: e13, result: t11 } = this._intervals[n9], s8 = a7 >= e13.min, r15 = this._isMaxInclusive ? a7 <= e13.max : a7 < e13.max;
      if (s8 && r15)
        return t11;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e12 = this._normalizationInfo;
    return e12 && (e12.normalizationField || e12.normalizationTotal || e12.normalizationType);
  }
  _getValueFromField(e12) {
    const t10 = e12.readAttribute(this._field);
    if (!this._needsNormalization() || null == t10)
      return t10;
    const { normalizationField: s7, normalizationTotal: r14, normalizationType: i12 } = this._normalizationInfo, a7 = e12.readAttribute(s7) ?? 1;
    if (i12)
      switch (i12) {
        case "esriNormalizeByField":
          return a7 ? t10 / a7 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t10) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t10 / r14 * 100;
        default:
          return void l5.error(`Found unknown normalization type: ${i12}`);
      }
    else
      l5.error("Normalization is required, but no type was set!");
  }
};
var d6 = class extends u12 {
  constructor(e12, t10, s7) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fieldsIndex = s7, this._fields = e12, this._seperator = t10 || "";
  }
  static async fromUVRenderer(e12, t10, s7, r14) {
    const i12 = e12.fieldDelimiter, a7 = [e12.field];
    e12.field2 && a7.push(e12.field2), e12.field3 && a7.push(e12.field3);
    const l6 = await i7(e12.backgroundFillSymbol, s7, r14), o13 = new d6(a7, i12, e12.fieldIndex);
    await Promise.all(e12.map.map(async (e13, i13) => {
      const a8 = await i7(e13.symbol, s7, r14), u14 = i13 + 1, c10 = await t10.createTemplateGroup(a8, l6, u14);
      "<Null>" === e13.value ? o13.setNullResult(c10) : o13.add(e13.value, c10);
    }));
    const u13 = await i7(e12.defaultSymbol, s7, r14);
    if (u13) {
      const e13 = Number.MAX_SAFE_INTEGER, s8 = await t10.createTemplateGroup(u13, l6, e13);
      o13.setDefault(s8);
    }
    return o13;
  }
  setNullResult(e12) {
    this._nullResult = e12;
  }
  add(e12, t10) {
    this._resultsMap.set(e12.toString(), t10);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e12, t10, s7, r14, i12) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a7 = null != this._fieldsIndex ? t10.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t10);
    if (null !== this._nullResult && (null == a7 || "" === a7 || "<Null>" === a7))
      return this._nullResult;
    if (null == a7)
      return this.getDefault();
    const n9 = a7.toString();
    return this._resultsMap.has(n9) ? this._resultsMap.get(n9) : this.getDefault();
  }
  _getValueFromFields(e12) {
    const t10 = [];
    for (const s7 of this._fields) {
      const r14 = e12.readAttribute(s7);
      null == r14 || "" === r14 ? t10.push("<Null>") : t10.push(r14);
    }
    return t10.join(this._seperator);
  }
};
async function h5(e12, t10) {
  const s7 = e12 || 1;
  if ("number" == typeof s7)
    return (e13, t11, r15) => s7;
  const r14 = await o8(s7, t10.spatialReference, t10.fields);
  return (e13, s8, i12) => i6(r14, e13, { $view: i12 }, t10.geometryType, s8) || 1;
}
var f12;
async function p8() {
  return f12 || (f12 = import("./createSymbolSchema-7H2FJJGU.js")), f12;
}
var y7 = class extends u12 {
  constructor(e12, t10, r14, i12, a7, n9) {
    super(), this.type = "dictionary", this._groupIdCache = new e2(100), this._loader = e12, this._fieldMap = e12.fieldMap, this._symbolFields = e12.getSymbolFields(), this._templates = t10, this._info = r14, this._scaleFn = i12, this._schemaUtilsModule = a7, this._symbolOptions = n9;
  }
  static async fromDictionaryRenderer(e12, t10, s7, r14) {
    const [{ DictionaryLoader: i12 }, a7] = await Promise.all([import("./DictionaryLoader-PXSNOSGD.js"), p8()]), n9 = new i12(e12.url, e12.config, e12.fieldMap);
    await n9.fetchResources({ spatialReference: s7.spatialReference, fields: s7.fields });
    const l6 = await h5(e12.scaleExpression, s7);
    return new y7(n9, t10, s7, l6, a7, e12.symbolOptions);
  }
  async _analyzeFeature(t10, s7, r14, i12, a7) {
    const o13 = t10.readLegacyFeature(), u13 = this._scaleFn(o13, r14, i12), c10 = this._attributeHash(o13) + "-" + u13, m6 = this._groupIdCache.get(c10);
    if (m6)
      return m6;
    const d7 = { ...i12, spatialReference: this._info.spatialReference, abortOptions: a7, fields: this._info.fields }, h6 = await this._loader.getSymbolAsync(o13, d7), f13 = this._schemaUtilsModule.createSymbolSchema(h6, this._symbolOptions), p9 = i7(f13, this._info, s7, a7).then((t11) => {
      if ("expanded-cim" !== (t11 == null ? void 0 : t11.type))
        return l5.error(new s2("mapview-bad-type", `Found unexpected type ${t11 == null ? void 0 : t11.type} in dictionary response`)), null;
      t11.hash += "-" + u13;
      for (const e12 of t11.layers)
        e12.scaleFactor = u13, e12.templateHash += "-" + u13;
      return this._templates.createTemplateGroup(t11, null);
    });
    return this._groupIdCache.put(c10, p9, 1), p9;
  }
  async analyze(e12, t10, s7, i12, a7, n9) {
    const l6 = t10.getCursor(), o13 = [];
    for (; l6.next(); )
      o13.push(this._analyzeFeature(l6, s7, i12, a7, n9));
    return Promise.all(o13).then((e13) => e13.filter(r));
  }
  match(e12, t10, s7, r14, i12) {
    return null;
  }
  _attributeHash(e12) {
    var _a;
    let t10 = "";
    for (const s7 of this._symbolFields) {
      const r14 = (_a = this._fieldMap) == null ? void 0 : _a[s7];
      r14 && (t10 += e12.attributes[r14] + "-");
    }
    return t10;
  }
};

export {
  e7 as e,
  E2 as E,
  e10 as e2,
  n5 as n,
  x7 as x,
  n8 as n2,
  o12 as o
};
//# sourceMappingURL=chunk-LLOJIW4K.js.map

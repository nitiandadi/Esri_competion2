import {
  o
} from "./chunk-ITU2WGYR.js";
import {
  O
} from "./chunk-CPQSD22U.js";
import {
  f,
  n
} from "./chunk-CJ2YD4VU.js";
import {
  r as r2
} from "./chunk-JGIZLXNQ.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js
function o2(o5, t3 = true) {
  o5.attributes.add(O.POSITION, "vec2"), t3 && o5.varyings.add("uv", "vec2"), o5.vertex.code.add(o`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      ${t3 ? o`uv = position * 0.5 + vec2(0.5);` : ""}
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js
var s3 = s.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");
var i = class {
  constructor() {
    this._includedModules = /* @__PURE__ */ new Map();
  }
  include(e3, r4) {
    if (this._includedModules.has(e3)) {
      const t3 = this._includedModules.get(e3);
      if (t3 !== r4) {
        s3.error("Trying to include shader module multiple times with different sets of options.");
        const r5 = /* @__PURE__ */ new Set();
        for (const n3 of Object.keys(t3))
          t3[n3] !== e3[n3] && r5.add(n3);
        for (const n3 of Object.keys(e3))
          t3[n3] !== e3[n3] && r5.add(n3);
        r5.forEach((r6) => console.error(`  ${r6}: current ${t3[r6]} new ${e3[r6]}`));
      }
    } else
      this._includedModules.set(e3, r4), e3(this.builder, r4);
  }
};
var o3 = class extends i {
  constructor() {
    super(...arguments), this.vertex = new u(), this.fragment = new u(), this.attributes = new m(), this.varyings = new h(), this.extensions = new d(), this.constants = new l();
  }
  get fragmentUniforms() {
    return this.fragment.uniforms.entries;
  }
  get builder() {
    return this;
  }
  generate(e3) {
    const r4 = this.extensions.generateSource(e3), t3 = this.attributes.generateSource(e3), n3 = this.varyings.generateSource(), s4 = "vertex" === e3 ? this.vertex : this.fragment, i4 = s4.uniforms.generateSource(), o5 = s4.code.generateSource(), a6 = "vertex" === e3 ? f2 : _, c2 = this.constants.generateSource().concat(s4.constants.generateSource());
    return `
${r4.join("\n")}

${a6}

${c2.join("\n")}

${i4.join("\n")}

${t3.join("\n")}

${n3.join("\n")}

${o5.join("\n")}`;
  }
  generateBind(e3, r4) {
    const n3 = /* @__PURE__ */ new Map();
    this.vertex.uniforms.entries.forEach((r5) => {
      const s5 = r5.bind[e3];
      r(s5) && n3.set(r5.name, s5);
    }), this.fragment.uniforms.entries.forEach((r5) => {
      const s5 = r5.bind[e3];
      r(s5) && n3.set(r5.name, s5);
    });
    const s4 = Array.from(n3.values()), i4 = s4.length;
    return (e4, t3, n4) => {
      for (let o5 = 0; o5 < i4; ++o5)
        s4[o5](r4, e4, t3, n4);
    };
  }
};
var a = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(e3) {
    if (!Array.isArray(e3))
      return this._add(e3);
    for (const r4 of e3)
      this._add(r4);
  }
  get(e3) {
    return this._entries.get(e3);
  }
  _add(r4) {
    if (t(r4))
      s3.error(`Trying to add null Uniform from ${new Error().stack}.`);
    else {
      if (this._entries.has(r4.name) && !this._entries.get(r4.name).equals(r4))
        throw new s2(`Duplicate uniform name ${r4.name} for different uniform type`);
      this._entries.set(r4.name, r4);
    }
  }
  generateSource() {
    return Array.from(this._entries.values()).map((e3) => r(e3.arraySize) ? `uniform ${e3.type} ${e3.name}[${e3.arraySize}];` : `uniform ${e3.type} ${e3.name};`);
  }
  get entries() {
    return Array.from(this._entries.values());
  }
};
var c = class {
  constructor() {
    this._entries = new Array();
  }
  add(e3) {
    this._entries.push(e3);
  }
  generateSource() {
    return this._entries;
  }
};
var u = class extends i {
  constructor() {
    super(...arguments), this.uniforms = new a(), this.code = new c(), this.constants = new l();
  }
  get builder() {
    return this;
  }
};
var m = class {
  constructor() {
    this._entries = new Array();
  }
  add(e3, r4) {
    this._entries.push([e3, r4]);
  }
  generateSource(e3) {
    return "fragment" === e3 ? [] : this._entries.map((e4) => `attribute ${e4[1]} ${e4[0]};`);
  }
};
var h = class {
  constructor() {
    this._entries = new Array();
  }
  add(e3, r4) {
    this._entries.push([e3, r4]);
  }
  generateSource() {
    return this._entries.map((e3) => `varying ${e3[1]} ${e3[0]};`);
  }
};
var d = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e3) {
    this._entries.add(e3);
  }
  generateSource(e3) {
    const r4 = "vertex" === e3 ? d.ALLOWLIST_VERTEX : d.ALLOWLIST_FRAGMENT;
    return Array.from(this._entries).filter((e4) => r4.includes(e4)).map((e4) => `#extension ${e4} : enable`);
  }
};
d.ALLOWLIST_FRAGMENT = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives"], d.ALLOWLIST_VERTEX = [];
var l = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e3, r4, t3) {
    let n3 = "ERROR_CONSTRUCTOR_STRING";
    switch (r4) {
      case "float":
        n3 = l._numberToFloatStr(t3);
        break;
      case "int":
        n3 = l._numberToIntStr(t3);
        break;
      case "bool":
        n3 = t3.toString();
        break;
      case "vec2":
        n3 = `vec2(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])})`;
        break;
      case "vec3":
        n3 = `vec3(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])},                            ${l._numberToFloatStr(t3[2])})`;
        break;
      case "vec4":
        n3 = `vec4(${l._numberToFloatStr(t3[0])},                            ${l._numberToFloatStr(t3[1])},                            ${l._numberToFloatStr(t3[2])},                            ${l._numberToFloatStr(t3[3])})`;
        break;
      case "ivec2":
        n3 = `ivec2(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])})`;
        break;
      case "ivec3":
        n3 = `ivec3(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])},                             ${l._numberToIntStr(t3[2])})`;
        break;
      case "ivec4":
        n3 = `ivec4(${l._numberToIntStr(t3[0])},                             ${l._numberToIntStr(t3[1])},                             ${l._numberToIntStr(t3[2])},                             ${l._numberToIntStr(t3[3])})`;
        break;
      case "mat2":
      case "mat3":
      case "mat4":
        n3 = `${r4}(${Array.prototype.map.call(t3, (e4) => l._numberToFloatStr(e4)).join(", ")})`;
    }
    return this._entries.add(`const ${r4} ${e3} = ${n3};`), this;
  }
  static _numberToIntStr(e3) {
    return e3.toFixed(0);
  }
  static _numberToFloatStr(e3) {
    return Number.isInteger(e3) ? e3.toFixed(1) : e3.toString();
  }
  generateSource() {
    return Array.from(this._entries);
  }
};
var _ = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif";
var f2 = "precision highp float;\nprecision highp sampler2D;";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/BindType.js
var a2;
!function(a6) {
  a6[a6.Pass = 0] = "Pass", a6[a6.Draw = 1] = "Draw";
}(a2 || (a2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Uniform.js
var i2 = class {
  constructor(i4, s4, t3, a6, n3 = null) {
    this.name = i4, this.type = s4, this.arraySize = n3, this.bind = { [a2.Pass]: null, [a2.Draw]: null }, r(t3) && r(a6) && (this.bind[t3] = a6);
  }
  equals(e3) {
    return this.type === e3.type && this.name === e3.name && this.arraySize === e3.arraySize;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js
var e = class extends i2 {
  constructor(r4, e3) {
    super(r4, "vec2", a2.Pass, (s4, o5, t3) => s4.setUniform2fv(r4, e3(o5, t3)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/WebGL2Utils.js
var t2 = "Size";
var n2 = "InvSize";
function r3(r4, i4, o5 = false, u3 = 0) {
  if (r4.hasWebGL2Context) {
    const t3 = o`vec2(textureSize(${i4}, ${o.int(u3)}))`;
    return o5 ? "(1.0 / " + t3 + ")" : t3;
  }
  return o5 ? i4 + n2 : i4 + t2;
}
function i3(t3, r4, i4, o5 = null, u3 = 0) {
  if (t3.hasWebGL2Context)
    return o`texelFetch(${r4}, ivec2(${i4}), ${o.int(u3)})`;
  let $ = o`texture2D(${r4}, ${i4} * `;
  return $ += o5 ? o`(${o5}))` : o`${r4 + n2})`, $;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/TextureSizeUniformType.js
var e2;
!function(e3) {
  e3[e3.None = 0] = "None", e3[e3.Size = 1] = "Size", e3[e3.InvSize = 2] = "InvSize";
}(e2 || (e2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js
var f3 = class extends i2 {
  constructor(r4, s4) {
    super(r4, "sampler2D", a2.Pass, (e3, o5, t3) => e3.bindTexture(r4, s4(o5, t3)));
  }
};
function u2(o5, c2, p = e2.None) {
  const u3 = [new f3(o5, c2)];
  if (p & e2.Size) {
    const i4 = o5 + t2;
    u3.push(new e(i4, (o6, t3) => {
      const i5 = c2(o6, t3);
      return r(i5) ? r2(a3, i5.descriptor.width, i5.descriptor.height) : f;
    }));
  }
  if (p & e2.InvSize) {
    const t3 = o5 + n2;
    u3.push(new e(t3, (o6, t4) => {
      const i4 = c2(o6, t4);
      return r(i4) ? r2(a3, 1 / i4.descriptor.width, 1 / i4.descriptor.height) : f;
    }));
  }
  return u3;
}
var a3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js
var o4 = class extends i2 {
  constructor(r4, o5) {
    super(r4, "float", a2.Pass, (s4, e3, t3) => s4.setUniform1f(r4, o5(e3, t3)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js
function a4(a6) {
  a6.code.add(o`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js
function a5(a6) {
  a6.include(a4), a6.code.add(o`float linearDepthFromFloat(float depth, vec2 nearFar) {
return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);
}
float linearDepthFromTexture(sampler2D depthTex, vec2 uv, vec2 nearFar) {
return linearDepthFromFloat(rgba2float(texture2D(depthTex, uv)), nearFar);
}`);
}

export {
  o2 as o,
  a2 as a,
  i2 as i,
  o3 as o2,
  t2 as t,
  n2 as n,
  r3 as r,
  i3 as i2,
  e,
  e2,
  f3 as f,
  u2 as u,
  a4 as a2,
  o4 as o3,
  a5 as a3
};
//# sourceMappingURL=chunk-AKCTBZVO.js.map

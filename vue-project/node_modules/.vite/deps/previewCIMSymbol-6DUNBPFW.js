import {
  o
} from "./chunk-FWLSWUZI.js";
import {
  c as c3
} from "./chunk-GXJHN5TD.js";
import "./chunk-7FAY4Z4C.js";
import {
  O as O2,
  W,
  ie,
  j,
  pe2 as pe,
  s,
  se
} from "./chunk-TOX3CURZ.js";
import "./chunk-VV2CU7S7.js";
import "./chunk-FYA3X5C5.js";
import "./chunk-DKDRIIV4.js";
import "./chunk-5SYMUP5B.js";
import "./chunk-R6XKQWZ7.js";
import "./chunk-O2JKCGK6.js";
import "./chunk-MSPZCZRZ.js";
import "./chunk-RURSJOSG.js";
import "./chunk-FSOPJKVB.js";
import "./chunk-RRNRSHX3.js";
import "./chunk-V2OTMPXZ.js";
import "./chunk-DUEDINK5.js";
import "./chunk-JGIZLXNQ.js";
import {
  l as l2
} from "./chunk-SJVVW34Y.js";
import {
  t as t2
} from "./chunk-5SBOPOJJ.js";
import "./chunk-NWZTRS6O.js";
import "./chunk-77E52HT5.js";
import {
  m
} from "./chunk-KNLATKCF.js";
import {
  O,
  c as c2,
  r,
  t
} from "./chunk-HBVUBDHI.js";
import "./chunk-WOEVHDZW.js";
import "./chunk-2VRWGZDB.js";
import "./chunk-2DA2JOWA.js";
import "./chunk-4YJQ46TP.js";
import "./chunk-LC5BGIRA.js";
import "./chunk-ST7DNJJS.js";
import "./chunk-FAK3SJAD.js";
import "./chunk-YMSHUIGU.js";
import "./chunk-REIXEATJ.js";
import "./chunk-EPJSBV4J.js";
import {
  p
} from "./chunk-QX5IKXT7.js";
import "./chunk-ONU3G4LF.js";
import "./chunk-P26WTKBK.js";
import "./chunk-WAN4YZSB.js";
import "./chunk-OKST3HK4.js";
import {
  l
} from "./chunk-BHQVXYUV.js";
import "./chunk-DKH5QOVM.js";
import "./chunk-X6SQQQR4.js";
import "./chunk-TNQLNDIQ.js";
import "./chunk-PSN7WPOI.js";
import "./chunk-FA3YUERM.js";
import "./chunk-LVRAFE6T.js";
import "./chunk-Y3KJPDCE.js";
import "./chunk-LSUFI7PR.js";
import {
  e,
  u
} from "./chunk-BQXNXAP2.js";
import "./chunk-JT54I3AY.js";
import "./chunk-TNTTCGVB.js";
import "./chunk-DC3QI5ZE.js";
import "./chunk-EGHLQERQ.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-5CMPUNQG.js";
import {
  U
} from "./chunk-QJXSE36Y.js";
import "./chunk-WV4G3ROK.js";
import "./chunk-M3KO43BW.js";
import "./chunk-SZO7ZKE4.js";
import "./chunk-YMLMMCYX.js";
import "./chunk-I2U7UK6N.js";
import "./chunk-6TTVNN6M.js";
import "./chunk-3UXY2S4E.js";
import "./chunk-CPUYSXBP.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-7FMLQXIT.js";
import "./chunk-B6GJAETG.js";
import "./chunk-FC74MT6E.js";
import "./chunk-H2ENCYR3.js";
import "./chunk-SVHG5VY2.js";
import "./chunk-FQ7L63IU.js";
import "./chunk-6K5VVUVI.js";
import "./chunk-S47644HM.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-DLM7WQKI.js";
import "./chunk-7GTATSRF.js";
import "./chunk-MTJ2HM2W.js";
import "./chunk-PXVSWY3C.js";
import {
  f
} from "./chunk-QLY5H3XF.js";
import "./chunk-UG2OEDEE.js";
import "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import "./chunk-PR6SXADK.js";
import "./chunk-MGJMBJDY.js";
import {
  c
} from "./chunk-WHB7G7RI.js";
import "./chunk-DFKQJ226.js";

// node_modules/@arcgis/core/symbols/cim/CIMSymbolRasterizer.js
var M;
!function(e2) {
  e2.Legend = "legend", e2.Preview = "preview";
}(M || (M = {}));
var _ = (e2) => e2 && e2.scaleFactor ? e2.scaleFactor : 1;
var v = 96 / 72;
var z = class {
  constructor(e2, t3) {
    this._spatialReference = e2, this._avoidSDF = t3, this._resourceCache = /* @__PURE__ */ new Map(), this._imageDataCanvas = null, this._pictureMarkerCache = /* @__PURE__ */ new Map(), this._textRasterizer = new s(), this._cimResourceManager = new o(), this._rasterizer = new c3(this._cimResourceManager);
  }
  get resourceManager() {
    return this._cimResourceManager;
  }
  async rasterizeCIMSymbolAsync(e2, t3, a, i, r2, s2, o2, n) {
    if (!e2)
      return null;
    const { data: g } = e2;
    if (!g || "CIMSymbolReference" !== g.type || !g.symbol)
      return null;
    const { symbol: u3 } = g;
    s2 || (s2 = O(u3));
    const d2 = await se.resolveSymbolOverrides(g, t3, this._spatialReference, r2, s2, o2, n);
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const p2 = this._imageDataCanvas, y2 = this._cimResourceManager, w = [];
    ie.fetchResources(d2, y2, w), w.length > 0 && await Promise.all(w);
    const { width: C, height: M2 } = a, _2 = I(s2, C, M2, i), z2 = ie.getEnvelope(d2, _2, y2);
    if (!z2)
      return null;
    const x2 = (window.devicePixelRatio || 1) * v;
    let R = 1, b = 0, P = 0;
    switch (u3.type) {
      case "CIMPointSymbol":
      case "CIMTextSymbol":
        {
          let e3 = 1;
          z2.width > C && (e3 = C / z2.width);
          let t4 = 1;
          z2.height > M2 && (t4 = M2 / z2.height), "preview" === i && (z2.width < C && (e3 = C / z2.width), z2.height < M2 && (t4 = M2 / z2.height)), R = Math.min(e3, t4), b = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        }
        break;
      case "CIMLineSymbol":
        {
          let e3 = 1;
          z2.height > M2 && (e3 = M2 / z2.height), R = e3, P = z2.y + z2.height / 2;
          const t4 = z2.x * R + C / 2, a2 = (z2.x + z2.width) * R + C / 2;
          if (t4 < 0) {
            const { paths: e4 } = _2;
            e4[0][0][0] -= t4;
          }
          if (a2 > C) {
            const { paths: e4 } = _2;
            e4[0][2][0] -= a2 - C;
          }
        }
        break;
      case "CIMPolygonSymbol": {
        b = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        const e3 = z2.x * R + C / 2, t4 = (z2.x + z2.width) * R + C / 2, a2 = z2.y * R + M2 / 2, i2 = (z2.y + z2.height) * R + M2 / 2, { rings: r3 } = _2;
        e3 < 0 && (r3[0][0][0] -= e3, r3[0][3][0] -= e3, r3[0][4][0] -= e3), a2 < 0 && (r3[0][0][1] += a2, r3[0][1][1] += a2, r3[0][4][1] += a2), t4 > C && (r3[0][1][0] -= t4 - C, r3[0][2][0] -= t4 - C), i2 > M2 && (r3[0][2][1] += i2 - M2, r3[0][3][1] += i2 - M2);
      }
    }
    p2.width = C * x2, p2.height = M2 * x2;
    const D = 1;
    p2.width += 2 * D, p2.height += 2 * D;
    const S = p2.getContext("2d"), k = O2.createIdentity();
    k.translate(-b, -P), k.scale(R * x2, -R * x2), k.translate(C * x2 / 2 + D, M2 * x2 / 2 + D), S.clearRect(0, 0, p2.width, p2.height);
    return new W(S, y2, k, true).drawSymbol(d2, _2), S.getImageData(0, 0, p2.width, p2.height);
  }
  async analyzeCIMSymbol(e2, t3, a, r2, o2) {
    const n = [], c5 = t3 ? { geometryType: r2, spatialReference: this._spatialReference, fields: t3 } : null;
    let h2;
    await j(e2.data, c5, this._cimResourceManager, n, this._avoidSDF), f(o2);
    for (const i of n)
      "CIMPictureMarker" !== i.cim.type && "CIMPictureFill" !== i.cim.type && "CIMPictureStroke" !== i.cim.type || (h2 || (h2 = []), h2.push(this._fetchPictureMarkerResource(i, o2))), a && "text" === i.type && "string" == typeof i.text && i.text.includes("[") && (i.text = c2(a, i.text, i.cim.textCase));
    return h2 && await Promise.all(h2), n;
  }
  rasterizeCIMSymbol3D(e2, t3, a, i, r2, s2) {
    const o2 = [];
    for (const n of e2) {
      i && "function" == typeof i.scaleFactor && (i.scaleFactor = i.scaleFactor(t3, r2, s2));
      const e3 = this._getRasterizedResource(n, t3, a, i, r2, s2);
      if (!e3)
        continue;
      let c5 = 0, h2 = e3.anchorX || 0, l3 = e3.anchorY || 0, m3 = false, g = 0, u3 = 0;
      if ("esriGeometryPoint" === a) {
        const e4 = _(i);
        if (g = t(n.offsetX, t3, r2, s2) * e4 || 0, u3 = t(n.offsetY, t3, r2, s2) * e4 || 0, "marker" === n.type)
          c5 = t(n.rotation, t3, r2, s2) || 0, m3 = !!n.rotateClockwise && n.rotateClockwise;
        else if ("text" === n.type) {
          if (c5 = t(n.angle, t3, r2, s2) || 0, void 0 !== n.horizontalAlignment)
            switch (n.horizontalAlignment) {
              case "left":
                h2 = -0.5;
                break;
              case "right":
                h2 = 0.5;
                break;
              default:
                h2 = 0;
            }
          if (void 0 !== n.verticalAlignment)
            switch (n.verticalAlignment) {
              case "top":
                l3 = 0.5;
                break;
              case "bottom":
                l3 = -0.5;
                break;
              case "baseline":
                l3 = -0.25;
                break;
              default:
                l3 = 0;
            }
        }
      }
      null != e3 && o2.push({ angle: c5, rotateClockWise: m3, anchorX: h2, anchorY: l3, offsetX: g, offsetY: u3, rasterizedResource: e3 });
    }
    return this.getSymbolImage(o2);
  }
  getSymbolImage(e2) {
    const t3 = document.createElement("canvas"), i = c(t3.getContext("2d"));
    let s2 = 0, o2 = 0, n = 0, c5 = 0;
    const h2 = [];
    for (let a = 0; a < e2.length; a++) {
      const t4 = e2[a], l4 = t4.rasterizedResource;
      if (!l4)
        continue;
      const m4 = l4.size, g2 = t4.offsetX, u3 = t4.offsetY, f3 = t4.anchorX, d2 = t4.anchorY, p2 = t4.rotateClockWise || false;
      let y2 = t4.angle, w = u(g2) - m4[0] * (0.5 + f3), C = u(u3) - m4[1] * (0.5 + d2), M2 = w + m4[0], _2 = C + m4[1];
      if (y2) {
        p2 && (y2 = -y2);
        const e3 = Math.sin(y2 * Math.PI / 180), t5 = Math.cos(y2 * Math.PI / 180), a2 = w * t5 - C * e3, i2 = w * e3 + C * t5, r2 = w * t5 - _2 * e3, s3 = w * e3 + _2 * t5, o3 = M2 * t5 - _2 * e3, n2 = M2 * e3 + _2 * t5, c6 = M2 * t5 - C * e3, h3 = M2 * e3 + C * t5;
        w = Math.min(a2, r2, o3, c6), C = Math.min(i2, s3, n2, h3), M2 = Math.max(a2, r2, o3, c6), _2 = Math.max(i2, s3, n2, h3);
      }
      s2 = w < s2 ? w : s2, o2 = C < o2 ? C : o2, n = M2 > n ? M2 : n, c5 = _2 > c5 ? _2 : c5;
      const v2 = i.createImageData(l4.size[0], l4.size[1]);
      v2.data.set(new Uint8ClampedArray(l4.image.buffer));
      const z2 = { offsetX: g2, offsetY: u3, rotateClockwise: p2, angle: y2, rasterizedImage: v2, anchorX: f3, anchorY: d2 };
      h2.push(z2);
    }
    t3.width = n - s2, t3.height = c5 - o2;
    const l3 = -s2, m3 = c5;
    for (let a = 0; a < h2.length; a++) {
      const e3 = h2[a], t4 = this._imageDataToCanvas(e3.rasterizedImage), s3 = e3.rasterizedImage.width, o3 = e3.rasterizedImage.height, n2 = l3 - s3 * (0.5 + e3.anchorX), c6 = m3 - o3 * (0.5 - e3.anchorY);
      if (e3.angle) {
        const a2 = (360 - e3.angle) * Math.PI / 180;
        i.save(), i.translate(u(e3.offsetX), -u(e3.offsetY)), i.translate(l3, m3), i.rotate(a2), i.translate(-l3, -m3), i.drawImage(t4, n2, c6), i.restore();
      } else
        i.drawImage(t4, n2 + u(e3.offsetX), c6 - u(e3.offsetY));
    }
    const g = new p({ x: l3 / t3.width - 0.5, y: m3 / t3.height - 0.5 });
    return { imageData: 0 !== t3.width && 0 !== t3.height ? i.getImageData(0, 0, t3.width, t3.height) : i.createImageData(1, 1), anchorPosition: g };
  }
  async _fetchPictureMarkerResource(e2, a) {
    const i = e2.materialHash;
    if (!this._pictureMarkerCache.get(i)) {
      const r2 = (await U(e2.cim.url, { responseType: "image", signal: a && a.signal })).data;
      this._pictureMarkerCache.set(i, r2);
    }
  }
  _imageDataToCanvas(e2) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const t3 = this._imageDataCanvas, i = c(t3.getContext("2d"));
    return t3.width = e2.width, t3.height = e2.height, i.putImageData(e2, 0, 0), t3;
  }
  _imageTo32Array(t3, i, r2, s2) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const o2 = this._imageDataCanvas, n = c(o2.getContext("2d"));
    if (o2.width = i, o2.height = r2, n.drawImage(t3, 0, 0, i, r2), s2) {
      n.save();
      const a = new l(s2);
      n.fillStyle = a.toHex(), n.globalCompositeOperation = "multiply", n.fillRect(0, 0, i, r2), n.globalCompositeOperation = "destination-atop", n.drawImage(t3, 0, 0, i, r2), n.restore();
    }
    return new Uint32Array(n.getImageData(0, 0, i, r2).data.buffer);
  }
  _getRasterizedResource(e2, t3, i, r2, s2, o2) {
    let n, c5, h2;
    const l3 = null, m3 = null;
    if ("text" === e2.type)
      return this._rasterizeTextResource(e2, t3, r2, s2, o2);
    ({ analyzedCIM: n, hash: c5 } = x(e2, t3, s2, o2));
    const g = _(r2);
    if ("CIMPictureMarker" === e2.cim.type) {
      const i2 = t(e2.size, t3, s2, o2) * g, { image: r3, width: n2, height: c6 } = c(this._getPictureResource(e2, i2, t(e2.color, t3, s2, o2)));
      return h2 = { image: r3, size: [n2, c6], sdf: false, simplePattern: false, anchorX: e2.anchorPoint ? e2.anchorPoint.x : 0, anchorY: e2.anchorPoint ? e2.anchorPoint.y : 0 }, h2;
    }
    m(n, g, { preserveOutlineWidth: false });
    const u3 = n;
    c5 += i, r2 && (c5 += JSON.stringify(r2));
    const f3 = this._resourceCache;
    return f3.has(c5) ? f3.get(c5) : (h2 = this._rasterizer.rasterizeJSONResource({ cim: u3, type: e2.type, url: e2.url, mosaicHash: c5, size: l3, path: m3 }, window.devicePixelRatio || 1, this._avoidSDF), f3.set(c5, h2), h2);
  }
  _rasterizeTextResource(e2, t3, a, i, r2) {
    const s2 = _(a), o2 = t(e2.text, t3, i, r2);
    if (!o2 || 0 === o2.length)
      return null;
    const n = t(e2.fontName, t3, i, r2), c5 = t(e2.style, t3, i, r2), h2 = t(e2.weight, t3, i, r2), l3 = t(e2.decoration, t3, i, r2), m3 = t(e2.size, t3, i, r2) * s2, g = t(e2.horizontalAlignment, t3, i, r2), u3 = t(e2.verticalAlignment, t3, i, r2), f3 = r(t(e2.color, t3, i, r2)), d2 = r(t(e2.outlineColor, t3, i, r2)), w = { color: f3, size: m3, horizontalAlignment: g, verticalAlignment: u3, font: { family: n, style: c5, weight: h2, decoration: l3 }, halo: { size: t(e2.outlineSize, t3, i, r2) || 0, color: d2, style: c5 }, pixelRatio: 1, premultiplyColors: !this._avoidSDF };
    return this._textRasterizer.rasterizeText(o2, w);
  }
  _getPictureResource(e2, t3, a) {
    const i = this._pictureMarkerCache.get(e2.materialHash);
    if (!i)
      return null;
    const s2 = i.height / i.width, o2 = t3 ? s2 > 1 ? u(t3) : u(t3) / s2 : i.width, n = t3 ? s2 > 1 ? u(t3) * s2 : u(t3) : i.height;
    return { image: this._imageTo32Array(i, o2, n, a), width: o2, height: n };
  }
};
function I(e2, t3, a, i) {
  const r2 = 1, s2 = -t3 / 2 + r2, o2 = t3 / 2 - r2, n = a / 2 - r2, c5 = -a / 2 + r2;
  switch (e2) {
    case "esriGeometryPoint":
      return { x: 0, y: 0 };
    case "esriGeometryPolyline":
      return { paths: [[[s2, 0], [0, 0], [o2, 0]]] };
    default:
      return "legend" === i ? { rings: [[[s2, n], [o2, 0], [o2, c5], [s2, c5], [s2, n]]] } : { rings: [[[s2, n], [o2, n], [o2, c5], [s2, c5], [s2, n]]] };
  }
}
function x(e2, t3, a, i) {
  let r2, s2;
  if ("function" == typeof e2.materialHash) {
    r2 = (0, e2.materialHash)(t3, a, i), s2 = pe(e2.cim, e2.materialOverrides);
  } else
    r2 = e2.materialHash, s2 = e2.cim;
  return { analyzedCIM: s2, hash: r2 };
}

// node_modules/@arcgis/core/symbols/support/previewCIMSymbol.js
var h = new z(null, true);
var m2 = e(t2.size);
var c4 = e(t2.maxSize);
var u2 = e(t2.lineWidth);
var f2 = 1;
function y(e2) {
  const t3 = e2 == null ? void 0 : e2.size;
  if ("number" == typeof t3)
    return { width: t3, height: t3 };
  return { width: null != t3 && "object" == typeof t3 && "width" in t3 ? t3.width : null, height: null != t3 && "object" == typeof t3 && "height" in t3 ? t3.height : null };
}
async function d(e2, l3 = {}) {
  var _a;
  const { node: s2, opacity: d2, symbolConfig: p2 } = l3, g = "object" == typeof p2 && "isSquareFill" in p2 && p2.isSquareFill, w = l3.cimOptions || l3, b = w.geometryType || O((_a = e2 == null ? void 0 : e2.data) == null ? void 0 : _a.symbol), M2 = y(l3), { feature: j2, fieldMap: v2 } = w;
  if (null == M2.width || null == M2.height) {
    const t3 = await se.resolveSymbolOverrides(e2.data, j2, null, v2, b);
    if (!t3)
      return null;
    (e2 = e2.clone()).data = { type: "CIMSymbolReference", symbol: t3 }, e2.data.primitiveOverrides = void 0;
    const l4 = [];
    ie.fetchResources(t3, h.resourceManager, l4), l4.length > 0 && await Promise.all(l4);
    const n = ie.getEnvelope(t3, null, h.resourceManager), r2 = n == null ? void 0 : n.width, s3 = n == null ? void 0 : n.height;
    M2.width = "esriGeometryPolygon" === b ? m2 : "esriGeometryPolyline" === b ? u2 : null != r2 && isFinite(r2) ? Math.min(r2, c4) : m2, M2.height = "esriGeometryPolygon" === b ? m2 : null != s3 && isFinite(s3) ? Math.max(Math.min(s3, c4), f2) : m2;
  }
  const S = await h.rasterizeCIMSymbolAsync(e2, j2, M2, g || "esriGeometryPolygon" !== b ? M.Preview : M.Legend, v2, b);
  if (!S)
    return null;
  const { width: C, height: I2 } = S, P = document.createElement("canvas");
  P.width = C, P.height = I2;
  P.getContext("2d").putImageData(S, 0, 0);
  const x2 = u(M2.width), z2 = u(M2.height), F = new Image(x2, z2);
  F.src = P.toDataURL(), null != d2 && (F.style.opacity = `${d2}`);
  let G = F;
  if (null != l3.effectView) {
    const e3 = { shape: { type: "image", x: 0, y: 0, width: x2, height: z2, src: F.src }, fill: null, stroke: null, offset: [0, 0] };
    G = l2([[e3]], [x2, z2], { effectView: l3.effectView });
  }
  return s2 && G && s2.appendChild(G), G;
}
export {
  d as previewCIMSymbol
};
//# sourceMappingURL=previewCIMSymbol-6DUNBPFW.js.map

import {
  r as r2
} from "./chunk-NI6ENKKR.js";
import {
  A,
  C,
  D,
  Et,
  H,
  J,
  K,
  L,
  M,
  Q,
  S,
  X,
  Z,
  kt,
  t,
  tt,
  xt
} from "./chunk-6XDV3BWZ.js";
import {
  a,
  j,
  p as p2,
  v
} from "./chunk-6ZUWLK7F.js";
import {
  s,
  s3 as s2
} from "./chunk-YVZY5LDV.js";
import {
  has,
  p
} from "./chunk-H32MMKAJ.js";
import {
  e,
  r
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t2 = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function r3(c2) {
  const r4 = X(c2, true);
  return !!r4 && (r4.endsWith(".arcgis.com") && !t2.includes(r4) && !c2.endsWith("/sharing/rest/generateToken"));
}

// node_modules/@arcgis/core/support/requestUtils.js
function c(r4, t3, n = false, s3) {
  return new Promise((i, c2) => {
    if (p2(s3))
      return void c2(a2());
    let m2 = () => {
      f(), c2(new Error(`Unable to load ${t3}`));
    }, u2 = () => {
      const e2 = r4;
      f(), i(e2);
    }, d2 = () => {
      if (!r4)
        return;
      const e2 = r4;
      f(), e2.src = "", c2(a2());
    };
    const f = () => {
      has("esri-image-decode") || (r4.removeEventListener("error", m2), r4.removeEventListener("load", u2)), m2 = null, u2 = null, r4 = null, r(s3) && s3.removeEventListener("abort", d2), d2 = null, n && URL.revokeObjectURL(t3);
    };
    r(s3) && s3.addEventListener("abort", d2), has("esri-image-decode") ? r4.decode().then(u2, m2) : (r4.addEventListener("error", m2), r4.addEventListener("load", u2));
  });
}
function a2() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const r4 = new Error();
    return r4.name = "AbortError", r4;
  }
}
function m(e2) {
  s.request.crossOriginNoCorsDomains || (s.request.crossOriginNoCorsDomains = {});
  const o = s.request.crossOriginNoCorsDomains;
  for (let r4 of e2)
    r4 = r4.toLowerCase(), /^https?:\/\//.test(r4) ? o[X(r4) ?? ""] = 0 : (o[X("http://" + r4) ?? ""] = 0, o[X("https://" + r4) ?? ""] = 0);
}
function u(e2) {
  const o = s.request.crossOriginNoCorsDomains;
  if (o) {
    let r4 = X(e2);
    if (r4)
      return r4 = r4.toLowerCase(), !M(r4, C()) && o[r4] < Date.now() - 36e5;
  }
  return false;
}
async function d(e2) {
  var _a;
  const o = s.request.crossOriginNoCorsDomains, n = X(e2);
  o && n && (o[n.toLowerCase()] = Date.now());
  const s3 = L(e2);
  e2 = s3.path, "json" === ((_a = s3.query) == null ? void 0 : _a.f) && (e2 += "?f=json");
  try {
    await fetch(e2, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function U(e2, t3) {
  var _a;
  const r4 = tt(e2), s3 = Z(e2);
  s3 || r4 || (e2 = K(e2));
  const n = { url: e2, requestOptions: { ...e(t3) } };
  let i = D(e2);
  if (i) {
    const e3 = await G(i, n);
    if (null != e3)
      return { data: e3, getHeader: M2, httpStatus: 200, requestOptions: n.requestOptions, url: n.url };
    i.after || i.error || (i = null);
  }
  if (e2 = n.url, "image" === (t3 = n.requestOptions).responseType) {
    if (has("host-webworker") || has("host-node"))
      throw N("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), n);
  } else if (r4)
    throw N("request:invalid-parameters", new Error("Data URLs are not supported for responseType = " + t3.responseType), n);
  if ("head" === t3.method) {
    if (t3.body)
      throw N("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), n);
    if (r4 || s3)
      throw N("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), n);
  }
  if (await B(), j2)
    return j2.execute(e2, t3);
  const l = new AbortController();
  v(t3, () => l.abort());
  const m2 = { controller: l, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: i, params: n, redoRequest: false, useIdentity: P.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, h = await Q2(m2);
  return (_a = i == null ? void 0 : i.after) == null ? void 0 : _a.call(i, h), h;
}
var j2;
var P = s.request;
var D2 = "FormData" in globalThis;
var _ = [499, 498, 403, 401];
var F = ["COM_0056", "COM_0057", "SB_0008"];
var I = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var M2 = () => null;
var R = Symbol();
function A2(e2) {
  const t3 = X(e2);
  t3 && !U._corsServers.includes(t3) && U._corsServers.push(t3);
}
function H2(e2) {
  const t3 = X(e2);
  return !t3 || t3.endsWith(".arcgis.com") || U._corsServers.includes(t3) || Q(t3);
}
function N(e2, t3, o, a3) {
  let l = "Error";
  const u2 = { url: o.url, requestOptions: o.requestOptions, getHeader: M2, ssl: false };
  if (t3 instanceof s2)
    return t3.details ? (t3.details = p(t3.details), t3.details.url = o.url, t3.details.requestOptions = o.requestOptions) : t3.details = u2, t3;
  if (t3) {
    const e3 = a3 && ((e4) => a3.headers.get(e4)), r4 = a3 && a3.status, s3 = t3.message;
    s3 && (l = s3), e3 && (u2.getHeader = e3), u2.httpStatus = (null != t3.httpCode ? t3.httpCode : t3.code) || r4 || 0, u2.subCode = t3.subcode, u2.messageCode = t3.messageCode, "string" == typeof t3.details ? u2.messages = [t3.details] : u2.messages = t3.details, u2.raw = R in t3 ? t3[R] : t3;
  }
  return j(t3) ? a() : new s2(e2, l, u2);
}
async function B() {
  has("host-webworker") ? j2 || (j2 = await import("./request-4QM3E7ME.js")) : U._abortableFetch || (U._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function $() {
  r2 || await import("./IdentityManager-LE4VIUIY.js");
}
async function z(r4) {
  var _a;
  const s3 = r4.params.url, o = r4.params.requestOptions, a3 = r4.controller.signal, n = o.body;
  let i = null, u2 = null;
  if (D2 && "HTMLFormElement" in globalThis && (n instanceof FormData ? i = n : n instanceof HTMLFormElement && (i = new FormData(n))), "string" == typeof n && (u2 = n), r4.fetchOptions = { cache: o.cacheBust && !U._abortableFetch.polyfill ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: P.priority, redirect: "follow", signal: a3 }, (i || u2) && (r4.fetchOptions.body = i || u2), "anonymous" === o.authMode && (r4.useIdentity = false), r4.hasToken = !!(/token=/i.test(s3) || ((_a = o.query) == null ? void 0 : _a.token) || (i == null ? void 0 : i.get("token"))), !r4.hasToken && s.apiKey && r3(s3) && (o.query || (o.query = {}), o.query.token = s.apiKey, r4.hasToken = true), r4.useIdentity && !r4.hasToken && !r4.credentialToken && !K2(s3) && !p2(a3)) {
    let e2;
    "immediate" === o.authMode ? (await $(), e2 = await r2.getCredential(s3, { signal: a3 }), r4.credential = e2) : "no-prompt" === o.authMode ? (await $(), e2 = await r2.getCredential(s3, { prompt: false, signal: a3 }).catch(() => {
    }), r4.credential = e2) : r2 && (e2 = r2.findCredential(s3)), e2 && (r4.credentialToken = e2.token, r4.useSSL = !!e2.ssl);
  }
}
function K2(e2) {
  return I.some((t3) => t3.test(e2));
}
async function W(e2) {
  let r4 = e2.params.url;
  const s3 = e2.params.requestOptions, o = e2.fetchOptions ?? {}, a3 = Z(r4) || tt(r4), n = s3.responseType || "json", l = a3 ? 0 : null != s3.timeout ? s3.timeout : P.timeout;
  let d2 = false;
  if (!a3) {
    e2.useSSL && (r4 = xt(r4)), s3.cacheBust && "default" === o.cache && (r4 = kt(r4, "request.preventCache", Date.now()));
    let a4 = { ...s3.query };
    e2.credentialToken && (a4.token = e2.credentialToken);
    let n2 = A(a4);
    has("esri-url-encodes-apostrophe") && (n2 = n2.replace(/'/g, "%27"));
    const i = r4.length + 1 + n2.length;
    let l2;
    d2 = "delete" === s3.method || "post" === s3.method || "put" === s3.method || !!s3.body || i > P.maxUrlLength;
    const u2 = s3.useProxy || !!J(r4);
    if (u2) {
      const e3 = S(r4);
      l2 = e3.path, !d2 && l2.length + 1 + i > P.maxUrlLength && (d2 = true), e3.query && (a4 = { ...e3.query, ...a4 });
    }
    if ("HEAD" === o.method && (d2 || u2)) {
      if (d2) {
        if (i > P.maxUrlLength)
          throw N("request:invalid-parameters", new Error("URL exceeds maximum length"), e2.params);
        throw N("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e2.params);
      }
      if (u2)
        throw N("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e2.params);
    }
    if (d2 ? (o.method = "delete" === s3.method ? "DELETE" : "put" === s3.method ? "PUT" : "POST", s3.body ? r4 = Et(r4, a4) : (o.body = A(a4), o.headers || (o.headers = {}), o.headers["Content-Type"] = "application/x-www-form-urlencoded")) : r4 = Et(r4, a4), u2 && (e2.useProxy = true, r4 = `${l2}?${r4}`), a4.token && D2 && o.body instanceof FormData && !t(r4) && o.body.set("token", a4.token), s3.hasOwnProperty("withCredentials"))
      e2.withCredentials = s3.withCredentials;
    else if (!M(r4, C())) {
      if (Q(r4))
        e2.withCredentials = true;
      else if (r2) {
        const s4 = r2.findServerInfo(r4);
        s4 && s4.webTierAuth && (e2.withCredentials = true);
      }
    }
    e2.withCredentials && (o.credentials = "include", u(r4) && await d(d2 ? Et(r4, a4) : r4));
  }
  let p3, v2, C2 = 0, L2 = false;
  l > 0 && (C2 = setTimeout(() => {
    L2 = true, e2.controller.abort();
  }, l));
  try {
    if ("native-request-init" === s3.responseType)
      v2 = o, v2.url = r4;
    else if ("image" !== s3.responseType || "default" !== o.cache || "GET" !== o.method || d2 || J2(s3.headers) || !a3 && !e2.useProxy && P.proxyUrl && !H2(r4)) {
      if (p3 = await U._abortableFetch(r4, o), e2.useProxy || A2(r4), "native" === s3.responseType)
        v2 = p3;
      else if ("HEAD" !== o.method)
        if (p3.ok) {
          switch (n) {
            case "array-buffer":
              v2 = await p3.arrayBuffer();
              break;
            case "blob":
            case "image":
              v2 = await p3.blob();
              break;
            default:
              v2 = await p3.text();
          }
          if (C2 && (clearTimeout(C2), C2 = 0), "json" === n || "xml" === n || "document" === n)
            if (v2)
              switch (n) {
                case "json":
                  v2 = JSON.parse(v2);
                  break;
                case "xml":
                  v2 = X2(v2, "application/xml");
                  break;
                case "document":
                  v2 = X2(v2, "text/html");
              }
            else
              v2 = null;
          if (v2) {
            if ("array-buffer" === n || "blob" === n) {
              const e3 = p3.headers.get("Content-Type");
              if (e3 && /application\/json|text\/plain/i.test(e3) && v2["blob" === n ? "size" : "byteLength"] <= 750)
                try {
                  const e4 = await new Response(v2).json();
                  e4.error && (v2 = e4);
                } catch {
                }
            }
            "image" === n && v2 instanceof Blob && (v2 = await Y(URL.createObjectURL(v2), e2, true));
          }
        } else
          v2 = await p3.text();
    } else
      v2 = await Y(r4, e2);
  } catch (j3) {
    if ("AbortError" === j3.name) {
      if (L2)
        throw new Error("Timeout exceeded");
      throw a("Request canceled");
    }
    if (!(!p3 && j3 instanceof TypeError && P.proxyUrl) || s3.body || "delete" === s3.method || "head" === s3.method || "post" === s3.method || "put" === s3.method || e2.useProxy || H2(r4))
      throw j3;
    e2.redoRequest = true, H({ proxyUrl: P.proxyUrl, urlPrefix: X(r4) ?? "" });
  } finally {
    C2 && clearTimeout(C2);
  }
  return [p3, v2];
}
async function G(e2, t3) {
  if (null != e2.responseData)
    return e2.responseData;
  if (e2.headers && (t3.requestOptions.headers = { ...t3.requestOptions.headers, ...e2.headers }), e2.query && (t3.requestOptions.query = { ...t3.requestOptions.query, ...e2.query }), e2.before) {
    let o, a3;
    try {
      a3 = await e2.before(t3);
    } catch (s3) {
      o = N("request:interceptor", s3, t3);
    }
    if ((a3 instanceof Error || a3 instanceof s2) && (o = N("request:interceptor", a3, t3)), o)
      throw e2.error && e2.error(o), o;
    return a3;
  }
}
function J2(e2) {
  if (e2) {
    for (const t3 of Object.getOwnPropertyNames(e2))
      if (e2[t3])
        return true;
  }
  return false;
}
function X2(e2, t3) {
  let r4;
  try {
    r4 = new DOMParser().parseFromString(e2, t3);
  } catch {
  }
  if (!r4 || r4.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return r4;
}
async function Q2(e2) {
  var _a;
  let r4, s3;
  await z(e2);
  try {
    do {
      [r4, s3] = await W(e2);
    } while (!await V(e2, r4, s3));
  } catch (n) {
    const t3 = N("request:server", n, e2.params, r4);
    throw t3.details.ssl = e2.useSSL, e2.interceptor && e2.interceptor.error && e2.interceptor.error(t3), t3;
  }
  const o = e2.params.url;
  if (s3 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e2.hasToken && !e2.credentialToken && ((_a = s3.user) == null ? void 0 : _a.username) && !Q(o)) {
      const e3 = X(o, true);
      e3 && P.trustedServers.push(e3);
    }
    Array.isArray(s3.authorizedCrossOriginNoCorsDomains) && m(s3.authorizedCrossOriginNoCorsDomains);
  }
  const a3 = e2.credential;
  if (a3 && r2) {
    const e3 = r2.findServerInfo(a3.server);
    let r5 = e3 && e3.owningSystemUrl;
    if (r5) {
      r5 = r5.replace(/\/?$/, "/sharing");
      const e4 = r2.findCredential(r5, a3.userId);
      e4 && -1 === r2._getIdenticalSvcIdx(r5, e4) && e4.resources.unshift(r5);
    }
  }
  return { data: s3, getHeader: r4 ? (e3) => r4 == null ? void 0 : r4.headers.get(e3) : M2, httpStatus: (r4 == null ? void 0 : r4.status) ?? 200, requestOptions: e2.params.requestOptions, ssl: e2.useSSL, url: e2.params.url };
}
async function V(e2, r4, s3) {
  if (e2.redoRequest)
    return e2.redoRequest = false, false;
  const o = e2.params.requestOptions;
  if (!r4 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let a3, n;
  if (!r4.ok)
    throw a3 = new Error(`Unable to load ${r4.url} status: ${r4.status}`), a3[R] = s3, a3;
  s3 && (s3.error ? a3 = s3.error : "error" === s3.status && Array.isArray(s3.messages) && (a3 = { ...s3 }, a3[R] = s3, a3.details = s3.messages));
  let i, l = null;
  a3 && (n = Number(a3.code), l = a3.hasOwnProperty("subcode") ? Number(a3.subcode) : null, i = a3.messageCode, i = i && i.toUpperCase());
  const u2 = o.authMode;
  if (403 === n && (4 === l || a3.message && a3.message.toLowerCase().includes("ssl") && !a3.message.toLowerCase().includes("permission"))) {
    if (!e2.useSSL)
      return e2.useSSL = true, false;
  } else if (!e2.hasToken && e2.useIdentity && ("no-prompt" !== u2 || 498 === n) && void 0 !== n && _.includes(n) && !K2(e2.params.url) && (403 !== n || i && !F.includes(i) && (null == l || 2 === l && e2.credentialToken))) {
    await $();
    try {
      const r5 = await r2.getCredential(e2.params.url, { error: N("request:server", a3, e2.params), prompt: "no-prompt" !== u2, signal: e2.controller.signal, token: e2.credentialToken });
      return e2.credential = r5, e2.credentialToken = r5.token, e2.useSSL = e2.useSSL || r5.ssl, false;
    } catch (c2) {
      if ("no-prompt" === u2)
        return e2.credential = void 0, e2.credentialToken = void 0, false;
      a3 = c2;
    }
  }
  if (a3)
    throw a3;
  return true;
}
function Y(e2, t3, r4 = false) {
  const s3 = t3.controller.signal, o = new Image();
  return t3.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = P.priority, o.src = e2, c(o, e2, r4, s3);
}
U._abortableFetch = null, U._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];

export {
  r3 as r,
  c,
  U
};
//# sourceMappingURL=chunk-JU2WP2RZ.js.map

import {
  E,
  a as a2,
  u as u2
} from "./chunk-YNAIRSAG.js";
import {
  A,
  B,
  C,
  D,
  F,
  G,
  L,
  M,
  P,
  U,
  V,
  Y,
  c,
  f,
  n,
  t as t2,
  u
} from "./chunk-DNXRTHCH.js";
import {
  r as r2
} from "./chunk-6D47PMZF.js";
import {
  s as s2
} from "./chunk-C2WY74GI.js";
import {
  a,
  e,
  s2 as s
} from "./chunk-MKHZ5X6F.js";
import {
  h,
  r,
  t,
  v
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/views/webgl/Util.js
function i(e2) {
  const r3 = e2.gl;
  switch (r3.getError()) {
    case r3.NO_ERROR:
      return null;
    case r3.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r3.INVALID_VALUE:
      return "An unacceptable value has been specified for an argument";
    case r3.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r3.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r3.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r3.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function n2(e2, r3) {
  return e2.vertexBuffers[r3].size / o(e2.layout[r3]);
}
function o(e2) {
  return e2[0].stride;
}
function R(e2, r3, t3, s4, a4 = 0) {
  const c3 = e2.gl, i2 = e2.capabilities.instancing;
  e2.bindBuffer(t3);
  for (const n3 of s4) {
    const e3 = r3.get(n3.name);
    void 0 === e3 && console.error(`There is no location for vertex attribute '${n3.name}' defined.`);
    const t4 = a4 * n3.stride;
    if (n3.count <= 4)
      c3.vertexAttribPointer(e3, n3.count, n3.type, n3.normalized, n3.stride, n3.offset + t4), c3.enableVertexAttribArray(e3), n3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3, n3.divisor);
    else if (9 === n3.count)
      for (let r4 = 0; r4 < 3; r4++)
        c3.vertexAttribPointer(e3 + r4, 3, n3.type, n3.normalized, n3.stride, n3.offset + 12 * r4 + t4), c3.enableVertexAttribArray(e3 + r4), n3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3 + r4, n3.divisor);
    else if (16 === n3.count)
      for (let r4 = 0; r4 < 4; r4++)
        c3.vertexAttribPointer(e3 + r4, 4, n3.type, n3.normalized, n3.stride, n3.offset + 16 * r4 + t4), c3.enableVertexAttribArray(e3 + r4), n3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3 + r4, n3.divisor);
    else
      console.error("Unsupported vertex attribute element count: " + n3.count);
  }
}
function E2(e2, t3, s4, a4) {
  const c3 = e2.gl, i2 = e2.capabilities.instancing;
  e2.bindBuffer(s4);
  for (const r3 of a4) {
    const e3 = t3.get(r3.name);
    if (r3.count <= 4)
      c3.disableVertexAttribArray(e3), r3.divisor && r3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3, 0);
    else if (9 === r3.count)
      for (let t4 = 0; t4 < 3; t4++)
        c3.disableVertexAttribArray(e3 + t4), r3.divisor && r3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3 + t4, 0);
    else if (16 === r3.count)
      for (let t4 = 0; t4 < 4; t4++)
        c3.disableVertexAttribArray(e3 + t4), r3.divisor && r3.divisor > 0 && i2 && i2.vertexAttribDivisor(e3 + t4, 0);
    else
      console.error("Unsupported vertex attribute element count: " + r3.count);
  }
  e2.unbindBuffer(A.ARRAY_BUFFER);
}
function _(e2) {
  switch (e2) {
    case P.ALPHA:
    case P.LUMINANCE:
    case P.RED:
    case P.RED_INTEGER:
    case U.R8:
    case U.R8I:
    case U.R8UI:
    case U.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case P.LUMINANCE_ALPHA:
    case P.RG:
    case P.RG_INTEGER:
    case U.RGBA4:
    case U.R16F:
    case U.R16I:
    case U.R16UI:
    case U.RG8:
    case U.RG8I:
    case U.RG8UI:
    case U.RG8_SNORM:
    case U.RGB565:
    case U.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case P.DEPTH_COMPONENT:
    case P.RGB:
    case P.RGB_INTEGER:
    case U.RGB8:
    case U.RGB8I:
    case U.RGB8UI:
    case U.RGB8_SNORM:
    case U.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case P.DEPTH_STENCIL:
    case P.RGBA:
    case P.RGBA_INTEGER:
    case U.RGBA8:
    case U.R32F:
    case U.R11F_G11F_B10F:
    case U.RG16F:
    case U.R32I:
    case U.R32UI:
    case U.RG16I:
    case U.RG16UI:
    case U.RGBA8I:
    case U.RGBA8UI:
    case U.RGBA8_SNORM:
    case U.SRGB8_ALPHA8:
    case U.RGB9_E5:
    case U.RGB10_A2UI:
    case U.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case U.RGB16F:
    case U.RGB16I:
    case U.RGB16UI:
      return 6;
    case U.RG32F:
    case U.RG32I:
    case U.RG32UI:
    case U.RGBA16F:
    case U.RGBA16I:
    case U.RGBA16UI:
      return 8;
    case U.RGB32F:
    case U.RGB32I:
    case U.RGB32UI:
      return 12;
    case U.RGBA32F:
    case U.RGBA32I:
    case U.RGBA32UI:
      return 16;
    case u.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case u.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case u.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case u.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case u.COMPRESSED_R11_EAC:
    case u.COMPRESSED_SIGNED_R11_EAC:
    case u.COMPRESSED_RGB8_ETC2:
    case u.COMPRESSED_SRGB8_ETC2:
    case u.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case u.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case u.COMPRESSED_RG11_EAC:
    case u.COMPRESSED_SIGNED_RG11_EAC:
    case u.COMPRESSED_RGBA8_ETC2_EAC:
    case u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}
function u3(r3) {
  if (t(r3))
    return 0;
  if ("descriptor" in r3)
    return r3.glName ? u3(r3.descriptor) : 0;
  const t3 = r3.internalFormat || "pixelFormat" in r3 && r3.pixelFormat;
  if (!t3)
    return 0;
  const s4 = "hasMipmap" in r3 && r3.hasMipmap ? 1.3 : 1, a4 = r3.width * r3.height;
  return _(t3) * a4 * s4;
}

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var a3 = s2.getLogger("esri.views.webgl.VertexArrayObject");
var f2 = class {
  constructor(t3, e2, i2, r3, n3 = null) {
    this._context = t3, this._locations = e2, this._layout = i2, this._buffers = r3, this._indexBuffer = n3, this._glName = null, this._initialized = false, t3.instanceCounter.increment(t2.VertexArrayObject, this);
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get size() {
    return Object.keys(this._buffers).reduce((t3, e2) => t3 + this._buffers[e2].size, r(this._indexBuffer) ? this._indexBuffer.size : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  dispose(t3 = true) {
    var _a, _b, _c;
    if (!this._context)
      return void ((this._glName || t3 && Object.getOwnPropertyNames(this._buffers).length > 0) && a3.warn("Leaked WebGL VAO"));
    if (this._glName) {
      const t4 = (_b = (_a = this._context) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.vao;
      t4 ? (t4.deleteVertexArray(this._glName), this._glName = null) : a3.warn("Leaked WebGL VAO");
    }
    if (this._context.getBoundVAO() === this && this._context.bindVAO(null), t3) {
      for (const t4 in this._buffers)
        (_c = this._buffers[t4]) == null ? void 0 : _c.dispose(), delete this._buffers[t4];
      this._indexBuffer = h(this._indexBuffer);
    }
    this._context.instanceCounter.decrement(t2.VertexArrayObject, this), this._context = v(this._context);
  }
  initialize() {
    if (this._initialized)
      return;
    const t3 = this._context.capabilities.vao;
    if (t3) {
      const e2 = t3.createVertexArray();
      t3.bindVertexArray(e2), this._bindLayout(), t3.bindVertexArray(null), this._glName = e2;
    }
    this._initialized = true;
  }
  bind() {
    this.initialize();
    const t3 = this._context.capabilities.vao;
    t3 ? t3.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout());
  }
  _bindLayout() {
    const { _buffers: t3, _layout: i2, _indexBuffer: r3 } = this;
    t3 || a3.error("Vertex buffer dictionary is empty!");
    const s4 = this._context.gl;
    for (const e2 in t3) {
      const r4 = t3[e2];
      r4 || a3.error("Vertex buffer is uninitialized!");
      const s5 = i2[e2];
      s5 || a3.error("Vertex element descriptor is empty!"), R(this._context, this._locations, r4, s5);
    }
    if (r(r3)) {
      !!this._context.capabilities.vao ? s4.bindBuffer(s4.ELEMENT_ARRAY_BUFFER, r3.glName) : this._context.bindBuffer(r3);
    }
  }
  unbind() {
    this.initialize();
    const t3 = this._context.capabilities.vao;
    t3 ? t3.bindVertexArray(null) : this._unbindLayout();
  }
  _unbindLayout() {
    const { _buffers: t3, _layout: i2 } = this;
    t3 || a3.error("Vertex buffer dictionary is empty!");
    for (const e2 in t3) {
      const r3 = t3[e2];
      r3 || a3.error("Vertex buffer is uninitialized!");
      const s4 = i2[e2];
      E2(this._context, this._locations, r3, s4);
    }
    r(this._indexBuffer) && this._context.unbindBuffer(this._indexBuffer.bufferType);
  }
};

// node_modules/@arcgis/core/views/webgl/BufferObject.js
var c2 = s2.getLogger("esri.views.webgl.BufferObject");
var E3 = class {
  static createIndex(e2, t3, r3) {
    return new E3(e2, A.ELEMENT_ARRAY_BUFFER, t3, r3);
  }
  static createVertex(e2, t3, r3) {
    return new E3(e2, A.ARRAY_BUFFER, t3, r3);
  }
  static createUniform(e2, t3, r3) {
    if (e2.type !== r2.WEBGL2)
      throw new Error("Uniform buffers are supported in WebGL2 only!");
    return new E3(e2, A.UNIFORM_BUFFER, t3, r3);
  }
  static createPixelPack(e2, t3 = F.STREAM_READ, r3) {
    if (e2.type !== r2.WEBGL2)
      throw new Error("Pixel pack buffers are supported in WebGL2 only!");
    const i2 = new E3(e2, A.PIXEL_PACK_BUFFER, t3);
    return r3 && i2.setSize(r3), i2;
  }
  static createPixelUnpack(e2, t3 = F.STREAM_DRAW, r3) {
    if (e2.type !== r2.WEBGL2)
      throw new Error("Pixel unpack buffers are supported in WebGL2 only!");
    return new E3(e2, A.PIXEL_UNPACK_BUFFER, t3, r3);
  }
  constructor(e2, t3, r3, i2) {
    this._context = e2, this.bufferType = t3, this.usage = r3, this._glName = null, this._size = -1, this._indexType = void 0, e2.instanceCounter.increment(t2.BufferObject, this), this._glName = this._context.gl.createBuffer(), u2(this._context.gl), i2 && this.setData(i2);
  }
  get glName() {
    return this._glName;
  }
  get size() {
    return this._size;
  }
  get indexType() {
    return this._indexType;
  }
  get byteSize() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER ? this._indexType === C.UNSIGNED_INT ? 4 * this._size : 2 * this._size : this._size;
  }
  get _isVAOAware() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER || this.bufferType === A.ARRAY_BUFFER;
  }
  dispose() {
    var _a;
    if ((_a = this._context) == null ? void 0 : _a.gl) {
      if (this._glName) {
        this._context.gl.deleteBuffer(this._glName), this._glName = null;
      }
      this._context.instanceCounter.decrement(t2.BufferObject, this), this._context = v(this._context);
    } else
      this._glName && c2.warn("Leaked WebGL buffer object");
  }
  setSize(e2, t3 = null) {
    if (e2 <= 0 && c2.error("Buffer size needs to be positive!"), this.bufferType === A.ELEMENT_ARRAY_BUFFER && r(t3))
      switch (this._indexType = t3, t3) {
        case C.UNSIGNED_SHORT:
          e2 *= 2;
          break;
        case C.UNSIGNED_INT:
          e2 *= 4;
      }
    this._setBufferData(e2);
  }
  setData(e2) {
    if (!e2)
      return;
    let t3 = e2.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (e(e2) && (t3 /= 2, this._indexType = C.UNSIGNED_SHORT), s(e2) && (t3 /= 4, this._indexType = C.UNSIGNED_INT)), this._setBufferData(t3, e2);
  }
  _setBufferData(e2, t3 = null) {
    this._size = e2;
    const r3 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const s4 = this._context.gl;
    r(t3) ? s4.bufferData(this.bufferType, t3, this.usage) : s4.bufferData(this.bufferType, e2, this.usage), u2(s4), this._isVAOAware && this._context.bindVAO(r3);
  }
  setSubData(e2, t3, r3, i2) {
    if (!e2)
      return;
    (t3 < 0 || t3 * e2.BYTES_PER_ELEMENT >= this.byteSize) && c2.error("offset is out of range!"), r3 >= i2 && c2.error("end must be bigger than start!"), (t3 + (i2 - r3)) * e2.BYTES_PER_ELEMENT > this.byteSize && c2.error("An attempt to write beyond the end of the buffer!");
    const s4 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const n3 = this._context.gl;
    if (this._context.type === r2.WEBGL2)
      n3.bufferSubData(this.bufferType, t3 * e2.BYTES_PER_ELEMENT, e2, r3, i2 - r3);
    else {
      const s5 = 0 === r3 && i2 === e2.length ? e2 : e2.subarray(r3, i2);
      n3.bufferSubData(this.bufferType, t3 * e2.BYTES_PER_ELEMENT, s5);
    }
    u2(n3), this._isVAOAware && this._context.bindVAO(s4);
  }
  getSubData(e2, t3 = 0, r3, i2) {
    if (this._context.type !== r2.WEBGL2)
      return void c2.error("Get buffer subdata is supported in WebGL2 only!");
    if (r3 < 0 || i2 < 0)
      return void c2.error("Problem getting subdata: offset and length were less than zero!");
    const s4 = b(e2) ? e2.BYTES_PER_ELEMENT : 1;
    if (s4 * ((r3 ?? 0) + (i2 ?? 0)) > e2.byteLength)
      return void c2.error("Problem getting subdata: offset and length exceeded destination size!");
    t3 + s4 * (i2 ?? 0) > this.byteSize && c2.warn("Potential problem getting subdata: requested data exceeds buffer size!");
    const n3 = this._context.gl;
    this._context.bindBuffer(this, A.COPY_READ_BUFFER), n3.getBufferSubData(A.COPY_READ_BUFFER, t3, e2, r3, i2), this._context.unbindBuffer(A.COPY_READ_BUFFER);
  }
  async getSubDataAsync(e2, t3 = 0, r3, i2) {
    this._context.type === r2.WEBGL2 ? (await this._context.clientWaitAsync(), this.getSubData(e2, t3, r3, i2)) : c2.error("Get buffer subdata is supported in WebGL2 only!");
  }
};
function b(t3) {
  return a(t3);
}

// node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var s3 = class {
  constructor(e2, s4) {
    this._context = e2, this._desc = s4, this.type = "renderbuffer", this._context.instanceCounter.increment(t2.Renderbuffer, this);
    const i2 = this._context.gl;
    this.glName = i2.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: n3, height: o2, internalFormat: h2, multisampled: c3 } = s4;
    if (c3) {
      if (this._context.type !== r2.WEBGL2)
        throw new Error("Multisampled renderbuffers are not supported in WebGL1!");
      i2.renderbufferStorageMultisample(i2.RENDERBUFFER, this.samples, h2, n3, o2);
    } else
      i2.renderbufferStorage(i2.RENDERBUFFER, h2, n3, o2);
  }
  get descriptor() {
    return this._desc;
  }
  get samples() {
    const e2 = this._desc.samples, t3 = this._context.parameters.maxSamples;
    return e2 ? Math.min(e2, t3) : t3;
  }
  resize(e2, t3) {
    const r3 = this._desc;
    if (r3.width === e2 && r3.height === t3)
      return;
    r3.width = e2, r3.height = t3;
    const s4 = this._context.gl;
    if (this._context.bindRenderbuffer(this), r3.multisampled) {
      s4.renderbufferStorageMultisample(s4.RENDERBUFFER, this.samples, r3.internalFormat, r3.width, r3.height);
    } else
      s4.renderbufferStorage(s4.RENDERBUFFER, r3.internalFormat, r3.width, r3.height);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(t2.Renderbuffer, this), this._context = v(this._context));
  }
};

// node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var x = class {
  constructor(t3, i2, r3 = null, h2 = null) {
    if (this._context = t3, this._glName = null, this._depthAttachment = null, this._stencilAttachment = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._depthStencilTexture = null, this._initialized = false, this._desc = { ...i2 }, t3.instanceCounter.increment(t2.FramebufferObject, this), r(r3)) {
      Array.isArray(r3) || (r3 = [r3]);
      for (let t4 = 0; t4 < r3.length; ++t4) {
        const e2 = r3[t4], i3 = f.COLOR_ATTACHMENT0 + t4;
        let h3;
        C2(e2) ? (b2(e2) ? (h3 = e2.descriptor, this._colorAttachments.set(i3, e2)) : (h3 = e2, this._colorAttachments.set(i3, new E(this._context, h3))), U2(h3, this._desc)) : (D2(e2) ? (h3 = e2.descriptor, this._colorAttachments.set(i3, e2)) : (h3 = e2, this._colorAttachments.set(i3, new s3(this._context, h3))), H(h3, this._desc)), this._validateColorAttachmentPoint(i3);
      }
    }
    if (r(h2)) {
      let t4, e2;
      if (C2(h2))
        this._context.capabilities.depthTexture || console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"), b2(h2) ? (e2 = h2.descriptor, this._depthStencilTexture = h2) : (e2 = h2, this._depthStencilTexture = new E(this._context, e2)), U2(e2, this._desc);
      else {
        D2(h2) ? (e2 = h2.descriptor, t4 = h2) : (e2 = h2, t4 = new s3(this._context, e2));
        const i3 = this._desc.depthStencilTarget ?? V.DEPTH_STENCIL_RENDER_BUFFER;
        i3 === V.STENCIL_RENDER_BUFFER ? this._stencilAttachment = t4 : i3 === V.DEPTH_RENDER_BUFFER || i3 === V.DEPTH_STENCIL_RENDER_BUFFER ? this._depthAttachment = t4 : console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'), this._desc.depthStencilTarget = i3, H(e2, this._desc);
      }
    }
  }
  dispose() {
    if (!this._desc)
      return;
    const t3 = this._context.getBoundFramebufferObject();
    if (this._disposeColorAttachments(), this._disposeDepthStencilAttachments(), this._glName) {
      this._context.gl.deleteFramebuffer(this._glName), this._glName = null;
    }
    this._context.bindFramebuffer(t3), this._context.instanceCounter.decrement(t2.FramebufferObject, this), this._desc = null;
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._desc;
  }
  get colorTexture() {
    const t3 = this._colorAttachments.get(f.COLOR_ATTACHMENT0);
    return t3 && b2(t3) ? t3 : null;
  }
  get colorAttachment() {
    return this._colorAttachments.get(f.COLOR_ATTACHMENT0);
  }
  get depthStencilAttachment() {
    return this._depthStencilTexture || this._depthAttachment || this._stencilAttachment;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    return this._desc.width ?? 0;
  }
  get height() {
    return this._desc.height ?? 0;
  }
  get gpuMemoryUsage() {
    return [...this._colorAttachments].reduce((t3, [e2, i2]) => t3 + u3(i2), 0) + u3(this.depthStencilAttachment);
  }
  getColorTexture(t3) {
    const e2 = this._colorAttachments.get(t3);
    return e2 && b2(e2) ? e2 : null;
  }
  attachColorTexture(t3, e2 = f.COLOR_ATTACHMENT0) {
    if (!t3)
      return;
    this._validateColorAttachmentPoint(e2);
    U2(t3.descriptor, this._desc), this._disposeColorAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, e2)), this._colorAttachments.set(e2, t3);
  }
  detachColorTexture(t3 = f.COLOR_ATTACHMENT0) {
    const e2 = this._colorAttachments.get(t3);
    if (b2(e2)) {
      const i2 = e2;
      return this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3)), this._colorAttachments.delete(t3), i2;
    }
  }
  setColorTextureTarget(t3, e2 = f.COLOR_ATTACHMENT0) {
    const i2 = this._colorAttachments.get(e2);
    b2(i2) && this._framebufferTexture2D(i2.glName, e2, t3);
  }
  attachDepthStencilTexture(t3) {
    if (t(t3))
      return;
    const e2 = t3.descriptor;
    e2.pixelFormat !== P.DEPTH_STENCIL && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"), e2.dataType !== G.UNSIGNED_INT_24_8 && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"), this._context.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"), U2(e2, this._desc), this._desc.depthStencilTarget && this._desc.depthStencilTarget !== V.DEPTH_STENCIL_TEXTURE && (this._desc.depthStencilTarget = V.DEPTH_STENCIL_TEXTURE), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, c)), this._depthStencilTexture = t3;
  }
  detachDepthStencilTexture() {
    const t3 = this._depthStencilTexture;
    return t3 && this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, c)), this._depthStencilTexture = null, t3;
  }
  attachDepthStencilBuffer(t3) {
    if (t(t3))
      return;
    const e2 = t3.descriptor;
    if (e2.internalFormat !== B.DEPTH_STENCIL && e2.internalFormat !== B.DEPTH_COMPONENT16 && console.error("Depth/Stencil buffer must have correct internalFormat"), H(e2, this._desc), this._disposeDepthStencilAttachments(), this._desc.depthStencilTarget = e2.internalFormat === B.DEPTH_STENCIL ? V.DEPTH_STENCIL_RENDER_BUFFER : V.DEPTH_RENDER_BUFFER, this._initialized) {
      this._context.bindFramebuffer(this);
      const e3 = this._context.gl, i2 = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? e3.DEPTH_ATTACHMENT : e3.DEPTH_STENCIL_ATTACHMENT;
      e3.framebufferRenderbuffer(n.FRAMEBUFFER, i2, e3.RENDERBUFFER, t3.glName);
    }
    this._depthAttachment = t3;
  }
  detachDepthStencilBuffer() {
    const t3 = this._context.gl, e2 = this._depthAttachment;
    if (e2 && this._initialized) {
      this._context.bindFramebuffer(this);
      const e3 = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? t3.DEPTH_ATTACHMENT : t3.DEPTH_STENCIL_ATTACHMENT;
      t3.framebufferRenderbuffer(n.FRAMEBUFFER, e3, t3.RENDERBUFFER, null);
    }
    return this._depthAttachment = null, e2;
  }
  detachAll() {
    this._colorAttachments.forEach((t3, e2) => this._detachColorAttachment(e2)), this.detachDepthStencilBuffer(), this.detachDepthStencilTexture();
  }
  copyToTexture(t3, e2, i2, r3, h2, s4, n3) {
    (t3 < 0 || e2 < 0 || h2 < 0 || s4 < 0) && console.error("Offsets cannot be negative!"), (i2 <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!");
    const c3 = this._desc, o2 = n3.descriptor;
    n3.descriptor.target !== M.TEXTURE_2D && console.error("Texture target must be TEXTURE_2D!"), (null == (c3 == null ? void 0 : c3.width) || null == (c3 == null ? void 0 : c3.height) || null == (o2 == null ? void 0 : o2.width) || null == (o2 == null ? void 0 : o2.height) || t3 + i2 > c3.width || e2 + r3 > c3.height || h2 + i2 > o2.width || s4 + r3 > o2.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const _2 = this._context, a4 = _2.bindTexture(n3, E.TEXTURE_UNIT_FOR_UPDATES);
    _2.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES), _2.bindFramebuffer(this), _2.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, h2, s4, t3, e2, i2, r3), _2.bindTexture(a4, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(t3, e2, i2, r3, h2, s4, n3) {
    (i2 <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!"), n3 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this);
    this._context.gl.readPixels(t3, e2, i2, r3, h2, s4, n3);
  }
  async readPixelsAsync(t3, e2, i2, n3, c3, o2, _2) {
    if (this._context.type !== r2.WEBGL2)
      return a2() && console.warn("Attempting to read pixels using pixel buffer object without WebGL2"), void this.readPixels(t3, e2, i2, n3, c3, o2, _2);
    const a4 = this._context.gl, l = E3.createPixelPack(this._context, F.STREAM_READ, _2.byteLength);
    this._context.bindBuffer(l), this._context.bindFramebuffer(this), a4.readPixels(t3, e2, i2, n3, c3, o2, 0), this._context.unbindBuffer(A.PIXEL_PACK_BUFFER), await l.getSubDataAsync(_2), l.dispose();
  }
  resize(t3, e2) {
    const i2 = this._desc;
    if (i2.width !== t3 || i2.height !== e2) {
      if (i2.width = t3, i2.height = e2, !this._initialized)
        return this._colorAttachments.forEach((i3) => {
          i3 && i3.resize(t3, e2);
        }), void (this._depthStencilTexture && this._depthStencilTexture.resize(t3, e2));
      this._colorAttachments.forEach((i3) => {
        i3 && i3.resize(t3, e2);
      }), null != this._depthStencilTexture ? this._depthStencilTexture.resize(t3, e2) : (this._depthAttachment || this._stencilAttachment) && (this._depthAttachment && this._depthAttachment.resize(t3, e2), this._stencilAttachment && this._stencilAttachment.resize(t3, e2)), this._context.getBoundFramebufferObject() === this && this._context.bindFramebuffer(null), this._initialized = false;
    }
  }
  initializeAndBind(t3 = n.FRAMEBUFFER) {
    const e2 = this._context.gl;
    if (this._initialized)
      return void e2.bindFramebuffer(t3, this.glName);
    this._glName && e2.deleteFramebuffer(this._glName);
    const i2 = this._context, r3 = e2.createFramebuffer(), s4 = this._desc, n3 = s4.colorTarget ?? Y.RENDER_BUFFER, l = s4.width ?? 1, u4 = s4.height ?? 1;
    if (e2.bindFramebuffer(t3, r3), 0 === this._colorAttachments.size)
      if (n3 === Y.TEXTURE || n3 === Y.CUBEMAP)
        this._colorAttachments.set(f.COLOR_ATTACHMENT0, S(i2, s4, this.descriptor.colorTarget === Y.CUBEMAP ? M.TEXTURE_CUBE_MAP : M.TEXTURE_2D));
      else {
        const t4 = new s3(i2, { internalFormat: U.RGBA4, width: l, height: u4 });
        this._colorAttachments.set(f.COLOR_ATTACHMENT0, t4);
      }
    this._colorAttachments.forEach((i3, r4) => {
      i3 && (b2(i3) ? this._framebufferTexture2D(i3.glName, r4, P2(i3), t3) : e2.framebufferRenderbuffer(t3, r4, e2.RENDERBUFFER, i3.glName));
    });
    const f3 = s4.depthStencilTarget ?? V.NONE;
    switch (f3) {
      case V.DEPTH_RENDER_BUFFER:
      case V.DEPTH_STENCIL_RENDER_BUFFER: {
        this._depthAttachment || (this._depthAttachment = new s3(i2, { internalFormat: s4.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? B.DEPTH_COMPONENT16 : B.DEPTH_STENCIL, width: l, height: u4 }));
        const r4 = f3 === V.DEPTH_RENDER_BUFFER ? e2.DEPTH_ATTACHMENT : e2.DEPTH_STENCIL_ATTACHMENT;
        e2.framebufferRenderbuffer(t3, r4, e2.RENDERBUFFER, this._depthAttachment.glName);
        break;
      }
      case V.STENCIL_RENDER_BUFFER:
        this._stencilAttachment || (this._stencilAttachment = new s3(i2, { internalFormat: B.STENCIL_INDEX8, width: l, height: u4 })), e2.framebufferRenderbuffer(t3, e2.STENCIL_ATTACHMENT, e2.RENDERBUFFER, this._stencilAttachment.glName);
        break;
      case V.DEPTH_STENCIL_TEXTURE:
        if (!this._depthStencilTexture) {
          i2.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");
          const t4 = { target: M.TEXTURE_2D, pixelFormat: P.DEPTH_STENCIL, dataType: G.UNSIGNED_INT_24_8, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, width: l, height: u4 };
          this._depthStencilTexture = new E(i2, t4);
        }
        this._framebufferTexture2D(this._depthStencilTexture.glName, e2.DEPTH_STENCIL_ATTACHMENT, P2(this._depthStencilTexture), t3);
    }
    if (a2()) {
      e2.checkFramebufferStatus(t3) !== e2.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = r3, this._initialized = true;
  }
  _framebufferTexture2D(t3, e2 = f.COLOR_ATTACHMENT0, i2 = M.TEXTURE_2D, r3 = n.FRAMEBUFFER, h2 = 0) {
    this._context.gl.framebufferTexture2D(r3, e2, i2, t3, h2);
  }
  _detachColorAttachment(t3) {
    a2() && console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");
    const e2 = this._context.gl, i2 = this._colorAttachments.get(t3);
    return b2(i2) ? this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3)) : this._initialized && (this._context.bindFramebuffer(this), e2.framebufferRenderbuffer(n.FRAMEBUFFER, t3, e2.RENDERBUFFER, null)), this._colorAttachments.delete(t3), i2;
  }
  _disposeColorAttachments() {
    this._colorAttachments.forEach((t3, e2) => {
      this._detachColorAttachment(e2), t3.dispose();
    }), this._colorAttachments.clear();
  }
  _disposeDepthStencilAttachments() {
    const t3 = this._context.gl;
    if (this._depthAttachment) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const e2 = this._desc.depthStencilTarget === V.DEPTH_RENDER_BUFFER ? t3.DEPTH_ATTACHMENT : t3.DEPTH_STENCIL_ATTACHMENT;
        t3.framebufferRenderbuffer(n.FRAMEBUFFER, e2, t3.RENDERBUFFER, null);
      }
      this._depthAttachment.dispose(), this._depthAttachment = null;
    }
    this._stencilAttachment && (this._initialized && (this._context.bindFramebuffer(this), t3.framebufferRenderbuffer(n.FRAMEBUFFER, t3.STENCIL_ATTACHMENT, t3.RENDERBUFFER, null)), this._stencilAttachment.dispose(), this._stencilAttachment = null), this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture.dispose(), this._depthStencilTexture = null);
  }
  _validateColorAttachmentPoint(e2) {
    if (-1 === x._MAX_COLOR_ATTACHMENTS) {
      const t3 = this._context.capabilities.drawBuffers;
      if (t3) {
        const e3 = this._context.gl;
        x._MAX_COLOR_ATTACHMENTS = e3.getParameter(t3.MAX_COLOR_ATTACHMENTS);
      } else
        x._MAX_COLOR_ATTACHMENTS = 1;
    }
    const i2 = e2 - f.COLOR_ATTACHMENT0;
    i2 + 1 > x._MAX_COLOR_ATTACHMENTS && s2.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${i2 + 1}. Implementation supports up to ${x._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
function b2(t3) {
  return null != t3 && "type" in t3 && "texture" === t3.type;
}
function D2(t3) {
  return null != t3 && "type" in t3 && "renderbuffer" === t3.type;
}
function C2(t3) {
  return b2(t3) || null != t3 && "pixelFormat" in t3;
}
function S(t3, e2, i2) {
  return new E(t3, { target: i2, pixelFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, width: e2.width, height: e2.height });
}
function U2(t3, e2) {
  t3.target !== M.TEXTURE_2D && t3.target !== M.TEXTURE_CUBE_MAP && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"), void 0 !== e2.width && e2.width >= 0 && void 0 !== e2.height && e2.height >= 0 ? e2.width === t3.width && e2.height === t3.height || console.error("Color attachment texture must match the framebuffer's!") : (e2.width = t3.width, e2.height = t3.height);
}
function H(t3, e2) {
  void 0 !== e2.width && e2.width >= 0 && void 0 !== e2.height && e2.height >= 0 ? e2.width === t3.width && e2.height === t3.height || console.error("Renderbuffer dimensions must match the framebuffer's!") : (e2.width = t3.width, e2.height = t3.height);
}
function P2(t3) {
  return t3.descriptor.target === M.TEXTURE_CUBE_MAP ? M.TEXTURE_CUBE_MAP_POSITIVE_X : M.TEXTURE_2D;
}
x._MAX_COLOR_ATTACHMENTS = -1;

export {
  i,
  n2 as n,
  _,
  f2 as f,
  E3 as E,
  s3 as s,
  x
};
//# sourceMappingURL=chunk-Y5X2DTPS.js.map

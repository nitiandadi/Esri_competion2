import {
  s as s3
} from "./chunk-RZHDFCVY.js";
import "./chunk-UJATNHHT.js";
import "./chunk-TE3PC254.js";
import "./chunk-3IDKVHSA.js";
import "./chunk-D4SYZIFV.js";
import {
  v
} from "./chunk-XWFAINWU.js";
import {
  p
} from "./chunk-NNXHBH3J.js";
import {
  u
} from "./chunk-L46P5ZGI.js";
import "./chunk-AOER6TTF.js";
import "./chunk-N5RJDK35.js";
import {
  _
} from "./chunk-D47GNCYL.js";
import "./chunk-B4KXWO6Z.js";
import {
  c
} from "./chunk-QSDDU4NM.js";
import {
  f as f2
} from "./chunk-FNGJTVTP.js";
import {
  O
} from "./chunk-3MIQEU54.js";
import {
  b
} from "./chunk-Q3FHJWKB.js";
import "./chunk-K7L4V6NL.js";
import "./chunk-763HXOZK.js";
import "./chunk-BRWDGS6Y.js";
import "./chunk-HZKQDRDV.js";
import "./chunk-CVSP2FBZ.js";
import "./chunk-UNUPXPO6.js";
import "./chunk-OF6BJKPA.js";
import "./chunk-PELFA5QO.js";
import "./chunk-FAK3SJAD.js";
import "./chunk-YMSHUIGU.js";
import "./chunk-RCZJUTGU.js";
import "./chunk-REIXEATJ.js";
import "./chunk-YEFLZ2OV.js";
import "./chunk-JLHQIHZ7.js";
import "./chunk-4GJORDIY.js";
import "./chunk-FXMJJBXP.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-WAN4YZSB.js";
import "./chunk-YZRPNTZZ.js";
import "./chunk-EVKJKYHI.js";
import "./chunk-TNQLNDIQ.js";
import "./chunk-FA3YUERM.js";
import "./chunk-LVRAFE6T.js";
import "./chunk-LSUFI7PR.js";
import "./chunk-5CMPUNQG.js";
import {
  U
} from "./chunk-YT74S35I.js";
import "./chunk-U5I7FQWJ.js";
import {
  A
} from "./chunk-M3KO43BW.js";
import "./chunk-JT54I3AY.js";
import "./chunk-TNTTCGVB.js";
import "./chunk-DC3QI5ZE.js";
import "./chunk-EGHLQERQ.js";
import "./chunk-7OAHPHOV.js";
import "./chunk-I2U7UK6N.js";
import "./chunk-UADQEL54.js";
import "./chunk-FQ7L63IU.js";
import "./chunk-6K5VVUVI.js";
import "./chunk-YHZVWABO.js";
import "./chunk-WATRS3LJ.js";
import "./chunk-CPUYSXBP.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-B6GJAETG.js";
import "./chunk-FC74MT6E.js";
import "./chunk-H2ENCYR3.js";
import {
  o
} from "./chunk-SVHG5VY2.js";
import "./chunk-S47644HM.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-DLM7WQKI.js";
import {
  a2 as a,
  e as e2,
  n2 as n,
  y3 as y2
} from "./chunk-7GTATSRF.js";
import "./chunk-MTJ2HM2W.js";
import "./chunk-PXVSWY3C.js";
import {
  f,
  w
} from "./chunk-QLY5H3XF.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import "./chunk-PR6SXADK.js";
import {
  F
} from "./chunk-MGJMBJDY.js";
import {
  e,
  r,
  t,
  y
} from "./chunk-WHB7G7RI.js";
import "./chunk-DFKQJ226.js";

// node_modules/@arcgis/core/layers/support/ElevationTileData.js
var e3 = class {
  constructor(a2, t2, s5, e4) {
    this._hasNoDataValues = null, this._minValue = null, this._maxValue = null, "pixelData" in a2 ? (this.values = a2.pixelData, this.width = a2.width, this.height = a2.height, this.noDataValue = a2.noDataValue) : (this.values = a2, this.width = t2, this.height = s5, this.noDataValue = e4);
  }
  get hasNoDataValues() {
    if (t(this._hasNoDataValues)) {
      const a2 = this.noDataValue;
      this._hasNoDataValues = this.values.includes(a2);
    }
    return this._hasNoDataValues;
  }
  get minValue() {
    return this._ensureBounds(), e(this._minValue);
  }
  get maxValue() {
    return this._ensureBounds(), e(this._maxValue);
  }
  _ensureBounds() {
    if (r(this._minValue))
      return;
    const { noDataValue: a2, values: t2 } = this;
    let e4 = 1 / 0, i = -1 / 0, h2 = true;
    for (const s5 of t2)
      s5 === a2 ? this._hasNoDataValues = true : (e4 = s5 < e4 ? s5 : e4, i = s5 > i ? s5 : i, h2 = false);
    h2 ? (this._minValue = 0, this._maxValue = 0) : (this._minValue = e4, this._maxValue = i > -3e38 ? i : 0);
  }
};

// node_modules/@arcgis/core/core/workers/WorkerHandle.js
var h = class {
  constructor(e4, t2, s5, i, h2 = {}) {
    this._mainMethod = t2, this._transferLists = s5, this._listeners = [], this._promise = u(e4, { ...h2, schedule: i }).then((e5) => {
      if (void 0 === this._thread) {
        this._thread = e5, this._promise = null, h2.hasInitialize && this.broadcast({}, "initialize");
        for (const e6 of this._listeners)
          this._connectListener(e6);
      } else
        e5.close();
    }), this._promise.catch((t3) => s.getLogger("esri.core.workers.WorkerHandle").error(`Failed to initialize ${e4} worker: ${t3}`));
  }
  on(r2, i) {
    const o3 = { removed: false, eventName: r2, callback: i, threadHandle: null };
    return this._listeners.push(o3), this._connectListener(o3), n(() => {
      o3.removed = true, F(this._listeners, o3), this._thread && r(o3.threadHandle) && o3.threadHandle.remove();
    });
  }
  destroy() {
    this._thread && (this._thread.close(), this._thread = null), this._promise = null;
  }
  invoke(e4, t2) {
    return this.invokeMethod(this._mainMethod, e4, t2);
  }
  invokeMethod(e4, t2, r2) {
    if (this._thread) {
      const s5 = this._transferLists[e4], i = s5 ? s5(t2) : [];
      return this._thread.invoke(e4, t2, { transferList: i, signal: r2 });
    }
    return this._promise ? this._promise.then(() => (f(r2), this.invokeMethod(e4, t2, r2))) : Promise.reject(null);
  }
  broadcast(e4, t2) {
    return this._thread ? Promise.all(this._thread.broadcast(t2, e4)).then(() => {
    }) : this._promise ? this._promise.then(() => this.broadcast(e4, t2)) : Promise.reject();
  }
  get promise() {
    return this._promise;
  }
  _connectListener(e4) {
    this._thread && this._thread.on(e4.eventName, e4.callback).then((t2) => {
      e4.removed || (e4.threadHandle = t2);
    });
  }
};

// node_modules/@arcgis/core/layers/support/LercDecoder.js
var s4 = class extends h {
  constructor(e4 = null) {
    super("LercWorker", "_decode", { _decode: (e5) => [e5.buffer] }, e4, { strategy: "dedicated" }), this.schedule = e4, this.ref = 0;
  }
  decode(e4, r2, t2) {
    return e4 && 0 !== e4.byteLength ? this.invoke({ buffer: e4, options: r2 }, t2) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (o2.forEach((e4, r2) => {
      e4 === this && o2.delete(r2);
    }), this.destroy());
  }
};
var o2 = /* @__PURE__ */ new Map();
function n2(t2 = null) {
  let n3 = o2.get(e(t2));
  return n3 || (r(t2) ? (n3 = new s4((e4) => t2.immediate.schedule(e4)), o2.set(t2, n3)) : (n3 = new s4(), o2.set(null, n3))), ++n3.ref, n3;
}

// node_modules/@arcgis/core/layers/ElevationLayer.js
var w2 = class extends s3(p(c(_(O(b))))) {
  constructor(...e4) {
    super(...e4), this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = n2();
  }
  normalizeCtorArgs(e4, r2) {
    return "string" == typeof e4 ? { url: e4, ...r2 } : e4;
  }
  destroy() {
    this._lercDecoder = y(this._lercDecoder);
  }
  readVersion(e4, r2) {
    let t2 = r2.currentVersion;
    return t2 || (t2 = 9.3), t2;
  }
  load(e4) {
    const r2 = r(e4) ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e5) => {
      for (let r3 = 0; r3 < e5.typeKeywords.length; r3++)
        if ("elevation 3d layer" === e5.typeKeywords[r3].toLowerCase())
          return true;
      throw new s2("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e4).catch(w).then(() => this._fetchImageService(r2))), Promise.resolve(this);
  }
  fetchTile(e4, t2, o3, s5) {
    const a2 = r((s5 = s5 || { signal: null }).signal) ? s5.signal : s5.signal = new AbortController().signal, l = { responseType: "array-buffer", signal: a2 }, p2 = { noDataValue: s5.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e4, t2, o3, s5)).then(() => U(this.getTileUrl(e4, t2, o3), l)).then((e5) => this._lercDecoder.decode(e5.data, p2, a2)).then((e5) => new e3(e5));
  }
  getTileUrl(e4, r2, t2) {
    const o3 = !this.tilemapCache && this.supportsBlankTile, i = A({ ...this.parsedUrl.query, blankTile: !o3 && null });
    return `${this.parsedUrl.path}/tile/${e4}/${r2}/${t2}${i ? "?" + i : ""}`;
  }
  async queryElevation(e4, r2) {
    const { ElevationQuery: t2 } = await import("./ElevationQuery-PZBHZ3BR.js");
    f(r2);
    return new t2().query(this, e4, r2);
  }
  async createElevationSampler(e4, r2) {
    const { ElevationQuery: t2 } = await import("./ElevationQuery-PZBHZ3BR.js");
    f(r2);
    return new t2().createSampler(this, e4, r2);
  }
  _fetchTileAvailability(e4, r2, t2, o3) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e4, r2, t2, o3) : Promise.resolve("unknown");
  }
  async _fetchImageService(e4) {
    var _a;
    if (this.sourceJSON)
      return this.sourceJSON;
    const t2 = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e4 }, o3 = await U(this.parsedUrl.path, t2);
    o3.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = o3.data, this.read(o3.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile.__isDefault__;
  }
};
e2([y2({ json: { read: { source: "copyrightText" } } })], w2.prototype, "copyright", void 0), e2([y2({ readOnly: true, type: v })], w2.prototype, "heightModelInfo", void 0), e2([y2({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], w2.prototype, "path", void 0), e2([y2({ type: ["show", "hide"] })], w2.prototype, "listMode", void 0), e2([y2({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w2.prototype, "minScale", void 0), e2([y2({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w2.prototype, "maxScale", void 0), e2([y2({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], w2.prototype, "opacity", void 0), e2([y2({ type: ["ArcGISTiledElevationServiceLayer"] })], w2.prototype, "operationalLayerType", void 0), e2([y2()], w2.prototype, "sourceJSON", void 0), e2([y2({ json: { read: false }, value: "elevation", readOnly: true })], w2.prototype, "type", void 0), e2([y2(f2)], w2.prototype, "url", void 0), e2([y2()], w2.prototype, "version", void 0), e2([o("version", ["currentVersion"])], w2.prototype, "readVersion", null), w2 = e2([a("esri.layers.ElevationLayer")], w2), w2.prototype.fetchTile.__isDefault__ = true;
var T = w2;
export {
  T as default
};
//# sourceMappingURL=ElevationLayer-U247X2NV.js.map

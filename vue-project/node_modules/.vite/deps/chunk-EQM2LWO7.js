import {
  A,
  D as D2,
  a as a3,
  c as c2,
  f as f4,
  l,
  o as o2
} from "./chunk-OSLJAK5K.js";
import {
  I as I2,
  P as P2,
  n,
  t as t3,
  v as v4
} from "./chunk-PY5ZEMWR.js";
import {
  E as E2,
  F,
  v as v3,
  z
} from "./chunk-5Y2E66SG.js";
import {
  M,
  f as f3,
  g
} from "./chunk-33DQ3DIB.js";
import {
  t as t2
} from "./chunk-JLELSJK5.js";
import {
  P as P3
} from "./chunk-QARU3EBQ.js";
import {
  v as v2
} from "./chunk-5JG6YWQJ.js";
import {
  ct
} from "./chunk-NOYTM57S.js";
import {
  r as r2
} from "./chunk-FFJQJQND.js";
import {
  h,
  r as r3
} from "./chunk-YMSHUIGU.js";
import {
  D,
  P,
  a as a2,
  f as f2
} from "./chunk-Y3KJPDCE.js";
import {
  o,
  u as u2
} from "./chunk-LSUFI7PR.js";
import {
  i
} from "./chunk-WATRS3LJ.js";
import {
  u,
  v,
  y
} from "./chunk-B6GJAETG.js";
import {
  c
} from "./chunk-FC74MT6E.js";
import {
  $,
  E,
  I
} from "./chunk-H2ENCYR3.js";
import {
  f
} from "./chunk-QLY5H3XF.js";
import {
  s2 as s
} from "./chunk-UG2OEDEE.js";
import {
  p as p2
} from "./chunk-PR6SXADK.js";
import {
  b,
  x
} from "./chunk-MGJMBJDY.js";
import {
  a,
  p,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
function W(e) {
  return null != e && e.every((e2) => "exceedslimit" !== e2.statisticType);
}
var $2 = "feature-store:unsupported-query";
var X = new h(2e6);
var Y = 0;
var ee = class {
  constructor(e) {
    this._geometryQueryCache = null, this._changeHandle = null, this.capabilities = { query: t2 }, this.geometryType = e.geometryType, this.hasM = !!e.hasM, this.hasZ = !!e.hasZ, this.objectIdField = e.objectIdField, this.spatialReference = e.spatialReference, this.definitionExpression = e.definitionExpression, this.featureStore = e.featureStore, this.aggregateAdapter = e.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e.timeInfo, e.cacheSpatialQueries && (this._geometryQueryCache = new r3(Y++ + "$$", X)), this.fieldsIndex = new r2(e.fields), e.scheduler && e.priority && (this._frameTask = e.scheduler.registerTask(e.priority));
  }
  destroy() {
    this._frameTask = p(this._frameTask), this.clearCache(), a(this._geometryQueryCache), this._changeHandle = p(this._changeHandle), a(this.fieldsIndex);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null;
  }
  async executeQuery(e, t4) {
    try {
      return (await this._executeQuery(e, {}, t4)).createQueryResponse();
    } catch (i2) {
      if (i2 !== F)
        throw i2;
      return new A([], e, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e = {}, t4) {
    try {
      return (await this._executeQuery(e, { returnGeometry: false, returnCentroid: false, outSR: null }, t4)).createQueryResponseForCount();
    } catch (i2) {
      if (i2 !== F)
        throw i2;
      return 0;
    }
  }
  async executeQueryForExtent(e, t4) {
    const i2 = e.outSR;
    try {
      const s2 = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), r4 = s2.size;
      if (!r4)
        return { count: 0, extent: null };
      return { count: r4, extent: await this._getBounds(s2.items, s2.spatialReference, i2 || this.spatialReference) };
    } catch (s2) {
      if (s2 === F)
        return { count: 0, extent: null };
      throw s2;
    }
  }
  async executeQueryForIds(e, t4) {
    return this.executeQueryForIdSet(e, t4).then((e2) => Array.from(e2));
  }
  async executeQueryForIdSet(e, t4) {
    try {
      const i2 = await this._executeQuery(e, { returnGeometry: true, returnCentroid: false, outSR: null }, t4), s2 = i2.items, r4 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e2 of s2)
          r4.add(i2.featureAdapter.getObjectId(e2));
      }, t4), r4;
    } catch (i2) {
      if (i2 === F)
        return /* @__PURE__ */ new Set();
      throw i2;
    }
  }
  async executeQueryForSnapping(e, t4) {
    const { point: i2, distance: s2, types: r4 } = e;
    if (r4 === D2.NONE)
      return { candidates: [] };
    const a4 = await this._reschedule(() => this._checkQuerySupport(e.query), t4), o3 = !E(i2.spatialReference, this.spatialReference);
    o3 && await f3(i2.spatialReference, this.spatialReference);
    const u3 = "number" == typeof s2 ? s2 : s2.x, c3 = "number" == typeof s2 ? s2 : s2.y, l2 = { xmin: i2.x - u3, xmax: i2.x + u3, ymin: i2.y - c3, ymax: i2.y + c3, spatialReference: i2.spatialReference }, h2 = o3 ? g(l2, this.spatialReference) : l2;
    if (!h2)
      return { candidates: [] };
    const m = (await v2(v(i2), null, { signal: t4 }))[0], p3 = (await v2(v(h2), null, { signal: t4 }))[0];
    if (t(m) || t(p3))
      return { candidates: [] };
    const f5 = new A(await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(p3.toJSON())), t4), a4, this);
    await this._reschedule(() => this._executeObjectIdsQuery(f5), t4), await this._reschedule(() => this._executeTimeQuery(f5), t4), await this._reschedule(() => this._executeAttributesQuery(f5), t4);
    const d = m.toJSON(), y2 = o3 ? g(d, this.spatialReference) : d, g2 = o3 ? Math.max(h2.xmax - h2.xmin, h2.ymax - h2.ymin) / 2 : s2;
    return f5.createSnappingResponse({ ...e, point: y2, distance: g2 }, i2.spatialReference);
  }
  async executeQueryForLatestObservations(e, t4) {
    if (!this.timeInfo || !this.timeInfo.trackIdField)
      throw new s($2, "Missing timeInfo or timeInfo.trackIdField", { query: e, timeInfo: this.timeInfo });
    try {
      const i2 = await this._executeQuery(e, {}, t4);
      return await this._reschedule(() => this._filterLatest(i2), t4), i2.createQueryResponse();
    } catch (s2) {
      if (s2 !== F)
        throw s2;
      return new A([], e, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e = {}, t4, i2) {
    const { field: s2, normalizationField: r4, valueExpression: a4 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s2, normalizationField: r4, valueExpression: a4 }, i2)).createSummaryStatisticsResponse(t4);
  }
  async executeQueryForUniqueValues(e = {}, t4, i2) {
    const { field: s2, field2: r4, field3: a4, valueExpression: n2 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s2, field2: r4, field3: a4, valueExpression: n2 }, i2)).createUniqueValuesResponse(t4);
  }
  async executeQueryForClassBreaks(e = {}, t4, i2) {
    const { field: s2, normalizationField: r4, valueExpression: a4 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s2, normalizationField: r4, valueExpression: a4 }, i2)).createClassBreaksResponse(t4);
  }
  async executeQueryForHistogram(e = {}, t4, i2) {
    const { field: s2, normalizationField: r4, valueExpression: a4 } = t4;
    return (await this._getQueryEngineResultForStats(e, { field: s2, normalizationField: r4, valueExpression: a4 }, i2)).createHistogramResponse(t4);
  }
  async fetchRecomputedExtents(e) {
    const [t4, i2] = await Promise.all(["getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getBounds(await this._getAllFeatures(), this.spatialReference, this.spatialReference), r(this._timeExtentPromise) ? this._timeExtentPromise : this._timeExtentPromise = t3(this.timeInfo, this.featureStore)]);
    return f(e), { fullExtent: t4, timeExtent: i2 };
  }
  async _getBounds(e, t4, i2) {
    const s2 = P(a2(), D);
    await this.featureStore.forEachBounds(e, (e2) => f2(s2, e2));
    const r4 = { xmin: s2[0], ymin: s2[1], xmax: s2[3], ymax: s2[4], spatialReference: E2(this.spatialReference) };
    this.hasZ && isFinite(s2[2]) && isFinite(s2[5]) && (r4.zmin = s2[2], r4.zmax = s2[5]);
    const a4 = g(r4, t4, i2);
    if (a4.spatialReference = E2(i2), a4.xmax - a4.xmin == 0) {
      const e2 = $(a4.spatialReference);
      a4.xmin -= e2, a4.xmax += e2;
    }
    if (a4.ymax - a4.ymin == 0) {
      const e2 = $(a4.spatialReference);
      a4.ymin -= e2, a4.ymax += e2;
    }
    if (this.hasZ && null != a4.zmin && null != a4.zmax && a4.zmax - a4.zmin == 0) {
      const e2 = $(a4.spatialReference);
      a4.zmin -= e2, a4.zmax += e2;
    }
    return a4;
  }
  async _schedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.schedule(e, t4) : e(P3);
  }
  async _reschedule(e, t4) {
    return r(this._frameTask) ? this._frameTask.reschedule(e, t4) : e(P3);
  }
  async _getAllFeaturesQueryEngineResult(e) {
    return new A(await this._getAllFeatures(), e, this);
  }
  async _getAllFeatures() {
    if (t(this._allFeaturesPromise)) {
      const e2 = [];
      this._allFeaturesPromise = (async () => {
        await this.featureStore.forEach((t5) => e2.push(t5));
      })().then(() => e2);
    }
    const e = this._allFeaturesPromise, t4 = await e;
    return e === this._allFeaturesPromise ? t4.slice() : this._getAllFeatures();
  }
  async _executeQuery(e, t4, i2) {
    e = p2(e), e = await this._schedule(() => z(e, this.definitionExpression, this.spatialReference), i2), e = await this._reschedule(() => this._checkQuerySupport(e), i2), e = { ...e, ...t4 };
    const r4 = await this._reschedule(() => this._executeSceneFilterQuery(e, i2), i2), a4 = await this._reschedule(() => this._executeGeometryQuery(e, r4, i2), i2);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a4), i2), await this._reschedule(() => this._executeObjectIdsQuery(a4), i2), await this._reschedule(() => this._executeTimeQuery(a4), i2), await this._reschedule(() => this._executeAttributesQuery(a4), i2), a4;
  }
  async _executeSceneFilterQuery(e, t4) {
    if (t(e.sceneFilter))
      return null;
    const { outSR: i2, returnGeometry: s2, returnCentroid: r4 } = e, a4 = this.featureStore.featureSpatialReference, o3 = e.sceneFilter.geometry, u3 = t(a4) || E(a4, o3.spatialReference) ? o3 : g(o3, a4);
    if (!u3)
      return null;
    const c3 = s2 || r4, l2 = I(i2) && !E(this.spatialReference, i2) && c3 ? async (e2) => this._project(e2, i2) : (e2) => e2, h2 = this.featureAdapter, m = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(u3)), t4);
    if ("disjoint" === e.sceneFilter.spatialRelationship) {
      if (!m.length)
        return null;
      const i3 = /* @__PURE__ */ new Set();
      for (const e2 of m)
        i3.add(h2.getObjectId(e2));
      const s3 = await this._reschedule(() => this._getAllFeatures(), t4), r5 = await this._reschedule(async () => {
        const r6 = await v4("esriSpatialRelDisjoint", u3, this.geometryType, this.hasZ, this.hasM), a5 = (e2) => !i3.has(h2.getObjectId(e2)) || r6(h2.getGeometry(e2)), n2 = await this._runSpatialFilter(s3, a5, t4);
        return new A(n2, e, this);
      }, t4);
      return l2(r5);
    }
    if (!m.length)
      return new A([], e, this);
    if (this._canExecuteSinglePass(u3, e))
      return l2(new A(m, e, this));
    const p3 = await v4("esriSpatialRelContains", u3, this.geometryType, this.hasZ, this.hasM), f5 = await this._runSpatialFilter(m, (e2) => p3(h2.getGeometry(e2)), t4);
    return l2(new A(f5, e, this));
  }
  async _executeGeometryQuery(i2, s2, r4) {
    if (r(s2) && 0 === s2.items.length)
      return s2;
    i2 = r(s2) ? s2.query : i2;
    const { geometry: a4, outSR: u3, spatialRel: c3, returnGeometry: l2, returnCentroid: h2 } = i2, m = this.featureStore.featureSpatialReference, p3 = !a4 || t(m) || E(m, a4.spatialReference) ? a4 : g(a4, m), f5 = l2 || h2, d = I(u3) && !E(this.spatialReference, u3), y2 = this._geometryQueryCache && t(s2) ? d && f5 ? JSON.stringify({ originalFilterGeometry: a4, spatialRelationship: c3, outSpatialReference: u3 }) : JSON.stringify({ originalFilterGeometry: a4, spatialRelationship: c3 }) : null, g2 = y2 ? this._geometryQueryCache.get(y2) : null;
    if (r(g2))
      return new A(g2, i2, this);
    const _ = async (e) => (d && f5 && await this._project(e, u3), y2 && this._geometryQueryCache.put(y2, e.items, e.items.length + 1), e);
    if (!p3)
      return _(r(s2) ? s2 : await this._getAllFeaturesQueryEngineResult(i2));
    const x2 = this.featureAdapter;
    let w = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(a4)), r4);
    if ("esriSpatialRelDisjoint" === c3) {
      if (!w.length)
        return _(r(s2) ? s2 : await this._getAllFeaturesQueryEngineResult(i2));
      const e = /* @__PURE__ */ new Set();
      for (const i3 of w)
        e.add(x2.getObjectId(i3));
      const t4 = r(s2) ? s2.items : await this._reschedule(() => this._getAllFeatures(), r4), a5 = await this._reschedule(async () => {
        const s3 = await v4(c3, p3, this.geometryType, this.hasZ, this.hasM), a6 = (t5) => !e.has(x2.getObjectId(t5)) || s3(x2.getGeometry(t5)), n2 = await this._runSpatialFilter(t4, a6, r4);
        return new A(n2, i2, this);
      }, r4);
      return _(a5);
    }
    if (r(s2)) {
      const i3 = new x();
      w = w.filter((e) => b(s2.items, e, s2.items.length, i3) >= 0);
    }
    if (!w.length) {
      const e = new A([], i2, this);
      return y2 && this._geometryQueryCache.put(y2, e.items, 1), e;
    }
    if (this._canExecuteSinglePass(p3, i2))
      return _(new A(w, i2, this));
    const S = await v4(c3, p3, this.geometryType, this.hasZ, this.hasM), F2 = await this._runSpatialFilter(w, (e) => S(x2.getGeometry(e)), r4);
    return _(new A(F2, i2, this));
  }
  _executeAggregateIdsQuery(e) {
    if (0 === e.items.length || !e.query.aggregateIds || !e.query.aggregateIds.length || t(this.aggregateAdapter))
      return;
    const t4 = /* @__PURE__ */ new Set();
    for (const s2 of e.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s2).forEach((e2) => t4.add(e2));
    }
    const i2 = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i2(e2)));
  }
  _executeObjectIdsQuery(e) {
    if (0 === e.items.length || !e.query.objectIds || !e.query.objectIds.length)
      return;
    const t4 = new Set(e.query.objectIds), i2 = this.featureAdapter.getObjectId;
    e.items = e.items.filter((e2) => t4.has(i2(e2)));
  }
  _executeTimeQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = n(this.timeInfo, e.query.timeExtent, this.featureAdapter);
    t(t4) || (e.items = e.items.filter(t4));
  }
  _executeAttributesQuery(e) {
    if (0 === e.items.length)
      return;
    const t4 = l(e.query.where, this.fieldsIndex);
    if (t4) {
      if (!t4.isStandardized)
        throw new TypeError("Where clause is not standardized");
      e.items = e.items.filter((e2) => t4.testFeature(e2, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e, t4, i2) {
    if (!t4)
      return e;
    if (t(this._frameTask))
      return e.filter((e2) => t4(e2));
    let s2 = 0;
    const r4 = new Array(), a4 = async (n2) => {
      for (; s2 < e.length; ) {
        const o3 = e[s2++];
        t4(o3) && (r4.push(o3), n2.madeProgress()), n2.done && await this._reschedule((e2) => a4(e2), i2);
      }
    };
    return this._reschedule((e2) => a4(e2), i2).then(() => r4);
  }
  _filterLatest(e) {
    const { trackIdField: t4, startTimeField: i2, endTimeField: s2 } = this.timeInfo, r4 = s2 || i2, a4 = /* @__PURE__ */ new Map(), n2 = this.featureAdapter.getAttribute;
    for (const o3 of e.items) {
      const e2 = n2(o3, t4), i3 = n2(o3, r4), s3 = a4.get(e2);
      (!s3 || i3 > n2(s3, r4)) && a4.set(e2, o3);
    }
    e.items = Array.from(a4.values());
  }
  _canExecuteSinglePass(e, t4) {
    const { spatialRel: i2 } = t4;
    return I2(e) && ("esriSpatialRelEnvelopeIntersects" === i2 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i2 || "esriSpatialRelContains" === i2 || "esriSpatialRelWithin" === i2));
  }
  async _project(e, t4) {
    if (!t4 || E(this.spatialReference, t4))
      return e;
    const i2 = this.featureAdapter, s2 = await M(e.items.map((e2) => v3(this.geometryType, this.hasZ, this.hasM, i2.getGeometry(e2))), this.spatialReference, t4);
    return e.items = s2.map((t5, s3) => i2.cloneWithGeometry(e.items[s3], ct(t5, this.hasZ, this.hasM))), e;
  }
  _getQueryBBoxes(e) {
    if (I2(e)) {
      if (u(e))
        return [o(e.xmin, e.ymin, e.xmax, e.ymax)];
      if (y(e))
        return e.rings.map((e2) => o(Math.min(e2[0][0], e2[2][0]), Math.min(e2[0][1], e2[2][1]), Math.max(e2[0][0], e2[2][0]), Math.max(e2[0][1], e2[2][1])));
    }
    return [c(u2(), e)];
  }
  async _searchFeatures(e) {
    const t4 = /* @__PURE__ */ new Set();
    await Promise.all(e.map((e2) => this.featureStore.forEachInBounds(e2, (e3) => t4.add(e3))));
    const i2 = Array.from(t4.values());
    return t4.clear(), i2;
  }
  async _checkStatisticsSupport(e, t4) {
    if ((e.distance ?? 0) < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text || e.outStatistics || e.groupByFieldsForStatistics || e.having || e.orderByFields)
      throw new s($2, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), Promise.all([this._checkStatisticsParamsSupport(t4), P2(e, this.geometryType, this.spatialReference), f3(this.spatialReference, e.outSR)]).then(() => e);
  }
  async _checkStatisticsParamsSupport(e) {
    let t4 = [];
    if (e.valueExpression) {
      const { arcadeUtils: i2 } = await i();
      t4 = i2.extractFieldNames(e.valueExpression);
    }
    if (e.field && t4.push(e.field), e.field2 && t4.push(e.field2), e.field3 && t4.push(e.field3), e.normalizationField && t4.push(e.normalizationField), !t4.length)
      throw new s($2, "params should have at least a field or valueExpression", { params: e });
    c2(this.fieldsIndex, t4, "params contains missing fields");
  }
  async _checkQuerySupport(e) {
    if ((e.distance ?? 0) < 0 || null != e.geometryPrecision || e.multipatchOption || e.pixelSize || e.relationParam || e.text)
      throw new s($2, "Unsupported query options", { query: e });
    return this._checkAttributesQuerySupport(e), this._checkStatisticsQuerySupport(e), Promise.all([P2(e, this.geometryType, this.spatialReference), f3(this.spatialReference, e.outSR)]).then(() => e);
  }
  _checkAttributesQuerySupport(e) {
    const { outFields: t4, orderByFields: s2, returnDistinctValues: r4, outStatistics: a4 } = e, n2 = a4 ? a4.map((e2) => e2.outStatisticFieldName && e2.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
    if (s2 && s2.length > 0) {
      const e2 = " asc", t5 = " desc", i2 = s2.map((i3) => {
        const s3 = i3.toLowerCase();
        return s3.includes(e2) ? s3.split(e2)[0] : s3.includes(t5) ? s3.split(t5)[0] : i3;
      }).filter((e3) => !n2.includes(e3));
      c2(this.fieldsIndex, i2, "orderByFields contains missing fields");
    }
    if (t4 && t4.length > 0)
      c2(this.fieldsIndex, t4, "outFields contains missing fields");
    else if (r4)
      throw new s($2, "outFields should be specified for returnDistinctValues", { query: e });
    o2(this.fieldsIndex, e.where);
  }
  _checkStatisticsQuerySupport(e) {
    const { outStatistics: t4, groupByFieldsForStatistics: s2, having: r4 } = e, a4 = s2 && s2.length, n2 = t4 && t4.length;
    if (r4) {
      if (!a4 || !n2)
        throw new s($2, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: e });
      a3(this.fieldsIndex, r4, t4);
    }
    if (n2) {
      if (!W(t4))
        return;
      const r5 = t4.map((e2) => e2.onStatisticField).filter(Boolean);
      c2(this.fieldsIndex, r5, "onStatisticFields contains missing fields"), a4 && c2(this.fieldsIndex, s2, "groupByFieldsForStatistics contains missing fields");
      for (const s3 of t4) {
        const { onStatisticField: t5, statisticType: r6 } = s3;
        if (("percentile_disc" === r6 || "percentile_cont" === r6) && "statisticParameters" in s3) {
          const { statisticParameters: t6 } = s3;
          if (!t6)
            throw new s($2, "statisticParamters should be set for percentile type", { definition: s3, query: e });
        } else if ("count" !== r6 && t5 && f4(t5, this.fieldsIndex))
          throw new s($2, "outStatistics contains non-numeric fields", { definition: s3, query: e });
      }
    }
  }
  async _getQueryEngineResultForStats(e, t4, i2) {
    e = p2(e);
    try {
      e = await this._schedule(() => z(e, this.definitionExpression, this.spatialReference), i2), e = await this._reschedule(() => this._checkStatisticsSupport(e, t4), i2);
      const s2 = await this._reschedule(() => this._executeSceneFilterQuery(e, i2), i2), r4 = await this._reschedule(() => this._executeGeometryQuery(e, s2, i2), i2);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r4), i2), await this._reschedule(() => this._executeObjectIdsQuery(r4), i2), await this._reschedule(() => this._executeTimeQuery(r4), i2), await this._reschedule(() => this._executeAttributesQuery(r4), i2), r4;
    } catch (r4) {
      if (r4 !== F)
        throw r4;
      return new A([], e, this);
    }
  }
};

export {
  ee
};
//# sourceMappingURL=chunk-EQM2LWO7.js.map

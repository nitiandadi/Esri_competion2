import {
  C,
  i
} from "./chunk-ORBSSD6D.js";
import {
  $,
  M,
  T as T2
} from "./chunk-BTIR4W7Z.js";
import {
  S,
  T,
  p
} from "./chunk-A44PLQY5.js";
import {
  D,
  F,
  R,
  b,
  d,
  f3 as f,
  m,
  m3 as m2
} from "./chunk-OC742RJZ.js";
import "./chunk-WOEVHDZW.js";
import {
  s2 as s
} from "./chunk-SLPOHICA.js";
import "./chunk-REIXEATJ.js";
import "./chunk-7YGY53FV.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-A3HP4ESO.js";
import "./chunk-HRFBINZY.js";
import "./chunk-BHQVXYUV.js";
import "./chunk-DKH5QOVM.js";
import "./chunk-JT54I3AY.js";
import "./chunk-DC3QI5ZE.js";
import "./chunk-TNTTCGVB.js";
import "./chunk-EGHLQERQ.js";
import "./chunk-2HZTCGYV.js";
import "./chunk-Z3YY72G4.js";
import "./chunk-M3KO43BW.js";
import "./chunk-CCWBAM3L.js";
import "./chunk-DOQX2NNO.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-2ZX6RZTI.js";
import "./chunk-5Q7F7FJ6.js";
import {
  w2 as w
} from "./chunk-XFNXUG2G.js";
import "./chunk-RDTHWDIE.js";
import "./chunk-EAFLFTSD.js";
import "./chunk-DOVXDFWE.js";
import "./chunk-M4BAPJ3L.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-KGIB6IYW.js";
import "./chunk-3PPVODAA.js";
import "./chunk-MTJ2HM2W.js";
import "./chunk-PXVSWY3C.js";
import "./chunk-WTKFW2TD.js";
import "./chunk-UG2OEDEE.js";
import "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import "./chunk-PR6SXADK.js";
import "./chunk-MGJMBJDY.js";
import {
  e,
  r
} from "./chunk-WHB7G7RI.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var N = class {
  convertVectorFieldData(e2) {
    const t = m.fromJSON(e2.pixelBlock), o = d(t, e2.type);
    return Promise.resolve(r(o) ? o.toJSON() : null);
  }
  async decode(r2) {
    const e2 = await S(r2.data, r2.options);
    return e2 && e2.toJSON();
  }
  symbolize(e2) {
    e2.pixelBlock = m.fromJSON(e2.pixelBlock), e2.extent = e2.extent ? w.fromJSON(e2.extent) : null;
    const t = this.symbolizer.symbolize(e2);
    return Promise.resolve(r(t) ? t.toJSON() : null);
  }
  async updateSymbolizer(r2) {
    var _a;
    this.symbolizer = T.fromJSON(r2.symbolizerJSON), r2.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r2.histograms);
  }
  async updateRasterFunction(r2) {
    this.rasterFunction = C(r2.rasterFunctionJSON);
  }
  async process(e2) {
    const t = this.rasterFunction.process({ extent: w.fromJSON(e2.extent), primaryPixelBlocks: e2.primaryPixelBlocks.map((e3) => r(e3) ? m.fromJSON(e3) : null), primaryRasterIds: e2.primaryRasterIds });
    return r(t) ? t.toJSON() : null;
  }
  stretch(e2) {
    const t = this.symbolizer.simpleStretch(m.fromJSON(e2.srcPixelBlock), e2.stretchParams);
    return Promise.resolve(r(t) && t.toJSON());
  }
  estimateStatisticsHistograms(r2) {
    const e2 = p(m.fromJSON(r2.srcPixelBlock));
    return Promise.resolve(e2);
  }
  split(r2) {
    const e2 = R(m.fromJSON(r2.srcPixelBlock), r2.tileSize, r2.maximumPyramidLevel);
    return e2 && e2.forEach((r3, t) => {
      e2.set(t, r3 == null ? void 0 : r3.toJSON());
    }), Promise.resolve(e2);
  }
  async mosaicAndTransform(r2) {
    const t = r2.srcPixelBlocks.map((r3) => r3 ? new m(r3) : null), o = b(t, r2.srcMosaicSize, { blockWidths: r2.blockWidths, alignmentInfo: r2.alignmentInfo, clipOffset: r2.clipOffset, clipSize: r2.clipSize });
    let i2, l = o;
    return r2.coefs && (l = F(o, r2.destDimension, r2.coefs, r2.sampleSpacing, r2.interpolation)), r2.projectDirections && r2.gcsGrid && (i2 = D(r2.destDimension, r2.gcsGrid), l = e(m2(l, r2.isUV ? "vector-uv" : "vector-magdir", i2))), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: i2 };
  }
  async createFlowMesh(r2, e2) {
    const t = { data: new Float32Array(r2.flowData.buffer), mask: new Uint8Array(r2.flowData.maskBuffer), width: r2.flowData.width, height: r2.flowData.height }, { vertexData: s2, indexData: o } = await f(r2.meshType, r2.simulationSettings, t, e2.signal);
    return { result: { vertexBuffer: s2.buffer, indexBuffer: o.buffer }, transferList: [s2.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(r2) {
    const e2 = w.fromJSON(r2.projectedExtent), s2 = w.fromJSON(r2.srcBufferExtent);
    let o = null;
    r2.datumTransformationSteps && (o = new s({ steps: r2.datumTransformationSteps })), (r2.includeGCSGrid || M(e2.spatialReference, s2.spatialReference, o)) && await T2();
    const i2 = r2.rasterTransform ? i(r2.rasterTransform) : null;
    return $({ ...r2, projectedExtent: e2, srcBufferExtent: s2, datumTransformation: o, rasterTransform: i2 });
  }
};
export {
  N as default
};
//# sourceMappingURL=RasterWorker-EUTMD3ZT.js.map

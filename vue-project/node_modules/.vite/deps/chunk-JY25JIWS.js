import {
  e
} from "./chunk-MXRYGWSY.js";
import {
  E
} from "./chunk-5Y2E66SG.js";
import {
  o
} from "./chunk-AWGMYJGH.js";
import {
  It
} from "./chunk-NOYTM57S.js";
import {
  s as s3,
  t as t2
} from "./chunk-U6GC73UT.js";
import {
  a,
  d
} from "./chunk-Y3KJPDCE.js";
import {
  u
} from "./chunk-LSUFI7PR.js";
import {
  n
} from "./chunk-FQ7L63IU.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/graphics/data/optimizedFeatureQueryEngineAdapter.js
var i = { getObjectId: (t3) => t3.objectId, getAttributes: (t3) => t3.attributes, getAttribute: (t3, e2) => t3.attributes[e2], cloneWithGeometry: (t3, e2) => new s3(e2, t3.attributes, null, t3.objectId), getGeometry: (t3) => t3.geometry, getCentroid: (r2, i2) => (t(r2.centroid) && (r2.centroid = e(new t2(), r2.geometry, i2.hasZ, i2.hasM)), r2.centroid) };

// node_modules/@arcgis/core/layers/graphics/data/FeatureStore.js
var f = a();
var g = class {
  constructor(e2) {
    this.geometryInfo = e2, this._boundsStore = new o(), this._featuresById = /* @__PURE__ */ new Map(), this._markedIds = /* @__PURE__ */ new Set(), this.events = new n(), this.featureAdapter = i;
  }
  get geometryType() {
    return this.geometryInfo.geometryType;
  }
  get hasM() {
    return this.geometryInfo.hasM;
  }
  get hasZ() {
    return this.geometryInfo.hasZ;
  }
  get numFeatures() {
    return this._featuresById.size;
  }
  get fullBounds() {
    return this._boundsStore.fullBounds;
  }
  get storeStatistics() {
    let e2 = 0;
    return this._featuresById.forEach((t3) => {
      r(t3.geometry) && t3.geometry.coords && (e2 += t3.geometry.coords.length);
    }), { featureCount: this._featuresById.size, vertexCount: e2 / (this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2) };
  }
  getFullExtent(e2) {
    if (t(this.fullBounds))
      return null;
    const [t3, s4, r2, i2] = this.fullBounds;
    return { xmin: t3, ymin: s4, xmax: r2, ymax: i2, spatialReference: E(e2) };
  }
  add(e2) {
    this._add(e2), this._emitChanged();
  }
  addMany(e2) {
    for (const t3 of e2)
      this._add(t3);
    this._emitChanged();
  }
  clear() {
    this._featuresById.clear(), this._boundsStore.clear(), this._emitChanged();
  }
  removeById(e2) {
    const t3 = this._featuresById.get(e2);
    return t3 ? (this._remove(t3), this._emitChanged(), t3) : null;
  }
  removeManyById(e2) {
    this._boundsStore.invalidateIndex();
    for (const t3 of e2) {
      const e3 = this._featuresById.get(t3);
      e3 && this._remove(e3);
    }
    this._emitChanged();
  }
  forEachBounds(e2, t3) {
    for (const s4 of e2) {
      const e3 = this._boundsStore.get(s4.objectId);
      e3 && t3(d(f, e3));
    }
  }
  getFeature(e2) {
    return this._featuresById.get(e2);
  }
  has(e2) {
    return this._featuresById.has(e2);
  }
  forEach(e2) {
    this._featuresById.forEach((t3) => e2(t3));
  }
  forEachInBounds(e2, t3) {
    this._boundsStore.forEachInBounds(e2, (e3) => {
      t3(this._featuresById.get(e3));
    });
  }
  startMarkingUsedFeatures() {
    this._boundsStore.invalidateIndex(), this._markedIds.clear();
  }
  sweep() {
    let e2 = false;
    this._featuresById.forEach((t3, s4) => {
      this._markedIds.has(s4) || (e2 = true, this._remove(t3));
    }), this._markedIds.clear(), e2 && this._emitChanged();
  }
  _emitChanged() {
    this.events.emit("changed", void 0);
  }
  _add(t3) {
    if (!t3)
      return;
    const i2 = t3.objectId;
    if (null == i2)
      return void s.getLogger("esri.layers.graphics.data.FeatureStore").error(new s2("featurestore:invalid-feature", "feature id is missing", { feature: t3 }));
    const a2 = this._featuresById.get(i2);
    let h;
    if (this._markedIds.add(i2), a2 ? (t3.displayId = a2.displayId, h = this._boundsStore.get(i2), this._boundsStore.delete(i2)) : r(this.onFeatureAdd) && this.onFeatureAdd(t3), t(t3.geometry) || !t3.geometry.coords || !t3.geometry.coords.length)
      return this._boundsStore.set(i2, null), void this._featuresById.set(i2, t3);
    h = It(r(h) ? h : u(), t3.geometry, this.geometryInfo.hasZ, this.geometryInfo.hasM), r(h) && this._boundsStore.set(i2, h), this._featuresById.set(i2, t3);
  }
  _remove(e2) {
    r(this.onFeatureRemove) && this.onFeatureRemove(e2);
    const t3 = e2.objectId;
    return this._markedIds.delete(t3), this._boundsStore.delete(t3), this._featuresById.delete(t3), e2;
  }
};

export {
  g
};
//# sourceMappingURL=chunk-JY25JIWS.js.map

import "./chunk-MLSUYO53.js";
import {
  t as t2
} from "./chunk-JJIMX2OW.js";
import "./chunk-T5EL7TIL.js";
import "./chunk-V6QYNDMP.js";
import {
  ut,
  wt
} from "./chunk-X7NPMCZZ.js";
import "./chunk-CFTD44JM.js";
import "./chunk-MI7FJDLG.js";
import {
  o
} from "./chunk-D5KVII6M.js";
import "./chunk-OJCBSPLX.js";
import "./chunk-EMRZKKP3.js";
import {
  n
} from "./chunk-VWOAL3VX.js";
import {
  y
} from "./chunk-FY3NCRRH.js";
import "./chunk-CIPSOFMY.js";
import "./chunk-LUOENZ4F.js";
import "./chunk-QGRPG4XS.js";
import "./chunk-M73MMEC7.js";
import {
  f2 as f
} from "./chunk-A5CTLI5A.js";
import "./chunk-WUBKNERF.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-GLDJLPWH.js";
import "./chunk-GMLVDTS4.js";
import "./chunk-G7CHVXDR.js";
import "./chunk-OAZLVZFS.js";
import "./chunk-CPSZPA6H.js";
import {
  e4 as e
} from "./chunk-Y54MR3BP.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-JY6H6KI3.js";
import "./chunk-TTCQP5LX.js";
import "./chunk-C2WY74GI.js";
import "./chunk-MCOYI7PX.js";
import "./chunk-EL4OGCJC.js";
import "./chunk-XPATKIHO.js";
import "./chunk-MKHZ5X6F.js";
import {
  t
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/graphics/dehydratedFeatures.js
var g = class {
  constructor(e2, t5, s3) {
    this.uid = e2, this.geometry = t5, this.attributes = s3, this.visible = true, this.objectId = null, this.centroid = null;
  }
};
var d = class {
  constructor() {
    this.exceededTransferLimit = false, this.features = [], this.fields = [], this.hasM = false, this.hasZ = false, this.geometryType = null, this.objectIdFieldName = null, this.globalIdFieldName = null, this.geometryProperties = null, this.geohashFieldName = null, this.spatialReference = null, this.transform = null;
  }
};

// node_modules/@arcgis/core/rest/query/operations/pbfDehydratedFeatureSet.js
function u(t5, e2) {
  return e2;
}
function p(t5, e2, r2, s3) {
  switch (r2) {
    case 0:
      return m2(t5, e2 + s3, 0);
    case 1:
      return "lowerLeft" === t5.originPosition ? m2(t5, e2 + s3, 1) : y2(t5, e2 + s3, 1);
  }
}
function c(t5, e2, r2, s3) {
  return 2 === r2 ? m2(t5, e2, 2) : p(t5, e2, r2, s3);
}
function d2(t5, e2, r2, s3) {
  return 2 === r2 ? m2(t5, e2, 3) : p(t5, e2, r2, s3);
}
function f2(t5, e2, r2, s3) {
  return 3 === r2 ? m2(t5, e2, 3) : c(t5, e2, r2, s3);
}
function m2({ translate: t5, scale: e2 }, r2, s3) {
  return t5[s3] + r2 * e2[s3];
}
function y2({ translate: t5, scale: e2 }, r2, s3) {
  return t5[s3] - r2 * e2[s3];
}
var _ = class {
  constructor(t5) {
    this._options = t5, this.geometryTypes = ["point", "multipoint", "polyline", "polygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = u, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return new d();
  }
  finishFeatureResult(t5) {
    if (this._options.applyTransform && (t5.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !t5.hasZ)
      return;
    const r2 = o(t5.geometryType, this._options.sourceSpatialReference, t5.spatialReference);
    if (!t(r2))
      for (const e2 of t5.features)
        r2(e2.geometry);
  }
  createSpatialReference() {
    return new f();
  }
  addField(t5, e2) {
    t5.fields.push(y.fromJSON(e2));
    const r2 = t5.fields.map((t6) => t6.name);
    this._attributesConstructor = function() {
      for (const t6 of r2)
        this[t6] = null;
    };
  }
  addFeature(t5, e2) {
    const r2 = this._options.maxStringAttributeLength ? this._options.maxStringAttributeLength : 0;
    if (r2 > 0)
      for (const s3 in e2.attributes) {
        const t6 = e2.attributes[s3];
        "string" == typeof t6 && t6.length > r2 && (e2.attributes[s3] = "");
      }
    t5.features.push(e2);
  }
  addQueryGeometry(t5, e2) {
    const { queryGeometry: r2, queryGeometryType: s3 } = e2, o3 = wt(r2.clone(), r2, false, false, this._transform), i = ut(o3, s3, false, false);
    let n2 = null;
    switch (s3) {
      case "esriGeometryPoint":
        n2 = "point";
        break;
      case "esriGeometryPolygon":
        n2 = "polygon";
        break;
      case "esriGeometryPolyline":
        n2 = "polyline";
        break;
      case "esriGeometryMultipoint":
        n2 = "multipoint";
    }
    i.type = n2, t5.queryGeometryType = s3, t5.queryGeometry = i;
  }
  prepareFeatures(e2) {
    switch (this._transform = e2.transform ?? null, this._options.applyTransform && e2.transform && (this._applyTransform = this._deriveApplyTransform(e2)), this._vertexDimension = 2, e2.hasZ && this._vertexDimension++, e2.hasM && this._vertexDimension++, e2.geometryType) {
      case "point":
        this.addCoordinate = (t5, e3, r2) => this.addCoordinatePoint(t5, e3, r2), this.createGeometry = (t5) => this.createPointGeometry(t5);
        break;
      case "polygon":
        this.addCoordinate = (t5, e3, r2) => this._addCoordinatePolygon(t5, e3, r2), this.createGeometry = (t5) => this._createPolygonGeometry(t5);
        break;
      case "polyline":
        this.addCoordinate = (t5, e3, r2) => this._addCoordinatePolyline(t5, e3, r2), this.createGeometry = (t5) => this._createPolylineGeometry(t5);
        break;
      case "multipoint":
        this.addCoordinate = (t5, e3, r2) => this._addCoordinateMultipoint(t5, e3, r2), this.createGeometry = (t5) => this._createMultipointGeometry(t5);
        break;
      case "mesh":
      case "extent":
        break;
      default:
        n(e2.geometryType);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, new g(e(), null, new this._attributesConstructor());
  }
  allocateCoordinates() {
    const t5 = this._lengths.reduce((t6, e2) => t6 + e2, 0);
    this._coordinateBuffer = new Float64Array(t5 * this._vertexDimension), this._coordinateBufferPtr = 0;
  }
  addLength(t5, e2) {
    0 === this._lengths.length && (this._toAddInCurrentPath = e2), this._lengths.push(e2);
  }
  createPointGeometry(t5) {
    const e2 = { type: "point", x: 0, y: 0, spatialReference: t5.spatialReference, hasZ: !!t5.hasZ, hasM: !!t5.hasM };
    return e2.hasZ && (e2.z = 0), e2.hasM && (e2.m = 0), e2;
  }
  addCoordinatePoint(t5, e2, r2) {
    const s3 = this._transform ? this._applyTransform(this._transform, e2, r2, 0) : e2;
    if (null != s3)
      switch (r2) {
        case 0:
          t5.x = s3;
          break;
        case 1:
          t5.y = s3;
          break;
        case 2:
          t5.hasZ ? t5.z = s3 : t5.m = s3;
          break;
        case 3:
          t5.m = s3;
      }
  }
  _transformPathLikeValue(t5, e2) {
    let r2 = 0;
    return e2 <= 1 && (r2 = this._previousCoordinate[e2], this._previousCoordinate[e2] += t5), this._transform ? this._applyTransform(this._transform, t5, e2, r2) : t5;
  }
  _addCoordinatePolyline(t5, e2, r2) {
    this._dehydratedAddPointsCoordinate(t5.paths, e2, r2);
  }
  _addCoordinatePolygon(t5, e2, r2) {
    this._dehydratedAddPointsCoordinate(t5.rings, e2, r2);
  }
  _addCoordinateMultipoint(t5, e2, r2) {
    0 === r2 && t5.points.push([]);
    const s3 = this._transformPathLikeValue(e2, r2);
    t5.points[t5.points.length - 1].push(s3);
  }
  _createPolygonGeometry(t5) {
    return { type: "polygon", rings: [[]], spatialReference: t5.spatialReference, hasZ: !!t5.hasZ, hasM: !!t5.hasM };
  }
  _createPolylineGeometry(t5) {
    return { type: "polyline", paths: [[]], spatialReference: t5.spatialReference, hasZ: !!t5.hasZ, hasM: !!t5.hasM };
  }
  _createMultipointGeometry(t5) {
    return { type: "multipoint", points: [], spatialReference: t5.spatialReference, hasZ: !!t5.hasZ, hasM: !!t5.hasM };
  }
  _dehydratedAddPointsCoordinate(t5, e2, r2) {
    0 === r2 && 0 == this._toAddInCurrentPath-- && (t5.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s3 = this._transformPathLikeValue(e2, r2), o3 = t5[t5.length - 1], i = this._coordinateBuffer;
    if (i) {
      if (0 === r2) {
        const t6 = this._coordinateBufferPtr * Float64Array.BYTES_PER_ELEMENT;
        o3.push(new Float64Array(i.buffer, t6, this._vertexDimension));
      }
      i[this._coordinateBufferPtr++] = s3;
    }
  }
  _deriveApplyTransform(t5) {
    const { hasZ: e2, hasM: r2 } = t5;
    return e2 && r2 ? f2 : e2 ? c : r2 ? d2 : p;
  }
};

// node_modules/@arcgis/core/views/3d/support/PBFDecoderWorker.js
var t4 = class {
  _parseFeatureQuery(t5) {
    var _a;
    const s3 = t2(t5.buffer, new _(t5.options)), o3 = { ...s3, spatialReference: (_a = s3.spatialReference) == null ? void 0 : _a.toJSON(), fields: s3.fields ? s3.fields.map((e2) => e2.toJSON()) : void 0 };
    return Promise.resolve(o3);
  }
};
function s2() {
  return new t4();
}
export {
  s2 as default
};
//# sourceMappingURL=PBFDecoderWorker-YYGUFR6D.js.map

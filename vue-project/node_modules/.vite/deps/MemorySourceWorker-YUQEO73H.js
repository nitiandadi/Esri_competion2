import {
  n,
  t as t2
} from "./chunk-R6W2D4MP.js";
import {
  a as a2,
  f as f2,
  g as g3,
  m,
  w
} from "./chunk-5KLGNVYS.js";
import {
  a,
  i as i2,
  o
} from "./chunk-HOZTBKBY.js";
import {
  g as g2
} from "./chunk-TOUWX7QY.js";
import {
  ee
} from "./chunk-KFKQAPIE.js";
import "./chunk-I6NT2Q5S.js";
import "./chunk-OGEJGMAT.js";
import "./chunk-IHH5JPM6.js";
import "./chunk-CKJEN72K.js";
import {
  f,
  g
} from "./chunk-FFQ74L2K.js";
import "./chunk-4INBF4X4.js";
import "./chunk-T5ZE4H5E.js";
import "./chunk-Y2A35C5L.js";
import "./chunk-5AFBRPYC.js";
import "./chunk-H7DQVFGE.js";
import "./chunk-4S6QYDLW.js";
import "./chunk-6WFGRBCZ.js";
import "./chunk-H52BWZLI.js";
import "./chunk-QDIJO3T2.js";
import "./chunk-HMF3PNQD.js";
import "./chunk-KHZKCEXF.js";
import "./chunk-BWDA3FLJ.js";
import "./chunk-3F26JL34.js";
import "./chunk-KEA4MCOH.js";
import "./chunk-E4FSIE7C.js";
import {
  nt,
  ot,
  st
} from "./chunk-UZM66DAH.js";
import "./chunk-CFTD44JM.js";
import "./chunk-MI7FJDLG.js";
import "./chunk-BDRIBQHS.js";
import "./chunk-POASDJDE.js";
import "./chunk-7WIVOZQ6.js";
import {
  r as r2
} from "./chunk-OXCMSIKI.js";
import "./chunk-HWGER6NN.js";
import "./chunk-FI2SN5P7.js";
import "./chunk-ZXEHLMMH.js";
import "./chunk-BHKUW5DD.js";
import "./chunk-G3ZCYHOR.js";
import "./chunk-5W2WWLX7.js";
import "./chunk-6PNW7TCI.js";
import "./chunk-QP5ZWBKN.js";
import "./chunk-UZTIVDTR.js";
import "./chunk-33RBBVRO.js";
import "./chunk-JU2WP2RZ.js";
import "./chunk-NI6ENKKR.js";
import "./chunk-6XDV3BWZ.js";
import {
  M
} from "./chunk-W3UIP6CW.js";
import "./chunk-CHJGFW3N.js";
import "./chunk-QLGPYDHY.js";
import "./chunk-5WYME2YP.js";
import {
  i
} from "./chunk-WVICJPEU.js";
import "./chunk-YMGINT43.js";
import "./chunk-2WLZX6A7.js";
import {
  c as c2,
  s as s2
} from "./chunk-M7CMZTD6.js";
import "./chunk-ERJGVLTB.js";
import {
  c
} from "./chunk-T5VSOT6T.js";
import "./chunk-OHZM2VYI.js";
import "./chunk-BF3T2CWA.js";
import "./chunk-PTCP7EIR.js";
import "./chunk-Z4G4Y7TU.js";
import "./chunk-4TEGWGCF.js";
import "./chunk-E4M4B5ZQ.js";
import "./chunk-JATK7CEQ.js";
import "./chunk-74TXAD7S.js";
import "./chunk-HIRLBWV3.js";
import "./chunk-AFQAO5F4.js";
import "./chunk-OA5ES74L.js";
import "./chunk-6VTYOWNK.js";
import "./chunk-RLEMMDH4.js";
import "./chunk-6ZUWLK7F.js";
import {
  s3 as s
} from "./chunk-YVZY5LDV.js";
import "./chunk-H32MMKAJ.js";
import "./chunk-MKHZ5X6F.js";
import {
  r,
  t
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = c;
var q = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: c };
var w2 = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
function D(e) {
  return s2(e) ? null != e.z : !!e.hasZ;
}
function O(e) {
  return s2(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    this._queryEngine && this._queryEngine && this._queryEngine.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(t3) {
    const i3 = [], { features: s3 } = t3, r3 = this._inferLayerProperties(s3, t3.fields), n2 = t3.fields || [], a3 = null != t3.hasM ? t3.hasM : !!r3.hasM, o2 = null != t3.hasZ ? t3.hasZ : !!r3.hasZ, l = !t3.spatialReference && !r3.spatialReference, c3 = l ? R : t3.spatialReference || r3.spatialReference, I = l ? q : null, b = t3.geometryType || r3.geometryType, F = !b;
    let j = t3.objectIdField || r3.objectIdField, _ = t3.timeInfo;
    if (!F && (l && i3.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !b))
      throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!j)
      throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (r3.objectIdField && j !== r3.objectIdField && (i3.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${j}" doesn't match the field name "${r3.objectIdField}", found in the provided fields` }), j = r3.objectIdField), j && !r3.objectIdField) {
      let e = null;
      n2.some((t4) => t4.name === j && (e = t4, true)) ? (e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : n2.unshift({ alias: j, name: j, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const d of n2) {
      if (null == d.name && (d.name = d.alias), null == d.alias && (d.alias = d.name), !d.name)
        throw new s("feature-layer:invalid-field-name", "field name is missing", { field: d });
      if (d.name === j && (d.type = "esriFieldTypeOID"), !i.jsonValues.includes(d.type))
        throw new s("feature-layer:invalid-field-type", `invalid type for field "${d.name}"`, { field: d });
    }
    const D2 = {};
    for (const e of n2)
      if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t4 = M(e);
        void 0 !== t4 && (D2[e.name] = t4);
      }
    if (this._fieldsIndex = new r2(n2), this._createDefaultAttributes = i2(D2, j), _) {
      if (_.startTimeField) {
        const e = this._fieldsIndex.get(_.startTimeField);
        e ? (_.startTimeField = e.name, e.type = "esriFieldTypeDate") : _.startTimeField = null;
      }
      if (_.endTimeField) {
        const e = this._fieldsIndex.get(_.endTimeField);
        e ? (_.endTimeField = e.name, e.type = "esriFieldTypeDate") : _.endTimeField = null;
      }
      if (_.trackIdField) {
        const e = this._fieldsIndex.get(_.trackIdField);
        e ? _.trackIdField = e.name : (_.trackIdField = null, i3.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: _ } }));
      }
      _.startTimeField || _.endTimeField || (i3.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: _ } }), _ = null);
    }
    const O2 = { warnings: i3, featureErrors: [], layerDefinition: { ...w2, drawingInfo: o(b), templates: a(D2), extent: I, geometryType: b, objectIdField: j, fields: n2, hasZ: o2, hasM: a3, timeInfo: _ }, assignedObjectIds: {} };
    if (this._queryEngine = new ee({ fields: n2, geometryType: b, hasM: a3, hasZ: o2, objectIdField: j, spatialReference: c3, featureStore: new g2({ geometryType: b, hasM: a3, hasZ: o2 }), timeInfo: _, cacheSpatialQueries: true }), !s3 || !s3.length)
      return this._nextObjectId = t2, O2;
    const S2 = n(j, s3);
    return this._nextObjectId = S2 + 1, await f(s3, c3), this._loadInitialFeatures(O2, s3);
  }
  async applyEdits(e) {
    const { spatialReference: t3, geometryType: i3 } = this._queryEngine;
    return await Promise.all([w(t3, i3), f(e.adds, t3), f(e.updates, t3)]), this._applyEdits(e);
  }
  queryFeatures(e, t3 = {}) {
    return this._queryEngine.executeQuery(e, t3.signal);
  }
  queryFeatureCount(e, t3 = {}) {
    return this._queryEngine.executeQueryForCount(e, t3.signal);
  }
  queryObjectIds(e, t3 = {}) {
    return this._queryEngine.executeQueryForIds(e, t3.signal);
  }
  queryExtent(e, t3 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t3.signal);
  }
  querySnapping(e, t3 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t3.signal);
  }
  _inferLayerProperties(e, i3) {
    let r3, n2, a3 = null, o2 = null, l = null;
    for (const d of e) {
      const e2 = d.geometry;
      if (!t(e2) && (a3 || (a3 = c2(e2)), o2 || (o2 = e2.spatialReference), null == r3 && (r3 = D(e2)), null == n2 && (n2 = O(e2)), a3 && o2 && null != r3 && null != n2))
        break;
    }
    if (i3 && i3.length) {
      let e2 = null;
      i3.some((t3) => {
        const i4 = "esriFieldTypeOID" === t3.type, s3 = !t3.type && t3.name && "objectid" === t3.name.toLowerCase();
        return e2 = t3, i4 || s3;
      }) && (l = e2.name);
    }
    return { geometryType: a3, spatialReference: o2, objectIdField: l, hasM: n2, hasZ: r3 };
  }
  async _loadInitialFeatures(e, t3) {
    const { geometryType: r3, hasM: n2, hasZ: o2, objectIdField: l, spatialReference: d, featureStore: u } = this._queryEngine, p = [];
    for (const a3 of t3) {
      if (null != a3.uid && (e.assignedObjectIds[a3.uid] = -1), a3.geometry && r3 !== c2(a3.geometry)) {
        e.featureErrors.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), n3 = m(this._fieldsIndex, t4, a3.attributes, true, e.warnings);
      n3 ? e.featureErrors.push(n3) : (this._assignObjectId(t4, a3.attributes, true), a3.attributes = t4, null != a3.uid && (e.assignedObjectIds[a3.uid] = a3.attributes[l]), r(a3.geometry) && (a3.geometry = g(a3.geometry, a3.geometry.spatialReference, d)), p.push(a3));
    }
    u.addMany(nt([], p, r3, o2, n2, l));
    const { fullExtent: f3, timeExtent: y } = await this._queryEngine.fetchRecomputedExtents();
    if (e.layerDefinition.extent = f3, y) {
      const { start: t4, end: i3 } = y;
      e.layerDefinition.timeInfo.timeExtent = [t4, i3];
    }
    return e;
  }
  async _applyEdits(e) {
    const { adds: t3, updates: i3, deletes: s3 } = e, r3 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t3 && t3.length && this._applyAddEdits(r3, t3), i3 && i3.length && this._applyUpdateEdits(r3, i3), s3 && s3.length) {
      for (const e2 of s3)
        r3.deleteResults.push(f2(e2));
      this._queryEngine.featureStore.removeManyById(s3);
    }
    const { fullExtent: n2, timeExtent: a3 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n2, timeExtent: a3, featureEditResults: r3 };
  }
  _applyAddEdits(e, t3) {
    const { addResults: r3 } = e, { geometryType: n2, hasM: o2, hasZ: l, objectIdField: d, spatialReference: u, featureStore: p } = this._queryEngine, f3 = [];
    for (const a3 of t3) {
      if (a3.geometry && n2 !== c2(a3.geometry)) {
        r3.push(a2("Incorrect geometry type."));
        continue;
      }
      const t4 = this._createDefaultAttributes(), o3 = m(this._fieldsIndex, t4, a3.attributes);
      if (o3)
        r3.push(o3);
      else {
        if (this._assignObjectId(t4, a3.attributes), a3.attributes = t4, null != a3.uid) {
          const t5 = a3.attributes[d];
          e.uidToObjectId[a3.uid] = t5;
        }
        if (r(a3.geometry)) {
          const e2 = a3.geometry.spatialReference ?? u;
          a3.geometry = g(g3(a3.geometry, e2), e2, u);
        }
        f3.push(a3), r3.push(f2(a3.attributes[d]));
      }
    }
    p.addMany(nt([], f3, n2, l, o2, d));
  }
  _applyUpdateEdits({ updateResults: e }, t3) {
    const { geometryType: r3, hasM: n2, hasZ: a3, objectIdField: d, spatialReference: u, featureStore: p } = this._queryEngine;
    for (const f3 of t3) {
      const { attributes: t4, geometry: y } = f3, m2 = t4 && t4[d];
      if (null == m2) {
        e.push(a2(`Identifier field ${d} missing`));
        continue;
      }
      if (!p.has(m2)) {
        e.push(a2(`Feature with object id ${m2} missing`));
        continue;
      }
      const h = st(p.getFeature(m2), r3, a3, n2);
      if (r(y)) {
        if (r3 !== c2(y)) {
          e.push(a2("Incorrect geometry type."));
          continue;
        }
        const t5 = y.spatialReference ?? u;
        h.geometry = g(g3(y, t5), t5, u);
      }
      if (t4) {
        const i3 = m(this._fieldsIndex, h.attributes, t4);
        if (i3) {
          e.push(i3);
          continue;
        }
      }
      p.add(ot(h, r3, a3, n2, d)), e.push(f2(m2));
    }
  }
  _assignObjectId(e, t3, i3 = false) {
    const s3 = this._queryEngine.objectIdField;
    i3 && t3 && isFinite(t3[s3]) ? e[s3] = t3[s3] : e[s3] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-YUQEO73H.js.map

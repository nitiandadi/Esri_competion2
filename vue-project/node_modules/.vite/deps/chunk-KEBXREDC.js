import {
  a as a4,
  c,
  h,
  m,
  m2,
  p as p4,
  s as s4,
  u,
  u2
} from "./chunk-M6GJ5NLR.js";
import {
  p as p3,
  v,
  y as y2,
  z
} from "./chunk-VY77CAXT.js";
import {
  a as a3
} from "./chunk-5W2WWLX7.js";
import {
  f2 as f,
  w,
  w2
} from "./chunk-T5VSOT6T.js";
import {
  l as l2
} from "./chunk-NXJOIK2O.js";
import {
  s as s3
} from "./chunk-HIRLBWV3.js";
import {
  l
} from "./chunk-AFQAO5F4.js";
import {
  a2,
  e,
  y3 as y
} from "./chunk-OA5ES74L.js";
import {
  a,
  p as p2
} from "./chunk-6ZUWLK7F.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-YVZY5LDV.js";
import {
  p
} from "./chunk-H32MMKAJ.js";
import {
  e as e2,
  i,
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/chunks/Zlib.js
var t2;
var e3;
var r2;
var i2 = {};
var s5 = { get exports() {
  return i2;
}, set exports(t7) {
  i2 = t7;
} };
e3 = s5, void 0 !== (t2 = function() {
  function t7() {
    this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = null;
  }
  return t7.prototype = { ensureBuffer: function(t8) {
    var e8 = this.buffer, r10 = e8 ? e8.byteLength : 0;
    if (t8 < r10)
      return e8;
    for (var i7 = 512; i7 < t8; )
      i7 <<= 1;
    for (var s9 = new Uint8Array(i7), f6 = 0; f6 < r10; ++f6)
      s9[f6] = e8[f6];
    return this.buffer = s9;
  }, getByte: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }, getBytes: function(t8) {
    var e8 = this.pos;
    if (t8) {
      this.ensureBuffer(e8 + t8);
      for (var r10 = e8 + t8; !this.eof && this.bufferLength < r10; )
        this.readBlock();
      var i7 = this.bufferLength;
      r10 > i7 && (r10 = i7);
    } else {
      for (; !this.eof; )
        this.readBlock();
      r10 = this.bufferLength;
    }
    return this.pos = r10, this.buffer.subarray(e8, r10);
  }, lookChar: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos]);
  }, getChar: function() {
    for (var t8 = this.pos; this.bufferLength <= t8; ) {
      if (this.eof)
        return null;
      this.readBlock();
    }
    return String.fromCharCode(this.buffer[this.pos++]);
  }, makeSubStream: function(t8, e8, r10) {
    for (var i7 = t8 + e8; this.bufferLength <= i7 && !this.eof; )
      this.readBlock();
    return new Stream(this.buffer, t8, e8, r10);
  }, skip: function(t8) {
    t8 || (t8 = 1), this.pos += t8;
  }, reset: function() {
    this.pos = 0;
  } }, t7;
}(), r2 = function() {
  if (!self || !self.Uint32Array)
    return null;
  var e8 = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r10 = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i7 = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), s9 = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], f6 = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
  function n9(t7) {
    throw new Error(t7);
  }
  function o4(e9) {
    var r11 = 0, i8 = e9[r11++], s10 = e9[r11++];
    -1 != i8 && -1 != s10 || n9("Invalid header in flate stream"), 8 != (15 & i8) && n9("Unknown compression method in flate stream"), ((i8 << 8) + s10) % 31 != 0 && n9("Bad FCHECK in flate stream"), 32 & s10 && n9("FDICT bit set in flate stream"), this.bytes = e9, this.bytesPos = r11, this.codeSize = 0, this.codeBuf = 0, t2.call(this);
  }
  return o4.prototype = Object.create(t2.prototype), o4.prototype.getBits = function(t7) {
    for (var e9, r11 = this.codeSize, i8 = this.codeBuf, s10 = this.bytes, f7 = this.bytesPos; r11 < t7; )
      void 0 === (e9 = s10[f7++]) && n9("Bad encoding in flate stream"), i8 |= e9 << r11, r11 += 8;
    return e9 = i8 & (1 << t7) - 1, this.codeBuf = i8 >> t7, this.codeSize = r11 -= t7, this.bytesPos = f7, e9;
  }, o4.prototype.getCode = function(t7) {
    for (var e9 = t7[0], r11 = t7[1], i8 = this.codeSize, s10 = this.codeBuf, f7 = this.bytes, o5 = this.bytesPos; i8 < r11; ) {
      var h6;
      void 0 === (h6 = f7[o5++]) && n9("Bad encoding in flate stream"), s10 |= h6 << i8, i8 += 8;
    }
    var a12 = e9[s10 & (1 << r11) - 1], u8 = a12 >> 16, l8 = 65535 & a12;
    return (0 == i8 || i8 < u8 || 0 == u8) && n9("Bad encoding in flate stream"), this.codeBuf = s10 >> u8, this.codeSize = i8 - u8, this.bytesPos = o5, l8;
  }, o4.prototype.generateHuffmanTable = function(t7) {
    for (var e9 = t7.length, r11 = 0, i8 = 0; i8 < e9; ++i8)
      t7[i8] > r11 && (r11 = t7[i8]);
    for (var s10 = 1 << r11, f7 = new Uint32Array(s10), n10 = 1, o5 = 0, h6 = 2; n10 <= r11; ++n10, o5 <<= 1, h6 <<= 1)
      for (var a12 = 0; a12 < e9; ++a12)
        if (t7[a12] == n10) {
          var u8 = 0, l8 = o5;
          for (i8 = 0; i8 < n10; ++i8)
            u8 = u8 << 1 | 1 & l8, l8 >>= 1;
          for (i8 = u8; i8 < s10; i8 += h6)
            f7[i8] = n10 << 16 | a12;
          ++o5;
        }
    return [f7, r11];
  }, o4.prototype.readBlock = function() {
    function t7(t8, e9, r11, i8, s10) {
      for (var f7 = t8.getBits(r11) + i8; f7-- > 0; )
        e9[b4++] = s10;
    }
    var o5 = this.getBits(3);
    if (1 & o5 && (this.eof = true), 0 != (o5 >>= 1)) {
      var h6, a12;
      if (1 == o5)
        h6 = s9, a12 = f6;
      else if (2 == o5) {
        for (var u8 = this.getBits(5) + 257, l8 = this.getBits(5) + 1, d4 = this.getBits(4) + 4, c6 = Array(e8.length), b4 = 0; b4 < d4; )
          c6[e8[b4++]] = this.getBits(3);
        for (var v6 = this.generateHuffmanTable(c6), g5 = 0, B3 = (b4 = 0, u8 + l8), p9 = new Array(B3); b4 < B3; ) {
          var y7 = this.getCode(v6);
          16 == y7 ? t7(this, p9, 2, 3, g5) : 17 == y7 ? t7(this, p9, 3, 3, g5 = 0) : 18 == y7 ? t7(this, p9, 7, 11, g5 = 0) : p9[b4++] = g5 = y7;
        }
        h6 = this.generateHuffmanTable(p9.slice(0, u8)), a12 = this.generateHuffmanTable(p9.slice(u8, B3));
      } else
        n9("Unknown block type in flate stream");
      for (var m7 = (x4 = this.buffer) ? x4.length : 0, k4 = this.bufferLength; ; ) {
        var w5 = this.getCode(h6);
        if (w5 < 256)
          k4 + 1 >= m7 && (m7 = (x4 = this.ensureBuffer(k4 + 1)).length), x4[k4++] = w5;
        else {
          if (256 == w5)
            return void (this.bufferLength = k4);
          var C4 = (w5 = r10[w5 -= 257]) >> 16;
          C4 > 0 && (C4 = this.getBits(C4)), g5 = (65535 & w5) + C4, w5 = this.getCode(a12), (C4 = (w5 = i7[w5]) >> 16) > 0 && (C4 = this.getBits(C4));
          var L3 = (65535 & w5) + C4;
          k4 + g5 >= m7 && (m7 = (x4 = this.ensureBuffer(k4 + g5)).length);
          for (var S4 = 0; S4 < g5; ++S4, ++k4)
            x4[k4] = x4[k4 - L3];
        }
      }
    } else {
      var A3, U3 = this.bytes, P3 = this.bytesPos;
      void 0 === (A3 = U3[P3++]) && n9("Bad block header in flate stream");
      var z2 = A3;
      void 0 === (A3 = U3[P3++]) && n9("Bad block header in flate stream"), z2 |= A3 << 8, void 0 === (A3 = U3[P3++]) && n9("Bad block header in flate stream");
      var H2 = A3;
      void 0 === (A3 = U3[P3++]) && n9("Bad block header in flate stream"), (H2 |= A3 << 8) != (65535 & ~z2) && n9("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
      var T4 = this.bufferLength, x4 = this.ensureBuffer(T4 + z2), E3 = T4 + z2;
      this.bufferLength = E3;
      for (var F2 = T4; F2 < E3; ++F2) {
        if (void 0 === (A3 = U3[P3++])) {
          this.eof = true;
          break;
        }
        x4[F2] = A3;
      }
      this.bytesPos = P3;
    }
  }, o4;
}()) && (e3.exports = r2);

// node_modules/@arcgis/core/layers/support/rasterFormats/ImageCanvasDecoder.js
var i3 = class {
  constructor(t7) {
    this._canvas = null, this._ctx = null, t7 && (this._canvas = t7.canvas, this._ctx = t7.ctx || t7.canvas && t7.canvas.getContext("2d"));
  }
  decode(n9, s9, r10) {
    if (!n9 || n9.byteLength < 10)
      throw new s2("imagecanvasdecoder: decode", "required a valid encoded data as input.");
    let { width: c6 = 0, height: h6 = 0, format: o4 } = s9;
    const { applyJpegMask: l8 } = s9;
    if (l8 && (!c6 || !h6))
      throw new s2("imagecanvasdecoder: decode", "image width and height are needed to apply jpeg mask directly to canvas");
    return new Promise((t7, d4) => {
      let g5 = null;
      "jpg" === o4 && l8 && (g5 = i3._getMask(n9, { width: c6, height: h6 }));
      const w5 = new Blob([new Uint8Array(n9)], { type: "image/" + o4 == "jpg" ? "jpeg" : o4 }), v6 = URL.createObjectURL(w5), m7 = new Image();
      let _3;
      m7.src = v6, m7.onload = () => {
        if (URL.revokeObjectURL(v6), p2(r10))
          return void d4(a());
        c6 = m7.width, h6 = m7.height, this._canvas && this._ctx ? (this._canvas.width === c6 && this._canvas.height === h6 || (this._canvas.width = c6, this._canvas.height = h6), this._ctx.clearRect(0, 0, c6, h6)) : (this._canvas = document.createElement("canvas"), this._canvas.width = c6, this._canvas.height = h6, this._ctx = this._canvas.getContext("2d")), this._ctx.drawImage(m7, 0, 0);
        const n10 = this._ctx.getImageData(0, 0, c6, h6);
        let i7;
        if (_3 = n10.data, s9.renderOnCanvas) {
          if (g5)
            for (i7 = 0; i7 < g5.length; i7++)
              g5[i7] ? _3[4 * i7 + 3] = 255 : _3[4 * i7 + 3] = 0;
          return this._ctx.putImageData(n10, 0, 0), void t7(null);
        }
        const o5 = c6 * h6, l9 = new Uint8Array(o5), w6 = new Uint8Array(o5), p9 = new Uint8Array(o5);
        if (g5)
          for (i7 = 0; i7 < o5; i7++)
            l9[i7] = _3[4 * i7], w6[i7] = _3[4 * i7 + 1], p9[i7] = _3[4 * i7 + 2];
        else
          for (g5 = new Uint8Array(o5), i7 = 0; i7 < o5; i7++)
            l9[i7] = _3[4 * i7], w6[i7] = _3[4 * i7 + 1], p9[i7] = _3[4 * i7 + 2], g5[i7] = _3[4 * i7 + 3];
        t7({ width: c6, height: h6, pixels: [l9, w6, p9], mask: g5, pixelType: "u8" });
      }, m7.onerror = () => {
        URL.revokeObjectURL(v6), d4("cannot load image");
      };
    });
  }
  static _getMask(t7, e8) {
    let a12 = null;
    try {
      const i7 = new Uint8Array(t7), s9 = Math.ceil(i7.length / 2);
      let r10 = 0;
      const c6 = i7.length - 2;
      for (r10 = s9; r10 < c6 && (255 !== i7[r10] || 217 !== i7[r10 + 1]); r10++)
        ;
      if (r10 += 2, r10 < i7.length - 1) {
        const t8 = new i2(i7.subarray(r10)).getBytes();
        a12 = new Uint8Array(e8.width * e8.height);
        let s10 = 0;
        for (let e9 = 0; e9 < t8.length; e9++)
          for (let n9 = 7; n9 >= 0; n9--)
            a12[s10++] = t8[e9] >> n9 & 1;
      }
    } catch (i7) {
    }
    return a12;
  }
};

// node_modules/@arcgis/core/chunks/Jpg.js
var e4;
var n;
var r3;
var o = {};
var a5 = { get exports() {
  return o;
}, set exports(e8) {
  o = e8;
} };
e4 = a5, n = function() {
  var e8 = function() {
    function e9(e10) {
      this.message = "JPEG error: " + e10;
    }
    return e9.prototype = new Error(), e9.prototype.name = "JpegError", e9.constructor = e9, e9;
  }();
  return function() {
    if (!self || !self.Uint8ClampedArray)
      return null;
    var n9 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r10 = 4017, o4 = 799, a12 = 3406, t7 = 2276, i7 = 1567, s9 = 3784, c6 = 5793, f6 = 2896;
    function l8() {
      this.decodeTransform = null, this.colorTransform = -1;
    }
    function u8(e9, n10) {
      for (var r11, o5, a13 = 0, t8 = [], i8 = 16; i8 > 0 && !e9[i8 - 1]; )
        i8--;
      t8.push({ children: [], index: 0 });
      var s10, c7 = t8[0];
      for (r11 = 0; r11 < i8; r11++) {
        for (o5 = 0; o5 < e9[r11]; o5++) {
          for ((c7 = t8.pop()).children[c7.index] = n10[a13]; c7.index > 0; )
            c7 = t8.pop();
          for (c7.index++, t8.push(c7); t8.length <= r11; )
            t8.push(s10 = { children: [], index: 0 }), c7.children[c7.index] = s10.children, c7 = s10;
          a13++;
        }
        r11 + 1 < i8 && (t8.push(s10 = { children: [], index: 0 }), c7.children[c7.index] = s10.children, c7 = s10);
      }
      return t8[0].children;
    }
    function h6(e9, n10, r11) {
      return 64 * ((e9.blocksPerLine + 1) * n10 + r11);
    }
    function v6(r11, o5, a13, t8, i8, s10, c7, f7, l9) {
      var u9 = a13.mcusPerLine, v7 = a13.progressive, m8 = o5, d5 = 0, p9 = 0;
      function k4() {
        if (p9 > 0)
          return p9--, d5 >> p9 & 1;
        if (255 === (d5 = r11[o5++])) {
          var n10 = r11[o5++];
          if (n10)
            throw new e8("unexpected marker " + (d5 << 8 | n10).toString(16));
        }
        return p9 = 7, d5 >>> 7;
      }
      function g5(n10) {
        for (var r12 = n10; ; ) {
          if ("number" == typeof (r12 = r12[k4()]))
            return r12;
          if ("object" != typeof r12)
            throw new e8("invalid huffman sequence");
        }
      }
      function C4(e9) {
        for (var n10 = 0; e9 > 0; )
          n10 = n10 << 1 | k4(), e9--;
        return n10;
      }
      function w5(e9) {
        if (1 === e9)
          return 1 === k4() ? 1 : -1;
        var n10 = C4(e9);
        return n10 >= 1 << e9 - 1 ? n10 : n10 + (-1 << e9) + 1;
      }
      function x4(e9, r12) {
        var o6 = g5(e9.huffmanTableDC), a14 = 0 === o6 ? 0 : w5(o6);
        e9.blockData[r12] = e9.pred += a14;
        for (var t9 = 1; t9 < 64; ) {
          var i9 = g5(e9.huffmanTableAC), s11 = 15 & i9, c8 = i9 >> 4;
          if (0 !== s11) {
            var f8 = n9[t9 += c8];
            e9.blockData[r12 + f8] = w5(s11), t9++;
          } else {
            if (c8 < 15)
              break;
            t9 += 16;
          }
        }
      }
      function y7(e9, n10) {
        var r12 = g5(e9.huffmanTableDC), o6 = 0 === r12 ? 0 : w5(r12) << l9;
        e9.blockData[n10] = e9.pred += o6;
      }
      function D4(e9, n10) {
        e9.blockData[n10] |= k4() << l9;
      }
      var T4 = 0;
      function P3(e9, r12) {
        if (T4 > 0)
          T4--;
        else
          for (var o6 = s10, a14 = c7; o6 <= a14; ) {
            var t9 = g5(e9.huffmanTableAC), i9 = 15 & t9, f8 = t9 >> 4;
            if (0 !== i9) {
              var u10 = n9[o6 += f8];
              e9.blockData[r12 + u10] = w5(i9) * (1 << l9), o6++;
            } else {
              if (f8 < 15) {
                T4 = C4(f8) + (1 << f8) - 1;
                break;
              }
              o6 += 16;
            }
          }
      }
      var L3, A3 = 0;
      function _3(r12, o6) {
        for (var a14, t9, i9 = s10, f8 = c7, u10 = 0; i9 <= f8; ) {
          var h7 = n9[i9];
          switch (A3) {
            case 0:
              if (u10 = (t9 = g5(r12.huffmanTableAC)) >> 4, 0 == (a14 = 15 & t9))
                u10 < 15 ? (T4 = C4(u10) + (1 << u10), A3 = 4) : (u10 = 16, A3 = 1);
              else {
                if (1 !== a14)
                  throw new e8("invalid ACn encoding");
                L3 = w5(a14), A3 = u10 ? 2 : 3;
              }
              continue;
            case 1:
            case 2:
              r12.blockData[o6 + h7] ? r12.blockData[o6 + h7] += k4() << l9 : 0 == --u10 && (A3 = 2 === A3 ? 3 : 0);
              break;
            case 3:
              r12.blockData[o6 + h7] ? r12.blockData[o6 + h7] += k4() << l9 : (r12.blockData[o6 + h7] = L3 << l9, A3 = 0);
              break;
            case 4:
              r12.blockData[o6 + h7] && (r12.blockData[o6 + h7] += k4() << l9);
          }
          i9++;
        }
        4 === A3 && 0 == --T4 && (A3 = 0);
      }
      function U3(e9, n10, r12, o6, a14) {
        var t9 = r12 % u9;
        n10(e9, h6(e9, (r12 / u9 | 0) * e9.v + o6, t9 * e9.h + a14));
      }
      function z2(e9, n10, r12) {
        n10(e9, h6(e9, r12 / e9.blocksPerLine | 0, r12 % e9.blocksPerLine));
      }
      var I3, M3, Y, q, S4, R3, H2 = t8.length;
      R3 = v7 ? 0 === s10 ? 0 === f7 ? y7 : D4 : 0 === f7 ? P3 : _3 : x4;
      var E3, J, V3, j2, B3 = 0;
      for (J = 1 === H2 ? t8[0].blocksPerLine * t8[0].blocksPerColumn : u9 * a13.mcusPerColumn; B3 < J; ) {
        var N2 = i8 ? Math.min(J - B3, i8) : J;
        for (M3 = 0; M3 < H2; M3++)
          t8[M3].pred = 0;
        if (T4 = 0, 1 === H2)
          for (I3 = t8[0], S4 = 0; S4 < N2; S4++)
            z2(I3, R3, B3), B3++;
        else
          for (S4 = 0; S4 < N2; S4++) {
            for (M3 = 0; M3 < H2; M3++)
              for (V3 = (I3 = t8[M3]).h, j2 = I3.v, Y = 0; Y < j2; Y++)
                for (q = 0; q < V3; q++)
                  U3(I3, R3, B3, Y, q);
            B3++;
          }
        p9 = 0, (E3 = b4(r11, o5)) && E3.invalid && (console.log("decodeScan - unexpected MCU data, next marker is: " + E3.invalid), o5 = E3.offset);
        var G2 = E3 && E3.marker;
        if (!G2 || G2 <= 65280)
          throw new e8("marker was not found");
        if (!(G2 >= 65488 && G2 <= 65495))
          break;
        o5 += 2;
      }
      return (E3 = b4(r11, o5)) && E3.invalid && (console.log("decodeScan - unexpected Scan data, next marker is: " + E3.invalid), o5 = E3.offset), o5 - m8;
    }
    function m7(n10, l9, u9) {
      var h7, v7, m8, d5, b5, p9, k4, g5, C4, w5, x4, y7, D4, T4, P3, L3, A3, _3 = n10.quantizationTable, U3 = n10.blockData;
      if (!_3)
        throw new e8("missing required Quantization Table.");
      for (var z2 = 0; z2 < 64; z2 += 8)
        C4 = U3[l9 + z2], w5 = U3[l9 + z2 + 1], x4 = U3[l9 + z2 + 2], y7 = U3[l9 + z2 + 3], D4 = U3[l9 + z2 + 4], T4 = U3[l9 + z2 + 5], P3 = U3[l9 + z2 + 6], L3 = U3[l9 + z2 + 7], C4 *= _3[z2], 0 != (w5 | x4 | y7 | D4 | T4 | P3 | L3) ? (w5 *= _3[z2 + 1], x4 *= _3[z2 + 2], y7 *= _3[z2 + 3], D4 *= _3[z2 + 4], T4 *= _3[z2 + 5], P3 *= _3[z2 + 6], L3 *= _3[z2 + 7], v7 = (h7 = (h7 = c6 * C4 + 128 >> 8) + (v7 = c6 * D4 + 128 >> 8) + 1 >> 1) - v7, A3 = (m8 = x4) * s9 + (d5 = P3) * i7 + 128 >> 8, m8 = m8 * i7 - d5 * s9 + 128 >> 8, k4 = (b5 = (b5 = f6 * (w5 - L3) + 128 >> 8) + (k4 = T4 << 4) + 1 >> 1) - k4, p9 = (g5 = (g5 = f6 * (w5 + L3) + 128 >> 8) + (p9 = y7 << 4) + 1 >> 1) - p9, d5 = (h7 = h7 + (d5 = A3) + 1 >> 1) - d5, m8 = (v7 = v7 + m8 + 1 >> 1) - m8, A3 = b5 * t7 + g5 * a12 + 2048 >> 12, b5 = b5 * a12 - g5 * t7 + 2048 >> 12, g5 = A3, A3 = p9 * o4 + k4 * r10 + 2048 >> 12, p9 = p9 * r10 - k4 * o4 + 2048 >> 12, k4 = A3, u9[z2] = h7 + g5, u9[z2 + 7] = h7 - g5, u9[z2 + 1] = v7 + k4, u9[z2 + 6] = v7 - k4, u9[z2 + 2] = m8 + p9, u9[z2 + 5] = m8 - p9, u9[z2 + 3] = d5 + b5, u9[z2 + 4] = d5 - b5) : (A3 = c6 * C4 + 512 >> 10, u9[z2] = A3, u9[z2 + 1] = A3, u9[z2 + 2] = A3, u9[z2 + 3] = A3, u9[z2 + 4] = A3, u9[z2 + 5] = A3, u9[z2 + 6] = A3, u9[z2 + 7] = A3);
      for (var I3 = 0; I3 < 8; ++I3)
        C4 = u9[I3], 0 != ((w5 = u9[I3 + 8]) | (x4 = u9[I3 + 16]) | (y7 = u9[I3 + 24]) | (D4 = u9[I3 + 32]) | (T4 = u9[I3 + 40]) | (P3 = u9[I3 + 48]) | (L3 = u9[I3 + 56])) ? (v7 = (h7 = 4112 + ((h7 = c6 * C4 + 2048 >> 12) + (v7 = c6 * D4 + 2048 >> 12) + 1 >> 1)) - v7, A3 = (m8 = x4) * s9 + (d5 = P3) * i7 + 2048 >> 12, m8 = m8 * i7 - d5 * s9 + 2048 >> 12, d5 = A3, k4 = (b5 = (b5 = f6 * (w5 - L3) + 2048 >> 12) + (k4 = T4) + 1 >> 1) - k4, p9 = (g5 = (g5 = f6 * (w5 + L3) + 2048 >> 12) + (p9 = y7) + 1 >> 1) - p9, A3 = b5 * t7 + g5 * a12 + 2048 >> 12, b5 = b5 * a12 - g5 * t7 + 2048 >> 12, g5 = A3, A3 = p9 * o4 + k4 * r10 + 2048 >> 12, p9 = p9 * r10 - k4 * o4 + 2048 >> 12, C4 = (C4 = (h7 = h7 + d5 + 1 >> 1) + g5) < 16 ? 0 : C4 >= 4080 ? 255 : C4 >> 4, w5 = (w5 = (v7 = v7 + m8 + 1 >> 1) + (k4 = A3)) < 16 ? 0 : w5 >= 4080 ? 255 : w5 >> 4, x4 = (x4 = (m8 = v7 - m8) + p9) < 16 ? 0 : x4 >= 4080 ? 255 : x4 >> 4, y7 = (y7 = (d5 = h7 - d5) + b5) < 16 ? 0 : y7 >= 4080 ? 255 : y7 >> 4, D4 = (D4 = d5 - b5) < 16 ? 0 : D4 >= 4080 ? 255 : D4 >> 4, T4 = (T4 = m8 - p9) < 16 ? 0 : T4 >= 4080 ? 255 : T4 >> 4, P3 = (P3 = v7 - k4) < 16 ? 0 : P3 >= 4080 ? 255 : P3 >> 4, L3 = (L3 = h7 - g5) < 16 ? 0 : L3 >= 4080 ? 255 : L3 >> 4, U3[l9 + I3] = C4, U3[l9 + I3 + 8] = w5, U3[l9 + I3 + 16] = x4, U3[l9 + I3 + 24] = y7, U3[l9 + I3 + 32] = D4, U3[l9 + I3 + 40] = T4, U3[l9 + I3 + 48] = P3, U3[l9 + I3 + 56] = L3) : (A3 = (A3 = c6 * C4 + 8192 >> 14) < -2040 ? 0 : A3 >= 2024 ? 255 : A3 + 2056 >> 4, U3[l9 + I3] = A3, U3[l9 + I3 + 8] = A3, U3[l9 + I3 + 16] = A3, U3[l9 + I3 + 24] = A3, U3[l9 + I3 + 32] = A3, U3[l9 + I3 + 40] = A3, U3[l9 + I3 + 48] = A3, U3[l9 + I3 + 56] = A3);
    }
    function d4(e9, n10) {
      for (var r11 = n10.blocksPerLine, o5 = n10.blocksPerColumn, a13 = new Int16Array(64), t8 = 0; t8 < o5; t8++)
        for (var i8 = 0; i8 < r11; i8++)
          m7(n10, h6(n10, t8, i8), a13);
      return n10.blockData;
    }
    function b4(e9, n10, r11) {
      function o5(n11) {
        return e9[n11] << 8 | e9[n11 + 1];
      }
      var a13 = e9.length - 1, t8 = r11 < n10 ? r11 : n10;
      if (n10 >= a13)
        return null;
      var i8 = o5(n10);
      if (i8 >= 65472 && i8 <= 65534)
        return { invalid: null, marker: i8, offset: n10 };
      for (var s10 = o5(t8); !(s10 >= 65472 && s10 <= 65534); ) {
        if (++t8 >= a13)
          return null;
        s10 = o5(t8);
      }
      return { invalid: i8.toString(16), marker: s10, offset: t8 };
    }
    return l8.prototype = { parse: function(r11) {
      function o5() {
        var e9 = r11[c7] << 8 | r11[c7 + 1];
        return c7 += 2, e9;
      }
      function a13() {
        var e9 = o5(), n10 = c7 + e9 - 2, a14 = b4(r11, n10, c7);
        a14 && a14.invalid && (console.log("readDataBlock - incorrect length, next marker is: " + a14.invalid), n10 = a14.offset);
        var t9 = r11.subarray(c7, n10);
        return c7 += t9.length, t9;
      }
      function t8(e9) {
        for (var n10 = Math.ceil(e9.samplesPerLine / 8 / e9.maxH), r12 = Math.ceil(e9.scanLines / 8 / e9.maxV), o6 = 0; o6 < e9.components.length; o6++) {
          H2 = e9.components[o6];
          var a14 = Math.ceil(Math.ceil(e9.samplesPerLine / 8) * H2.h / e9.maxH), t9 = Math.ceil(Math.ceil(e9.scanLines / 8) * H2.v / e9.maxV), i9 = n10 * H2.h, s11 = r12 * H2.v * 64 * (i9 + 1);
          H2.blockData = new Int16Array(s11), H2.blocksPerLine = a14, H2.blocksPerColumn = t9;
        }
        e9.mcusPerLine = n10, e9.mcusPerColumn = r12;
      }
      var i8, s10, c7 = 0, f7 = null, l9 = null, h7 = [], m8 = [], p9 = [], k4 = o5();
      if (65496 !== k4)
        throw new e8("SOI not found");
      for (k4 = o5(); 65497 !== k4; ) {
        var g5, C4, w5;
        switch (k4) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            var x4 = a13();
            65504 === k4 && 74 === x4[0] && 70 === x4[1] && 73 === x4[2] && 70 === x4[3] && 0 === x4[4] && (f7 = { version: { major: x4[5], minor: x4[6] }, densityUnits: x4[7], xDensity: x4[8] << 8 | x4[9], yDensity: x4[10] << 8 | x4[11], thumbWidth: x4[12], thumbHeight: x4[13], thumbData: x4.subarray(14, 14 + 3 * x4[12] * x4[13]) }), 65518 === k4 && 65 === x4[0] && 100 === x4[1] && 111 === x4[2] && 98 === x4[3] && 101 === x4[4] && (l9 = { version: x4[5] << 8 | x4[6], flags0: x4[7] << 8 | x4[8], flags1: x4[9] << 8 | x4[10], transformCode: x4[11] });
            break;
          case 65499:
            for (var y7 = o5() + c7 - 2; c7 < y7; ) {
              var D4 = r11[c7++], T4 = new Uint16Array(64);
              if (D4 >> 4 == 0)
                for (C4 = 0; C4 < 64; C4++)
                  T4[n9[C4]] = r11[c7++];
              else {
                if (D4 >> 4 != 1)
                  throw new e8("DQT - invalid table spec");
                for (C4 = 0; C4 < 64; C4++)
                  T4[n9[C4]] = o5();
              }
              h7[15 & D4] = T4;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i8)
              throw new e8("Only single frame JPEGs supported");
            o5(), (i8 = {}).extended = 65473 === k4, i8.progressive = 65474 === k4, i8.precision = r11[c7++], i8.scanLines = o5(), i8.samplesPerLine = o5(), i8.components = [], i8.componentIds = {};
            var P3, L3 = r11[c7++], A3 = 0, _3 = 0;
            for (g5 = 0; g5 < L3; g5++) {
              P3 = r11[c7];
              var U3 = r11[c7 + 1] >> 4, z2 = 15 & r11[c7 + 1];
              A3 < U3 && (A3 = U3), _3 < z2 && (_3 = z2);
              var I3 = r11[c7 + 2];
              w5 = i8.components.push({ h: U3, v: z2, quantizationId: I3, quantizationTable: null }), i8.componentIds[P3] = w5 - 1, c7 += 3;
            }
            i8.maxH = A3, i8.maxV = _3, t8(i8);
            break;
          case 65476:
            var M3 = o5();
            for (g5 = 2; g5 < M3; ) {
              var Y = r11[c7++], q = new Uint8Array(16), S4 = 0;
              for (C4 = 0; C4 < 16; C4++, c7++)
                S4 += q[C4] = r11[c7];
              var R3 = new Uint8Array(S4);
              for (C4 = 0; C4 < S4; C4++, c7++)
                R3[C4] = r11[c7];
              g5 += 17 + S4, (Y >> 4 == 0 ? p9 : m8)[15 & Y] = u8(q, R3);
            }
            break;
          case 65501:
            o5(), s10 = o5();
            break;
          case 65498:
            o5();
            var H2, E3 = r11[c7++], J = [];
            for (g5 = 0; g5 < E3; g5++) {
              var V3 = i8.componentIds[r11[c7++]];
              H2 = i8.components[V3];
              var j2 = r11[c7++];
              H2.huffmanTableDC = p9[j2 >> 4], H2.huffmanTableAC = m8[15 & j2], J.push(H2);
            }
            var B3 = r11[c7++], N2 = r11[c7++], G2 = r11[c7++], O4 = v6(r11, c7, i8, J, s10, B3, N2, G2 >> 4, 15 & G2);
            c7 += O4;
            break;
          case 65535:
            255 !== r11[c7] && c7--;
            break;
          default:
            if (255 === r11[c7 - 3] && r11[c7 - 2] >= 192 && r11[c7 - 2] <= 254) {
              c7 -= 3;
              break;
            }
            throw new e8("unknown marker " + k4.toString(16));
        }
        k4 = o5();
      }
      for (this.width = i8.samplesPerLine, this.height = i8.scanLines, this.jfif = f7, this.eof = c7, this.adobe = l9, this.components = [], g5 = 0; g5 < i8.components.length; g5++) {
        var Q = h7[(H2 = i8.components[g5]).quantizationId];
        Q && (H2.quantizationTable = Q), this.components.push({ output: d4(i8, H2), scaleX: H2.h / i8.maxH, scaleY: H2.v / i8.maxV, blocksPerLine: H2.blocksPerLine, blocksPerColumn: H2.blocksPerColumn });
      }
      this.numComponents = this.components.length;
    }, _getLinearizedBlockData: function(e9, n10) {
      var r11, o5, a13, t8, i8, s10, c7, f7, l9, u9, h7, v7 = this.width / e9, m8 = this.height / n10, d5 = 0, b5 = this.components.length, p9 = e9 * n10 * b5, k4 = new Uint8ClampedArray(p9), g5 = new Uint32Array(e9), C4 = 4294967288;
      for (c7 = 0; c7 < b5; c7++) {
        for (o5 = (r11 = this.components[c7]).scaleX * v7, a13 = r11.scaleY * m8, d5 = c7, h7 = r11.output, t8 = r11.blocksPerLine + 1 << 3, i8 = 0; i8 < e9; i8++)
          f7 = 0 | i8 * o5, g5[i8] = (f7 & C4) << 3 | 7 & f7;
        for (s10 = 0; s10 < n10; s10++)
          for (u9 = t8 * ((f7 = 0 | s10 * a13) & C4) | (7 & f7) << 3, i8 = 0; i8 < e9; i8++)
            k4[d5] = h7[u9 + g5[i8]], d5 += b5;
      }
      var w5 = this.decodeTransform;
      if (w5)
        for (c7 = 0; c7 < p9; )
          for (f7 = 0, l9 = 0; f7 < b5; f7++, c7++, l9 += 2)
            k4[c7] = (k4[c7] * w5[l9] >> 8) + w5[l9 + 1];
      return k4;
    }, _isColorConversionNeeded: function() {
      return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this.colorTransform : 1 === this.colorTransform;
    }, _convertYccToRgb: function(e9) {
      for (var n10, r11, o5, a13 = 0, t8 = e9.length; a13 < t8; a13 += 3)
        n10 = e9[a13], r11 = e9[a13 + 1], o5 = e9[a13 + 2], e9[a13] = n10 - 179.456 + 1.402 * o5, e9[a13 + 1] = n10 + 135.459 - 0.344 * r11 - 0.714 * o5, e9[a13 + 2] = n10 - 226.816 + 1.772 * r11;
      return e9;
    }, _convertYcckToRgb: function(e9) {
      for (var n10, r11, o5, a13, t8 = 0, i8 = 0, s10 = e9.length; i8 < s10; i8 += 4)
        n10 = e9[i8], r11 = e9[i8 + 1], o5 = e9[i8 + 2], a13 = e9[i8 + 3], e9[t8++] = r11 * (-660635669420364e-19 * r11 + 437130475926232e-18 * o5 - 54080610064599e-18 * n10 + 48449797120281e-17 * a13 - 0.154362151871126) - 122.67195406894 + o5 * (-957964378445773e-18 * o5 + 817076911346625e-18 * n10 - 0.00477271405408747 * a13 + 1.53380253221734) + n10 * (961250184130688e-18 * n10 - 0.00266257332283933 * a13 + 0.48357088451265) + a13 * (-336197177618394e-18 * a13 + 0.484791561490776), e9[t8++] = 107.268039397724 + r11 * (219927104525741e-19 * r11 - 640992018297945e-18 * o5 + 659397001245577e-18 * n10 + 426105652938837e-18 * a13 - 0.176491792462875) + o5 * (-778269941513683e-18 * o5 + 0.00130872261408275 * n10 + 770482631801132e-18 * a13 - 0.151051492775562) + n10 * (0.00126935368114843 * n10 - 0.00265090189010898 * a13 + 0.25802910206845) + a13 * (-318913117588328e-18 * a13 - 0.213742400323665), e9[t8++] = r11 * (-570115196973677e-18 * r11 - 263409051004589e-19 * o5 + 0.0020741088115012 * n10 - 0.00288260236853442 * a13 + 0.814272968359295) - 20.810012546947 + o5 * (-153496057440975e-19 * o5 - 132689043961446e-18 * n10 + 560833691242812e-18 * a13 - 0.195152027534049) + n10 * (0.00174418132927582 * n10 - 0.00255243321439347 * a13 + 0.116935020465145) + a13 * (-343531996510555e-18 * a13 + 0.24165260232407);
      return e9;
    }, _convertYcckToCmyk: function(e9) {
      for (var n10, r11, o5, a13 = 0, t8 = e9.length; a13 < t8; a13 += 4)
        n10 = e9[a13], r11 = e9[a13 + 1], o5 = e9[a13 + 2], e9[a13] = 434.456 - n10 - 1.402 * o5, e9[a13 + 1] = 119.541 - n10 + 0.344 * r11 + 0.714 * o5, e9[a13 + 2] = 481.816 - n10 - 1.772 * r11;
      return e9;
    }, _convertCmykToRgb: function(e9) {
      for (var n10, r11, o5, a13, t8 = 0, i8 = 1 / 255, s10 = 0, c7 = e9.length; s10 < c7; s10 += 4)
        n10 = e9[s10] * i8, r11 = e9[s10 + 1] * i8, o5 = e9[s10 + 2] * i8, a13 = e9[s10 + 3] * i8, e9[t8++] = 255 + n10 * (-4.387332384609988 * n10 + 54.48615194189176 * r11 + 18.82290502165302 * o5 + 212.25662451639585 * a13 - 285.2331026137004) + r11 * (1.7149763477362134 * r11 - 5.6096736904047315 * o5 - 17.873870861415444 * a13 - 5.497006427196366) + o5 * (-2.5217340131683033 * o5 - 21.248923337353073 * a13 + 17.5119270841813) - a13 * (21.86122147463605 * a13 + 189.48180835922747), e9[t8++] = 255 + n10 * (8.841041422036149 * n10 + 60.118027045597366 * r11 + 6.871425592049007 * o5 + 31.159100130055922 * a13 - 79.2970844816548) + r11 * (-15.310361306967817 * r11 + 17.575251261109482 * o5 + 131.35250912493976 * a13 - 190.9453302588951) + o5 * (4.444339102852739 * o5 + 9.8632861493405 * a13 - 24.86741582555878) - a13 * (20.737325471181034 * a13 + 187.80453709719578), e9[t8++] = 255 + n10 * (0.8842522430003296 * n10 + 8.078677503112928 * r11 + 30.89978309703729 * o5 - 0.23883238689178934 * a13 - 14.183576799673286) + r11 * (10.49593273432072 * r11 + 63.02378494754052 * o5 + 50.606957656360734 * a13 - 112.23884253719248) + o5 * (0.03296041114873217 * o5 + 115.60384449646641 * a13 - 193.58209356861505) - a13 * (22.33816807309886 * a13 + 180.12613974708367);
      return e9;
    }, getData: function(n10, r11, o5) {
      if (this.numComponents > 4)
        throw new e8("Unsupported color mode");
      var a13 = this._getLinearizedBlockData(n10, r11);
      if (1 === this.numComponents && o5) {
        for (var t8 = a13.length, i8 = new Uint8ClampedArray(3 * t8), s10 = 0, c7 = 0; c7 < t8; c7++) {
          var f7 = a13[c7];
          i8[s10++] = f7, i8[s10++] = f7, i8[s10++] = f7;
        }
        return i8;
      }
      if (3 === this.numComponents && this._isColorConversionNeeded())
        return this._convertYccToRgb(a13);
      if (4 === this.numComponents) {
        if (this._isColorConversionNeeded())
          return o5 ? this._convertYcckToRgb(a13) : this._convertYcckToCmyk(a13);
        if (o5)
          return this._convertCmykToRgb(a13);
      }
      return a13;
    } }, l8;
  }();
}, void 0 !== (r3 = n()) && (e4.exports = r3);

// node_modules/@arcgis/core/layers/support/rasterFormats/JpgPlus.js
var r4 = class {
  static decode(r10, n9 = false) {
    const s9 = new Uint8Array(r10), o4 = new o();
    o4.parse(s9);
    const { width: a12, height: i7, numComponents: f6, eof: h6 } = o4, l8 = o4.getData(a12, i7, true), c6 = a12 * i7;
    let u8, g5 = null, p9 = 0, w5 = 0, m7 = 0;
    if (!n9 && h6 < s9.length - 1)
      try {
        const t7 = new i2(s9.subarray(h6)).getBytes();
        g5 = new Uint8Array(c6);
        let r11 = 0;
        for (p9 = 0; p9 < t7.length; p9++)
          for (m7 = 7; m7 >= 0; m7--)
            g5[r11++] = t7[p9] >> m7 & 1;
      } catch {
      }
    if (1 === f6 && l8.length === a12 * i7) {
      const t7 = new Uint8Array(l8.buffer);
      u8 = [t7, t7, t7];
    } else {
      for (u8 = [], p9 = 0; p9 < 3; p9++)
        u8.push(new Uint8Array(c6));
      for (m7 = 0, w5 = 0; w5 < c6; w5++)
        for (p9 = 0; p9 < 3; p9++)
          u8[p9][w5] = l8[m7++];
    }
    return { width: a12, height: i7, pixels: u8, mask: g5 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/Lerc.js
var t3 = [{ pixelType: "S8", size: 1, ctor: Int8Array, range: [-128, 127] }, { pixelType: "U8", size: 1, ctor: Uint8Array, range: [0, 255] }, { pixelType: "S16", size: 2, ctor: Int16Array, range: [-32768, 32767] }, { pixelType: "U16", size: 2, ctor: Uint16Array, range: [0, 65536] }, { pixelType: "S32", size: 4, ctor: Int32Array, range: [-2147483648, 2147483647] }, { pixelType: "U32", size: 4, ctor: Uint32Array, range: [0, 4294967296] }, { pixelType: "F32", size: 4, ctor: Float32Array, range: [-34027999387901484e22, 34027999387901484e22] }, { pixelType: "F64", size: 8, ctor: Float64Array, range: [-17976931348623157e292, 17976931348623157e292] }];
var n2 = null;
var r5 = false;
function a6() {
  return n2 || (n2 = import("./lerc-wasm-K3LPHFVC.js").then((e8) => e8.l).then(({ default: t7 }) => t7({ locateFile: (t8) => a3(`esri/layers/support/rasterFormats/${t8}`) })).then((e8) => {
    u3(e8), r5 = true;
  }), n2);
}
var l3 = { getBlobInfo: null, decode: null };
function s6(e8) {
  return 16 + (e8 >> 3 << 3);
}
function i4(e8, t7, n9) {
  n9.set(e8.slice(t7, t7 + n9.length));
}
function u3(e8) {
  const { _malloc: n9, _free: r10, _lerc_getBlobInfo: a12, _lerc_getDataRanges: o4, _lerc_decode_4D: u8, asm: f6 } = e8;
  let c6;
  const h6 = Object.values(f6).find((t7) => t7 && "buffer" in t7 && t7.buffer === e8.HEAPU8.buffer), y7 = (e9) => {
    const t7 = e9.map((e10) => s6(e10)), r11 = t7.reduce((e10, t8) => e10 + t8), a13 = n9(r11);
    c6 = new Uint8Array(h6.buffer);
    let o5 = t7[0];
    t7[0] = a13;
    for (let n10 = 1; n10 < t7.length; n10++) {
      const e10 = t7[n10];
      t7[n10] = t7[n10 - 1] + o5, o5 = e10;
    }
    return t7;
  };
  l3.getBlobInfo = (e9) => {
    const t7 = 12, n10 = 3, l8 = new Uint8Array(4 * t7), s9 = new Uint8Array(8 * n10), [u9, f7, p9] = y7([e9.length, l8.length, s9.length]);
    c6.set(e9, u9), c6.set(l8, f7), c6.set(s9, p9);
    let g5 = a12(u9, e9.length, f7, p9, t7, n10);
    if (g5)
      throw r10(u9), new Error(`lerc-getBlobInfo: error code is ${g5}`);
    c6 = new Uint8Array(h6.buffer), i4(c6, f7, l8), i4(c6, p9, s9);
    const d4 = new Uint32Array(l8.buffer), b4 = new Float64Array(s9.buffer), [w5, A3, , m7, U3, x4, C4, V3, T4, D4, z2] = d4, F2 = { version: w5, depthCount: D4, width: m7, height: U3, validPixelCount: C4, bandCount: x4, blobSize: V3, maskCount: T4, dataType: A3, minValue: b4[0], maxValue: b4[1], maxZerror: b4[2], statistics: [], bandCountWithNoData: z2 };
    if (z2)
      return F2;
    if (1 === D4 && 1 === x4)
      return r10(u9), F2.statistics.push({ minValue: b4[0], maxValue: b4[1] }), F2;
    const I3 = D4 * x4 * 8, _3 = new Uint8Array(I3), k4 = new Uint8Array(I3);
    let B3 = u9, S4 = 0, v6 = 0, E3 = false;
    if (c6.byteLength < u9 + 2 * I3 ? (r10(u9), E3 = true, [B3, S4, v6] = y7([e9.length, I3, I3]), c6.set(e9, B3)) : [S4, v6] = y7([I3, I3]), c6.set(_3, S4), c6.set(k4, v6), g5 = o4(B3, e9.length, D4, x4, S4, v6), g5)
      throw r10(B3), E3 || r10(S4), new Error(`lerc-getDataRanges: error code is ${g5}`);
    c6 = new Uint8Array(h6.buffer), i4(c6, S4, _3), i4(c6, v6, k4);
    const O4 = new Float64Array(_3.buffer), $ = new Float64Array(k4.buffer), j2 = F2.statistics;
    for (let r11 = 0; r11 < x4; r11++)
      if (D4 > 1) {
        const e10 = O4.slice(r11 * D4, (r11 + 1) * D4), t8 = $.slice(r11 * D4, (r11 + 1) * D4), n11 = Math.min.apply(null, e10), a13 = Math.max.apply(null, t8);
        j2.push({ minValue: n11, maxValue: a13, depthStats: { minValues: e10, maxValues: t8 } });
      } else
        j2.push({ minValue: O4[r11], maxValue: $[r11] });
    return r10(B3), E3 || r10(S4), F2;
  }, l3.decode = (e9, n10) => {
    const { maskCount: a13, depthCount: o5, bandCount: l8, width: s9, height: f7, dataType: p9, bandCountWithNoData: g5 } = n10, d4 = t3[p9], b4 = s9 * f7, w5 = new Uint8Array(b4 * l8), A3 = b4 * o5 * l8 * d4.size, m7 = new Uint8Array(A3), U3 = new Uint8Array(l8), x4 = new Uint8Array(8 * l8), [C4, V3, T4, D4, z2] = y7([e9.length, w5.length, m7.length, U3.length, x4.length]);
    c6.set(e9, C4), c6.set(w5, V3), c6.set(m7, T4), c6.set(U3, D4), c6.set(x4, z2);
    const F2 = u8(C4, e9.length, a13, V3, o5, s9, f7, l8, p9, T4, D4, z2);
    if (F2)
      throw r10(C4), new Error(`lerc-decode: error code is ${F2}`);
    c6 = new Uint8Array(h6.buffer), i4(c6, T4, m7), i4(c6, V3, w5);
    let I3 = null;
    if (g5) {
      i4(c6, D4, U3), i4(c6, z2, x4), I3 = [];
      const e10 = new Float64Array(x4.buffer);
      for (let t7 = 0; t7 < U3.length; t7++)
        I3.push(U3[t7] ? e10[t7] : null);
    }
    return r10(C4), { data: m7, maskData: w5, noDataValues: I3 };
  };
}
function f2(e8, t7, n9, r10, a12) {
  if (n9 < 2)
    return e8;
  const o4 = new r10(t7 * n9);
  if (a12)
    for (let l8 = 0, s9 = 0; l8 < t7; l8++)
      for (let r11 = 0, a13 = l8; r11 < n9; r11++, a13 += t7)
        o4[a13] = e8[s9++];
  else
    for (let l8 = 0, s9 = 0; l8 < t7; l8++)
      for (let r11 = 0, a13 = l8; r11 < n9; r11++, a13 += t7)
        o4[s9++] = e8[a13];
  return o4;
}
function c2(e8, n9 = {}) {
  const r10 = n9.inputOffset ?? 0, a12 = e8 instanceof Uint8Array ? e8.subarray(r10) : new Uint8Array(e8, r10), o4 = l3.getBlobInfo(a12), { data: s9, maskData: i7, noDataValues: u8 } = l3.decode(a12, o4), { width: c6, height: h6, bandCount: y7, depthCount: p9, dataType: g5, maskCount: d4, statistics: b4 } = o4, w5 = t3[g5], A3 = new w5.ctor(s9.buffer), m7 = [], U3 = [], x4 = c6 * h6, C4 = x4 * p9;
  for (let t7 = 0; t7 < y7; t7++) {
    const e9 = A3.subarray(t7 * C4, (t7 + 1) * C4);
    if (n9.returnInterleaved)
      m7.push(e9);
    else {
      const t8 = f2(e9, x4, p9, w5.ctor, true);
      m7.push(t8);
    }
    U3.push(i7.subarray(t7 * C4, (t7 + 1) * C4));
  }
  const V3 = 0 === d4 ? null : 1 === d4 ? U3[0] : new Uint8Array(x4);
  if (d4 > 1) {
    V3.set(U3[0]);
    for (let e9 = 1; e9 < U3.length; e9++) {
      const t7 = U3[e9];
      for (let e10 = 0; e10 < x4; e10++)
        V3[e10] = V3[e10] & t7[e10];
    }
  }
  const { noDataValue: T4 } = n9, D4 = null != T4 && w5.range[0] <= T4 && w5.range[1] >= T4;
  if (d4 > 0 && D4)
    for (let t7 = 0; t7 < y7; t7++) {
      const e9 = m7[t7], n10 = U3[t7] || V3;
      for (let t8 = 0; t8 < x4; t8++)
        0 === n10[t8] && (e9[t8] = T4);
    }
  const z2 = d4 === y7 && y7 > 1 ? U3 : null, { pixelType: F2 } = w5;
  return { width: c6, height: h6, bandCount: y7, pixelType: F2, depthCount: p9, statistics: b4, pixels: m7, mask: V3, bandMasks: z2, noDataValues: u8 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Lzw.js
function e5(e8, n9, t7, r10 = true) {
  if (n9 % 4 != 0 || t7 % 4 != 0) {
    const i7 = new ArrayBuffer(4 * Math.ceil(t7 / 4)), o4 = new Uint8Array(i7), l8 = new Uint8Array(e8, n9, t7);
    if (r10)
      for (let e9 = 0; e9 < o4.length; e9 += 4)
        o4[e9] = l8[e9 + 3], o4[e9 + 1] = l8[e9 + 2], o4[e9 + 2] = l8[e9 + 1], o4[e9 + 3] = l8[e9];
    else
      o4.set(l8);
    return new Uint32Array(o4.buffer);
  }
  if (r10) {
    const r11 = new Uint8Array(e8, n9, t7), i7 = new Uint8Array(r11.length);
    for (let e9 = 0; e9 < i7.length; e9 += 4)
      i7[e9] = r11[e9 + 3], i7[e9 + 1] = r11[e9 + 2], i7[e9 + 2] = r11[e9 + 1], i7[e9 + 3] = r11[e9];
    return new Uint32Array(i7.buffer);
  }
  return new Uint32Array(e8, n9, t7 / 4);
}
function n3() {
  const e8 = [];
  for (let n9 = 0; n9 <= 257; n9++)
    e8[n9] = [n9];
  return e8;
}
function t4(e8, n9) {
  for (let t7 = 0; t7 < n9.length; t7++)
    e8.push(n9[t7]);
}
var r6 = /* @__PURE__ */ new Set();
function i5(i7, o4, l8, f6 = true) {
  const s9 = e5(i7, o4, l8, f6);
  let a12 = 9, c6 = n3(), u8 = 32, h6 = c6.length, d4 = [], w5 = 1, g5 = s9[0], y7 = 0;
  const A3 = s9.length, U3 = 8 * (4 * A3 - l8), p9 = [];
  for (; null != g5; ) {
    if (u8 >= a12)
      u8 -= a12, y7 = g5 >>> 32 - a12, g5 <<= a12;
    else {
      y7 = g5 >>> 32 - u8, g5 = s9[w5++];
      const e9 = a12 - u8;
      u8 = 32 - e9, y7 = (y7 << e9) + (g5 >>> u8), g5 <<= e9;
    }
    if (257 === y7)
      break;
    if (256 === y7) {
      a12 = 9, c6 = n3(), h6 = c6.length, d4 = [];
      continue;
    }
    const e8 = c6[y7];
    if (null == e8) {
      if (y7 > c6.length)
        throw new Error("data integrity issue: code does not exist on code page");
      d4.push(d4[0]), c6[h6++] = d4.slice(), t4(p9, d4);
    } else
      t4(p9, e8), d4.push(e8[0]), d4.length > 1 && (c6[h6++] = d4.slice()), d4 = e8.slice();
    if (r6.has(h6) && a12++, 0 === u8 && (g5 = s9[w5++], u8 = 32), w5 > A3 || w5 === A3 && u8 <= U3)
      break;
  }
  return new Uint8Array(p9);
}
r6.add(511), r6.add(1023), r6.add(2047), r6.add(4095), r6.add(8191);

// node_modules/@arcgis/core/layers/support/rasterFormats/Raw.js
var e6 = (e8, r10) => {
  const a12 = r10.width * r10.height, n9 = r10.pixelType;
  return Math.floor(e8.byteLength / (a12 * t5(n9)));
};
var t5 = (e8) => {
  let t7 = 1;
  switch (e8) {
    case Uint8Array:
    case Int8Array:
      t7 = 1;
      break;
    case Uint16Array:
    case Int16Array:
      t7 = 2;
      break;
    case Uint32Array:
    case Int32Array:
    case Float32Array:
      t7 = 4;
      break;
    case Float64Array:
      t7 = 8;
  }
  return t7;
};
var r7 = (e8, t7) => {
  if (8 * e8.byteLength < t7)
    return null;
  const r10 = new Uint8Array(e8, 0, Math.ceil(t7 / 8)), a12 = new Uint8Array(t7);
  let n9 = 0, s9 = 0, l8 = 0, i7 = 0;
  for (l8 = 0; l8 < r10.length - 1; l8++)
    for (s9 = r10[l8], i7 = 7; i7 >= 0; i7--)
      a12[n9++] = s9 >> i7 & 1;
  for (i7 = 7; n9 < t7 - 1; )
    s9 = r10[r10.length - 1], a12[n9++] = s9 >> i7 & 1, i7--;
  return a12;
};
var a7 = class {
  static decode(a12, n9) {
    const s9 = n9.pixelType, l8 = [], i7 = n9.width * n9.height, h6 = e6(a12, n9), { bandIds: c6, format: y7 } = n9, o4 = c6 && c6.length || e6(a12, n9), b4 = a12.byteLength - a12.byteLength % (i7 * t5(s9)), f6 = new s9(a12, 0, i7 * h6);
    let u8, g5, A3, p9, d4 = null;
    if ("bip" === y7)
      for (u8 = 0; u8 < o4; u8++) {
        for (A3 = new s9(i7), p9 = c6 ? c6[u8] : u8, g5 = 0; g5 < i7; g5++)
          A3[g5] = f6[g5 * h6 + p9];
        l8.push(A3);
      }
    else if ("bsq" === y7)
      for (u8 = 0; u8 < o4; u8++)
        p9 = c6 ? c6[u8] : u8, l8.push(f6.subarray(p9 * i7, (p9 + 1) * i7));
    return b4 < a12.byteLength - 1 && (d4 = r7(a12.slice(b4), i7)), { pixels: l8, mask: d4 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js
function r8(r10, t7) {
  let n9 = 0, o4 = "", e8 = 0, f6 = 0;
  const c6 = r10.length;
  for (; n9 < c6; )
    f6 = r10[n9++], e8 = f6 >> 4, e8 < 8 ? e8 = 1 : 15 === e8 ? (e8 = 4, f6 = (7 & f6) << 18 | (63 & r10[n9++]) << 12 | (63 & r10[n9++]) << 6 | 63 & r10[n9++]) : 14 === e8 ? (e8 = 3, f6 = (15 & f6) << 12 | (63 & r10[n9++]) << 6 | 63 & r10[n9++]) : (e8 = 2, f6 = (31 & f6) << 6 | 63 & r10[n9++]), (0 !== f6 || t7) && (o4 += String.fromCharCode(f6));
  return o4;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffTags.js
var e7 = (() => {
  const e8 = [];
  return e8[254] = "NEWSUBFILETYPE", e8[255] = "SUBFILETYPE", e8[256] = "IMAGEWIDTH", e8[257] = "IMAGELENGTH", e8[258] = "BITSPERSAMPLE", e8[259] = "COMPRESSION", e8[262] = "PHOTOMETRICINTERPRETATION", e8[263] = "THRESHHOLDING", e8[264] = "CELLWIDTH", e8[265] = "CELLLENGTH", e8[266] = "FILLORDER", e8[269] = "DOCUMENTNAME", e8[270] = "IMAGEDESCRIPTION", e8[271] = "MAKE", e8[272] = "MODEL", e8[273] = "STRIPOFFSETS", e8[274] = "ORIENTATION", e8[277] = "SAMPLESPERPIXEL", e8[278] = "ROWSPERSTRIP", e8[279] = "STRIPBYTECOUNTS", e8[280] = "MINSAMPLEVALUE", e8[281] = "MAXSAMPLEVALUE", e8[282] = "XRESOLUTION", e8[283] = "YRESOLUTION", e8[284] = "PLANARCONFIGURATION", e8[285] = "PAGENAME", e8[286] = "XPOSITION", e8[287] = "YPOSITION", e8[288] = "FREEOFFSETS", e8[289] = "FREEBYTECOUNTS", e8[290] = "GRAYRESPONSEUNIT", e8[291] = "GRAYRESPONSECURVE", e8[292] = "T4OPTIONS", e8[293] = "T6OPTIONS", e8[296] = "RESOLUTIONUNIT", e8[297] = "PAGENUMBER", e8[300] = "COLORRESPONSEUNIT", e8[301] = "TRANSFERFUNCTION", e8[305] = "SOFTWARE", e8[306] = "DATETIME", e8[315] = "ARTIST", e8[316] = "HOSTCOMPUTER", e8[317] = "PREDICTOR", e8[318] = "WHITEPOINT", e8[319] = "PRIMARYCHROMATICITIES", e8[320] = "COLORMAP", e8[321] = "HALFTONEHINTS", e8[322] = "TILEWIDTH", e8[323] = "TILELENGTH", e8[324] = "TILEOFFSETS", e8[325] = "TILEBYTECOUNTS", e8[326] = "BADFAXLINES", e8[327] = "CLEANFAXDATA", e8[328] = "CONSECUTIVEBADFAXLINES", e8[330] = "SUBIFD", e8[332] = "INKSET", e8[333] = "INKNAMES", e8[334] = "NUMBEROFINKS", e8[336] = "DOTRANGE", e8[337] = "TARGETPRINTER", e8[338] = "EXTRASAMPLES", e8[339] = "SAMPLEFORMAT", e8[340] = "SMINSAMPLEVALUE", e8[341] = "SMAXSAMPLEVALUE", e8[342] = "TRANSFERRANGE", e8[347] = "JPEGTABLES", e8[512] = "JPEGPROC", e8[513] = "JPEGIFOFFSET", e8[514] = "JPEGIFBYTECOUNT", e8[515] = "JPEGRESTARTINTERVAL", e8[517] = "JPEGLOSSLESSPREDICTORS", e8[518] = "JPEGPOINTTRANSFORM", e8[519] = "JPEGQTABLES", e8[520] = "JPEGDCTABLES", e8[521] = "JPEGACTABLES", e8[529] = "YCBCRCOEFFICIENTS", e8[530] = "YCBCRSUBSAMPLING", e8[531] = "YCBCRPOSITIONING", e8[532] = "REFERENCEBLACKWHITE", e8[700] = "XMP", e8[33550] = "GEOPIXELSCALE", e8[33922] = "GEOTIEPOINTS", e8[33432] = "COPYRIGHT", e8[42112] = "GDAL_METADATA", e8[42113] = "GDAL_NODATA", e8[50844] = "RPCCOEFFICIENT", e8[34264] = "GEOTRANSMATRIX", e8[34735] = "GEOKEYDIRECTORY", e8[34736] = "GEODOUBLEPARAMS", e8[34737] = "GEOASCIIPARAMS", e8[34665] = "EXIFIFD", e8[34853] = "GPSIFD", e8[40965] = "INTEROPERABILITYIFD", e8;
})();
var i6 = (() => {
  const i7 = e7.slice();
  return i7[36864] = "ExifVersion", i7[40960] = "FlashpixVersion", i7[40961] = "ColorSpace", i7[42240] = "Gamma", i7[37121] = "ComponentsConfiguration", i7[37122] = "CompressedBitsPerPixel", i7[40962] = "PixelXDimension", i7[40963] = "PixelYDimension", i7[37500] = "MakerNote", i7[37510] = "UserComment", i7[40964] = "RelatedSoundFile", i7[36867] = "DateTimeOriginal", i7[36868] = "DateTimeDigitized", i7[36880] = "OffsetTime", i7[36881] = "OffsetTimeOriginal", i7[36882] = "OffsetTimeDigitized", i7[37520] = "SubSecTime", i7[37521] = "SubSecTimeOriginal", i7[37522] = "SubSecTimeDigitized", i7[37888] = "Temperature", i7[37889] = "Humidity", i7[37890] = "Pressure", i7[37891] = "WaterDepth", i7[37892] = "Acceleration", i7[37893] = "CameraElevationAngle", i7[42016] = "ImageUniqueID", i7[42032] = "CameraOwnerName", i7[42033] = "BodySerialNumber", i7[42034] = "LensSpecification", i7[42035] = "LensMake", i7[42036] = "LensModel", i7[42037] = "LensSerialNumber", i7[33434] = "ExposureTime", i7[33437] = "FNumber", i7[34850] = "ExposureProgram", i7[34852] = "SpectralSensitivity", i7[34855] = "PhotographicSensitivity", i7[34856] = "OECF", i7[34864] = "SensitivityType", i7[34865] = "StandardOutputSensitivity", i7[34866] = "RecommendedExposureIndex", i7[34867] = "ISOSpeed", i7[34868] = "ISOSpeedLatitudeyyy", i7[34869] = "ISOSpeedLatitudezzz", i7[37377] = "ShutterSpeedValue", i7[37378] = "ApertureValue", i7[37379] = "BrightnessValue", i7[37380] = "ExposureBiasValue", i7[37381] = "MaxApertureValue", i7[37382] = "SubjectDistance", i7[37383] = "MeteringMode", i7[37384] = "LightSource", i7[37385] = "Flash", i7[37386] = "FocalLength", i7[37396] = "SubjectArea", i7[41483] = "FlashEnergy", i7[41484] = "SpatialFrequencyResponse", i7[41486] = "FocalPlaneXResolution", i7[41487] = "FocalPlaneYResolution", i7[41488] = "FocalPlaneResolutionUnit", i7[41492] = "SubjectLocation", i7[41493] = "ExposureIndex", i7[41495] = "SensingMethod", i7[41728] = "FileSource", i7[41729] = "SceneType", i7[41730] = "CFAPattern", i7[41985] = "CustomRendered", i7[41986] = "ExposureMode", i7[41987] = "WhiteBalance", i7[41988] = "DigitalZoomRatio", i7[41989] = "FocalLengthIn35mmFilm", i7[41990] = "SceneCaptureType", i7[41991] = "GainControl", i7[41992] = "Contrast", i7[41993] = "Saturation", i7[41994] = "Sharpness", i7[41995] = "DeviceSettingDescription", i7[41996] = "SubjectDistanceRange", i7;
})();
var t6 = ["GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "GPSHPositioningError"];
var o2 = (() => {
  const e8 = [];
  return e8[1024] = "GTModelTypeGeoKey", e8[1025] = "GTRasterTypeGeoKey", e8[1026] = "GTCitationGeoKey", e8[2048] = "GeographicTypeGeoKey", e8[2049] = "GeogCitationGeoKey", e8[2050] = "GeogGeodeticDatumGeoKey", e8[2051] = "GeogPrimeMeridianGeoKey", e8[2052] = "GeogLinearUnitsGeoKey", e8[2053] = "GeogLinearUnitSizeGeoKey", e8[2054] = "GeogAngularUnitsGeoKey", e8[2055] = "GeogAngularUnitSizeGeoKey", e8[2056] = "GeogEllipsoidGeoKey", e8[2057] = "GeogSemiMajorAxisGeoKey", e8[2058] = "GeogSemiMinorAxisGeoKey", e8[2059] = "GeogInvFlatteningGeoKey", e8[2061] = "GeogPrimeMeridianLongGeoKey", e8[2060] = "GeogAzimuthUnitsGeoKey", e8[3072] = "ProjectedCSTypeGeoKey", e8[3073] = "PCSCitationGeoKey", e8[3074] = "ProjectionGeoKey", e8[3075] = "ProjCoordTransGeoKey", e8[3076] = "ProjLinearUnitsGeoKey", e8[3077] = "ProjLinearUnitSizeGeoKey", e8[3078] = "ProjStdParallel1GeoKey", e8[3079] = "ProjStdParallel2GeoKey", e8[3080] = "ProjNatOriginLongGeoKey", e8[3081] = "ProjNatOriginLatGeoKey", e8[3082] = "ProjFalseEastingGeoKey", e8[3083] = "ProjFalseNorthingGeoKey", e8[3084] = "ProjFalseOriginLongGeoKey", e8[3085] = "ProjFalseOriginLatGeoKey", e8[3086] = "ProjFalseOriginEastingGeoKey", e8[3087] = "ProjFalseOriginNorthingGeoKey", e8[3088] = "ProjCenterLongGeoKey", e8[3090] = "ProjCenterEastingGeoKey", e8[3091] = "ProjCenterNorthingGeoKey", e8[3092] = "ProjScaleAtNatOriginGeoKey", e8[3093] = "ProjScaleAtCenterGeoKey", e8[3094] = "ProjAzimuthAngleGeoKey", e8[3095] = "ProjStraightVertPoleLongGeoKey", e8[4096] = "VerticalCSTypeGeoKey", e8[4097] = "VerticalCitationGeoKey", e8[4098] = "VerticalDatumGeoKey", e8[4099] = "VerticalUnitsGeoKey", e8;
})();
var S = (i7, t7) => {
  let o4 = (t7 || e7)[i7];
  return void 0 === o4 && (o4 = "unknown" + String(i7)), o4;
};
var E = /* @__PURE__ */ new Map();
E.set("EXIFIFD", i6), E.set("GPSIFD", t6);
var n4 = { TIFF_TAGS: e7, ifdTags: E, GEO_KEYS: o2, getTagName: S };

// node_modules/@arcgis/core/layers/support/rasterFormats/utils.js
var r9 = (() => {
  const r10 = new ArrayBuffer(4), n9 = new Uint8Array(r10);
  return new Uint32Array(r10)[0] = 1, 1 === n9[0];
})();

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js
var f3 = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, -1, -1, -1, 8, 8, 8];
var u4 = 4294967296;
var c3 = /* @__PURE__ */ new Set([1, 5, 6, 7, 8, 34712, 34887]);
function h2(e8, t7) {
  let n9 = "unknown";
  return 3 === e8 ? n9 = 64 === t7 ? "f64" : "f32" : 1 === e8 ? 1 === t7 ? n9 = "u1" : 2 === t7 ? n9 = "u2" : 4 === t7 ? n9 = "u4" : t7 <= 8 ? n9 = "u8" : t7 <= 16 ? n9 = "u16" : t7 <= 32 && (n9 = "u32") : 2 === e8 && (t7 <= 8 ? n9 = "s8" : t7 <= 16 ? n9 = "s16" : t7 <= 32 && (n9 = "s32")), n9;
}
function g(e8) {
  let t7 = null;
  switch (e8 ? e8.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      t7 = Uint8Array;
      break;
    case "u16":
      t7 = Uint16Array;
      break;
    case "u32":
      t7 = Uint32Array;
      break;
    case "s8":
      t7 = Int8Array;
      break;
    case "s16":
      t7 = Int16Array;
      break;
    case "s32":
      t7 = Int32Array;
      break;
    case "f64":
      t7 = Float64Array;
      break;
    default:
      t7 = Float32Array;
  }
  return t7;
}
function E2(e8, t7) {
  return { x: t7[0] * e8.x + t7[1] * e8.y + t7[2], y: t7[3] * e8.x + t7[4] * e8.y + t7[5] };
}
function I(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values;
}
function T(e8, t7) {
  var _a;
  return (_a = e8.get(t7)) == null ? void 0 : _a.values;
}
function p5(e8, t7) {
  var _a, _b;
  return (_b = (_a = e8.get(t7)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function d(e8, t7) {
  var _a, _b;
  return (_b = (_a = e8.get(t7)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
}
function w3(e8, t7, n9, a12 = 0, i7 = n4.TIFF_TAGS, s9 = 4) {
  const l8 = 8 === s9, o4 = l8 ? G(new DataView(e8, n9, 8), 0, t7) : new DataView(e8, n9, 2).getUint16(0, t7), f6 = 4 + 2 * s9, u8 = l8 ? 8 : 2, c6 = u8 + o4 * f6;
  if (n9 + c6 > e8.byteLength)
    return { success: false, ifd: null, nextIFD: null, requiredBufferSize: c6 };
  const h6 = n9 + c6 + 4 <= e8.byteLength ? C(new DataView(e8, n9 + c6, 8 === s9 ? 8 : 4), 0, t7, 8 === s9) : null, g5 = n9 + u8, E3 = /* @__PURE__ */ new Map();
  let I3, T4, p9, d4, w5, m7 = 0, S4 = 0;
  for (let y7 = 0; y7 < o4; y7++) {
    T4 = new DataView(e8, g5 + f6 * y7, f6), p9 = T4.getUint16(0, t7), w5 = T4.getUint16(2, t7), d4 = n4.getTagName(p9, i7);
    const n10 = [];
    2 === s9 ? (m7 = T4.getUint16(4, t7), S4 = T4.getUint16(6, t7)) : 4 === s9 ? (m7 = T4.getUint32(4, t7), S4 = T4.getUint32(8, t7)) : 8 === s9 && (m7 = C(T4, 4, t7, true), S4 = C(T4, 12, t7, true), n10.push(T4.getUint32(12, t7)), n10.push(T4.getUint32(16, t7))), I3 = { id: p9, type: w5, valueCount: m7, valueOffset: S4, valueOffsets: n10, values: null }, L(e8, t7, I3, a12, false, s9), E3.set(d4, I3);
  }
  return { success: true, ifd: E3, nextIFD: h6, requiredBufferSize: c6 };
}
var m3 = (e8, t7) => c2(e8, { inputOffset: t7 }).pixels[0];
function S2(e8, t7) {
  if (1 !== t7 && 2 !== t7 && 4 !== t7)
    return e8;
  const n9 = new Uint8Array(e8), a12 = 8 / t7, i7 = new Uint8Array(e8.byteLength * a12);
  let s9 = 0;
  const r10 = 2 ** t7 - 1;
  for (let l8 = 0; l8 < n9.length; l8++) {
    const e9 = n9[l8];
    for (let n10 = 0; n10 < a12; n10++)
      i7[s9++] = e9 << t7 * n10 >>> 8 - t7 & r10;
  }
  return i7.buffer;
}
function y3(e8, n9, a12) {
  const i7 = new o();
  i7.parse(e8), i7.colorTransform = 6 === a12 ? -1 : 0;
  const s9 = i7.getData(i7.width, i7.height, 1 !== n9);
  return new Uint8Array(s9.buffer);
}
function A(e8) {
  const t7 = new i2(e8).getBytes(), n9 = new ArrayBuffer(t7.length), a12 = new Uint8Array(n9);
  return a12.set(t7), a12;
}
async function M(e8, t7, a12, s9, r10) {
  const o4 = r9 === t7, f6 = d(a12, "BITSPERSAMPLE"), u8 = d(a12, "SAMPLESPERPIXEL"), c6 = d(a12, "PHOTOMETRICINTERPRETATION"), E3 = h2(d(a12, "SAMPLEFORMAT") ?? 1, f6), I3 = d(a12, "COMPRESSION") ?? 1, T4 = g(E3);
  let p9, w5, M3;
  if (34887 === I3)
    return await a6(), m3(e8, s9);
  if (1 === I3)
    p9 = e8.slice(s9, s9 + r10), w5 = new Uint8Array(p9);
  else if (8 === I3 || 32946 === I3)
    w5 = new Uint8Array(e8, s9, r10), w5 = A(w5), p9 = w5.buffer;
  else if (6 === I3)
    w5 = new Uint8Array(e8, s9, r10), w5 = y3(w5, u8, c6), p9 = w5.buffer;
  else if (7 === I3) {
    const t8 = a12.get("JPEGTABLES").values, n9 = t8.length - 2;
    w5 = new Uint8Array(n9 + r10 - 2);
    for (let e9 = 0; e9 < n9; e9++)
      w5[e9] = t8[e9];
    const i7 = new Uint8Array(e8, s9 + 2, r10 - 2);
    for (let e9 = 0; e9 < i7.length; e9++)
      w5[n9 + e9] = i7[e9];
    w5 = y3(w5, u8, c6), p9 = w5.buffer;
  } else {
    if (5 !== I3)
      throw new Error("tiff-decode: unsupport compression " + I3);
    w5 = i5(e8, s9, r10, t7), p9 = w5.buffer;
  }
  if (p9 = S2(p9, f6), "u8" === E3 || "s8" === E3 || o4)
    M3 = new T4(p9);
  else {
    p9 = new ArrayBuffer(w5.length);
    const e9 = new Uint8Array(p9);
    switch (E3) {
      case "u16":
      case "s16":
        for (let t8 = 0; t8 < w5.length; t8 += 2)
          e9[t8] = w5[t8 + 1], e9[t8 + 1] = w5[t8];
        break;
      case "u32":
      case "s32":
      case "f32":
        for (let t8 = 0; t8 < w5.length; t8 += 4)
          e9[t8] = w5[t8 + 3], e9[t8 + 1] = w5[t8 + 2], e9[t8 + 2] = w5[t8 + 1], e9[t8 + 3] = w5[t8];
    }
    M3 = new T4(p9);
  }
  return M3;
}
async function P(e8, t7, n9) {
  const a12 = T(n9, "TILEOFFSETS");
  if (void 0 === a12)
    return null;
  const i7 = T(n9, "TILEBYTECOUNTS"), { width: s9, height: r10, pixelType: l8, tileWidth: o4, tileHeight: f6 } = R([n9]), u8 = D(n9, t7), c6 = d(n9, "SAMPLESPERPIXEL") || t7.planes, h6 = s9 * r10, E3 = d(n9, "BITSPERSAMPLE"), I3 = 34887 === (d(n9, "COMPRESSION") ?? 1), p9 = g(l8), w5 = [];
  for (let g5 = 0; g5 < c6; g5++)
    w5.push(new p9(h6));
  let m7, S4, y7, A3, P3, O4, b4, x4, L3, N2, U3, k4, G2;
  const F2 = Math.ceil(s9 / o4);
  if (E3 % 8 == 0) {
    if (I3 && u8 && c6 > 1) {
      const l9 = Math.round(a12.length / c6);
      for (m7 = 0; m7 < l9; m7++) {
        O4 = Math.floor(m7 / F2) * f6, b4 = m7 % F2 * o4, x4 = O4 * s9 + b4;
        for (let l10 = 0; l10 < c6; l10++) {
          const u9 = m7 * c6 + l10;
          if (0 !== i7[u9])
            for (y7 = await M(e8, t7.littleEndian, n9, a12[u9], i7[u9]), N2 = 0, L3 = x4, k4 = Math.min(o4, s9 - b4), U3 = Math.min(f6, r10 - O4), G2 = w5[l10], A3 = 0; A3 < U3; A3++)
              for (L3 = x4 + A3 * s9, N2 = A3 * o4, P3 = 0; P3 < k4; P3++, L3++, N2++)
                G2[L3] = y7[N2];
        }
      }
    } else
      for (m7 = 0; m7 < a12.length; m7++)
        if (0 !== i7[m7])
          for (O4 = Math.floor(m7 / F2) * f6, b4 = m7 % F2 * o4, x4 = O4 * s9 + b4, y7 = await M(e8, t7.littleEndian, n9, a12[m7], i7[m7]), N2 = 0, L3 = x4, k4 = Math.min(o4, s9 - b4), U3 = Math.min(f6, r10 - O4), S4 = 0; S4 < c6; S4++)
            if (G2 = w5[S4], u8 || I3)
              for (A3 = 0; A3 < U3; A3++)
                for (L3 = x4 + A3 * s9, N2 = o4 * f6 * S4 + A3 * o4, P3 = 0; P3 < k4; P3++, L3++, N2++)
                  G2[L3] = y7[N2];
            else
              for (A3 = 0; A3 < U3; A3++)
                for (L3 = x4 + A3 * s9, N2 = A3 * o4 * c6 + S4, P3 = 0; P3 < k4; P3++, L3++, N2 += c6)
                  G2[L3] = y7[N2];
  }
  return { width: s9, height: r10, pixelType: l8, pixels: w5 };
}
var O = (e8, t7, n9) => {
  const a12 = r9 === t7.littleEndian, s9 = T(n9, "STRIPOFFSETS");
  if (void 0 === s9)
    return null;
  const { width: r10, height: o4, pixelType: f6 } = R([n9]), u8 = d(n9, "SAMPLESPERPIXEL") || t7.planes, c6 = d(n9, "PHOTOMETRICINTERPRETATION"), h6 = r10 * o4, E3 = d(n9, "BITSPERSAMPLE"), I3 = g(f6), p9 = new I3(h6 * u8), w5 = T(n9, "STRIPBYTECOUNTS"), m7 = d(n9, "ROWSPERSTRIP"), M3 = d(n9, "COMPRESSION") ?? 1;
  let P3, O4, b4, x4, L3, D4, N2, U3, k4, G2 = m7;
  if (E3 % 8 == 0)
    for (P3 = 0; P3 < s9.length; P3++) {
      if (L3 = P3 * (m7 * r10) * u8, G2 = (P3 + 1) * m7 > o4 ? o4 - P3 * m7 : m7, "u8" === f6 || "s8" === f6 || a12)
        8 === M3 || 32946 === M3 ? (N2 = new Uint8Array(e8, s9[P3], w5[P3]), N2 = A(N2), D4 = N2.buffer) : 6 === M3 ? (N2 = new Uint8Array(e8, s9[P3], w5[P3]), N2 = y3(N2, u8, c6), D4 = N2.buffer) : 5 === M3 ? (N2 = i5(e8, s9[P3], w5[P3], t7.littleEndian), D4 = N2.buffer) : (w5[P3] !== G2 * r10 * u8 * E3 / 8 && console.log("strip byte counts is different than expected"), D4 = e8.slice(s9[P3], s9[P3] + w5[P3])), D4 = S2(D4, E3), x4 = new I3(D4);
      else {
        switch (6 === M3 || 8 === M3 || 32946 === M3 ? (N2 = new Uint8Array(e8, s9[P3], w5[P3]), U3 = A(N2), D4 = U3.buffer) : (w5[P3] !== G2 * r10 * u8 * E3 / 8 && console.log("strip byte counts is different than expected"), D4 = new ArrayBuffer(w5[P3]), N2 = new Uint8Array(e8, s9[P3], w5[P3]), U3 = new Uint8Array(D4)), f6) {
          case "u16":
          case "s16":
            for (b4 = 0; b4 < N2.length; b4 += 2)
              U3[b4] = N2[b4 + 1], U3[b4 + 1] = N2[b4];
            break;
          case "u32":
          case "s32":
          case "f32":
            for (b4 = 0; b4 < N2.length; b4 += 4)
              U3[b4] = N2[b4 + 3], U3[b4 + 1] = N2[b4 + 2], U3[b4 + 2] = N2[b4 + 1], U3[b4 + 3] = N2[b4];
        }
        D4 = S2(D4, E3), x4 = new I3(D4);
      }
      p9.set(x4, L3);
    }
  const F2 = [];
  if (1 === u8)
    F2.push(p9);
  else
    for (P3 = 0; P3 < u8; P3++) {
      for (k4 = new I3(h6), O4 = 0; O4 < h6; O4++)
        k4[O4] = p9[O4 * u8 + P3];
      F2.push(k4);
    }
  return { width: r10, height: o4, pixelType: f6, pixels: F2 };
};
var b = (e8, t7, n9) => {
  if (!(e8 && e8.length > 0 && t7 && n9))
    return null;
  let a12, i7, s9;
  const r10 = e8[0].length, l8 = e8.length, o4 = new Uint8Array(r10);
  for (let f6 = 0; f6 < l8; f6++)
    if (a12 = e8[f6], i7 = t7[f6], s9 = n9[f6], 0 === f6)
      for (let e9 = 0; e9 < r10; e9++)
        o4[e9] = a12[e9] < i7 || a12[e9] > s9 ? 0 : 1;
    else
      for (let e9 = 0; e9 < r10; e9++)
        o4[e9] && (o4[e9] = a12[e9] < i7 || a12[e9] > s9 ? 0 : 1);
  return o4;
};
var x = (e8) => {
  if (!e8)
    return null;
  const t7 = e8.match(/<Item(.*?)Item>/gi);
  if (!t7 || 0 === t7.length)
    return null;
  const n9 = /* @__PURE__ */ new Map();
  let a12, i7, s9, r10, l8;
  for (let p9 = 0; p9 < t7.length; p9++)
    a12 = t7[p9], i7 = a12.slice("<Item ".length, a12.indexOf(">")), r10 = a12.indexOf("sample="), r10 > -1 && (l8 = a12.slice(r10 + 'sample="'.length, a12.indexOf('"', r10 + 'sample="'.length))), r10 = a12.indexOf("name="), r10 > -1 && (i7 = a12.slice(r10 + 'name="'.length, a12.indexOf('"', r10 + 'name="'.length))), i7 && (s9 = a12.slice(a12.indexOf(">") + 1, a12.indexOf("</Item>")).trim(), null != l8 ? n9.has(i7) ? n9.get(i7)[l8] = s9 : n9.set(i7, [s9]) : n9.set(i7, s9)), l8 = null;
  const o4 = n9.get("STATISTICS_MINIMUM"), f6 = n9.get("STATISTICS_MAXIMUM"), u8 = n9.get("STATISTICS_MEAN"), c6 = n9.get("STATISTICS_STDDEV");
  let h6 = null;
  if (o4 && f6) {
    h6 = [];
    for (let e9 = 0; e9 < o4.length; e9++)
      h6.push({ min: parseFloat(o4[e9]), max: parseFloat(f6[e9]), avg: u8 && parseFloat(u8[e9]), stddev: c6 && parseFloat(c6[e9]) });
  }
  const g5 = n9.get("BandName"), E3 = n9.get("WavelengthMin"), I3 = n9.get("WavelengthMax");
  let T4 = null;
  if (g5) {
    T4 = [];
    for (let e9 = 0; e9 < g5.length; e9++)
      T4.push({ BandName: g5[e9], WavelengthMin: E3 && parseFloat(E3[e9]), WavelengthMax: I3 && parseFloat(I3[e9]) });
  }
  return { statistics: h6, bandProperties: T4, dataType: n9.get("DataType"), rawMetadata: n9 };
};
function L(e8, t7, n9, a12 = 0, i7 = false, s9 = 4) {
  if (n9.values)
    return true;
  const r10 = n9.type, l8 = n9.valueCount;
  let o4 = n9.valueOffset, c6 = [];
  const h6 = f3[r10], g5 = 8 * h6, E3 = l8 * h6, I3 = l8 * f3[r10] * 8;
  let T4, p9;
  const d4 = 8 === s9 ? 64 : 32, w5 = n9.valueOffsets;
  if (I3 > d4) {
    if (E3 > (i7 ? e8.byteLength : e8 ? e8.byteLength - o4 + a12 : 0))
      return n9.offlineOffsetSize = [o4, E3], n9.values = null, false;
  }
  if (I3 <= d4) {
    if (!t7)
      if (d4 <= 32)
        o4 >>>= 32 - I3;
      else {
        const e9 = (w5 == null ? void 0 : w5.length) ? w5[0] : o4 >>> 0, t8 = (w5 == null ? void 0 : w5.length) ? w5[1] : Math.round((o4 - e9) / u4);
        I3 <= 32 ? (o4 = e9 >>> 32 - I3, w5[0] = o4) : (o4 = e9 * 2 ** (32 - I3) + (t8 >>> 32 - I3), w5[0] = e9, w5[1] = t8 >>> 32 - I3);
      }
    if (1 === l8 && g5 === d4)
      c6 = [o4];
    else if (64 === d4) {
      const e9 = (w5 == null ? void 0 : w5.length) ? w5[0] : o4 >>> 0, t8 = (w5 == null ? void 0 : w5.length) ? w5[1] : Math.round((o4 - e9) / u4);
      let n10 = e9, a13 = 32;
      for (p9 = 1; p9 <= l8; p9++) {
        const e10 = 32 - g5 * p9 % 32;
        if (a13 < g5) {
          const i8 = n10 << e10 >>> 32 - a13, s10 = t8 << 32 - a13 >>> 32 - a13;
          n10 = t8, c6.push(i8 + s10 * 2 ** (g5 - a13)), a13 -= 32 - (g5 - a13);
        } else
          c6.push(n10 << e10 >>> 32 - g5), a13 -= g5;
        0 === a13 && (a13 = 32, n10 = t8);
      }
    } else
      for (p9 = 1; p9 <= l8; p9++) {
        const e9 = 32 - g5 * p9;
        c6.push(o4 << e9 >>> 32 - g5);
      }
  } else {
    o4 -= a12, i7 && (o4 = 0);
    for (let n10 = o4; n10 < o4 + E3; n10 += h6) {
      switch (r10) {
        case 1:
        case 2:
        case 7:
          T4 = new DataView(e8, n10, 1).getUint8(0);
          break;
        case 3:
          T4 = new DataView(e8, n10, 2).getUint16(0, t7);
          break;
        case 4:
        case 13:
          T4 = new DataView(e8, n10, 4).getUint32(0, t7);
          break;
        case 5:
          T4 = new DataView(e8, n10, 4).getUint32(0, t7) / new DataView(e8, n10 + 4, 4).getUint32(0, t7);
          break;
        case 6:
          T4 = new DataView(e8, n10, 1).getInt8(0);
          break;
        case 8:
          T4 = new DataView(e8, n10, 2).getInt16(0, t7);
          break;
        case 9:
          T4 = new DataView(e8, n10, 4).getInt32(0, t7);
          break;
        case 10:
          T4 = new DataView(e8, n10, 4).getInt32(0, t7) / new DataView(e8, n10 + 4, 4).getInt32(0, t7);
          break;
        case 11:
          T4 = new DataView(e8, n10, 4).getFloat32(0, t7);
          break;
        case 12:
          T4 = new DataView(e8, n10, 8).getFloat64(0, t7);
          break;
        case 16:
        case 18:
          T4 = G(new DataView(e8, n10, 8), 0, t7);
          break;
        case 17:
          T4 = F(new DataView(e8, n10, 8), 0, t7);
          break;
        default:
          T4 = null;
      }
      c6.push(T4);
    }
  }
  if (2 === r10) {
    let e9 = "";
    const t8 = c6;
    for (c6 = [], p9 = 0; p9 < t8.length; p9++)
      0 === t8[p9] && "" !== e9 ? (c6.push(e9), e9 = "") : e9 += String.fromCharCode(t8[p9]);
    "" === e9 && 0 !== c6.length || c6.push(e9);
  }
  return n9.values = c6, true;
}
function R(e8) {
  const t7 = e8[0], n9 = d(t7, "TILEWIDTH"), a12 = d(t7, "TILELENGTH"), i7 = d(t7, "IMAGEWIDTH"), s9 = d(t7, "IMAGELENGTH"), r10 = d(t7, "BITSPERSAMPLE"), l8 = d(t7, "SAMPLESPERPIXEL"), o4 = d(t7, "SAMPLEFORMAT") ?? 1, f6 = h2(o4, r10), u8 = D(t7), g5 = I(t7, "GDAL_NODATA");
  let w5 = null;
  (g5 == null ? void 0 : g5.length) && (w5 = g5.map((e9) => parseFloat(e9)), w5.some((e9) => isNaN(e9)) && (w5 = null));
  const m7 = d(t7, "COMPRESSION") ?? 1;
  let S4;
  switch (m7) {
    case 1:
      S4 = "NONE";
      break;
    case 2:
    case 3:
    case 4:
    case 32771:
      S4 = "CCITT";
      break;
    case 5:
      S4 = "LZW";
      break;
    case 6:
    case 7:
      S4 = "JPEG";
      break;
    case 32773:
      S4 = "PACKBITS";
      break;
    case 8:
    case 32946:
      S4 = "DEFLATE";
      break;
    case 34712:
      S4 = "JPEG2000";
      break;
    case 34887:
      S4 = "LERC";
      break;
    default:
      S4 = String(m7);
  }
  let y7 = true, A3 = "";
  c3.has(m7) || (y7 = false, A3 += "unsupported tag compression " + m7), o4 > 3 && (y7 = false, A3 += "unsupported tag sampleFormat " + o4), 1 !== r10 && 2 !== r10 && 4 !== r10 && r10 % 8 != 0 && (y7 = false, A3 += "unsupported tag bitsPerSample " + r10);
  const M3 = p5(t7, "GEOASCIIPARAMS");
  let P3;
  if (M3) {
    const e9 = M3.split("|").find((e10) => e10.includes("ESRI PE String = ")), t8 = e9 ? e9.replace("ESRI PE String = ", "") : "";
    P3 = t8.startsWith("COMPD_CS") || t8.startsWith("PROJCS") || t8.startsWith("GEOGCS") ? { wkid: null, wkt: t8 } : null;
  }
  const O4 = T(t7, "GEOTIEPOINTS"), b4 = T(t7, "GEOPIXELSCALE"), L3 = T(t7, "GEOTRANSMATRIX"), R3 = t7.has("GEOKEYDIRECTORY") ? t7.get("GEOKEYDIRECTORY").data : null;
  let k4, G2, F2 = false, C4 = false;
  if (R3) {
    F2 = 2 === d(R3, "GTRasterTypeGeoKey");
    const e9 = d(R3, "GTModelTypeGeoKey");
    if (2 === e9) {
      const e10 = d(R3, "GeographicTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (P3 = { wkid: e10 }), P3 || 32767 !== e10 || (C4 = true, P3 = { wkid: 4326 });
    } else if (1 === e9) {
      const e10 = d(R3, "ProjectedCSTypeGeoKey");
      e10 >= 1024 && e10 <= 32766 && (P3 = { wkid: e10 });
    }
  }
  if (b4 && O4 && O4.length >= 6 ? (k4 = [b4[0], 0, O4[3] - O4[0] * b4[0], 0, -Math.abs(b4[1]), O4[4] - O4[1] * b4[1]], F2 && (k4[2] -= 0.5 * k4[0] + 0.5 * k4[1], k4[5] -= 0.5 * k4[3] + 0.5 * k4[4])) : L3 && 16 === L3.length && (k4 = F2 ? [L3[0], L3[1], L3[3] - 0.5 * L3[0], L3[4], L3[5], L3[7] - 0.5 * L3[5]] : [L3[0], L3[1], L3[3], L3[4], L3[5], L3[7]]), k4) {
    const e9 = [{ x: 0, y: s9 }, { x: 0, y: 0 }, { x: i7, y: s9 }, { x: i7, y: 0 }];
    let t8, n10 = Number.POSITIVE_INFINITY, a13 = Number.POSITIVE_INFINITY, r11 = Number.NEGATIVE_INFINITY, l9 = Number.NEGATIVE_INFINITY;
    for (let i8 = 0; i8 < e9.length; i8++)
      t8 = E2(e9[i8], k4), n10 = t8.x > n10 ? n10 : t8.x, r11 = t8.x < r11 ? r11 : t8.x, a13 = t8.y > a13 ? a13 : t8.y, l9 = t8.y < l9 ? l9 : t8.y;
    G2 = { xmin: n10, xmax: r11, ymin: a13, ymax: l9, spatialReference: P3 };
  } else
    G2 = { xmin: -0.5, ymin: 0.5 - s9, xmax: i7 - 0.5, ymax: 0.5, spatialReference: P3 };
  C4 && (G2.xmax - G2.xmin > 400 || Math.max(Math.abs(G2.xmin), Math.abs(G2.xmax)) > 361) && (P3 = null, G2.spatialReference = null);
  const v6 = N(e8);
  let B3, W2, H2, Y, _3;
  if (v6.length > 0) {
    H2 = Math.round(Math.log(i7 / d(v6[0], "IMAGEWIDTH")) / Math.LN2);
    const e9 = v6[v6.length - 1];
    Y = Math.round(Math.log(i7 / d(e9, "IMAGEWIDTH")) / Math.LN2), B3 = d(e9, "TILEWIDTH"), W2 = d(e9, "TILELENGTH");
  }
  B3 = null != Y && Y > 0 ? B3 || n9 : null, W2 = null != Y && Y > 0 ? W2 || a12 : null, n9 && (_3 = [{ maxCol: Math.ceil(i7 / n9) - 1, maxRow: Math.ceil(s9 / a12) - 1, minRow: 0, minCol: 0 }], v6.forEach((e9) => {
    _3.push({ maxCol: Math.ceil(d(e9, "IMAGEWIDTH") / d(e9, "TILEWIDTH")) - 1, maxRow: Math.ceil(d(e9, "IMAGELENGTH") / d(e9, "TILELENGTH")) - 1, minRow: 0, minCol: 0 });
  }));
  const K = p5(e8[0], "GDAL_METADATA"), X = x(K);
  A3 += " " + V({ width: i7, height: s9, tileWidth: n9, tileHeight: a12, planes: l8, ifds: e8 });
  return { width: i7, height: s9, tileWidth: n9, tileHeight: a12, planes: l8, isBSQ: u8, pixelType: f6, compression: S4, noData: w5, hasMaskBand: U(e8).length === v6.length + 1, isSupported: y7, message: A3, extent: G2, isPseudoGeographic: C4, affine: b4 ? null : k4, firstPyramidLevel: H2, maximumPyramidLevel: Y, pyramidBlockWidth: B3, pyramidBlockHeight: W2, tileBoundary: _3, metadata: X };
}
function D(e8, t7) {
  const n9 = I(e8, "PLANARCONFIGURATION");
  return n9 ? 2 === n9[0] : !!t7 && t7.isBSQ;
}
function N(e8) {
  return e8.filter((e9) => 1 === d(e9, "NEWSUBFILETYPE"));
}
function U(e8) {
  return e8.filter((e9) => {
    const t7 = 4 == (4 & (d(e9, "NEWSUBFILETYPE") ?? 0)), n9 = 4 === d(e9, "PHOTOMETRICINTERPRETATION");
    return t7 && n9;
  });
}
function k(e8) {
  const { littleEndian: t7, isBigTiff: n9, firstIFDPos: a12 } = v2(e8);
  let i7 = a12;
  const s9 = [];
  do {
    const a13 = B(e8, t7, i7, 0, n4.TIFF_TAGS, n9 ? 8 : 4);
    if (!a13.success)
      break;
    s9.push(a13.ifd), i7 = a13.nextIFD;
  } while (i7 > 0);
  return { ...R(s9), littleEndian: t7, isBigTiff: n9, ifds: s9, pyramidIFDs: N(s9), maskIFDs: U(s9) };
}
function G(e8, t7, n9) {
  const a12 = e8.getUint32(t7, n9), i7 = e8.getUint32(t7 + 4, n9);
  return n9 ? i7 * u4 + a12 : a12 * u4 + i7;
}
function F(e8, t7, n9) {
  let a12 = n9 ? e8.getInt32(t7, n9) : e8.getUint32(t7, n9), i7 = n9 ? e8.getUint32(t7 + 4, n9) : e8.getInt32(t7 + 4, n9);
  const s9 = (n9 ? a12 : i7) >= 0 ? 1 : -1;
  n9 ? a12 *= s9 : i7 *= s9;
  return s9 * (n9 ? i7 * u4 + a12 : a12 * u4 + i7);
}
function C(e8, t7, n9, a12) {
  return a12 ? G(e8, t7, n9) : e8.getUint32(t7, n9);
}
function v2(e8) {
  const t7 = new DataView(e8, 0, 16), n9 = t7.getUint16(0, false);
  let a12 = null;
  if (18761 === n9)
    a12 = true;
  else {
    if (19789 !== n9)
      throw new Error("unexpected endianess byte");
    a12 = false;
  }
  const i7 = t7.getUint16(2, a12);
  if (42 !== i7 && 43 !== i7)
    throw new Error("unexpected tiff identifier");
  let s9 = 4;
  const r10 = 43 === i7;
  if (r10) {
    const e9 = t7.getUint16(s9, a12);
    if (s9 += 2, 8 !== e9)
      throw new Error("unsupported bigtiff version");
    if (0 !== t7.getUint16(s9, a12))
      throw new Error("unsupported bigtiff version");
    s9 += 2;
  }
  return { littleEndian: a12, isBigTiff: r10, firstIFDPos: C(t7, s9, a12, r10) };
}
function B(t7, n9, a12, i7 = 0, s9 = n4.TIFF_TAGS, l8 = 4) {
  const o4 = w3(t7, n9, a12, i7, s9, l8);
  let f6;
  const u8 = o4.ifd;
  if (u8) {
    if (n4.ifdTags.forEach((e8, a13) => {
      u8.has(a13) && (f6 = u8.get(a13), f6.data = w3(t7, n9, f6.valueOffset - i7, i7, e8).ifd);
    }), u8.has("GEOKEYDIRECTORY")) {
      f6 = u8.get("GEOKEYDIRECTORY");
      const e8 = f6.values;
      if (e8 && e8.length > 4) {
        const a13 = e8[0] + "." + e8[1] + "." + e8[2];
        f6.data = w3(t7, n9, f6.valueOffset + 6 - i7, i7, n4.GEO_KEYS, 2).ifd, f6.data && f6.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a13] });
      }
    }
    if (u8.has("XMP")) {
      f6 = u8.get("XMP");
      const t8 = f6.values;
      "number" == typeof t8[0] && 7 === f6.type && (f6.values = [r8(new Uint8Array(t8))]);
    }
  }
  return o4;
}
function V(e8) {
  const { width: t7, height: n9, tileHeight: a12, tileWidth: i7 } = e8, s9 = e8.planes, r10 = i7 ? i7 * a12 : t7 * n9, l8 = d(e8.ifds[0], "BITSPERSAMPLE");
  let o4 = "";
  return r10 * s9 > 2 ** 30 / (l8 > 8 ? l8 / 8 : 1) && (o4 = i7 ? "tiled tiff exceeding 1 gigabits per tile is not supported" : "scanline tiff exceeding 1 gigabits is not supported"), o4;
}
async function W(e8, t7) {
  const { headerInfo: n9, ifd: a12, offsets: i7, sizes: r10 } = t7, l8 = [];
  for (let s9 = 0; s9 < i7.length; s9++) {
    const t8 = await M(e8, n9.littleEndian, a12, i7[s9], r10[s9] || e8.byteLength);
    l8.push(t8);
  }
  const o4 = D(a12, n9), f6 = d(a12, "BITSPERSAMPLE"), u8 = h2(d(a12, "SAMPLEFORMAT") ?? 1, f6), c6 = d(a12, "SAMPLESPERPIXEL") || n9.planes, E3 = g(u8), I3 = d(a12, "TILEWIDTH"), T4 = d(a12, "TILELENGTH"), p9 = d(a12, "COMPRESSION") ?? 1, w5 = I3 * T4;
  let m7;
  const S4 = [];
  let y7 = l8[0];
  const A3 = 34887 === p9;
  for (let s9 = 0; s9 < c6; s9++) {
    if (m7 = new E3(w5), o4 && A3) {
      if (y7 = l8[s9], y7.length)
        for (let e9 = 0; e9 < w5; e9++)
          m7[e9] = y7[s9][e9 + s9];
    } else if (y7.length)
      if (o4 || A3 && !o4)
        m7 = y7.slice(w5 * s9, w5 * (s9 + 1));
      else
        for (let e9 = 0; e9 < w5; e9++)
          m7[e9] = y7[e9 * c6 + s9];
    S4.push(m7);
  }
  const P3 = n9.noData ? n9.noData[0] : t7.noDataValue, O4 = n9.metadata ? n9.metadata.statistics : null, x4 = O4 ? O4.map((e9) => e9.min) : null, L3 = O4 ? O4.map((e9) => e9.max) : null, R3 = { pixelType: u8, width: I3, height: T4, pixels: S4, noDataValue: P3 };
  return null != P3 ? u(R3, P3) : x4 && L3 && t7.applyMinMaxConstraint && (R3.mask = b(S4, x4, L3)), R3;
}
async function H(e8, t7 = {}) {
  const n9 = t7.pyramidLevel || 0, a12 = t7.headerInfo || k(e8), { ifds: i7, noData: r10 } = a12;
  if (0 === i7.length)
    throw new Error("no valid image file directory");
  const l8 = V(a12);
  if (l8)
    throw l8;
  let o4 = null;
  const f6 = -1 === n9 ? i7[i7.length - 1] : i7[n9], u8 = r10 ?? t7.noDataValue;
  return o4 = a12.tileWidth ? await P(e8, a12, f6) : await O(e8, a12, f6), o4 ? (null != u8 && u(o4, u8), o4) : o4;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js
var m4 = function(t7) {
  var e8, a12, i7, s9, r10, n9;
  function o4(t8) {
    var e9, a13, i8, s10, r11, n10, o5, h6, c6, l8, p9, d4, u8;
    for (this.data = t8, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, r11 = null; ; ) {
      switch (e9 = this.readUInt32(), h6 = function() {
        var t9, e10;
        for (e10 = [], t9 = 0; t9 < 4; ++t9)
          e10.push(String.fromCharCode(this.data[this.pos++]));
        return e10;
      }.call(this).join(""), h6) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e9);
          break;
        case "fcTL":
          r11 && this.animation.frames.push(r11), this.pos += 4, r11 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, s10 = this.readUInt16(), i8 = this.readUInt16() || 100, r11.delay = 1e3 * s10 / i8, r11.disposeOp = this.data[this.pos++], r11.blendOp = this.data[this.pos++], r11.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === h6 && (this.pos += 4, e9 -= 4), t8 = (null != r11 ? r11.data : void 0) || this.imgData, p9 = 0; 0 <= e9 ? p9 < e9 : p9 > e9; 0 <= e9 ? ++p9 : --p9)
            t8.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = this.read(e9), (c6 = 255 - this.transparency.indexed.length) > 0)
                for (d4 = 0; 0 <= c6 ? d4 < c6 : d4 > c6; 0 <= c6 ? ++d4 : --d4)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e9)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e9);
          }
          break;
        case "tEXt":
          n10 = (l8 = this.read(e9)).indexOf(0), o5 = String.fromCharCode.apply(String, l8.slice(0, n10)), this.text[o5] = String.fromCharCode.apply(String, l8.slice(n10 + 1));
          break;
        case "IEND":
          return r11 && this.animation.frames.push(r11), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = 4 === (u8 = this.colorType) || 6 === u8, a13 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a13, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e9;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  return o4.load = function(t8, e9, a13) {
    var i8;
    return "function" == typeof e9 && (a13 = e9), (i8 = new XMLHttpRequest()).open("GET", t8, true), i8.responseType = "arraybuffer", i8.onload = function() {
      var t9;
      return t9 = new o4(new Uint8Array(i8.response || i8.mozResponseArrayBuffer)), "function" == typeof (null != e9 ? e9.getContext : void 0) && t9.render(e9), "function" == typeof a13 ? a13(t9) : void 0;
    }, i8.send(null);
  }, a12 = 1, i7 = 2, e8 = 0, o4.prototype.read = function(t8) {
    var e9, a13;
    for (a13 = [], e9 = 0; 0 <= t8 ? e9 < t8 : e9 > t8; 0 <= t8 ? ++e9 : --e9)
      a13.push(this.data[this.pos++]);
    return a13;
  }, o4.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o4.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o4.prototype.decodePixels = function(t8) {
    var e9, a13, i8, s10, r11, n10, o5, h6, c6, p9, d4, u8, f6, m7, g5, w5, y7, x4, b4, k4, T4, I3, C4;
    if (null == t8 && (t8 = this.imgData), 0 === t8.length)
      return new Uint8Array(0);
    for (t8 = (t8 = new i2(t8)).getBytes(), w5 = (u8 = this.pixelBitlength / 8) * this.width, f6 = new Uint8Array(w5 * this.height), n10 = t8.length, g5 = 0, m7 = 0, a13 = 0; m7 < n10; ) {
      switch (t8[m7++]) {
        case 0:
          for (s10 = b4 = 0; b4 < w5; s10 = b4 += 1)
            f6[a13++] = t8[m7++];
          break;
        case 1:
          for (s10 = k4 = 0; k4 < w5; s10 = k4 += 1)
            e9 = t8[m7++], r11 = s10 < u8 ? 0 : f6[a13 - u8], f6[a13++] = (e9 + r11) % 256;
          break;
        case 2:
          for (s10 = T4 = 0; T4 < w5; s10 = T4 += 1)
            e9 = t8[m7++], i8 = (s10 - s10 % u8) / u8, y7 = g5 && f6[(g5 - 1) * w5 + i8 * u8 + s10 % u8], f6[a13++] = (y7 + e9) % 256;
          break;
        case 3:
          for (s10 = I3 = 0; I3 < w5; s10 = I3 += 1)
            e9 = t8[m7++], i8 = (s10 - s10 % u8) / u8, r11 = s10 < u8 ? 0 : f6[a13 - u8], y7 = g5 && f6[(g5 - 1) * w5 + i8 * u8 + s10 % u8], f6[a13++] = (e9 + Math.floor((r11 + y7) / 2)) % 256;
          break;
        case 4:
          for (s10 = C4 = 0; C4 < w5; s10 = C4 += 1)
            e9 = t8[m7++], i8 = (s10 - s10 % u8) / u8, r11 = s10 < u8 ? 0 : f6[a13 - u8], 0 === g5 ? y7 = x4 = 0 : (y7 = f6[(g5 - 1) * w5 + i8 * u8 + s10 % u8], x4 = i8 && f6[(g5 - 1) * w5 + (i8 - 1) * u8 + s10 % u8]), o5 = r11 + y7 - x4, h6 = Math.abs(o5 - r11), p9 = Math.abs(o5 - y7), d4 = Math.abs(o5 - x4), c6 = h6 <= p9 && h6 <= d4 ? r11 : p9 <= d4 ? y7 : x4, f6[a13++] = (e9 + c6) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t8[m7 - 1]);
      }
      g5++;
    }
    return f6;
  }, o4.prototype.decodePalette = function() {
    var t8, e9, a13, i8, s10, r11, n10, o5, h6;
    for (a13 = this.palette, r11 = this.transparency.indexed || [], s10 = new Uint8Array((r11.length || 0) + a13.length), i8 = 0, a13.length, t8 = 0, e9 = n10 = 0, o5 = a13.length; n10 < o5; e9 = n10 += 3)
      s10[i8++] = a13[e9], s10[i8++] = a13[e9 + 1], s10[i8++] = a13[e9 + 2], s10[i8++] = null != (h6 = r11[t8++]) ? h6 : 255;
    return s10;
  }, o4.prototype.copyToImageData = function(t8, e9) {
    var a13, i8, s10, r11, n10, o5, h6, c6, l8, p9, d4;
    if (i8 = this.colors, l8 = null, a13 = this.hasAlphaChannel, this.palette.length && (l8 = null != (d4 = this._decodedPalette) ? d4 : this._decodedPalette = this.decodePalette(), i8 = 4, a13 = true), c6 = (s10 = t8.data || t8).length, n10 = l8 || e9, r11 = o5 = 0, 1 === i8)
      for (; r11 < c6; )
        h6 = l8 ? 4 * e9[r11 / 4] : o5, p9 = n10[h6++], s10[r11++] = p9, s10[r11++] = p9, s10[r11++] = p9, s10[r11++] = a13 ? n10[h6++] : this.transparency.grayscale && this.transparency.grayscale === p9 ? 0 : 255, o5 = h6;
    else
      for (; r11 < c6; )
        h6 = l8 ? 4 * e9[r11 / 4] : o5, s10[r11++] = n10[h6++], s10[r11++] = n10[h6++], s10[r11++] = n10[h6++], s10[r11++] = a13 ? n10[h6++] : this.transparency.rgb && this.transparency.rgb[1] === n10[h6 - 3] && this.transparency.rgb[3] === n10[h6 - 2] && this.transparency.rgb[5] === n10[h6 - 1] ? 0 : 255, o5 = h6;
  }, o4.prototype.decode = function() {
    var t8;
    return t8 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t8, this.decodePixels()), t8;
  }, r10 = t7.document && t7.document.createElement("canvas"), n9 = r10 && r10.getContext("2d"), s9 = function(t8) {
    var e9;
    return n9.width = t8.width, n9.height = t8.height, n9.clearRect(0, 0, t8.width, t8.height), n9.putImageData(t8, 0, 0), (e9 = new Image()).src = r10.toDataURL(), e9;
  }, o4.prototype.decodeFrames = function(t8) {
    var e9, a13, i8, r11, n10, o5, h6, c6;
    if (this.animation) {
      for (c6 = [], a13 = n10 = 0, o5 = (h6 = this.animation.frames).length; n10 < o5; a13 = ++n10)
        e9 = h6[a13], i8 = t8.createImageData(e9.width, e9.height), r11 = this.decodePixels(new Uint8Array(e9.data)), this.copyToImageData(i8, r11), e9.imageData = i8, c6.push(e9.image = s9(i8));
      return c6;
    }
  }, o4.prototype.renderFrame = function(t8, s10) {
    var r11, n10, o5;
    return r11 = (n10 = this.animation.frames)[s10], o5 = n10[s10 - 1], 0 === s10 && t8.clearRect(0, 0, this.width, this.height), (null != o5 ? o5.disposeOp : void 0) === a12 ? t8.clearRect(o5.xOffset, o5.yOffset, o5.width, o5.height) : (null != o5 ? o5.disposeOp : void 0) === i7 && t8.putImageData(o5.imageData, o5.xOffset, o5.yOffset), r11.blendOp === e8 && t8.clearRect(r11.xOffset, r11.yOffset, r11.width, r11.height), t8.drawImage(r11.image, r11.xOffset, r11.yOffset);
  }, o4.prototype.animate = function(t8) {
    var e9, a13, i8, s10, r11, n10, o5 = this;
    return a13 = 0, n10 = this.animation, s10 = n10.numFrames, i8 = n10.frames, r11 = n10.numPlays, (e9 = function() {
      var n11, h6;
      if (n11 = a13++ % s10, h6 = i8[n11], o5.renderFrame(t8, n11), s10 > 1 && a13 / s10 < r11)
        return o5.animation._timeout = setTimeout(e9, h6.delay);
    })();
  }, o4.prototype.stopAnimation = function() {
    var t8;
    return clearTimeout(null != (t8 = this.animation) ? t8._timeout : void 0);
  }, o4.prototype.render = function(t8) {
    var e9, a13;
    return t8._png && t8._png.stopAnimation(), t8._png = this, t8.width = this.width, t8.height = this.height, e9 = t8.getContext("2d"), this.animation ? (this.decodeFrames(e9), this.animate(e9)) : (a13 = e9.createImageData(this.width, this.height), this.copyToImageData(a13, this.decodePixels()), e9.putImageData(a13, 0, 0));
  }, o4;
}(self);
var g2 = /* @__PURE__ */ new Set(["jpg", "png", "bmp", "gif"]);
async function w4(e8, a12) {
  if (!r9)
    throw new s2("rasterCoded:decode", "lerc decoder is not supported on big endian platform");
  await a6();
  const { offset: s9 } = a12, { width: r10, height: h6, pixelType: c6, statistics: l8, depthCount: p9, noDataValues: d4, bandMasks: u8, pixels: m7, mask: g5 } = c2(e8, { inputOffset: s9, returnInterleaved: a12.returnInterleaved });
  return new m({ width: r10, height: h6, pixelType: c6.toLowerCase(), pixels: m7, mask: g5, statistics: l8, bandMasks: u8, depthCount: p9, noDataValues: d4 });
}
async function y4(t7, e8) {
  const s9 = await H(t7, { ...e8, noDataValue: null });
  i(s9);
  const r10 = new m({ width: s9.width, height: s9.height, pixels: s9.pixels, pixelType: s9.pixelType.toLowerCase(), mask: s9.mask, statistics: null });
  return r10.updateStatistics(), r10;
}
async function x2(t7, e8) {
  const a12 = await W(t7, e8.customOptions), s9 = new m({ width: a12.width, height: a12.height, pixels: a12.pixels, pixelType: a12.pixelType.toLowerCase(), mask: a12.mask, statistics: null });
  return s9.updateStatistics(), s9;
}
function b2(t7, e8) {
  const a12 = e8.pixelType || "u8", s9 = m.getPixelArrayConstructor(a12), r10 = "u8" === a12 ? t7 : new s9(t7.buffer), n9 = [], o4 = e8.planes || 1;
  if (1 === o4)
    n9.push(r10);
  else
    for (let i7 = 0; i7 < o4; i7++) {
      const a13 = (e8.width || 1) * (e8.height || t7.length), h7 = new s9(a13);
      for (let t8 = 0; t8 < a13; t8++)
        h7[t8] = r10[t8 * o4 + i7];
      n9.push(h7);
    }
  const h6 = new m({ width: e8.width || 1, height: e8.height || t7.length, pixels: n9, pixelType: a12, statistics: null });
  return h6.updateStatistics(), h6;
}
function k2(t7, e8) {
  return b2(new i2(new Uint8Array(t7)).getBytes(), e8);
}
function T2(t7, e8) {
  return b2(i5(t7, e8.offset, e8.eof, !e8.isInputBigEndian), e8);
}
function I2(t7, e8, a12) {
  const { pixelTypeCtor: s9 } = O2(e8.pixelType), r10 = (0, a7.decode)(t7, { width: e8.width, height: e8.height, pixelType: s9, format: a12 }), n9 = new m({ width: e8.width, height: e8.height, pixels: r10.pixels, pixelType: e8.pixelType, mask: r10.mask, statistics: null });
  return n9.updateStatistics(), n9;
}
function C2(t7, e8) {
  const a12 = r4.decode(t7, e8.hasNoZlibMask ?? void 0), s9 = new m({ width: a12.width, height: a12.height, pixels: a12.pixels, pixelType: "U8", mask: a12.mask, statistics: null });
  return s9.updateStatistics(), s9;
}
function v3(t7, e8) {
  const a12 = new Uint8Array(t7), s9 = new m4(a12), { width: r10, height: n9 } = e8, o4 = r10 * n9, h6 = s9.decode();
  let c6, l8 = 0, p9 = 0;
  const d4 = new Uint8Array(o4);
  for (l8 = 0; l8 < o4; l8++)
    d4[l8] = h6[4 * l8 + 3];
  const u8 = new m({ width: r10, height: n9, pixels: [], pixelType: "U8", mask: d4, statistics: [] });
  for (l8 = 0; l8 < 3; l8++) {
    for (c6 = new Uint8Array(o4), p9 = 0; p9 < o4; p9++)
      c6[p9] = h6[4 * p9 + l8];
    u8.addData({ pixels: c6 });
  }
  return u8.updateStatistics(), u8;
}
async function U2(t7, e8, a12, r10) {
  const n9 = new i3(), o4 = { applyJpegMask: false, format: e8, ...a12 }, h6 = await n9.decode(t7, o4, r10), c6 = new m(h6);
  return c6.updateStatistics(), c6;
}
function A2(e8) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "parameter encodeddata is required.");
  const a12 = new Uint8Array(e8, 0, 10);
  let i7 = "";
  return 255 === a12[0] && 216 === a12[1] ? i7 = "jpg" : 137 === a12[0] && 80 === a12[1] && 78 === a12[2] && 71 === a12[3] ? i7 = "png" : 67 === a12[0] && 110 === a12[1] && 116 === a12[2] && 90 === a12[3] && 73 === a12[4] && 109 === a12[5] && 97 === a12[6] && 103 === a12[7] && 101 === a12[8] && 32 === a12[9] ? i7 = "lerc" : 76 === a12[0] && 101 === a12[1] && 114 === a12[2] && 99 === a12[3] && 50 === a12[4] && 32 === a12[5] ? i7 = "lerc2" : 73 === a12[0] && 73 === a12[1] && 42 === a12[2] && 0 === a12[3] || 77 === a12[0] && 77 === a12[1] && 0 === a12[2] && 42 === a12[3] || 73 === a12[0] && 73 === a12[1] && 43 === a12[2] && 0 === a12[3] || 77 === a12[0] && 77 === a12[1] && 0 === a12[2] && 43 === a12[3] ? i7 = "tiff" : 71 === a12[0] && 73 === a12[1] && 70 === a12[2] ? i7 = "gif" : 66 === a12[0] && 77 === a12[1] ? i7 = "bmp" : String.fromCharCode.apply(null, a12).toLowerCase().includes("error") && (i7 = "error"), i7;
}
function D2(e8) {
  let a12 = null;
  switch (e8) {
    case "lerc":
    case "lerc2":
      a12 = w4;
      break;
    case "jpg":
      a12 = C2;
      break;
    case "png":
      a12 = v3;
      break;
    case "bsq":
    case "bip":
      a12 = (t7, a13) => I2(t7, a13, e8);
      break;
    case "tiff":
      a12 = y4;
      break;
    case "deflate":
      a12 = k2;
      break;
    case "lzw":
      a12 = T2;
      break;
    case "error":
      a12 = () => {
        throw new s2("rasterCodec:decode", "input data contains error");
      };
      break;
    default:
      a12 = () => {
        throw new s2("rasterCodec:decode", "unsupported raster format");
      };
  }
  return a12;
}
function O2(t7) {
  let e8 = null, a12 = null;
  switch (t7 ? t7.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      a12 = 255, e8 = Uint8Array;
      break;
    case "u16":
      a12 = a12 || 65535, e8 = Uint16Array;
      break;
    case "u32":
      a12 = a12 || 2 ** 32 - 1, e8 = Uint32Array;
      break;
    case "s8":
      a12 = a12 || -128, e8 = Int8Array;
      break;
    case "s16":
      a12 = a12 || -32768, e8 = Int16Array;
      break;
    case "s32":
      a12 = a12 || 0 - 2 ** 31, e8 = Int32Array;
      break;
    default:
      e8 = Float32Array;
  }
  return { pixelTypeCtor: e8, noDataValue: a12 };
}
function P2(t7, a12 = 1) {
  if (!t7)
    return;
  const { pixels: s9, width: r10, height: n9, mask: o4 } = t7;
  if (!s9 || 0 === s9.length)
    return;
  const h6 = s9.length, c6 = r10 - 1, l8 = n9 - 1, p9 = [];
  let d4, u8, f6, m7, g5, w5, y7 = null;
  const x4 = m.getPixelArrayConstructor(t7.pixelType);
  if (0 === a12) {
    for (d4 = 0; d4 < h6; d4++) {
      for (g5 = s9[d4], w5 = new x4(c6 * l8), u8 = 0; u8 < l8; u8++)
        for (m7 = u8 * r10, f6 = 0; f6 < c6; f6++)
          w5[u8 * c6 + f6] = g5[m7 + f6];
      p9.push(w5);
    }
    if (r(o4))
      for (y7 = new Uint8Array(c6 * l8), u8 = 0; u8 < l8; u8++)
        for (m7 = u8 * r10, f6 = 0; f6 < c6; f6++)
          y7[u8 * c6 + f6] = o4[m7 + f6];
  } else {
    for (d4 = 0; d4 < h6; d4++) {
      for (g5 = s9[d4], w5 = new x4(c6 * l8), u8 = 0; u8 < l8; u8++)
        for (m7 = u8 * r10, f6 = 0; f6 < c6; f6++)
          w5[u8 * c6 + f6] = (g5[m7 + f6] + g5[m7 + f6 + 1] + g5[m7 + r10 + f6] + g5[m7 + r10 + f6 + 1]) / 4;
      p9.push(w5);
    }
    if (o4)
      for (y7 = new Uint8Array(c6 * l8), u8 = 0; u8 < l8; u8++)
        for (m7 = u8 * r10, f6 = 0; f6 < c6; f6++)
          y7[u8 * c6 + f6] = Math.min.apply(null, [o4[m7 + f6], o4[m7 + f6 + 1], o4[m7 + r10 + f6], o4[m7 + r10 + f6 + 1]]);
  }
  t7.width = c6, t7.height = l8, t7.mask = y7, t7.pixels = p9;
}
function j(t7) {
  let e8 = A2(t7);
  return "lerc2" === e8 ? e8 = "lerc" : "error" === e8 && (e8 = ""), e8;
}
async function S3(e8, a12 = {}, i7) {
  if (null == e8)
    throw new s2("rasterCodec:decode", "missing encodeddata parameter.");
  let s9 = a12.format && a12.format.toLowerCase();
  if (!("bsq" !== s9 && "bip" !== s9 || null != a12.width && null != a12.height))
    throw new s2("rasterCodec:decode", "requires width and height in options parameter.");
  if ("tiff" === s9 && a12.customOptions)
    return x2(e8, a12);
  if ((!s9 || "bsq" !== s9 && "bip" !== s9 && "deflate" !== s9 && "lzw" !== s9) && (s9 = A2(e8)), a12.useCanvas && g2.has(s9))
    return U2(e8, s9, a12, i7);
  const r10 = D2(s9);
  a12.isPoint && (null != (a12 = { ...a12 }).width && a12.width++, null != a12.height && a12.height++);
  const n9 = await r10(e8, a12);
  return n9 ? ("jpg" !== s9 && null != a12.noDataValue && 1 === n9.depthCount && u(n9, a12.noDataValue, { customFloatTolerance: a12.tolerance }), a12.isPoint && P2(n9), n9) : n9;
}

// node_modules/@arcgis/core/renderers/support/stretchRendererUtils.js
var n5 = new s3({ none: "none", standardDeviation: "standard-deviation", histogramEqualization: "histogram-equalization", minMax: "min-max", percentClip: "percent-clip", sigmoid: "sigmoid" });
var a8 = { 0: "none", 3: "standardDeviation", 4: "histogramEqualization", 5: "minMax", 6: "percentClip", 9: "sigmoid" };

// node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js
var a9 = 1;
var l4 = [0.299, 0.587, 0.114];
function f4(t7, n9 = 256) {
  n9 = Math.min(n9, 256);
  const { size: e8, counts: i7 } = t7, s9 = new Uint8Array(e8), o4 = i7.reduce((t8, e9) => t8 + e9 / n9, 0);
  let r10 = 0, a12 = 0, l8 = 0, f6 = o4;
  for (let u8 = 0; u8 < e8; u8++)
    if (l8 += i7[u8], !(u8 < e8 - 1 && l8 + i7[u8 + 1] < f6)) {
      for (; r10 < n9 - 1 && f6 < l8; )
        r10++, f6 += o4;
      for (let t8 = a12; t8 <= u8; t8++)
        s9[t8] = r10;
      a12 = u8 + 1;
    }
  for (let u8 = a12; u8 < e8; u8++)
    s9[u8] = n9 - 1;
  return s9;
}
function u5(t7) {
  const { minCutOff: n9, maxCutOff: e8, gamma: i7, pixelType: s9, rounding: o4 } = t7, r10 = t7.outMin || 0, a12 = t7.outMax || 255;
  if (!["u8", "u16", "s8", "s16"].includes(s9))
    return null;
  const l8 = n9.length;
  let f6, u8, c6 = 0;
  "s8" === s9 ? c6 = -127 : "s16" === s9 && (c6 = -32767);
  let h6 = 256;
  ["u16", "s16"].includes(s9) && (h6 = 65536);
  const p9 = [], g5 = [], x4 = a12 - r10;
  for (f6 = 0; f6 < l8; f6++)
    g5[f6] = e8[f6] - n9[f6], p9[f6] = 0 === g5[f6] ? 0 : x4 / g5[f6];
  let d4;
  const y7 = [];
  let C4, O4, b4;
  if (i7 && i7.length >= l8) {
    const t8 = M2(l8, i7);
    for (f6 = 0; f6 < l8; f6++) {
      for (b4 = [], u8 = 0; u8 < h6; u8++)
        if (0 !== g5[f6])
          if (C4 = u8 + c6, d4 = (C4 - n9[f6]) / g5[f6], O4 = 1, i7[f6] > 1 && (O4 -= (1 / x4) ** (d4 * t8[f6])), C4 < e8[f6] && C4 > n9[f6]) {
            const t9 = O4 * x4 * d4 ** (1 / i7[f6]) + r10;
            b4[u8] = "floor" === o4 ? Math.floor(t9) : "round" === o4 ? Math.round(t9) : t9;
          } else
            C4 >= e8[f6] ? b4[u8] = a12 : b4[u8] = r10;
        else
          b4[u8] = r10;
      y7[f6] = b4;
    }
  } else
    for (f6 = 0; f6 < l8; f6++) {
      for (b4 = [], u8 = 0; u8 < h6; u8++)
        if (C4 = u8 + c6, C4 <= n9[f6])
          b4[u8] = r10;
        else if (C4 >= e8[f6])
          b4[u8] = a12;
        else {
          const t8 = (C4 - n9[f6]) * p9[f6] + r10;
          b4[u8] = "floor" === o4 ? Math.floor(t8) : "round" === o4 ? Math.round(t8) : t8;
        }
      y7[f6] = b4;
    }
  if (null != t7.contrastOffset) {
    const n10 = m5(t7.contrastOffset, t7.brightnessOffset);
    for (f6 = 0; f6 < l8; f6++)
      for (b4 = y7[f6], u8 = 0; u8 < h6; u8++)
        b4[u8] = n10[b4[u8]];
  }
  return { lut: y7, offset: c6 };
}
function m5(t7, n9) {
  const e8 = Math.min(Math.max(t7, -100), 100), i7 = Math.min(Math.max(n9 ?? 0, -100), 100), s9 = 255, o4 = 128;
  let r10 = 0, a12 = 0;
  const l8 = new Uint8Array(256);
  for (r10 = 0; r10 < 256; r10++)
    e8 > 0 && e8 < 100 ? a12 = (200 * r10 - 100 * s9 + 2 * s9 * i7) / (2 * (100 - e8)) + o4 : e8 <= 0 && e8 > -100 ? a12 = (200 * r10 - 100 * s9 + 2 * s9 * i7) * (100 + e8) / 2e4 + o4 : 100 === e8 ? (a12 = 200 * r10 - 100 * s9 + (s9 + 1) * (100 - e8) + 2 * s9 * i7, a12 = a12 > 0 ? s9 : 0) : -100 === e8 && (a12 = o4), l8[r10] = a12 > s9 ? s9 : a12 < 0 ? 0 : a12;
  return l8;
}
function c4(t7, n9, e8) {
  const i7 = [];
  for (let s9 = 0; s9 < n9.length; s9++) {
    let o4 = 0, r10 = 0, a12 = 0;
    "min" in n9[s9] ? { min: o4, max: r10, avg: a12 } = n9[s9] : [o4, r10, a12] = n9[s9];
    let f6 = a12 ?? 0;
    "u8" !== t7 && (f6 = 255 * (f6 - o4) / (r10 - o4)), e8 && (f6 *= l4[s9]), i7.push(h3(f6));
  }
  return i7;
}
function h3(t7) {
  if (t7 <= 0 || t7 >= 255)
    return a9;
  let n9 = 0;
  150 !== t7 && (n9 = t7 <= 150 ? 45 * Math.cos(0.01047 * t7) : 17 * Math.sin(0.021 * t7));
  const e8 = 255, i7 = t7 + n9, s9 = Math.log(t7 / e8), o4 = Math.log(i7 / e8);
  if (0 === o4)
    return a9;
  const r10 = s9 / o4;
  return isNaN(r10) ? a9 : Math.min(9.9, Math.max(0.01, r10));
}
function p6(n9) {
  var _a;
  if (t(n9) || !((_a = n9.pixels) == null ? void 0 : _a.length))
    return null;
  const { pixels: e8, mask: i7, pixelType: s9 } = n9, o4 = n9.width * n9.height, r10 = e8.length;
  let a12, l8, f6, u8, m7;
  const c6 = [], h6 = [];
  let p9, g5, x4, d4, M3, y7, C4, O4, b4, v6;
  const k4 = 256;
  for (u8 = 0; u8 < r10; u8++) {
    if (p9 = new Uint32Array(k4), x4 = e8[u8], "u8" === s9)
      if (a12 = -0.5, l8 = 255.5, i7)
        for (m7 = 0; m7 < o4; m7++)
          i7[m7] && p9[x4[m7]]++;
      else
        for (m7 = 0; m7 < o4; m7++)
          p9[x4[m7]]++;
    else {
      let t7 = false;
      n9.statistics || (n9.updateStatistics(), t7 = true);
      const e9 = n9.statistics;
      if (a12 = e9[u8].minValue, l8 = e9[u8].maxValue, f6 = (l8 - a12) / k4, 0 === f6) {
        !e9 || n9.validPixelCount || t7 || n9.updateStatistics();
        const i8 = (n9.validPixelCount || n9.width * n9.height) / k4;
        for (let t8 = 0; t8 < k4; t8++)
          p9[t8] = Math.round(i8 * (t8 + 1)) - Math.round(i8 * t8);
      } else {
        for (g5 = new Uint32Array(k4 + 1), m7 = 0; m7 < o4; m7++)
          i7 && !i7[m7] || g5[Math.floor((x4[m7] - a12) / f6)]++;
        for (m7 = 0; m7 < k4 - 1; m7++)
          p9[m7] = g5[m7];
        p9[k4 - 1] = g5[k4 - 1] + g5[k4];
      }
    }
    for (c6.push({ min: a12, max: l8, size: k4, counts: p9 }), d4 = 0, M3 = 0, O4 = 0, m7 = 0; m7 < k4; m7++)
      d4 += p9[m7], M3 += m7 * p9[m7];
    for (b4 = M3 / d4, m7 = 0; m7 < k4; m7++)
      O4 += p9[m7] * (m7 - b4) ** 2;
    v6 = Math.sqrt(O4 / (d4 - 1)), f6 = (l8 - a12) / k4, y7 = (b4 + 0.5) * f6 + a12, C4 = v6 * f6, h6.push({ min: a12, max: l8, avg: y7, stddev: C4 });
  }
  return { statistics: h6, histograms: c6 };
}
function g3(t7) {
  const n9 = [];
  for (let e8 = 0; e8 < t7.length; e8++) {
    const { min: i7, max: s9, size: o4, counts: r10 } = t7[e8];
    let a12 = 0, l8 = 0;
    for (let t8 = 0; t8 < o4; t8++)
      a12 += r10[t8], l8 += t8 * r10[t8];
    const f6 = l8 / a12;
    let u8 = 0;
    for (let t8 = 0; t8 < o4; t8++)
      u8 += r10[t8] * (t8 - f6) ** 2;
    const m7 = (s9 - i7) / o4, c6 = (f6 + 0.5) * m7 + i7, h6 = Math.sqrt(u8 / (a12 - 1)) * m7;
    n9.push({ min: i7, max: s9, avg: c6, stddev: h6 });
  }
  return n9;
}
function x3(t7, s9) {
  var _a;
  const { pixelBlock: a12, bandIds: l8, returnHistogramLut: u8, rasterInfo: m7 } = s9;
  let c6 = null, h6 = null, g5 = t7.stretchType;
  if ("number" == typeof g5 && (g5 = a8[g5]), t7.dra)
    if ("minMax" === g5 && r(a12) && a12.statistics)
      c6 = a12.statistics.map((t8) => [t8.minValue, t8.maxValue, 0, 0]);
    else {
      const t8 = p6(a12);
      c6 = r(t8) ? t8.statistics : null, h6 = r(t8) ? t8.histograms : null;
    }
  else
    c6 = ((_a = t7.statistics) == null ? void 0 : _a.length) > 0 ? t7.statistics : e2(m7.statistics), h6 = t7.histograms || e2(m7.histograms);
  "percentClip" !== g5 && "histogramEqualization" !== g5 || (h6 == null ? void 0 : h6.length) || (g5 = "minMax");
  const x4 = (c6 == null ? void 0 : c6.length) || (h6 == null ? void 0 : h6.length) || m7.bandCount, M3 = [], y7 = [];
  let C4, O4, b4, v6, k4, w5, z2, A3, U3;
  c6 && !Array.isArray(c6[0]) && (c6 = c6.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev]));
  const [P3, T4] = s4(m7.pixelType);
  if (!(c6 == null ? void 0 : c6.length)) {
    for (c6 = [], A3 = 0; A3 < x4; A3++)
      c6.push([P3, T4, 1, 1]);
    "standardDeviation" === g5 && (g5 = "minMax");
  }
  switch (g5) {
    case "none":
      for (A3 = 0; A3 < x4; A3++)
        M3[A3] = P3, y7[A3] = T4;
      break;
    case "minMax":
      for (A3 = 0; A3 < x4; A3++)
        M3[A3] = c6[A3][0], y7[A3] = c6[A3][1];
      break;
    case "standardDeviation":
      for (A3 = 0; A3 < x4; A3++)
        M3[A3] = c6[A3][2] - t7.numberOfStandardDeviations * c6[A3][3], y7[A3] = c6[A3][2] + t7.numberOfStandardDeviations * c6[A3][3], M3[A3] < c6[A3][0] && (M3[A3] = c6[A3][0]), y7[A3] > c6[A3][1] && (y7[A3] = c6[A3][1]);
      break;
    case "histogramEqualization":
      for (i(h6), A3 = 0; A3 < x4; A3++)
        M3[A3] = h6[A3].min, y7[A3] = h6[A3].max;
      break;
    case "percentClip":
      for (i(h6), A3 = 0; A3 < h6.length; A3++) {
        for (C4 = h6[A3], k4 = new Uint32Array(C4.size), v6 = [...C4.counts], v6.length >= 20 && (v6[0] = v6[1] = v6[2] = v6[v6.length - 1] = v6[v6.length - 2] = 0), b4 = 0, O4 = (C4.max - C4.min) / C4.size, z2 = -0.5 === C4.min && 1 === O4 ? 0.5 : 0, U3 = 0; U3 < C4.size; U3++)
          b4 += v6[U3], k4[U3] = b4;
        for (w5 = (t7.minPercent || 0) * b4 / 100, M3[A3] = C4.min + z2, U3 = 0; U3 < C4.size; U3++)
          if (k4[U3] > w5) {
            M3[A3] = C4.min + O4 * (U3 + z2);
            break;
          }
        for (w5 = (1 - (t7.maxPercent || 0) / 100) * b4, y7[A3] = C4.max + z2, U3 = C4.size - 2; U3 >= 0; U3--)
          if (k4[U3] < w5) {
            y7[A3] = C4.min + O4 * (U3 + 2 - z2);
            break;
          }
        if (y7[A3] < M3[A3]) {
          const t8 = M3[A3];
          M3[A3] = y7[A3], y7[A3] = t8;
        }
      }
      break;
    default:
      for (A3 = 0; A3 < x4; A3++)
        M3[A3] = c6[A3][0], y7[A3] = c6[A3][1];
  }
  let q, S4, j2;
  "histogramEqualization" === g5 ? (i(h6), S4 = h6[0].size || 256, q = 0, u8 && (j2 = h6.map((t8) => f4(t8)))) : (S4 = t7.max || 255, q = t7.min || 0);
  return d2({ minCutOff: M3, maxCutOff: y7, outMax: S4, outMin: q, histogramLut: j2 }, l8);
}
function d2(t7, n9) {
  if (null == n9 || 0 === n9.length)
    return t7;
  const e8 = Math.max.apply(null, n9), { minCutOff: i7, maxCutOff: s9, outMin: o4, outMax: r10, histogramLut: a12 } = t7;
  return i7.length === n9.length || i7.length <= e8 ? t7 : { minCutOff: n9.map((t8) => i7[t8]), maxCutOff: n9.map((t8) => s9[t8]), histogramLut: a12 ? n9.map((t8) => a12[t8]) : null, outMin: o4, outMax: r10 };
}
function M2(t7, n9) {
  const e8 = new Float32Array(t7);
  for (let i7 = 0; i7 < t7; i7++)
    n9[i7] > 1 ? n9[i7] > 2 ? e8[i7] = 6.5 + (n9[i7] - 2) ** 2.5 : e8[i7] = 6.5 + 100 * (2 - n9[i7]) ** 4 : e8[i7] = 1;
  return e8;
}
function y5(n9, e8) {
  var _a;
  if (t(n9) || !((_a = n9.pixels) == null ? void 0 : _a.length))
    return n9;
  const { mask: i7, width: o4, height: r10, pixels: a12 } = n9, { minCutOff: l8, maxCutOff: f6, gamma: u8 } = e8, m7 = e8.outMin || 0, c6 = e8.outMax || 255, h6 = o4 * r10, p9 = e8.outputPixelType || "u8", g5 = n9.pixels.map(() => m.createEmptyBand(p9, h6)), x4 = g5.length;
  let d4, y7, C4, O4, b4;
  const v6 = c6 - m7, k4 = [], w5 = [];
  for (d4 = 0; d4 < x4; d4++)
    w5[d4] = f6[d4] - l8[d4], k4[d4] = 0 === w5[d4] ? 0 : v6 / w5[d4];
  const z2 = p9.startsWith("u") || p9.startsWith("s"), A3 = u8 && u8.length >= x4, U3 = !!e8.isRenderer;
  if (A3) {
    const t7 = M2(x4, u8);
    for (y7 = 0; y7 < h6; y7++)
      if (null == i7 || i7[y7])
        for (d4 = 0; d4 < x4; d4++)
          if (0 !== w5[d4])
            if (C4 = a12[d4][y7], b4 = (C4 - l8[d4]) / w5[d4], O4 = 1, u8[d4] > 1 && (O4 -= (1 / v6) ** (b4 * t7[d4])), C4 < f6[d4] && C4 > l8[d4]) {
              const t8 = O4 * v6 * b4 ** (1 / u8[d4]) + m7;
              g5[d4][y7] = U3 ? Math.floor(t8) : z2 ? Math.round(t8) : t8;
            } else
              C4 >= f6[d4] ? g5[d4][y7] = c6 : g5[d4][y7] = m7;
          else
            g5[d4][y7] = m7;
  } else
    for (y7 = 0; y7 < h6; y7++)
      if (null == i7 || i7[y7])
        for (d4 = 0; d4 < x4; d4++)
          if (C4 = a12[d4][y7], C4 < f6[d4] && C4 > l8[d4]) {
            const t7 = (C4 - l8[d4]) * k4[d4] + m7;
            g5[d4][y7] = U3 ? Math.floor(t7) : z2 ? Math.round(t7) : t7;
          } else
            C4 >= f6[d4] ? g5[d4][y7] = c6 : g5[d4][y7] = m7;
  const P3 = new m({ width: o4, height: r10, mask: i7, pixels: g5, pixelType: p9 });
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/layers/support/RasterStorageInfo.js
var p7;
var l5 = p7 = class extends l {
  constructor() {
    super(...arguments), this.blockWidth = void 0, this.blockHeight = void 0, this.compression = null, this.origin = null, this.firstPyramidLevel = null, this.maximumPyramidLevel = null, this.pyramidScalingFactor = 2, this.pyramidBlockWidth = null, this.pyramidBlockHeight = null, this.isVirtualTileInfo = false, this.tileInfo = null, this.transposeInfo = null, this.blockBoundary = null;
  }
  clone() {
    return new p7({ blockWidth: this.blockWidth, blockHeight: this.blockHeight, compression: this.compression, origin: p(this.origin), firstPyramidLevel: this.firstPyramidLevel, maximumPyramidLevel: this.maximumPyramidLevel, pyramidResolutions: p(this.pyramidResolutions), pyramidScalingFactor: this.pyramidScalingFactor, pyramidBlockWidth: this.pyramidBlockWidth, pyramidBlockHeight: this.pyramidBlockHeight, isVirtualTileInfo: this.isVirtualTileInfo, tileInfo: p(this.tileInfo), transposeInfo: p(this.transposeInfo), blockBoundary: p(this.blockBoundary) });
  }
};
e([y({ type: Number, json: { write: true } })], l5.prototype, "blockWidth", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "blockHeight", void 0), e([y({ type: String, json: { write: true } })], l5.prototype, "compression", void 0), e([y({ type: w, json: { write: true } })], l5.prototype, "origin", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "firstPyramidLevel", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "maximumPyramidLevel", void 0), e([y({ json: { write: true } })], l5.prototype, "pyramidResolutions", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "pyramidScalingFactor", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "pyramidBlockWidth", void 0), e([y({ type: Number, json: { write: true } })], l5.prototype, "pyramidBlockHeight", void 0), e([y({ type: Boolean, json: { write: true } })], l5.prototype, "isVirtualTileInfo", void 0), e([y({ json: { write: true } })], l5.prototype, "tileInfo", void 0), e([y()], l5.prototype, "transposeInfo", void 0), e([y()], l5.prototype, "blockBoundary", void 0), l5 = p7 = e([a2("esri.layers.support.RasterStorageInfo")], l5);
var n6 = l5;

// node_modules/@arcgis/core/layers/support/RasterInfo.js
var l6;
var h4 = l6 = class extends l {
  constructor(t7) {
    super(t7), this.attributeTable = null, this.bandCount = null, this.colormap = null, this.extent = null, this.format = void 0, this.height = null, this.width = null, this.histograms = null, this.keyProperties = {}, this.multidimensionalInfo = null, this.noDataValue = null, this.pixelSize = null, this.pixelType = null, this.isPseudoSpatialReference = false, this.spatialReference = null, this.statistics = null, this.storageInfo = null, this.transform = null;
  }
  get dataType() {
    var _a, _b;
    const t7 = ((_b = (_a = this.keyProperties) == null ? void 0 : _a.DataType) == null ? void 0 : _b.toLowerCase()) ?? "generic";
    return "stdtime" === t7 ? "standard-time" : t7;
  }
  get nativeExtent() {
    return this._get("nativeExtent") || this.extent;
  }
  set nativeExtent(t7) {
    t7 && this._set("nativeExtent", t7);
  }
  get nativePixelSize() {
    if (t(this.transform) || !this.transform.affectsPixelSize)
      return this.pixelSize;
    const t7 = this.nativeExtent;
    return { x: t7.width / this.width, y: t7.height / this.height };
  }
  get hasMultidimensionalTranspose() {
    var _a;
    return !!((_a = this.storageInfo) == null ? void 0 : _a.transposeInfo);
  }
  clone() {
    return new l6({ attributeTable: p(this.attributeTable), bandCount: this.bandCount, colormap: p(this.colormap), extent: p(this.extent), nativePixelSize: p(this.nativePixelSize), format: this.format, height: this.height, width: this.width, histograms: p(this.histograms), keyProperties: p(this.keyProperties), multidimensionalInfo: p(this.multidimensionalInfo), noDataValue: this.noDataValue, pixelSize: p(this.pixelSize), pixelType: this.pixelType, isPseudoSpatialReference: this.isPseudoSpatialReference, spatialReference: p(this.spatialReference), statistics: p(this.statistics), storageInfo: p(this.storageInfo), transform: p(this.transform) });
  }
};
e([y({ json: { write: true } })], h4.prototype, "attributeTable", void 0), e([y({ json: { write: true } })], h4.prototype, "bandCount", void 0), e([y({ json: { write: true } })], h4.prototype, "colormap", void 0), e([y({ type: String, readOnly: true })], h4.prototype, "dataType", null), e([y({ type: w2, json: { write: true } })], h4.prototype, "extent", void 0), e([y({ type: w2, json: { write: true } })], h4.prototype, "nativeExtent", null), e([y({ json: { write: true } })], h4.prototype, "nativePixelSize", null), e([y({ json: { write: true } })], h4.prototype, "format", void 0), e([y({ json: { write: true } })], h4.prototype, "height", void 0), e([y({ json: { write: true } })], h4.prototype, "width", void 0), e([y({ json: { write: true } })], h4.prototype, "hasMultidimensionalTranspose", null), e([y({ json: { write: true } })], h4.prototype, "histograms", void 0), e([y({ json: { write: true } })], h4.prototype, "keyProperties", void 0), e([y({ json: { write: true } })], h4.prototype, "multidimensionalInfo", void 0), e([y({ json: { write: true } })], h4.prototype, "noDataValue", void 0), e([y({ json: { write: true } })], h4.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], h4.prototype, "pixelType", void 0), e([y()], h4.prototype, "isPseudoSpatialReference", void 0), e([y({ type: f, json: { write: true } })], h4.prototype, "spatialReference", void 0), e([y({ json: { write: true } })], h4.prototype, "statistics", void 0), e([y({ type: n6, json: { write: true } })], h4.prototype, "storageInfo", void 0), e([y({ json: { write: true } })], h4.prototype, "transform", void 0), h4 = l6 = e([a2("esri.layers.support.RasterInfo")], h4);
var u6 = h4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/surfaceUtils.js
function n7(t7) {
  let { altitude: e8, azimuth: i7 } = t7;
  const { hillshadeType: n9, pixelSizePower: l8 = 1, pixelSizeFactor: s9 = 1, scalingType: a12, isGCS: o4, resolution: r10 } = t7, c6 = "multi-directional" === n9 ? 2 * t7.zFactor : t7.zFactor, { x: h6, y: f6 } = r10;
  let u8 = c6 / (8 * h6), p9 = c6 / (8 * f6);
  if (o4 && c6 > 1e-3 && (u8 /= 111e3, p9 /= 111e3), "adjusted" === a12)
    if (o4) {
      const t8 = 111e3 * h6, e9 = 111e3 * f6;
      u8 = (c6 + t8 ** l8 * s9) / (8 * t8), p9 = (c6 + e9 ** l8 * s9) / (8 * e9);
    } else
      u8 = (c6 + h6 ** l8 * s9) / (8 * h6), p9 = (c6 + f6 ** l8 * s9) / (8 * f6);
  let d4 = (90 - e8) * Math.PI / 180, x4 = Math.cos(d4), m7 = (360 - i7 + 90) * Math.PI / 180, w5 = Math.sin(d4) * Math.cos(m7), y7 = Math.sin(d4) * Math.sin(m7);
  const M3 = [315, 270, 225, 360, 180, 0], A3 = [60, 60, 60, 60, 60, 90], g5 = new Float32Array([3, 5, 3, 2, 1, 4]), k4 = g5.reduce((t8, e9) => t8 + e9), P3 = g5.map((t8) => t8 / k4), Z = "multi-directional" === n9 ? M3.length : 1, C4 = new Float32Array(6), F2 = new Float32Array(6), b4 = new Float32Array(6);
  if ("multi-directional" === n9)
    for (let z2 = 0; z2 < Z; z2++)
      e8 = A3[z2], i7 = M3[z2], d4 = (90 - e8) * Math.PI / 180, x4 = Math.cos(d4), m7 = (360 - i7 + 90) * Math.PI / 180, w5 = Math.sin(d4) * Math.cos(m7), y7 = Math.sin(d4) * Math.sin(m7), C4[z2] = x4, F2[z2] = w5, b4[z2] = y7;
  else
    C4.fill(x4), F2.fill(w5), b4.fill(y7);
  return { resolution: r10, factor: [u8, p9], sinZcosA: w5, sinZsinA: y7, cosZ: x4, sinZcosAs: F2, sinZsinAs: b4, cosZs: C4, weights: P3, hillshadeType: ["traditional", "multi-directional"].indexOf(n9) };
}
function l7(l8, s9) {
  if (!a4(l8))
    return l8;
  const { width: a12, height: o4, mask: r10 } = l8, c6 = new Uint8Array(a12 * o4);
  let h6 = 1;
  if (r(r10)) {
    for (let t7 = 0; t7 < r10.length; t7++)
      if (r10[t7]) {
        h6 = r10[t7];
        break;
      }
    c6.set(r10);
  }
  const { factor: f6, sinZcosA: u8, sinZsinA: p9, cosZ: d4, sinZcosAs: x4, sinZsinAs: m7, cosZs: w5, weights: y7 } = n7(s9), [M3, A3] = f6, { hillshadeType: g5 } = s9, k4 = l8.pixels[0], P3 = new Uint8Array(a12 * o4);
  let Z, C4, F2, b4, z2, S4, T4, U3;
  const v6 = 1, j2 = r(r10);
  for (let t7 = v6; t7 < o4 - v6; t7++) {
    const e8 = t7 * a12;
    for (let t8 = v6; t8 < a12 - v6; t8++) {
      if (r10 && !r10[e8 + t8]) {
        P3[e8 + t8] = 0;
        continue;
      }
      let i7 = 8;
      if (j2 && (i7 = (r10[e8 - a12 + t8 - 1] + r10[e8 - a12 + t8] + r10[e8 - a12 + t8 + 1] + r10[e8 + t8 - 1] + r10[e8 + t8 + 1] + r10[e8 + a12 + t8 - 1] + r10[e8 + a12 + t8] + r10[e8 + a12 + t8 + 1]) / h6, i7 < 7)) {
        P3[e8 + t8] = 0, c6[e8 + t8] = 0;
        continue;
      }
      r10 && 7 === i7 ? (Z = r10[e8 - a12 + t8 - 1] ? k4[e8 - a12 + t8 - 1] : k4[e8 + t8], C4 = r10[e8 - a12 + t8] ? k4[e8 - a12 + t8] : k4[e8 + t8], F2 = r10[e8 - a12 + t8 + 1] ? k4[e8 - a12 + t8 + 1] : k4[e8 + t8], b4 = r10[e8 + t8 - 1] ? k4[e8 + t8 - 1] : k4[e8 + t8], z2 = r10[e8 + t8 + 1] ? k4[e8 + t8 + 1] : k4[e8 + t8], S4 = r10[e8 + a12 + t8 - 1] ? k4[e8 + a12 + t8 - 1] : k4[e8 + t8], T4 = r10[e8 + a12 + t8] ? k4[e8 + a12 + t8] : k4[e8 + t8], U3 = r10[e8 + a12 + t8 + 1] ? k4[e8 + a12 + t8 + 1] : k4[e8 + t8]) : (Z = k4[e8 - a12 + t8 - 1], C4 = k4[e8 - a12 + t8], F2 = k4[e8 - a12 + t8 + 1], b4 = k4[e8 + t8 - 1], z2 = k4[e8 + t8 + 1], S4 = k4[e8 + a12 + t8 - 1], T4 = k4[e8 + a12 + t8], U3 = k4[e8 + a12 + t8 + 1]);
      const n9 = (F2 + z2 + z2 + U3 - (Z + b4 + b4 + S4)) * M3, l9 = (S4 + T4 + T4 + U3 - (Z + C4 + C4 + F2)) * A3, s10 = Math.sqrt(1 + n9 * n9 + l9 * l9);
      let o5 = 0;
      if ("traditional" === g5) {
        let t9 = 255 * (d4 + p9 * l9 - u8 * n9) / s10;
        t9 < 0 && (t9 = 0), o5 = t9;
      } else {
        const t9 = m7.length;
        for (let e9 = 0; e9 < t9; e9++) {
          let t10 = 255 * (w5[e9] + m7[e9] * l9 - x4[e9] * n9) / s10;
          t10 < 0 && (t10 = 0), o5 += t10 * y7[e9];
        }
      }
      P3[e8 + t8] = 255 & o5;
    }
  }
  for (let t7 = 0; t7 < o4; t7++)
    P3[t7 * a12] = P3[t7 * a12 + 1], P3[(t7 + 1) * a12 - 1] = P3[(t7 + 1) * a12 - 2];
  for (let t7 = 1; t7 < a12 - 1; t7++)
    P3[t7] = P3[t7 + a12], P3[t7 + (o4 - 1) * a12] = P3[t7 + (o4 - 2) * a12];
  return new m({ width: a12, height: o4, pixels: [P3], mask: r10 ? c6 : null, pixelType: "u8", validPixelCount: l8.validPixelCount, statistics: [{ minValue: 0, maxValue: 255 }] });
}
function s7(t7, e8, n9, l8) {
  if (!a4(t7) || !a4(e8))
    return;
  const { min: s9, max: a12 } = l8, o4 = t7.pixels[0], { pixels: r10, mask: c6 } = e8, h6 = r10[0], f6 = 255.00001 / (a12 - s9), u8 = new Uint8ClampedArray(h6.length), p9 = new Uint8ClampedArray(h6.length), d4 = new Uint8ClampedArray(h6.length), x4 = n9.length - 1;
  for (let i7 = 0; i7 < h6.length; i7++) {
    if (c6 && 0 === c6[i7])
      continue;
    const t8 = Math.floor((h6[i7] - s9) * f6), [e9, l9] = n9[t8 < 0 ? 0 : t8 > x4 ? x4 : t8], a13 = o4[i7], r11 = a13 * l9, m7 = r11 * (1 - Math.abs(e9 % 2 - 1)), w5 = a13 - r11;
    switch (Math.floor(e9)) {
      case 0:
        u8[i7] = r11 + w5, p9[i7] = m7 + w5, d4[i7] = w5;
        break;
      case 1:
        u8[i7] = m7 + w5, p9[i7] = r11 + w5, d4[i7] = w5;
        break;
      case 2:
        u8[i7] = w5, p9[i7] = r11 + w5, d4[i7] = m7 + w5;
        break;
      case 3:
        u8[i7] = w5, p9[i7] = m7 + w5, d4[i7] = r11 + w5;
        break;
      case 4:
        u8[i7] = m7 + w5, p9[i7] = w5, d4[i7] = r11 + w5;
        break;
      case 5:
      case 6:
        u8[i7] = r11 + w5, p9[i7] = w5, d4[i7] = m7 + w5;
    }
  }
  t7.pixels = [u8, p9, d4], t7.updateStatistics();
}
function a10(n9, l8) {
  if (!a4(n9))
    return n9;
  const s9 = l8.zFactor, a12 = l8.pixelSizePower ?? 1, o4 = l8.pixelSizeFactor ?? 1, r10 = l8.slopeType, c6 = l8.isGCS, { width: h6, height: f6, mask: u8 } = n9, p9 = n9.pixels[0], d4 = new Uint8Array(h6 * f6);
  let x4 = 1;
  if (r(u8)) {
    for (let t7 = 0; t7 < u8.length; t7++)
      if (u8[t7]) {
        x4 = u8[t7];
        break;
      }
    d4.set(u8);
  }
  const m7 = new Float32Array(h6 * f6), { x: w5, y: y7 } = l8.resolution;
  let M3 = s9 / (8 * w5), A3 = s9 / (8 * y7);
  c6 && Math.abs(s9 - 1) < 1e-4 && (M3 /= 111e3, A3 /= 111e3), "adjusted" === r10 && (M3 = (s9 + w5 ** a12 * o4) / (8 * w5), A3 = (s9 + y7 ** a12 * o4) / (8 * y7));
  const g5 = 1;
  let k4, P3, Z, C4, F2, b4, z2, S4;
  const T4 = r(u8);
  for (let t7 = g5; t7 < f6 - g5; t7++) {
    const e8 = t7 * h6;
    for (let t8 = g5; t8 < h6 - g5; t8++) {
      if (u8 && !u8[e8 + t8]) {
        m7[e8 + t8] = 0;
        continue;
      }
      let i7 = 0;
      if (T4 && (i7 = (u8[e8 - h6 + t8 - 1] + u8[e8 - h6 + t8] + u8[e8 - h6 + t8 + 1] + u8[e8 + t8 - 1] + u8[e8 + t8 + 1] + u8[e8 + h6 + t8 - 1] + u8[e8 + h6 + t8] + u8[e8 + h6 + t8 + 1]) / x4, i7 < 7)) {
        m7[e8 + t8] = 0, d4[e8 + t8] = 0;
        continue;
      }
      u8 && 7 === i7 ? (k4 = u8[e8 - h6 + t8 - 1] ? p9[e8 - h6 + t8 - 1] : p9[e8 + t8], P3 = u8[e8 - h6 + t8] ? p9[e8 - h6 + t8] : p9[e8 + t8], Z = u8[e8 - h6 + t8 + 1] ? p9[e8 - h6 + t8 + 1] : p9[e8 + t8], C4 = u8[e8 + t8 - 1] ? p9[e8 + t8 - 1] : p9[e8 + t8], F2 = u8[e8 + t8 + 1] ? p9[e8 + t8 + 1] : p9[e8 + t8], b4 = u8[e8 + h6 + t8 - 1] ? p9[e8 + h6 + t8 - 1] : p9[e8 + t8], z2 = u8[e8 + h6 + t8] ? p9[e8 + h6 + t8] : p9[e8 + t8], S4 = u8[e8 + h6 + t8 + 1] ? p9[e8 + h6 + t8 + 1] : p9[e8 + t8]) : (k4 = p9[e8 - h6 + t8 - 1], P3 = p9[e8 - h6 + t8], Z = p9[e8 - h6 + t8 + 1], C4 = p9[e8 + t8 - 1], F2 = p9[e8 + t8 + 1], b4 = p9[e8 + h6 + t8 - 1], z2 = p9[e8 + h6 + t8], S4 = p9[e8 + h6 + t8 + 1]);
      const n10 = (Z + F2 + F2 + S4 - (k4 + C4 + C4 + b4)) * M3, l9 = (b4 + z2 + z2 + S4 - (k4 + P3 + P3 + Z)) * A3, s10 = Math.sqrt(n10 * n10 + l9 * l9);
      m7[e8 + t8] = "percent-rise" === r10 ? 100 * s10 : 57.2957795 * Math.atan(s10);
    }
  }
  for (let t7 = 0; t7 < f6; t7++)
    m7[t7 * h6] = m7[t7 * h6 + 1], m7[(t7 + 1) * h6 - 1] = m7[(t7 + 1) * h6 - 2];
  for (let t7 = 1; t7 < h6 - 1; t7++)
    m7[t7] = m7[t7 + h6], m7[t7 + (f6 - 1) * h6] = m7[t7 + (f6 - 2) * h6];
  const U3 = new m({ width: h6, height: f6, pixels: [m7], mask: u8 ? d4 : null, pixelType: "f32", validPixelCount: n9.validPixelCount });
  return U3.updateStatistics(), U3;
}
function o3(n9, l8 = {}) {
  if (!a4(n9))
    return n9;
  const { width: s9, height: a12, mask: o4 } = n9, r10 = n9.pixels[0], c6 = new Uint8Array(s9 * a12);
  r(o4) && c6.set(o4);
  const h6 = new Float32Array(s9 * a12), { resolution: f6 } = l8, u8 = f6 ? 1 / f6.x : 1, p9 = f6 ? 1 / f6.y : 1, d4 = 1;
  let x4, m7, w5, y7, M3, A3, g5, k4;
  const P3 = r(o4);
  for (let t7 = d4; t7 < a12 - d4; t7++) {
    const e8 = t7 * s9;
    for (let t8 = d4; t8 < s9 - d4; t8++) {
      if (o4 && !o4[e8 + t8]) {
        h6[e8 + t8] = 0;
        continue;
      }
      let i7 = 0;
      if (P3 && (i7 = o4[e8 - s9 + t8 - 1] + o4[e8 - s9 + t8] + o4[e8 - s9 + t8 + 1] + o4[e8 + t8 - 1] + o4[e8 + t8 + 1] + o4[e8 + s9 + t8 - 1] + o4[e8 + s9 + t8] + o4[e8 + s9 + t8 + 1], i7 < 7)) {
        h6[e8 + t8] = 0, c6[e8 + t8] = 0;
        continue;
      }
      o4 && 7 === i7 ? (x4 = o4[e8 - s9 + t8 - 1] ? r10[e8 - s9 + t8 - 1] : r10[e8 + t8], m7 = o4[e8 - s9 + t8] ? r10[e8 - s9 + t8] : r10[e8 + t8], w5 = o4[e8 - s9 + t8 + 1] ? r10[e8 - s9 + t8 + 1] : r10[e8 + t8], y7 = o4[e8 + t8 - 1] ? r10[e8 + t8 - 1] : r10[e8 + t8], M3 = o4[e8 + t8 + 1] ? r10[e8 + t8 + 1] : r10[e8 + t8], A3 = o4[e8 + s9 + t8 - 1] ? r10[e8 + s9 + t8 - 1] : r10[e8 + t8], g5 = o4[e8 + s9 + t8] ? r10[e8 + s9 + t8] : r10[e8 + t8], k4 = o4[e8 + s9 + t8 + 1] ? r10[e8 + s9 + t8 + 1] : r10[e8 + t8]) : (x4 = r10[e8 - s9 + t8 - 1], m7 = r10[e8 - s9 + t8], w5 = r10[e8 - s9 + t8 + 1], y7 = r10[e8 + t8 - 1], M3 = r10[e8 + t8 + 1], A3 = r10[e8 + s9 + t8 - 1], g5 = r10[e8 + s9 + t8], k4 = r10[e8 + s9 + t8 + 1]);
      const n10 = (w5 + M3 + M3 + k4 - (x4 + y7 + y7 + A3)) * u8, l9 = (A3 + g5 + g5 + k4 - (x4 + m7 + m7 + w5)) * p9;
      let a13 = -1;
      0 === n10 && 0 === l9 || (a13 = 90 - 57.29578 * Math.atan2(l9, -n10), a13 < 0 && (a13 += 360), 360 === a13 ? a13 = 0 : a13 > 360 && (a13 %= 360)), h6[e8 + t8] = a13;
    }
  }
  for (let t7 = 0; t7 < a12; t7++)
    h6[t7 * s9] = h6[t7 * s9 + 1], h6[(t7 + 1) * s9 - 1] = h6[(t7 + 1) * s9 - 2];
  for (let t7 = 1; t7 < s9 - 1; t7++)
    h6[t7] = h6[t7 + s9], h6[t7 + (a12 - 1) * s9] = h6[t7 + (a12 - 2) * s9];
  return new m({ width: s9, height: a12, pixels: [h6], mask: o4 ? c6 : null, pixelType: "f32", validPixelCount: n9.validPixelCount, statistics: [{ minValue: 0, maxValue: 360 }] });
}

// node_modules/@arcgis/core/renderers/support/colorRampUtils.js
var n8 = ["random", "ndvi", "ndvi2", "ndvi3", "elevation", "gray", "hillshade"];
var d3 = [{ id: "aspect_predefined", type: "multipart", colorRamps: [{ fromColor: [190, 190, 190], toColor: [255, 45, 8] }, { fromColor: [255, 45, 8], toColor: [255, 181, 61] }, { fromColor: [255, 181, 61], toColor: [255, 254, 52] }, { fromColor: [255, 254, 52], toColor: [0, 251, 50] }, { fromColor: [0, 251, 50], toColor: [255, 254, 52] }, { fromColor: [0, 253, 255], toColor: [0, 181, 255] }, { fromColor: [0, 181, 255], toColor: [26, 35, 253] }, { fromColor: [26, 35, 253], toColor: [255, 57, 251] }, { fromColor: [255, 57, 251], toColor: [255, 45, 8] }] }, { id: "blackToWhite_predefined", fromColor: [0, 0, 0], toColor: [255, 255, 255] }, { id: "blueBright_predefined", fromColor: [204, 204, 255], toColor: [0, 0, 224] }, { id: "blueLightToDark_predefined", fromColor: [211, 229, 232], toColor: [46, 100, 140] }, { id: "blueGreenBright_predefined", fromColor: [203, 245, 234], toColor: [48, 207, 146] }, { id: "blueGreenLightToDark_predefined", fromColor: [216, 242, 237], toColor: [21, 79, 74] }, { id: "brownLightToDark_predefined", fromColor: [240, 236, 170], toColor: [102, 72, 48] }, { id: "brownToBlueGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [156, 85, 31], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [33, 130, 145] }] }, { id: "brownToBlueGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [110, 70, 45], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [48, 100, 102] }] }, { id: "coefficientBias_predefined", fromColor: [214, 214, 255], toColor: [0, 57, 148] }, { id: "coldToHotDiverging_predefined", type: "multipart", colorRamps: [{ fromColor: [69, 117, 181], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [214, 47, 39] }] }, { id: "conditionNumber_predefined", type: "multipart", colorRamps: [{ fromColor: [0, 97, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 34, 0] }] }, { id: "cyanToPurple_predefined", type: "multipart", colorRamps: [{ fromColor: [0, 245, 245], toColor: [0, 0, 245] }, { fromColor: [0, 0, 245], toColor: [245, 0, 245] }] }, { id: "cyanLightToBlueDark_predefined", type: "multipart", colorRamps: [{ fromColor: [182, 237, 240], toColor: [31, 131, 224] }, { fromColor: [31, 131, 224], toColor: [9, 9, 145] }] }, { id: "distance_predefined", fromColor: [255, 200, 0], toColor: [0, 0, 255] }, { id: "elevation1_predefined", type: "multipart", colorRamps: [{ fromColor: [175, 240, 233], toColor: [255, 255, 179] }, { fromColor: [255, 255, 179], toColor: [0, 128, 64] }, { fromColor: [0, 128, 64], toColor: [252, 186, 3] }, { fromColor: [252, 186, 3], toColor: [128, 0, 0] }, { fromColor: [120, 0, 0], toColor: [105, 48, 13] }, { fromColor: [105, 48, 13], toColor: [171, 171, 171] }, { fromColor: [171, 171, 171], toColor: [255, 252, 255] }] }, { id: "elevation2_predefined", type: "multipart", colorRamps: [{ fromColor: [118, 219, 211], toColor: [255, 255, 199] }, { fromColor: [255, 255, 199], toColor: [255, 255, 128] }, { fromColor: [255, 255, 128], toColor: [217, 194, 121] }, { fromColor: [217, 194, 121], toColor: [135, 96, 38] }, { fromColor: [135, 96, 38], toColor: [150, 150, 181] }, { fromColor: [150, 150, 181], toColor: [181, 150, 181] }, { fromColor: [181, 150, 181], toColor: [255, 252, 255] }] }, { id: "errors_predefined", fromColor: [255, 235, 214], toColor: [196, 10, 10] }, { id: "grayLightToDark_predefined", fromColor: [219, 219, 219], toColor: [69, 69, 69] }, { id: "greenBright_predefined", fromColor: [204, 255, 204], toColor: [14, 204, 14] }, { id: "greenLightToDark_predefined", fromColor: [220, 245, 233], toColor: [34, 102, 51] }, { id: "greenToBlue_predefined", type: "multipart", colorRamps: [{ fromColor: [32, 204, 16], toColor: [0, 242, 242] }, { fromColor: [0, 242, 242], toColor: [2, 33, 227] }] }, { id: "orangeBright_predefined", fromColor: [255, 235, 204], toColor: [240, 118, 5] }, { id: "orangeLightToDark_predefined", fromColor: [250, 233, 212], toColor: [171, 65, 36] }, { id: "partialSpectrum_predefined", type: "multipart", colorRamps: [{ fromColor: [242, 241, 162], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }, { fromColor: [252, 3, 69], toColor: [176, 7, 237] }, { fromColor: [176, 7, 237], toColor: [2, 29, 173] }] }, { id: "partialSpectrum1Diverging_predefined", type: "multipart", colorRamps: [{ fromColor: [135, 38, 38], toColor: [240, 149, 12] }, { fromColor: [240, 149, 12], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [74, 80, 181] }, { fromColor: [74, 80, 181], toColor: [39, 32, 122] }] }, { id: "partialSpectrum2Diverging_predefined", type: "multipart", colorRamps: [{ fromColor: [115, 77, 42], toColor: [201, 137, 52] }, { fromColor: [201, 137, 52], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [91, 63, 176] }, { fromColor: [91, 63, 176], toColor: [81, 13, 97] }] }, { id: "pinkToYellowGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [158, 30, 113], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [99, 110, 45] }] }, { id: "pinkToYellowGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [97, 47, 73], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [22, 59, 15] }] }, { id: "precipitation_predefined", type: "multipart", colorRamps: [{ fromColor: [194, 82, 60], toColor: [237, 161, 19] }, { fromColor: [237, 161, 19], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 219, 0] }, { fromColor: [0, 219, 0], toColor: [32, 153, 143] }, { fromColor: [32, 153, 143], toColor: [11, 44, 122] }] }, { id: "prediction_predefined", type: "multipart", colorRamps: [{ fromColor: [40, 146, 199], toColor: [250, 250, 100] }, { fromColor: [250, 250, 100], toColor: [232, 16, 20] }] }, { id: "purpleBright_predefined", fromColor: [255, 204, 255], toColor: [199, 0, 199] }, { id: "purpleToGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [77, 32, 150], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [20, 122, 11] }] }, { id: "purpleToGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [67, 14, 89], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [24, 79, 15] }] }, { id: "purpleBlueBright_predefined", fromColor: [223, 184, 230], toColor: [112, 12, 242] }, { id: "purpleBlueLightToDark_predefined", fromColor: [229, 213, 242], toColor: [93, 44, 112] }, { id: "purpleRedBright_predefined", fromColor: [255, 204, 225], toColor: [199, 0, 99] }, { id: "purpleRedLightToDark_predefined", fromColor: [250, 215, 246], toColor: [143, 17, 57] }, { id: "redBright_predefined", fromColor: [255, 204, 204], toColor: [219, 0, 0] }, { id: "redLightToDark_predefined", fromColor: [255, 224, 224], toColor: [143, 10, 10] }, { id: "redToBlueDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [196, 69, 57], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [48, 95, 207] }] }, { id: "redToBlueDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [107, 13, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [13, 53, 97] }] }, { id: "redToGreen_predefined", type: "multipart", colorRamps: [{ fromColor: [245, 0, 0], toColor: [245, 245, 0] }, { fromColor: [245, 245, 0], toColor: [0, 245, 0] }] }, { id: "redToGreenDivergingBright_predefined", type: "multipart", colorRamps: [{ fromColor: [186, 20, 20], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [54, 145, 33] }] }, { id: "redToGreenDivergingDark_predefined", type: "multipart", colorRamps: [{ fromColor: [97, 21, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [16, 69, 16] }] }, { id: "slope_predefined", type: "multipart", colorRamps: [{ fromColor: [56, 168, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }] }, { id: "spectrumFullBright_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 0, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 0, 255] }] }, { id: "spectrumFullDark_predefined", type: "multipart", colorRamps: [{ fromColor: [153, 0, 0], toColor: [153, 153, 0] }, { fromColor: [153, 153, 0], toColor: [0, 153, 153] }, { fromColor: [0, 153, 153], toColor: [0, 0, 153] }] }, { id: "spectrumFullLight_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 153, 153], toColor: [255, 255, 153] }, { fromColor: [255, 255, 153], toColor: [153, 255, 255] }, { fromColor: [153, 255, 255], toColor: [153, 153, 255] }] }, { id: "surface_predefined", type: "multipart", colorRamps: [{ fromColor: [112, 153, 89], toColor: [242, 238, 162] }, { fromColor: [242, 238, 162], toColor: [242, 206, 133] }, { fromColor: [242, 206, 133], toColor: [194, 140, 124] }, { fromColor: [194, 140, 124], toColor: [255, 242, 255] }] }, { id: "temperature_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 252, 255], toColor: [255, 0, 255] }, { fromColor: [255, 0, 255], toColor: [0, 0, 255] }, { fromColor: [0, 0, 255], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 255, 0] }, { fromColor: [0, 255, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 128, 0] }, { fromColor: [255, 128, 0], toColor: [128, 0, 0] }] }, { id: "whiteToBlack_predefined", fromColor: [255, 255, 255], toColor: [0, 0, 0] }, { id: "yellowToDarkRed_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [242, 167, 46] }, { fromColor: [242, 167, 46], toColor: [107, 0, 0] }] }, { id: "yellowToGreenToDarkBlue_predefined", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [56, 224, 9] }, { fromColor: [56, 224, 9], toColor: [26, 147, 171] }, { fromColor: [26, 147, 171], toColor: [12, 16, 120] }] }, { id: "yellowToRed_predefined", fromColor: [245, 245, 0], toColor: [255, 0, 0] }, { id: "yellowGreenBright_predefined", fromColor: [236, 252, 204], toColor: [157, 204, 16] }, { id: "yellowGreenLightToDark_predefined", fromColor: [215, 240, 175], toColor: [96, 107, 45] }];
var p8 = { aspect_predefined: "Aspect", blackToWhite_predefined: "Black to White", blueBright_predefined: "Blue Bright", blueLightToDark_predefined: "Blue Light to Dark", blueGreenBright_predefined: "Blue-Green Bright", blueGreenLightToDark_predefined: "Blue-Green Light to Dark", brownLightToDark_predefined: "Brown Light to Dark", brownToBlueGreenDivergingBright_predefined: "Brown to Blue Green Diverging, Bright", brownToBlueGreenDivergingDark_predefined: "Brown to Blue Green Diverging, Dark", coefficientBias_predefined: "Coefficient Bias", coldToHotDiverging_predefined: "Cold to Hot Diverging", conditionNumber_predefined: "Condition Number", cyanToPurple_predefined: "Cyan to Purple", cyanLightToBlueDark_predefined: "Cyan-Light to Blue-Dark", distance_predefined: "Distance", elevation1_predefined: "Elevation #1", elevation2_predefined: "Elevation #2", errors_predefined: "Errors", grayLightToDark_predefined: "Gray Light to Dark", greenBright_predefined: "Green Bright", greenLightToDark_predefined: "Green Light to Dark", greenToBlue_predefined: "Green to Blue", orangeBright_predefined: "Orange Bright", orangeLightToDark_predefined: "Orange Light to Dark", partialSpectrum_predefined: "Partial Spectrum", partialSpectrum1Diverging_predefined: "Partial Spectrum 1 Diverging", partialSpectrum2Diverging_predefined: "Partial Spectrum 2 Diverging", pinkToYellowGreenDivergingBright_predefined: "Pink to YellowGreen Diverging, Bright", pinkToYellowGreenDivergingDark_predefined: "Pink to YellowGreen Diverging, Dark", precipitation_predefined: "Precipitation", prediction_predefined: "Prediction", purpleBright_predefined: "Purple Bright", purpleToGreenDivergingBright_predefined: "Purple to Green Diverging, Bright", purpleToGreenDivergingDark_predefined: "Purple to Green Diverging, Dark", purpleBlueBright_predefined: "Purple-Blue Bright", purpleBlueLightToDark_predefined: "Purple-Blue Light to Dark", purpleRedBright_predefined: "Purple-Red Bright", purpleRedLightToDark_predefined: "Purple-Red Light to Dark", redBright_predefined: "Red Bright", redLightToDark_predefined: "Red Light to Dark", redToBlueDivergingBright_predefined: "Red to Blue Diverging, Bright", redToBlueDivergingDark_predefined: "Red to Blue Diverging, Dark", redToGreen_predefined: "Red to Green", redToGreenDivergingBright_predefined: "Red to Green Diverging, Bright", redToGreenDivergingDark_predefined: "Red to Green Diverging, Dark", slope_predefined: "Slope", spectrumFullBright_predefined: "Spectrum-Full Bright", spectrumFullDark_predefined: "Spectrum-Full Dark", spectrumFullLight_predefined: "Spectrum-Full Light", surface_predefined: "Surface", temperature_predefined: "Temperature", whiteToBlack_predefined: "White to Black", yellowToDarkRed_predefined: "Yellow to Dark Red", yellowToGreenToDarkBlue_predefined: "Yellow to Green to Dark Blue", yellowToRed_predefined: "Yellow to Red", yellowGreenBright_predefined: "Yellow-Green Bright", yellowGreenLightToDark_predefined: "Yellow-Green Light to Dark" };
var a11 = new s3({ Aspect: "aspect", "Black to White": "black-to-white", "Blue Bright": "blue-bright", "Blue Light to Dark": "blue-light-to-dark", "Blue-Green Bright": "blue-green-bright", "Blue-Green Light to Dark": "blue-green-light-to-dark", "Brown Light to Dark": "brown-light-to-dark", "Brown to Blue Green Diverging, Bright": "brown-to-blue-green-diverging-right", "Brown to Blue Green Diverging, Dark": "brown-to-blue-green-diverging-dark", "Coefficient Bias": "coefficient-bias", "Cold to Hot Diverging": "cold-to-hot-diverging", "Condition Number": "condition-number", "Cyan to Purple": "cyan-to-purple", "Cyan-Light to Blue-Dark": "cyan-light-to-blue-dark", Distance: "distance", "Elevation #1": "elevation1", "Elevation #2": "elevation2", Errors: "errors", "Gray Light to Dark": "gray-light-to-dark", "Green Bright": "green-bright", "Green Light to Dark": "green-light-to-dark", "Green to Blue": "green-to-blue", "Orange Bright": "orange-bright", "Orange Light to Dark": "orange-light-to-dark", "Partial Spectrum": "partial-spectrum", "Partial Spectrum 1 Diverging": "partial-spectrum-1-diverging", "Partial Spectrum 2 Diverging": "partial-spectrum-2-diverging", "Pink to YellowGreen Diverging, Bright": "pink-to-yellow-green-diverging-bright", "Pink to YellowGreen Diverging, Dark": "pink-to-yellow-green-diverging-dark", Precipitation: "precipitation", Prediction: "prediction", "urple Bright": "purple-bright", "Purple to Green Diverging, Bright": "purple-to-green-diverging-bright", "Purple to Green Diverging, Dark": "purple-to-green-diverging-dark", "Purple-Blue Bright": "purple-blue-bright", "Purple-Blue Light to Dark": "purple-blue-light-to-dark", "Purple-Red Bright": "purple-red-bright", "Purple-Red Light to Dark": "purple-red-light-to-dark", "Red Bright": "red-bright", "Red Light to Dark": "red-light-to-dark", "Red to Blue Diverging, Bright": "red-to-blue-diverging-bright", "Red to Blue Diverging, Dark": "red-to-blue-diverging-dark", "Red to Green": "red-to-green", "Red to Green Diverging, Bright": "red-to-green-diverging-bright", "Red to Green Diverging, Dark": "red-to-green-diverging-dark", Slope: "slope", "Spectrum-Full Bright": "spectrum-full-bright", "Spectrum-Full Dark": "spectrum-full-dark", "Spectrum-Full Light": "spectrum-full-light", Surface: "surface", Temperature: "temperature", "White to Black": "white-to-black", "Yellow to Dark Red": "yellow-to-dark-red", "Yellow to Green to Dark Blue": "yellow-to-green-to-dark-blue", "Yellow to Red": "yellow-to-red", "Yellow-Green Bright": "yellow-green-bright", "Yellow-Green Light to Dark": "yellow-green-light-to-dark" });
function g4(o4, r10) {
  if (!o4 || !r10 || o4.length !== r10.length)
    return false;
  for (let e8 = 0; e8 < o4.length; e8++)
    if (o4[e8] > r10[e8] + 2 || o4[e8] < r10[e8] - 2)
      return false;
  return true;
}
function f5(r10, e8) {
  if (!r10)
    return;
  const t7 = e8 || d3;
  let l8 = null;
  return "algorithmic" === r10.type ? t7.some((o4) => {
    if (g4(r10.fromColor.toRgb(), o4.fromColor) && g4(r10.toColor.toRgb(), o4.toColor))
      return l8 = o4.id, true;
  }) : "multipart" === r10.type && t7.some((e9) => {
    const t8 = r10.colorRamps, i7 = e9.colorRamps;
    if (t8 && i7 && t8.length === i7.length && !i7.some((r11, e10) => {
      if (!g4(t8[e10].fromColor.toRgb(), new l2(r11.fromColor).toRgb()) || !g4(t8[e10].toColor.toRgb(), new l2(r11.toColor).toRgb()))
        return true;
    })) {
      if (l8)
        return true;
      l8 = e9.id;
    }
  }), l8;
}
function C3(o4) {
  const r10 = f5(o4);
  return r10 ? p8[r10] : null;
}
function m6(o4) {
  var _a;
  const r10 = a11.toJSON(o4), e8 = (_a = Object.entries(p8).find((o5) => o5[1] === r10)) == null ? void 0 : _a[0], t7 = d3.find((o5) => o5.id === e8);
  return t7 ? t7.colorRamps ? { type: "multipart", colorRamps: t7.colorRamps.map((o5) => ({ type: "algorithmic", algorithm: "esriCIELabAlgorithm", fromColor: o5.fromColor, toColor: o5.toColor })) } : { type: "algorithmic", algorithm: "esriCIELabAlgorithm", fromColor: t7.fromColor, toColor: t7.toColor } : null;
}
function u7(o4) {
  const r10 = (o4 = o4 || {}).numColors || 256, e8 = o4.distanceOffset || 0, t7 = null != o4.isCustomInterval ? o4.isCustomInterval : null !== o4.distanceInterval && o4.distanceInterval !== 1 / (r10 - 1), l8 = o4.distanceInterval || 1 / (r10 - 1);
  return { ...o4, numColors: r10, distanceOffset: e8, interpolateAlpha: !!o4.interpolateAlpha, distanceInterval: l8, isCustomInterval: t7, weights: o4.weights };
}
function h5(o4, r10, e8) {
  const { numColors: t7, distanceOffset: l8, distanceInterval: i7, isCustomInterval: n9 } = e8, d4 = 0 === o4.s, p9 = 0 === r10.s;
  let a12 = o4.h, g5 = r10.h;
  d4 && !p9 ? a12 = g5 : p9 && !d4 && (r10 = { ...r10, h: a12 }, g5 = a12);
  let f6, C4 = Math.abs(g5 - a12);
  const m7 = 360;
  C4 < m7 / 2 ? f6 = (g5 - a12) * i7 : (C4 = m7 - C4, f6 = a12 > g5 ? C4 * i7 : -C4 * i7);
  const u8 = (r10.s - o4.s) * i7, h6 = (r10.v - o4.v) * i7;
  let { s: c6, v: s9 } = o4, D4 = a12;
  if (l8) {
    const o5 = l8 / i7;
    D4 = (D4 + o5 * f6 + m7) % m7, c6 += o5 * u8, s9 += o5 * h6;
  }
  const B3 = [];
  for (let k4 = 0; k4 < t7 - 1; k4++)
    B3.push({ h: D4, s: c6, v: s9 }), D4 = (D4 + f6 + m7) % m7, c6 += u8, s9 += h6;
  return B3.push(n9 ? { h: D4, s: c6, v: s9 } : r10), B3;
}
function c5(o4, r10, e8) {
  const { numColors: t7, distanceOffset: l8, distanceInterval: i7, isCustomInterval: n9 } = e8;
  let { l: d4, a: p9, b: a12 } = o4;
  const g5 = (r10.l - d4) * i7, f6 = (r10.a - p9) * i7, C4 = (r10.b - a12) * i7, m7 = [];
  if (l8) {
    const o5 = l8 / i7;
    d4 += o5 * g5, p9 += o5 * f6, a12 += o5 * C4;
  }
  for (let u8 = 0; u8 < t7 - 1; u8++)
    m7.push({ l: d4, a: p9, b: a12 }), d4 += g5, p9 += f6, a12 += C4;
  return m7.push(n9 ? { l: d4, a: p9, b: a12 } : r10), m7;
}
function s8(o4, r10, e8) {
  const { numColors: t7, distanceOffset: l8, distanceInterval: i7, isCustomInterval: n9 } = e8, d4 = o4.h, p9 = r10.h, a12 = 2 * Math.PI;
  let g5;
  if (d4 <= p9) {
    const o5 = p9 - d4, r11 = p9 - d4 - a12;
    g5 = Math.abs(r11) < Math.abs(o5) ? r11 : o5;
  } else {
    const o5 = p9 + a12 - d4, r11 = p9 - d4;
    g5 = Math.abs(r11) < Math.abs(o5) ? r11 : o5;
  }
  const f6 = g5 * i7, C4 = (r10.l - o4.l) * i7, m7 = (r10.c - o4.c) * i7;
  let { l: u8, c: h6, h: c6 } = o4;
  if (l8) {
    const o5 = l8 / i7;
    u8 += o5 * C4, h6 += o5 * m7, c6 = (c6 + o5 * f6 + a12) % a12;
  }
  const s9 = [];
  for (let D4 = 0; D4 < t7 - 1; D4++)
    s9.push({ l: u8, c: h6, h: c6 }), u8 += C4, h6 += m7, c6 = (c6 + f6 + a12) % a12;
  return s9.push(n9 ? { l: u8, c: h6, h: c6 } : r10), s9;
}
function D3(o4, i7) {
  let { fromColor: n9, toColor: d4 } = o4;
  3 === n9.length && (n9 = n9.concat([255])), 3 === d4.length && (d4 = d4.concat([255]));
  const p9 = o4.algorithm || "esriCIELabAlgorithm", a12 = u7(i7), { numColors: g5, distanceOffset: f6, isCustomInterval: C4, interpolateAlpha: m7 } = a12;
  if (1 === g5 && 0 === f6)
    return [n9];
  if (2 === g5 && 0 === f6 && !C4)
    return [n9, d4];
  const D4 = { r: n9[0], g: n9[1], b: n9[2] }, B3 = { r: d4[0], g: d4[1], b: d4[2] }, k4 = "esriCIELabAlgorithm" === p9 ? c5(z(D4), z(B3), a12) : "esriHSVAlgorithm" === p9 ? h5(y2(D4), y2(B3), a12) : s8(v(D4), v(B3), a12), _3 = [], v6 = n9[3] ?? 255, R3 = ((d4[3] ?? 255) - v6) / (g5 - 1);
  for (let r10 = 0; r10 < g5; r10++) {
    const { r: o5, g: e8, b: t7 } = p3(k4[r10]), i8 = m7 ? Math.round(v6 + R3 * r10) : 255;
    _3.push([o5, e8, t7, i8]);
  }
  return _3;
}
function B2(o4, r10) {
  const { numColors: e8, interpolateAlpha: t7 } = u7(r10);
  let l8 = r10 == null ? void 0 : r10.weights;
  const { colorRamps: i7 } = o4;
  if (l8) {
    const o5 = l8.reduce((o6, r11) => o6 + r11);
    l8 = l8.map((r11) => r11 / o5);
  } else {
    l8 = [];
    for (let o5 = 0; o5 < i7.length; o5++)
      l8[o5] = 1 / i7.length;
  }
  const n9 = [];
  let d4 = 0, p9 = 0;
  const a12 = 1 / (e8 - 1);
  let g5 = false;
  for (let C4 = 0; C4 < i7.length; C4++) {
    let o5 = g5 ? 0 : d4 * a12 - p9, r11 = C4 === i7.length - 1 ? e8 - 1 - d4 : (l8[C4] - o5) / a12;
    if (g5 = Math.ceil(r11) === r11, r11 = Math.ceil(r11), 0 === r11)
      continue;
    o5 /= l8[C4];
    const f7 = D3(i7[C4], { numColors: r11, interpolateAlpha: t7, distanceOffset: o5, distanceInterval: a12 / l8[C4] });
    d4 += f7.length, n9.push(...f7), p9 += l8[C4];
  }
  const f6 = [...i7[i7.length - 1].toColor];
  return 3 === f6.length && f6.push(255), n9.push(f6), n9;
}
function k3(o4, r10) {
  const e8 = "toJSON" in o4 ? o4.toJSON() : o4;
  return "multipart" === e8.type ? B2(e8, r10) : D3(e8, r10);
}
function _(o4, r10) {
  const e8 = k3(o4, r10), t7 = r10 == null ? void 0 : r10.interpolateAlpha;
  return e8.forEach((o5, r11) => {
    o5.unshift(r11), t7 || o5.pop();
  }), e8;
}
function v4(o4) {
  const r10 = C3(o4);
  if (o4) {
    if ("algorithmic" === o4.type)
      return { ...R2(o4), Name: r10 };
    if (o4.colorRamps) {
      const e8 = o4.colorRamps.map(R2);
      return { type: "MultiPartColorRamp", NumColorRamps: e8.length, ArrayOfColorRamp: e8, Name: r10 };
    }
  }
}
function R2(o4) {
  var _a;
  if (!o4)
    return;
  return { Algorithm: ((_a = o4.toJSON()) == null ? void 0 : _a.Algorithm) || "esriHSVAlgorithm", type: "AlgorithmicColorRamp", FromColor: b3(o4.fromColor), ToColor: b3(o4.toColor) };
}
function b3(o4) {
  const e8 = y2(o4);
  return { type: "HsvColor", Hue: e8.h, Saturation: e8.s, Value: e8.v, AlphaValue: 255 };
}
function y6(o4) {
  const r10 = o4.reverse().map((o5) => {
    const r11 = o5.toString(16);
    return r11.length < 2 ? "0" + r11 : r11;
  });
  return 4294967295 & Number.parseInt(r10.join(""), 16);
}

// node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js
function L2(e8, t7) {
  const { attributeTable: r10, bandCount: s9 } = e8;
  if (t(r10) || s9 > 1)
    return false;
  if (t7) {
    if (null == r10.fields.find((e9) => e9.name.toLowerCase() === t7.toLowerCase()))
      return false;
  }
  return true;
}
function _2(e8) {
  const { bandCount: t7, dataType: r10, pixelType: s9 } = e8;
  return "elevation" === r10 || "generic" === r10 && 1 === t7 && ("s16" === s9 || "f32" === s9 || "f64" === s9);
}
function V2(e8) {
  const { bandCount: t7, colormap: r10 } = e8;
  return r(r10) && r10.length > 0 && 1 === t7;
}
var v5 = class extends l {
  constructor(e8) {
    super(e8);
  }
  bind() {
    const { rendererJSON: e8 } = this;
    if (!e8)
      return { success: false };
    let t7;
    switch (this.lookup = { rendererJSON: {} }, e8.type) {
      case "uniqueValue":
        t7 = this._updateUVRenderer(e8);
        break;
      case "rasterColormap":
        t7 = this._updateColormapRenderer(e8);
        break;
      case "rasterStretch":
        t7 = this._updateStretchRenderer(e8);
        break;
      case "classBreaks":
        t7 = this._updateClassBreaksRenderer(e8);
        break;
      case "rasterShadedRelief":
        t7 = this._updateShadedReliefRenderer(e8);
        break;
      case "vectorField":
        t7 = this._updateVectorFieldRenderer();
        break;
      case "flowRenderer":
        t7 = this._updateFlowRenderer();
    }
    return t7;
  }
  symbolize(e8) {
    let t7 = e8 && e8.pixelBlock;
    if (!O3(t7))
      return t7;
    if (e8.simpleStretchParams && "rasterStretch" === this.rendererJSON.type)
      return this.simpleStretch(t7, e8.simpleStretchParams);
    try {
      let r10;
      switch (t7.pixels.length > 3 && (t7 = h(t7, [0, 1, 2])), this.rendererJSON.type) {
        case "uniqueValue":
        case "rasterColormap":
          r10 = this._symbolizeColormap(t7);
          break;
        case "classBreaks":
          r10 = this._symbolizeClassBreaks(t7);
          break;
        case "rasterStretch":
          r10 = this._symbolizeStretch(t7, e8.bandIds);
          break;
        case "rasterShadedRelief": {
          const s9 = e8.extent, o4 = s9.spatialReference.isGeographic, a12 = { x: (s9.xmax - s9.xmin) / t7.width, y: (s9.ymax - s9.ymin) / t7.height };
          r10 = this._symbolizeShadedRelief(t7, { isGCS: o4, resolution: a12 });
          break;
        }
      }
      return r10;
    } catch (r10) {
      return s.getLogger(this.declaredClass).error("symbolize", r10.message), t7;
    }
  }
  simpleStretch(e8, t7) {
    if (!O3(e8))
      return e8;
    try {
      return e8.pixels.length > 3 && (e8 = h(e8, [0, 1, 2])), y5(e8, { ...t7, isRenderer: true });
    } catch (r10) {
      return s.getLogger(this.declaredClass).error("symbolize", r10.message), e8;
    }
  }
  generateWebGLParameters(e8) {
    if (["uniqueValue", "rasterColormap", "classBreaks"].includes(this.rendererJSON.type)) {
      const { indexedColormap: e9, offset: t8 } = this.lookup.colormapLut || {};
      return { colormap: e9, colormapOffset: t8, type: "lut" };
    }
    const { pixelBlock: t7, isGCS: r10, resolution: s9, bandIds: o4 } = e8, { rendererJSON: a12 } = this;
    return "rasterStretch" === a12.type ? this._generateStretchWebGLParams(t7, a12, o4) : "rasterShadedRelief" === a12.type ? this._generateShadedReliefWebGLParams(a12, r10, s9 ?? void 0) : "vectorField" === a12.type ? this._generateVectorFieldWebGLParams(a12) : null;
  }
  _isLUTChanged(e8) {
    if (!this.lookup || !this.lookup.rendererJSON)
      return true;
    if ("colorRamp" in this.rendererJSON) {
      const t7 = this.rendererJSON.colorRamp;
      return e8 ? JSON.stringify(t7) !== JSON.stringify(this.lookup.rendererJSON.colorRamp) : (this.rendererJSON, this.lookup.rendererJSON, JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON));
    }
    return JSON.stringify(this.rendererJSON) !== JSON.stringify(this.lookup.rendererJSON);
  }
  _symbolizeColormap(e8) {
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return u2(e8, this.lookup.colormapLut);
  }
  _symbolizeClassBreaks(e8) {
    const { canUseIndexedLUT: t7 } = this._analyzeClassBreaks(this.rendererJSON);
    if (this._isLUTChanged()) {
      if (!this.bind().success)
        return e8;
    }
    return t7 ? u2(e8, this.lookup.colormapLut) : m2(e8, this.lookup.remapLut ?? []);
  }
  _symbolizeStretch(e8, t7) {
    var _a, _b, _c;
    const { rasterInfo: r10 } = this, { pixelType: s9, bandCount: a12 } = r10, n9 = this.rendererJSON, i7 = ["u8", "u16", "s8", "s16"].includes(s9);
    let l8, u8;
    const { dra: c6 } = n9, { gamma: d4 } = this.lookup;
    if ("histogramEqualization" === n9.stretchType) {
      const s10 = c6 ? null : (_a = this.lookup) == null ? void 0 : _a.histogramLut, o4 = x3(n9, { rasterInfo: r10, pixelBlock: e8, bandIds: t7, returnHistogramLut: !s10 }), a13 = y5(e8, { ...o4, gamma: d4, isRenderer: true });
      u8 = p4(a13, { lut: c6 ? o4.histogramLut : s10, offset: 0 });
    } else if (i7) {
      if (c6) {
        const o4 = x3(n9, { rasterInfo: r10, pixelBlock: e8, bandIds: t7 });
        l8 = u5({ pixelType: s9, ...o4, gamma: d4, rounding: "floor" });
      } else if (this._isLUTChanged()) {
        if (!this.bind().success)
          return e8;
        l8 = this.lookup ? this.lookup.stretchLut : null;
      } else
        l8 = this.lookup ? this.lookup.stretchLut : null;
      if (!l8)
        return e8;
      a12 > 1 && (t7 == null ? void 0 : t7.length) === ((_b = e2(e8)) == null ? void 0 : _b.pixels.length) && (l8 == null ? void 0 : l8.lut.length) === a12 && (l8 = { lut: t7.map((e9) => l8.lut[e9]), offset: l8.offset }), u8 = p4(e8, l8);
    } else {
      const s10 = x3(n9, { rasterInfo: r10, pixelBlock: e8, bandIds: t7 });
      u8 = y5(e8, { ...s10, gamma: d4, isRenderer: true });
    }
    if (n9.colorRamp) {
      if (this._isLUTChanged(true)) {
        if (!this.bind().success)
          return e8;
      }
      u8 = u2(u8, (_c = this.lookup) == null ? void 0 : _c.colormapLut);
    }
    return u8;
  }
  _symbolizeShadedRelief(e8, t7) {
    var _a;
    const r10 = this.rendererJSON, s9 = { ...r10, ...t7 }, a12 = l7(e8, s9);
    if (!r10.colorRamp)
      return a12;
    let n9;
    if (this._isLUTChanged(true)) {
      if (!this.bind().success)
        return a12;
      n9 = this.lookup ? this.lookup.hsvMap : null;
    } else
      n9 = this.lookup ? this.lookup.hsvMap : null;
    if (!n9)
      return a12;
    const i7 = ((_a = e2(this.rasterInfo.statistics)) == null ? void 0 : _a[0]) ?? { min: 0, max: 8e3 };
    return s7(a12, e8, n9, i7), a12;
  }
  _isVectorFieldData() {
    const { bandCount: e8, dataType: t7 } = this.rasterInfo;
    return 2 === e8 && ("vector-magdir" === t7 || "vector-uv" === t7);
  }
  _updateVectorFieldRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateFlowRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateUVRenderer(e8) {
    var _a;
    const { bandCount: t7, attributeTable: r10, pixelType: s9 } = this.rasterInfo, o4 = e8.field1;
    if (!o4)
      return { success: false, error: "Unsupported renderer; missing UniqueValueRenderer.field." };
    const n9 = e8.defaultSymbol, i7 = 1 === t7 && ["u8", "s8"].includes(s9);
    if (!L2(this.rasterInfo, o4) && !i7)
      return { success: false, error: "Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table." };
    const l8 = [];
    if (r(r10)) {
      const t8 = r10.fields.find((e9) => "value" === e9.name.toLowerCase());
      if (!t8)
        return { success: false, error: "Unsupported data; the data's raster attribute table does not have a value field." };
      r10.features.forEach((r11) => {
        var _a2, _b;
        const s10 = (_a2 = e8.uniqueValueInfos) == null ? void 0 : _a2.find((e9) => String(e9.value) === String(r11.attributes[o4])), a12 = (_b = s10 == null ? void 0 : s10.symbol) == null ? void 0 : _b.color;
        a12 ? l8.push([r11.attributes[t8.name]].concat(a12)) : n9 && l8.push([r11.attributes[t8.name]].concat(n9.color));
      });
    } else {
      if ("value" !== o4.toLowerCase())
        return { success: false, error: 'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not availalbe.' };
      (_a = e8.uniqueValueInfos) == null ? void 0 : _a.forEach((e9) => {
        var _a2;
        const t8 = (_a2 = e9 == null ? void 0 : e9.symbol) == null ? void 0 : _a2.color;
        t8 ? l8.push([parseInt("" + e9.value, 10)].concat(t8)) : n9 && l8.push([parseInt("" + e9.value, 10)].concat(n9 == null ? void 0 : n9.color));
      });
    }
    if (0 === l8.length)
      return { success: false, error: "Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table." };
    const u8 = c({ colormap: l8 });
    return this.lookup = { rendererJSON: e8, colormapLut: u8 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateColormapRenderer(e8) {
    if (!V2(this.rasterInfo))
      return { success: false, error: "Unsupported data; the data source does not have a colormap." };
    const t7 = e8.colormapInfos.map((e9) => [e9.value].concat(e9.color)).sort((e9, t8) => e9[0] - t8[0]);
    if (!t7 || 0 === t7.length)
      return { success: false, error: "Unsupported renderer; ColormapRenderer must have meaningful colormapInfos." };
    const r10 = c({ colormap: t7 });
    return this.lookup = { rendererJSON: e8, colormapLut: r10 }, this.canRenderInWebGL = true, { success: true };
  }
  _updateShadedReliefRenderer(e8) {
    if (!_2(this.rasterInfo))
      return { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.` };
    if (e8.colorRamp) {
      const r10 = _(e8.colorRamp, { interpolateAlpha: true }), s9 = c({ colormap: r10 }), o4 = [], a12 = s9.indexedColormap;
      for (let e9 = 0; e9 < a12.length; e9 += 4) {
        const r11 = y2({ r: a12[e9], g: a12[e9 + 1], b: a12[e9 + 2] });
        o4.push([r11.h / 60, r11.s / 100, 255 * r11.v / 100]);
      }
      this.lookup = { rendererJSON: e8, colormapLut: s9, hsvMap: o4 };
    } else
      this.lookup = null;
    return this.canRenderInWebGL = true, { success: true };
  }
  _analyzeClassBreaks(e8) {
    const { attributeTable: t7, pixelType: r10 } = this.rasterInfo, s9 = r(t7) ? t7.fields.find((e9) => "value" === e9.name.toLowerCase()) : null, o4 = r(t7) ? t7.fields.find((t8) => t8.name.toLowerCase() === e8.field.toLowerCase()) : null, n9 = null != s9 && null !== o4;
    return { canUseIndexedLUT: ["u8", "u16", "s8", "s16"].includes(r10) || n9, tableValueField: s9, tableBreakField: o4 };
  }
  _updateClassBreaksRenderer(e8) {
    const { attributeTable: t7 } = this.rasterInfo, { canUseIndexedLUT: r10, tableValueField: s9, tableBreakField: o4 } = this._analyzeClassBreaks(e8), n9 = e8.classBreakInfos;
    if (!(n9 == null ? void 0 : n9.length))
      return { success: false, error: "Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos." };
    const i7 = n9.sort((e9, t8) => e9.classMaxValue - t8.classMaxValue), l8 = i7[i7.length - 1];
    let u8 = e8.minValue;
    if (!r10) {
      const t8 = [];
      for (let e9 = 0; e9 < i7.length; e9++)
        t8.push({ value: i7[e9].classMinValue ?? u8, mappedColor: i7[e9].symbol.color }), u8 = i7[e9].classMaxValue;
      return t8.push({ value: l8.classMaxValue, mappedColor: l8.symbol.color }), this.lookup = { rendererJSON: e8, remapLut: t8 }, this.canRenderInWebGL = false, { success: true };
    }
    const c6 = [];
    if (r(t7) && null != s9 && null !== o4 && s9 !== o4) {
      const r11 = s9.name, a12 = o4.name, n10 = i7[i7.length - 1], { classMaxValue: l9 } = n10;
      u8 = e8.minValue;
      for (const e9 of t7.features) {
        const t8 = e9.attributes[r11], s10 = e9.attributes[a12], o5 = s10 === l9 ? n10 : s10 < u8 ? null : i7.find(({ classMaxValue: e10 }) => e10 > s10);
        o5 && c6.push([t8].concat(o5.symbol.color));
      }
    } else {
      u8 = Math.floor(e8.minValue);
      for (let e9 = 0; e9 < i7.length; e9++) {
        const t8 = i7[e9];
        for (let e10 = u8; e10 < t8.classMaxValue; e10++)
          c6.push([e10].concat(t8.symbol.color));
        u8 = Math.ceil(t8.classMaxValue);
      }
      l8.classMaxValue === u8 && c6.push([l8.classMaxValue].concat(l8.symbol.color));
    }
    const p9 = c({ colormap: c6, fillUnspecified: false });
    return this.lookup = { rendererJSON: e8, colormapLut: p9 }, this.canRenderInWebGL = true, { success: true };
  }
  _isHistogramRequired(e8) {
    return "percentClip" === e8 || "histogramEqualization" === e8;
  }
  _isValidRasterStatistics(e8) {
    return r(e8) && e8.length > 0 && null != e8[0].min && null != e8[0].max;
  }
  _updateStretchRenderer(e8) {
    var _a, _b;
    let { stretchType: t7, dra: r10 } = e8;
    if (!("none" === t7 || ((_a = e8.statistics) == null ? void 0 : _a.length) || this._isValidRasterStatistics(this.rasterInfo.statistics) || r10))
      return { success: false, error: "Unsupported renderer; StretchRenderer.statistics is required when dynamic range adjustment is not used." };
    const s9 = e2(e8.histograms || this.rasterInfo.histograms);
    !this._isHistogramRequired(e8.stretchType) || (s9 == null ? void 0 : s9.length) || r10 || (t7 = "minMax");
    const { computeGamma: a12, useGamma: n9, colorRamp: i7 } = e8;
    let { gamma: l8 } = e8;
    if (n9 && a12 && !(l8 == null ? void 0 : l8.length)) {
      const t8 = ((_b = e8.statistics) == null ? void 0 : _b.length) ? e8.statistics : e2(this.rasterInfo.statistics);
      l8 = c4(this.rasterInfo.pixelType, t8);
    }
    const u8 = this.rasterInfo.pixelType, c6 = !r10 && ["u8", "u16", "s8", "s16"].includes(u8);
    if ("histogramEqualization" === t7) {
      const t8 = s9.map((e9) => f4(e9));
      this.lookup = { rendererJSON: e8, histogramLut: t8 };
    } else if (c6) {
      const t8 = x3(e8, { rasterInfo: this.rasterInfo }), r11 = u5({ pixelType: u8, ...t8, gamma: n9 ? l8 : null, rounding: "floor" });
      this.lookup = { rendererJSON: e8, stretchLut: r11 };
    }
    if (i7) {
      const t8 = _(i7, { interpolateAlpha: true });
      this.lookup || (this.lookup = { rendererJSON: e8 }), this.lookup.colormapLut = c({ colormap: t8 }), this.lookup.rendererJSON = e8;
    }
    return this.lookup.gamma = n9 && (l8 == null ? void 0 : l8.length) ? l8 : null, this.canRenderInWebGL = true, { success: true };
  }
  _generateStretchWebGLParams(e8, t7, r10) {
    let s9 = null, o4 = null;
    const n9 = this.lookup && this.lookup.colormapLut;
    t7.colorRamp && n9 && (s9 = n9.indexedColormap, o4 = n9.offset), "histogramEqualization" === t7.stretchType && (t7 = { ...t7, stretchType: "minMax" });
    const { gamma: i7 } = this.lookup, l8 = !!(t7.useGamma && i7 && i7.some((e9) => 1 !== e9)), { minCutOff: u8, maxCutOff: c6, outMin: p9, outMax: d4 } = x3(t7, { rasterInfo: this.rasterInfo, pixelBlock: e8, bandIds: r10 });
    let h6 = 0;
    r(e8) && (h6 = e8.getPlaneCount(), 2 === h6 && ((e8 = e8.clone()).statistics = [e8.statistics[0]], e8.pixels = [e8.pixels[0]]));
    const { bandCount: m7 } = this.rasterInfo, f6 = Math.min(3, (r10 == null ? void 0 : r10.length) || h6 || m7, m7), y7 = new Float32Array(f6), g5 = s9 || l8 ? 1 : 255;
    let S4;
    for (S4 = 0; S4 < u8.length; S4++)
      y7[S4] = c6[S4] === u8[S4] ? 0 : (d4 - p9) / (c6[S4] - u8[S4]) / g5;
    const k4 = new Float32Array(f6);
    if (l8 && i7)
      for (S4 = 0; S4 < f6; S4++)
        i7[S4] > 1 ? i7[S4] > 2 ? k4[S4] = 6.5 + (i7[S4] - 2) ** 2.5 : k4[S4] = 6.5 + 100 * (2 - i7[S4]) ** 4 : k4[S4] = 1;
    return { bandCount: f6, outMin: p9 / g5, outMax: d4 / g5, minCutOff: u8, maxCutOff: c6, factor: y7, useGamma: l8, gamma: l8 ? i7 : [1, 1, 1], gammaCorrection: l8 ? k4 : [1, 1, 1], colormap: s9, colormapOffset: o4, stretchType: t7.stretchType, type: "stretch" };
  }
  _generateShadedReliefWebGLParams(e8, t7 = false, r10 = { x: 0, y: 0 }) {
    var _a;
    let s9 = null, a12 = null;
    const n9 = this.lookup && this.lookup.colormapLut;
    e8.colorRamp && n9 && (s9 = n9.indexedColormap, a12 = n9.offset);
    const i7 = { ...e8, isGCS: t7, resolution: r10 }, l8 = n7(i7), u8 = (_a = e2(this.rasterInfo.statistics)) == null ? void 0 : _a[0];
    return { ...l8, minValue: (u8 == null ? void 0 : u8.min) ?? 0, maxValue: (u8 == null ? void 0 : u8.max) ?? 8e3, hillshadeType: "traditional" === e8.hillshadeType ? 0 : 1, type: "hillshade", colormap: s9, colormapOffset: a12 };
  }
  _generateVectorFieldWebGLParams(e8) {
    var _a, _b, _c;
    const { style: t7, inputUnit: r10, outputUnit: s9, visualVariables: o4, symbolTileSize: n9, flowRepresentation: i7 } = e8;
    let l8;
    const u8 = ((_a = this.rasterInfo.statistics) == null ? void 0 : _a[0].min) ?? 0, c6 = ((_b = this.rasterInfo.statistics) == null ? void 0 : _b[0].max) ?? 50, p9 = (o4 == null ? void 0 : o4.find((e9) => "sizeInfo" === e9.type)) ?? { type: "sizeInfo", field: "Magnitude", maxDataValue: c6, maxSize: 0.8 * n9, minDataValue: u8, minSize: 0.2 * n9 }, d4 = p9.minDataValue ?? u8, h6 = p9.maxDataValue ?? c6, m7 = r(p9.maxSize) && r(p9.minSize) ? [p9.minSize / n9, p9.maxSize / n9] : [0.2, 0.8];
    if ("wind_speed" === t7) {
      const e9 = (m7[0] + m7[1]) / 2;
      m7[0] = m7[1] = e9;
    }
    const f6 = r(d4) && r(h6) ? [d4, h6] : null;
    if ("classified_arrow" === t7)
      if (r(d4) && r(h6) && r(p9)) {
        l8 = [];
        const e9 = (p9.maxDataValue - p9.minDataValue) / 5;
        for (let t8 = 0; t8 < 6; t8++)
          l8.push(p9.minDataValue + e9 * t8);
      } else
        l8 = [0, 1e-6, 3.5, 7, 10.5, 14];
    const y7 = "flow_to" === i7 === ("ocean_current_kn" === t7 || "ocean_current_m" === t7) ? 0 : Math.PI, b4 = o4 == null ? void 0 : o4.find((e9) => "rotationInfo" === e9.type);
    return { breakValues: l8, dataRange: f6, inputUnit: r10, outputUnit: s9, symbolTileSize: n9, symbolPercentRange: m7, style: t7 || "single_arrow", rotation: y7, rotationType: ((_c = this.rasterInfo.storageInfo) == null ? void 0 : _c.tileInfo) && "vector-uv" === this.rasterInfo.dataType ? "geographic" : (b4 == null ? void 0 : b4.rotationType) || e8.rotationType, type: "vectorField" };
  }
};
function O3(e8) {
  return a4(e8) && 0 !== e8.validPixelCount;
}
e([y({ json: { write: true } })], v5.prototype, "rendererJSON", void 0), e([y({ type: u6, json: { write: true } })], v5.prototype, "rasterInfo", void 0), e([y({ json: { write: true } })], v5.prototype, "lookup", void 0), e([y()], v5.prototype, "canRenderInWebGL", void 0), v5 = e([a2("esri.renderers.support.RasterSymbolizer")], v5);
var T3 = v5;

export {
  n8 as n,
  d3 as d,
  a11 as a,
  C3 as C,
  m6 as m,
  k3 as k,
  _,
  v4 as v,
  y6 as y,
  n5 as n2,
  a8 as a2,
  n6 as n3,
  u6 as u,
  r8 as r,
  n4,
  r9 as r2,
  L,
  R,
  D,
  N,
  U,
  v2,
  B,
  j,
  S3 as S,
  u5 as u2,
  p6 as p,
  g3 as g,
  x3 as x,
  M2 as M,
  y5 as y2,
  a10 as a3,
  o3 as o,
  T3 as T
};
//# sourceMappingURL=chunk-KEBXREDC.js.map

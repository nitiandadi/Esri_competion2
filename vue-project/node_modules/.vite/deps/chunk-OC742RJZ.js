import {
  m
} from "./chunk-JT54I3AY.js";
import {
  R,
  w2 as w
} from "./chunk-XFNXUG2G.js";
import {
  s as s3
} from "./chunk-RDTHWDIE.js";
import {
  s as s4
} from "./chunk-QXPN4D5D.js";
import {
  l
} from "./chunk-KGIB6IYW.js";
import {
  a2 as a,
  e as e2,
  y3 as y
} from "./chunk-3PPVODAA.js";
import {
  f
} from "./chunk-WTKFW2TD.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  has,
  p
} from "./chunk-PR6SXADK.js";
import {
  t as t2
} from "./chunk-MGJMBJDY.js";
import {
  e,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l2 = class {
  constructor(l4 = null, a4 = null, t4 = null) {
    this.minValue = l4, this.maxValue = a4, this.noDataValue = t4;
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js
var t3 = 9999999e31;
var e3 = 2e-7;
var n = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34028234663852886e22, 34028234663852886e22], f64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
function s5(t4) {
  return n[t4] ?? [-34028234663852886e22, 34028234663852886e22];
}
function u(n2, u6, a4) {
  if (n2.depthCount && n2.depthCount > 1)
    return;
  const { pixels: i, statistics: l4, pixelType: o2 } = n2, r3 = i[0].length, f5 = n2.bandMasks ?? [], c4 = n2.mask ?? new Uint8Array(r3).fill(255), b3 = "f32" === o2 || "f64" === o2, m6 = s5(o2);
  let h4 = false;
  for (let s9 = 0; s9 < i.length; s9++) {
    const n3 = "number" == typeof u6 ? u6 : u6[s9];
    if (null == n3)
      continue;
    const p5 = (l4 == null ? void 0 : l4[s9].minValue) ?? m6[0], N = (l4 == null ? void 0 : l4[s9].maxValue) ?? m6[1];
    if (p5 > n3 + Number.EPSILON || N < n3 - Number.EPSILON)
      continue;
    const M4 = f5[s9] || new Uint8Array(r3).fill(255), d4 = i[s9], A3 = a4 == null ? void 0 : a4.customFloatTolerance;
    if (b3 && 0 !== A3) {
      let s10 = A3;
      s10 || (s10 = Math.abs(n3) >= t3 ? e3 * Math.abs(n3) : "f32" === o2 ? 2 ** -23 : Number.EPSILON);
      for (let t4 = 0; t4 < d4.length; t4++)
        M4[t4] && Math.abs(d4[t4] - n3) < s10 && (d4[t4] = 0, M4[t4] = 0, c4[t4] = 0, h4 = true);
    } else
      for (let t4 = 0; t4 < d4.length; t4++)
        M4[t4] && d4[t4] === n3 && (d4[t4] = 0, M4[t4] = 0, c4[t4] = 0, h4 = true);
    f5[s9] = M4;
  }
  h4 && (n2.bandMasks = f5, n2.mask = c4), h4 && "updateStatistics" in n2 && n2.updateStatistics();
}

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var u2;
var g = u2 = class extends l {
  static createEmptyBand(t4, e4) {
    return new (u2.getPixelArrayConstructor(t4))(e4);
  }
  static getPixelArrayConstructor(t4) {
    let e4;
    switch (t4) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e4 = Uint8Array;
        break;
      case "u16":
        e4 = Uint16Array;
        break;
      case "u32":
        e4 = Uint32Array;
        break;
      case "s8":
        e4 = Int8Array;
        break;
      case "s16":
        e4 = Int16Array;
        break;
      case "s32":
        e4 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e4 = Float32Array;
        break;
      case "f64":
        e4 = Float64Array;
    }
    return e4;
  }
  constructor(t4) {
    super(t4), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.premultiplyAlpha = false, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t4) {
    if (!t4)
      return "f32";
    let e4 = t4.toLowerCase();
    return ["u1", "u2", "u4"].includes(e4) ? e4 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e4) || (e4 = "f32"), e4;
  }
  getPlaneCount() {
    var _a;
    return (_a = this.pixels) == null ? void 0 : _a.length;
  }
  addData(t4) {
    if (!t4.pixels || t4.pixels.length !== this.width * this.height)
      throw new s2("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t4.pixels), this.statistics.push(t4.statistics ?? new l2());
  }
  getAsRGBA() {
    const t4 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t4);
        break;
      default:
        this._fillFrom8Bit(t4);
    }
    return new Uint8ClampedArray(t4);
  }
  getAsRGBAFloat() {
    const t4 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t4), t4;
  }
  updateStatistics() {
    if (!this.pixels)
      return;
    this.statistics = this.pixels.map((t5) => this._calculateBandStatistics(t5, this.mask));
    const t4 = this.mask;
    let e4 = 0;
    if (r(t4))
      for (let s9 = 0; s9 < t4.length; s9++)
        t4[s9] && e4++;
    else
      e4 = this.width * this.height;
    this.validPixelCount = e4;
  }
  clamp(t4) {
    if (!t4 || "f64" === t4 || "f32" === t4 || !this.pixels)
      return;
    const [e4, s9] = s5(t4), i = this.pixels, l4 = this.width * this.height, r3 = i.length;
    let o2, a4, h4;
    const n2 = [];
    for (let p5 = 0; p5 < r3; p5++) {
      h4 = u2.createEmptyBand(t4, l4), o2 = i[p5];
      for (let t5 = 0; t5 < l4; t5++)
        a4 = o2[t5], h4[t5] = a4 > s9 ? s9 : a4 < e4 ? e4 : a4;
      n2.push(h4);
    }
    this.pixels = n2, this.pixelType = t4;
  }
  extractBands(t4) {
    const { pixels: e4, statistics: s9 } = this;
    if (t(t4) || 0 === t4.length || !e4 || 0 === e4.length)
      return this;
    const i = e4.length, l4 = t4.some((t5) => t5 >= e4.length), r3 = i === t4.length && !t4.some((t5, e5) => t5 !== e5);
    return l4 || r3 ? this : new u2({ pixelType: this.pixelType, width: this.width, height: this.height, mask: this.mask, validPixelCount: this.validPixelCount, maskIsAlpha: this.maskIsAlpha, pixels: t4.map((t5) => e4[t5]), statistics: s9 && t4.map((t5) => s9[t5]) });
  }
  clone() {
    const t4 = new u2({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e4;
    r(this.mask) && (this.mask instanceof Uint8Array ? t4.mask = new Uint8Array(this.mask) : t4.mask = this.mask.slice(0));
    const s9 = u2.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t4.pixels = [];
      const i = !!this.pixels[0].slice;
      for (e4 = 0; e4 < this.pixels.length; e4++)
        t4.pixels[e4] = i ? this.pixels[e4].slice(0, this.pixels[e4].length) : new s9(this.pixels[e4]);
    }
    if (this.statistics)
      for (t4.statistics = [], e4 = 0; e4 < this.statistics.length; e4++)
        t4.statistics[e4] = p(this.statistics[e4]);
    return t4.premultiplyAlpha = this.premultiplyAlpha, t4;
  }
  _fillFrom8Bit(t4) {
    const { mask: e4, maskIsAlpha: s9, premultiplyAlpha: i, pixels: o2 } = this;
    if (!t4 || !o2 || !o2.length)
      return void s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let a4, h4, n2, p5;
    a4 = h4 = n2 = o2[0], o2.length >= 3 ? (h4 = o2[1], n2 = o2[2]) : 2 === o2.length && (h4 = o2[1]);
    const c4 = new Uint32Array(t4), u6 = this.width * this.height;
    if (a4.length === u6)
      if (r(e4) && e4.length === u6)
        if (s9)
          for (p5 = 0; p5 < u6; p5++) {
            const t5 = e4[p5];
            if (t5) {
              const e5 = t5 / 255;
              c4[p5] = i ? t5 << 24 | n2[p5] * e5 << 16 | h4[p5] * e5 << 8 | a4[p5] * e5 : t5 << 24 | n2[p5] << 16 | h4[p5] << 8 | a4[p5];
            }
          }
        else
          for (p5 = 0; p5 < u6; p5++)
            e4[p5] && (c4[p5] = 255 << 24 | n2[p5] << 16 | h4[p5] << 8 | a4[p5]);
      else
        for (p5 = 0; p5 < u6; p5++)
          c4[p5] = 255 << 24 | n2[p5] << 16 | h4[p5] << 8 | a4[p5];
    else
      s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t4) {
    const { pixels: e4, mask: s9, statistics: i } = this;
    if (!t4 || !e4 || !e4.length)
      return void s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const o2 = this.pixelType;
    let a4 = 1, h4 = 0, n2 = 1;
    if (i && i.length > 0) {
      for (const t5 of i)
        if (null != t5.minValue && (h4 = Math.min(h4, t5.minValue)), null != t5.maxValue && null != t5.minValue) {
          const e5 = t5.maxValue - t5.minValue;
          n2 = Math.max(n2, e5);
        }
      a4 = 255 / n2;
    } else {
      let t5 = 255;
      "s8" === o2 ? (h4 = -128, t5 = 127) : "u16" === o2 ? t5 = 65535 : "s16" === o2 ? (h4 = -32768, t5 = 32767) : "u32" === o2 ? t5 = 4294967295 : "s32" === o2 ? (h4 = -2147483648, t5 = 2147483647) : "f32" === o2 ? (h4 = -34e38, t5 = 34e38) : "f64" === o2 && (h4 = -Number.MAX_VALUE, t5 = Number.MAX_VALUE), a4 = 255 / (t5 - h4);
    }
    const p5 = new Uint32Array(t4), c4 = this.width * this.height;
    let u6, g5, m6, d4, f5;
    if (u6 = g5 = m6 = e4[0], u6.length !== c4)
      return s.getLogger(this.declaredClass).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e4.length >= 2)
      if (g5 = e4[1], e4.length >= 3 && (m6 = e4[2]), r(s9) && s9.length === c4)
        for (d4 = 0; d4 < c4; d4++)
          s9[d4] && (p5[d4] = 255 << 24 | (m6[d4] - h4) * a4 << 16 | (g5[d4] - h4) * a4 << 8 | (u6[d4] - h4) * a4);
      else
        for (d4 = 0; d4 < c4; d4++)
          p5[d4] = 255 << 24 | (m6[d4] - h4) * a4 << 16 | (g5[d4] - h4) * a4 << 8 | (u6[d4] - h4) * a4;
    else if (r(s9) && s9.length === c4)
      for (d4 = 0; d4 < c4; d4++)
        f5 = (u6[d4] - h4) * a4, s9[d4] && (p5[d4] = 255 << 24 | f5 << 16 | f5 << 8 | f5);
    else
      for (d4 = 0; d4 < c4; d4++)
        f5 = (u6[d4] - h4) * a4, p5[d4] = 255 << 24 | f5 << 16 | f5 << 8 | f5;
  }
  _fillFrom32Bit(t4) {
    const { pixels: e4, mask: s9 } = this;
    if (!t4 || !e4 || !e4.length)
      return s.getLogger(this.declaredClass).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i, o2, a4, h4;
    i = o2 = a4 = e4[0], e4.length >= 3 ? (o2 = e4[1], a4 = e4[2]) : 2 === e4.length && (o2 = e4[1]);
    const n2 = this.width * this.height;
    if (i.length !== n2)
      return s.getLogger(this.declaredClass).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let p5 = 0;
    if (r(s9) && s9.length === n2)
      for (h4 = 0; h4 < n2; h4++)
        t4[p5++] = i[h4], t4[p5++] = o2[h4], t4[p5++] = a4[h4], t4[p5++] = 1 & s9[h4];
    else
      for (h4 = 0; h4 < n2; h4++)
        t4[p5++] = i[h4], t4[p5++] = o2[h4], t4[p5++] = a4[h4], t4[p5++] = 1;
  }
  _calculateBandStatistics(t4, e4) {
    let s9 = 1 / 0, i = -1 / 0;
    const l4 = t4.length;
    let o2, a4 = 0;
    if (r(e4))
      for (o2 = 0; o2 < l4; o2++)
        e4[o2] && (a4 = t4[o2], s9 = a4 < s9 ? a4 : s9, i = a4 > i ? a4 : i);
    else
      for (o2 = 0; o2 < l4; o2++)
        a4 = t4[o2], s9 = a4 < s9 ? a4 : s9, i = a4 > i ? a4 : i;
    return new l2(s9, i);
  }
};
e2([y({ json: { write: true } })], g.prototype, "width", void 0), e2([y({ json: { write: true } })], g.prototype, "height", void 0), e2([y({ json: { write: true } })], g.prototype, "pixelType", void 0), e2([s3("pixelType")], g.prototype, "castPixelType", null), e2([y({ json: { write: true } })], g.prototype, "validPixelCount", void 0), e2([y({ json: { write: true } })], g.prototype, "mask", void 0), e2([y({ json: { write: true } })], g.prototype, "maskIsAlpha", void 0), e2([y({ json: { write: true } })], g.prototype, "pixels", void 0), e2([y()], g.prototype, "premultiplyAlpha", void 0), e2([y({ json: { write: true } })], g.prototype, "statistics", void 0), e2([y({ json: { write: true } })], g.prototype, "depthCount", void 0), e2([y({ json: { write: true } })], g.prototype, "noDataValues", void 0), e2([y({ json: { write: true } })], g.prototype, "bandMasks", void 0), g = u2 = e2([a("esri.layers.support.PixelBlock")], g);
var m2 = g;

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var o;
var s6;
!function(t4) {
  t4[t4.matchAny = 0] = "matchAny", t4[t4.matchAll = 1] = "matchAll";
}(o || (o = {})), function(t4) {
  t4[t4.bestMatch = 0] = "bestMatch", t4[t4.fail = 1] = "fail";
}(s6 || (s6 = {}));
var r2 = 6;
function a2(e4) {
  return r(e4) && "esri.layers.support.PixelBlock" === e4.declaredClass && e4.pixels && e4.pixels.length > 0;
}
function h(t4, e4) {
  if (!(e4 == null ? void 0 : e4.length) || !a2(t4))
    return t4;
  const n2 = t4.pixels.length;
  return e4 && e4.some((t5) => t5 >= n2) || 1 === n2 && 1 === e4.length && 0 === e4[0] ? t4 : n2 !== e4.length || e4.some((t5, e5) => t5 !== e5) ? new m2({ pixelType: t4.pixelType, width: t4.width, height: t4.height, mask: t4.mask, validPixelCount: t4.validPixelCount, maskIsAlpha: t4.maskIsAlpha, pixels: e4.map((e5) => t4.pixels[e5]), statistics: t4.statistics && e4.map((e5) => t4.statistics[e5]) }) : t4;
}
function f2(e4) {
  if (!(e4 == null ? void 0 : e4.length) || e4.some((t4) => !a2(t4)))
    return null;
  if (1 === e4.length)
    return r(e4[0]) ? e4[0].clone() : null;
  const n2 = e4, { width: i, height: o2, pixelType: s9 } = n2[0];
  if (n2.some((t4) => t4.width !== i || t4.height !== o2))
    return null;
  const r3 = n2.map(({ mask: t4 }) => t4).filter((t4) => null != t4);
  let h4 = null;
  r3.length && (h4 = new Uint8Array(i * o2), h4.set(r3[0]), r3.length > 1 && w2(r3.slice(1), h4));
  const f5 = [];
  n2.forEach(({ pixels: t4 }) => f5.push(...t4));
  const c4 = n2.map(({ statistics: t4 }) => t4).filter((t4) => t4 == null ? void 0 : t4.length), u6 = [];
  return c4.forEach((t4) => u6.push(...t4)), new m2({ pixelType: s9, width: i, height: o2, mask: h4, pixels: f5, statistics: u6.length ? u6 : null });
}
function c(t4) {
  if (!t4)
    return;
  const e4 = t4.colormap;
  if (!e4 || 0 === e4.length)
    return;
  const n2 = e4.sort((t5, e5) => t5[0] - e5[0]);
  let l4 = 0;
  n2[0][0] < 0 && (l4 = n2[0][0]);
  const i = Math.max(256, n2[n2.length - 1][0] - l4 + 1), o2 = new Uint8Array(4 * i), s9 = [];
  let r3, a4 = 0, h4 = 0;
  const f5 = 5 === n2[0].length;
  if (i > 65536)
    return n2.forEach((t5) => {
      s9[t5[0] - l4] = f5 ? t5.slice(1) : t5.slice(1).concat([255]);
    }), { indexed2DColormap: s9, offset: l4, alphaSpecified: f5 };
  if (t4.fillUnspecified)
    for (r3 = n2[h4], a4 = r3[0] - l4; a4 < i; a4++)
      o2[4 * a4] = r3[1], o2[4 * a4 + 1] = r3[2], o2[4 * a4 + 2] = r3[3], o2[4 * a4 + 3] = f5 ? r3[4] : 255, a4 === r3[0] - l4 && (r3 = h4 === n2.length - 1 ? r3 : n2[++h4]);
  else
    for (a4 = 0; a4 < n2.length; a4++)
      r3 = n2[a4], h4 = 4 * (r3[0] - l4), o2[h4] = r3[1], o2[h4 + 1] = r3[2], o2[h4 + 2] = r3[3], o2[h4 + 3] = f5 ? r3[4] : 255;
  return { indexedColormap: o2, offset: l4, alphaSpecified: f5 };
}
function u3(e4, n2) {
  if (!a2(e4))
    return e4;
  if (!n2 || !n2.indexedColormap && !n2.indexed2DColormap)
    return e4;
  const l4 = e4.clone(), i = l4.pixels;
  let o2 = l4.mask;
  const s9 = l4.width * l4.height;
  if (1 !== i.length)
    return e4;
  const { indexedColormap: r3, indexed2DColormap: h4, offset: f5, alphaSpecified: c4 } = n2;
  let u6 = 0;
  const p5 = i[0], x4 = new Uint8Array(p5.length), m6 = new Uint8Array(p5.length), g5 = new Uint8Array(p5.length);
  let d4, y5 = 0;
  if (r3) {
    const e5 = r3.length - 1;
    if (r(o2))
      for (u6 = 0; u6 < s9; u6++)
        o2[u6] && (y5 = 4 * (p5[u6] - f5), y5 < f5 || y5 > e5 ? o2[u6] = 0 : (x4[u6] = r3[y5], m6[u6] = r3[y5 + 1], g5[u6] = r3[y5 + 2], o2[u6] = r3[y5 + 3]));
    else {
      for (o2 = new Uint8Array(s9), u6 = 0; u6 < s9; u6++)
        y5 = 4 * (p5[u6] - f5), y5 < f5 || y5 > e5 ? o2[u6] = 0 : (x4[u6] = r3[y5], m6[u6] = r3[y5 + 1], g5[u6] = r3[y5 + 2], o2[u6] = r3[y5 + 3]);
      l4.mask = o2;
    }
  } else if (h4)
    if (r(o2))
      for (u6 = 0; u6 < s9; u6++)
        o2[u6] && (d4 = h4[p5[u6]], x4[u6] = d4[0], m6[u6] = d4[1], g5[u6] = d4[2], o2[u6] = d4[3]);
    else {
      for (o2 = new Uint8Array(s9), u6 = 0; u6 < s9; u6++)
        d4 = h4[p5[u6]], x4[u6] = d4[0], m6[u6] = d4[1], g5[u6] = d4[2], o2[u6] = d4[3];
      l4.mask = o2;
    }
  return l4.pixels = [x4, m6, g5], l4.statistics = null, l4.pixelType = "u8", l4.maskIsAlpha = c4, l4;
}
function p2(t4, e4) {
  if (!a2(t4))
    return null;
  const { pixels: n2, mask: i } = t4, o2 = n2.length;
  let s9 = e4.lut;
  const { offset: r3 } = e4;
  s9 && 1 === s9[0].length && (s9 = n2.map(() => s9));
  const h4 = [], f5 = e4.outputPixelType || "u8";
  for (let l4 = 0; l4 < o2; l4++) {
    const t5 = x(n2[l4], i, s9[l4], r3 || 0, f5);
    h4.push(t5);
  }
  const c4 = new m2({ width: t4.width, height: t4.height, pixels: h4, mask: i, pixelType: f5 });
  return c4.updateStatistics(), c4;
}
function x(t4, e4, n2, i, o2) {
  const s9 = t4.length, r3 = m2.createEmptyBand(o2, s9);
  if (e4)
    for (let l4 = 0; l4 < s9; l4++)
      e4[l4] && (r3[l4] = n2[t4[l4] - i]);
  else
    for (let l4 = 0; l4 < s9; l4++)
      r3[l4] = n2[t4[l4] - i];
  return r3;
}
function m3(t4, e4) {
  if (!a2(t4))
    return null;
  const n2 = t4.clone(), { pixels: l4 } = n2, i = n2.width * n2.height, o2 = e4.length, s9 = Math.floor(o2 / 2), r3 = e4[Math.floor(s9)], h4 = l4[0];
  let f5, c4, u6, p5, x4, m6, g5 = false;
  const d4 = new Uint8Array(i), y5 = new Uint8Array(i), w5 = new Uint8Array(i);
  let k3 = n2.mask;
  const M4 = 4 === e4[0].mappedColor.length;
  for (k3 || (k3 = new Uint8Array(i), k3.fill(M4 ? 255 : 1), n2.mask = k3), x4 = 0; x4 < i; x4++)
    if (k3[x4]) {
      for (f5 = h4[x4], g5 = false, m6 = s9, c4 = r3, u6 = 0, p5 = o2 - 1; p5 - u6 > 1; ) {
        if (f5 === c4.value) {
          g5 = true;
          break;
        }
        f5 > c4.value ? u6 = m6 : p5 = m6, m6 = Math.floor((u6 + p5) / 2), c4 = e4[Math.floor(m6)];
      }
      g5 || (f5 === e4[u6].value ? (c4 = e4[u6], g5 = true) : f5 === e4[p5].value ? (c4 = e4[p5], g5 = true) : f5 < e4[u6].value ? (g5 = false, c4 = null) : f5 > e4[u6].value && (f5 < e4[p5].value ? (c4 = e4[u6], g5 = true) : p5 === o2 - 1 ? (g5 = false, c4 = null) : (c4 = e4[p5], g5 = true))), g5 ? (d4[x4] = c4.mappedColor[0], y5[x4] = c4.mappedColor[1], w5[x4] = c4.mappedColor[2], k3[x4] = c4.mappedColor[3]) : d4[x4] = y5[x4] = w5[x4] = k3[x4] = 0;
    }
  return n2.pixels = [d4, y5, w5], n2.mask = k3, n2.pixelType = "u8", n2.maskIsAlpha = M4, n2;
}
function g2(t4, e4) {
  if (!a2(t4))
    return null;
  const { width: n2, height: o2 } = t4, { inputRanges: s9, outputValues: r3, outputPixelType: h4, noDataRanges: f5, allowUnmatched: c4, isLastInputRangeInclusive: u6 } = e4, p5 = t4.pixels[0], x4 = m2.createEmptyBand(h4, p5.length), m6 = t4.mask, g5 = new Uint8Array(n2 * o2);
  m6 ? g5.set(m6) : g5.fill(255);
  const d4 = t4.pixelType.startsWith("f") ? 1e-6 : 0, y5 = s9.map((t5) => t5 - d4);
  y5[0] = s9[0], y5[y5.length - 1] = s9[s9.length - 1] + (u6 ? 1e-6 : 0);
  const w5 = s9.length / 2, [k3, M4] = s5(h4);
  for (let l4 = 0; l4 < o2; l4++)
    for (let t5 = 0; t5 < n2; t5++) {
      const e5 = l4 * n2 + t5;
      if (g5[e5]) {
        const t6 = p5[e5];
        let n3 = false;
        for (let l5 = w5 - 1; l5 >= 0; l5--)
          if (t6 === y5[2 * l5] || t6 > y5[2 * l5] && t6 < y5[2 * l5 + 1]) {
            x4[e5] = r3[l5], n3 = true;
            break;
          }
        n3 || (c4 ? x4[e5] = t6 > M4 ? M4 : t6 < k3 ? k3 : t6 : g5[e5] = 0);
      }
    }
  if (f5 == null ? void 0 : f5.length)
    for (let l4 = 0; l4 < o2; l4++)
      for (let t5 = 0; t5 < n2; t5++) {
        const e5 = l4 * n2 + t5;
        if (!m6 || m6[e5]) {
          const t6 = p5[e5];
          for (let n3 = 0; n3 < w5; n3 += 2)
            if (t6 >= f5[n3] && t6 <= f5[n3 + 1]) {
              x4[e5] = 0, g5[e5] = 0;
              break;
            }
        }
      }
  return new m2({ width: n2, height: o2, pixelType: h4, pixels: [x4], mask: g5 });
}
function d(t4, e4, n2, l4) {
  const i = null != n2 && n2.length >= 2 ? new Set(n2) : null, o2 = 1 === (n2 == null ? void 0 : n2.length) ? n2[0] : null, s9 = !!(e4 == null ? void 0 : e4.length);
  for (let r3 = 0; r3 < t4.length; r3++)
    if (l4[r3]) {
      const n3 = t4[r3];
      if (s9) {
        let t5 = false;
        for (let l5 = 0; l5 < e4.length; l5 += 2)
          if (n3 >= e4[l5] && n3 <= e4[l5 + 1]) {
            t5 = true;
            break;
          }
        t5 || (l4[r3] = 0);
      }
      l4[r3] && (n3 === o2 || (i == null ? void 0 : i.has(n3))) && (l4[r3] = 0);
    }
}
function y2(t4, e4) {
  const n2 = t4[0].length;
  for (let l4 = 0; l4 < n2; l4++)
    if (e4[l4]) {
      let n3 = false;
      for (let e5 = 0; e5 < t4.length; e5++)
        if (t4[e5][l4]) {
          n3 = true;
          break;
        }
      n3 || (e4[l4] = 0);
    }
}
function w2(t4, e4) {
  const n2 = t4[0].length;
  for (let l4 = 0; l4 < n2; l4++)
    if (e4[l4]) {
      let n3 = false;
      for (let e5 = 0; e5 < t4.length; e5++)
        if (0 === t4[e5][l4]) {
          n3 = true;
          break;
        }
      n3 && (e4[l4] = 0);
    }
}
function k(t4, e4) {
  if (!a2(t4))
    return null;
  const { width: n2, height: i, pixels: o2 } = t4, s9 = n2 * i, r3 = new Uint8Array(s9);
  t4.mask ? r3.set(t4.mask) : r3.fill(255);
  const h4 = o2.length, { includedRanges: f5, noDataValues: c4, outputPixelType: u6, matchAll: p5, lookups: m6 } = e4;
  if (m6) {
    const t5 = [];
    for (let e5 = 0; e5 < h4; e5++) {
      const n3 = m6[e5], l4 = x(o2[e5], r3, n3.lut, n3.offset || 0, "u8");
      t5.push(l4);
    }
    1 === t5.length ? r3.set(t5[0]) : p5 ? y2(t5, r3) : w2(t5, r3);
  } else if (p5) {
    const t5 = [];
    for (let e5 = 0; e5 < h4; e5++) {
      const n3 = new Uint8Array(s9);
      n3.set(r3), d(o2[e5], f5 == null ? void 0 : f5.slice(2 * e5, 2 * e5 + 2), c4 == null ? void 0 : c4[e5], n3), t5.push(n3);
    }
    1 === t5.length ? r3.set(t5[0]) : y2(t5, r3);
  } else
    for (let l4 = 0; l4 < h4; l4++)
      d(o2[l4], f5 == null ? void 0 : f5.slice(2 * l4, 2 * l4 + 2), c4 == null ? void 0 : c4[l4], r3);
  return new m2({ width: n2, height: i, pixelType: u6, pixels: o2, mask: r3 });
}
function M(t4) {
  const { srcPixelType: e4, inputRanges: n2, outputValues: o2, allowUnmatched: s9, noDataRanges: r3, isLastInputRangeInclusive: a4, outputPixelType: h4 } = t4;
  if ("u8" !== e4 && "s8" !== e4 && "u16" !== e4 && "s16" !== e4)
    return null;
  const f5 = e4.includes("16") ? 65536 : 256, c4 = e4.includes("s") ? -f5 / 2 : 0, u6 = m2.createEmptyBand(h4, f5), p5 = new Uint8Array(f5);
  s9 && p5.fill(255);
  const [x4, m6] = s5(h4);
  if ((n2 == null ? void 0 : n2.length) && (o2 == null ? void 0 : o2.length)) {
    const t5 = 1e-6, e5 = n2.map((e6) => e6 - t5);
    e5[0] = n2[0], a4 && (e5[e5.length - 1] = n2[n2.length - 1]);
    for (let n3 = 0; n3 < e5.length; n3++) {
      const t6 = o2[n3] > m6 ? m6 : o2[n3] < x4 ? x4 : o2[n3], l4 = Math.ceil(e5[2 * n3] - c4), i = Math.floor(e5[2 * n3 + 1] - c4);
      for (let e6 = l4; e6 <= i; e6++)
        u6[e6] = t6, p5[e6] = 255;
    }
  }
  if (r3 == null ? void 0 : r3.length)
    for (let l4 = 0; l4 < r3.length; l4++) {
      const t5 = Math.ceil(r3[2 * l4] - c4), e5 = Math.floor(r3[2 * l4 + 1] - c4);
      for (let n3 = t5; n3 <= e5; n3++)
        p5[n3] = 0;
    }
  return { lut: u6, offset: c4, mask: p5 };
}
function A(t4, e4, n2) {
  if ("u8" !== t4 && "s8" !== t4 && "u16" !== t4 && "s16" !== t4)
    return null;
  const l4 = t4.includes("16") ? 65536 : 256, i = t4.includes("s") ? -l4 / 2 : 0, o2 = new Uint8Array(l4);
  if (e4)
    for (let s9 = 0; s9 < e4.length; s9++) {
      const t5 = Math.ceil(e4[2 * s9] - i), n3 = Math.floor(e4[2 * s9 + 1] - i);
      for (let e5 = t5; e5 <= n3; e5++)
        o2[e5] = 255;
    }
  else
    o2.fill(255);
  if (n2)
    for (let s9 = 0; s9 < n2.length; s9++)
      o2[n2[s9] - i] = 0;
  return { lut: o2, offset: i };
}
function U(t4, e4, n2, l4, i, o2, s9, r3) {
  return { xmin: i <= n2 * t4 ? 0 : i < n2 * t4 + t4 ? i - n2 * t4 : t4, ymin: o2 <= l4 * e4 ? 0 : o2 < l4 * e4 + e4 ? o2 - l4 * e4 : e4, xmax: i + s9 <= n2 * t4 ? 0 : i + s9 < n2 * t4 + t4 ? i + s9 - n2 * t4 : t4, ymax: o2 + r3 <= l4 * e4 ? 0 : o2 + r3 < l4 * e4 + e4 ? o2 + r3 - l4 * e4 : e4 };
}
function T(t4, n2) {
  if (!t4 || 0 === t4.length)
    return null;
  const l4 = t4.find((t5) => t5.pixelBlock);
  if (!l4 || t(l4.pixelBlock))
    return null;
  const i = (l4.extent.xmax - l4.extent.xmin) / l4.pixelBlock.width, o2 = (l4.extent.ymax - l4.extent.ymin) / l4.pixelBlock.height, s9 = 0.01 * Math.min(i, o2), r3 = t4.sort((t5, e4) => Math.abs(t5.extent.ymax - e4.extent.ymax) > s9 ? e4.extent.ymax - t5.extent.ymax : Math.abs(t5.extent.xmin - e4.extent.xmin) > s9 ? t5.extent.xmin - e4.extent.xmin : 0), a4 = Math.min.apply(null, r3.map((t5) => t5.extent.xmin)), h4 = Math.min.apply(null, r3.map((t5) => t5.extent.ymin)), f5 = Math.max.apply(null, r3.map((t5) => t5.extent.xmax)), c4 = Math.max.apply(null, r3.map((t5) => t5.extent.ymax)), u6 = { x: Math.round((n2.xmin - a4) / i), y: Math.round((c4 - n2.ymax) / o2) }, p5 = { width: Math.round((f5 - a4) / i), height: Math.round((c4 - h4) / o2) }, x4 = { width: Math.round((n2.xmax - n2.xmin) / i), height: Math.round((n2.ymax - n2.ymin) / o2) };
  if (Math.round(p5.width / l4.pixelBlock.width) * Math.round(p5.height / l4.pixelBlock.height) !== r3.length || u6.x < 0 || u6.y < 0 || p5.width < x4.width || p5.height < x4.height)
    return null;
  return { extent: n2, pixelBlock: b(r3.map((t5) => t5.pixelBlock), p5, { clipOffset: u6, clipSize: x4 }) };
}
function C(t4, e4, n2, l4, i, o2) {
  const { width: s9, height: r3 } = n2.block, { x: a4, y: h4 } = n2.offset, { width: f5, height: c4 } = n2.mosaic, u6 = U(s9, r3, l4, i, a4, h4, f5, c4);
  let p5 = 0, x4 = 0;
  if (o2) {
    const t5 = o2.hasGCSSShiftTransform ? 360 : o2.halfWorldWidth ?? 0, e5 = s9 * o2.resolutionX, n3 = o2.startX + l4 * e5;
    n3 < t5 && n3 + e5 > t5 ? x4 = o2.rightPadding : n3 >= t5 && (p5 = o2.leftMargin - o2.rightPadding, x4 = 0);
  }
  if (u6.xmax -= x4, "number" != typeof e4)
    for (let m6 = u6.ymin; m6 < u6.ymax; m6++) {
      const n3 = (i * r3 + m6 - h4) * f5 + (l4 * s9 - a4) + p5, o3 = m6 * s9;
      for (let l5 = u6.xmin; l5 < u6.xmax; l5++)
        t4[n3 + l5] = e4[o3 + l5];
    }
  else
    for (let m6 = u6.ymin; m6 < u6.ymax; m6++) {
      const n3 = (i * r3 + m6 - h4) * f5 + (l4 * s9 - a4) + p5;
      for (let l5 = u6.xmin; l5 < u6.xmax; l5++)
        t4[n3 + l5] = e4;
    }
}
function b(n2, i, o2 = {}) {
  const { clipOffset: s9, clipSize: r3, alignmentInfo: h4, blockWidths: f5 } = o2;
  if (f5)
    return P(n2, i, { blockWidths: f5 });
  const c4 = n2.find((t4) => a2(t4));
  if (t(c4))
    return null;
  const u6 = r3 ? r3.width : i.width, p5 = r3 ? r3.height : i.height, x4 = c4.width, m6 = c4.height, g5 = i.width / x4, d4 = i.height / m6, y5 = { offset: s9 || { x: 0, y: 0 }, mosaic: r3 || i, block: { width: x4, height: m6 } }, w5 = c4.pixelType, k3 = m2.getPixelArrayConstructor(w5), M4 = c4.pixels.length, A3 = [];
  let U3, T2;
  for (let t4 = 0; t4 < M4; t4++) {
    T2 = new k3(u6 * p5);
    for (let e4 = 0; e4 < d4; e4++)
      for (let l4 = 0; l4 < g5; l4++) {
        const i2 = n2[e4 * g5 + l4];
        a2(i2) && (U3 = i2.pixels[t4], C(T2, U3, y5, l4, e4, h4));
      }
    A3.push(T2);
  }
  let b3;
  if (n2.some((n3) => t(n3) || r(n3.mask) && n3.mask.length > 0)) {
    b3 = new Uint8Array(u6 * p5);
    for (let e4 = 0; e4 < d4; e4++)
      for (let l4 = 0; l4 < g5; l4++) {
        const i2 = n2[e4 * g5 + l4], o3 = r(i2) ? i2.mask : null;
        r(o3) ? C(b3, o3, y5, l4, e4, h4) : C(b3, i2 ? 1 : 0, y5, l4, e4, h4);
      }
  }
  const S3 = new m2({ width: u6, height: p5, pixels: A3, pixelType: w5, mask: b3 });
  return S3.updateStatistics(), S3;
}
function P(i, o2, s9) {
  const r3 = i.find((e4) => r(e4));
  if (t(r3))
    return null;
  const h4 = i.some((e4) => !r(e4) || !!e4.mask), { width: f5, height: c4 } = o2, u6 = h4 ? new Uint8Array(f5 * c4) : null, { blockWidths: p5 } = s9, x4 = [], m6 = r3.getPlaneCount(), g5 = m2.getPixelArrayConstructor(r3.pixelType);
  if (h4)
    for (let t4 = 0, e4 = 0; t4 < i.length; e4 += p5[t4], t4++) {
      const l4 = i[t4];
      if (!a2(l4))
        continue;
      const o3 = e(l4.mask);
      for (let n2 = 0; n2 < c4; n2++)
        for (let i2 = 0; i2 < p5[t4]; i2++)
          u6[n2 * f5 + i2 + e4] = null == o3 ? 255 : o3[n2 * l4.width + i2];
    }
  for (let t4 = 0; t4 < m6; t4++) {
    const e4 = new g5(f5 * c4);
    for (let n2 = 0, l4 = 0; n2 < i.length; l4 += p5[n2], n2++) {
      const o3 = i[n2];
      if (!a2(o3))
        continue;
      const s10 = o3.pixels[t4];
      if (null != s10)
        for (let t5 = 0; t5 < c4; t5++)
          for (let i2 = 0; i2 < p5[n2]; i2++)
            e4[t5 * f5 + i2 + l4] = s10[t5 * o3.width + i2];
    }
    x4.push(e4);
  }
  const d4 = new m2({ width: f5, height: c4, mask: u6, pixels: x4, pixelType: r3.pixelType });
  return d4.updateStatistics(), d4;
}
function S(t4, e4, n2) {
  if (!a2(t4))
    return null;
  const { width: l4, height: i } = t4, o2 = e4.x, s9 = e4.y, r3 = n2.width + o2, h4 = n2.height + s9;
  if (o2 < 0 || s9 < 0 || r3 > l4 || h4 > i)
    return t4;
  if (0 === o2 && 0 === s9 && r3 === l4 && h4 === i)
    return t4;
  t4.mask || (t4.mask = new Uint8Array(l4 * i));
  const f5 = t4.mask;
  for (let a4 = 0; a4 < i; a4++) {
    const t5 = a4 * l4;
    for (let e5 = 0; e5 < l4; e5++)
      f5[t5 + e5] = a4 < s9 || a4 >= h4 || e5 < o2 || e5 >= r3 ? 0 : 1;
  }
  return t4.updateStatistics(), t4;
}
function B(t4) {
  if (!a2(t4))
    return null;
  const e4 = t4.clone(), { width: l4, height: i, pixels: o2 } = t4, s9 = o2[0], r3 = e4.pixels[0], h4 = e(t4.mask);
  for (let n2 = 2; n2 < i - 1; n2++) {
    const t5 = /* @__PURE__ */ new Map();
    for (let i2 = n2 - 2; i2 < n2 + 2; i2++)
      for (let e6 = 0; e6 < 4; e6++) {
        const n3 = i2 * l4 + e6;
        _(t5, s9[n3], h4 ? h4[n3] : 1);
      }
    r3[n2 * l4] = v(t5), r3[n2 * l4 + 1] = r3[n2 * l4 + 2] = r3[n2 * l4];
    let e5 = 3;
    for (; e5 < l4 - 1; e5++) {
      let i2 = (n2 - 2) * l4 + e5 + 1;
      _(t5, s9[i2], h4 ? h4[i2] : 1), i2 = (n2 - 1) * l4 + e5 + 1, _(t5, s9[i2], h4 ? h4[i2] : 1), i2 = n2 * l4 + e5 + 1, _(t5, s9[i2], h4 ? h4[i2] : 1), i2 = (n2 + 1) * l4 + e5 + 1, _(t5, s9[i2], h4 ? h4[i2] : 1), i2 = (n2 - 2) * l4 + e5 - 3, I(t5, s9[i2], h4 ? h4[i2] : 1), i2 = (n2 - 1) * l4 + e5 - 3, I(t5, s9[i2], h4 ? h4[i2] : 1), i2 = n2 * l4 + e5 - 3, I(t5, s9[i2], h4 ? h4[i2] : 1), i2 = (n2 + 1) * l4 + e5 - 3, I(t5, s9[i2], h4 ? h4[i2] : 1), r3[n2 * l4 + e5] = v(t5);
    }
    r3[n2 * l4 + e5 + 1] = r3[n2 * l4 + e5];
  }
  for (let n2 = 0; n2 < l4; n2++)
    r3[n2] = r3[l4 + n2] = r3[2 * l4 + n2], r3[(i - 1) * l4 + n2] = r3[(i - 2) * l4 + n2];
  return e4.updateStatistics(), e4;
}
function v(t4) {
  if (0 === t4.size)
    return 0;
  let e4 = 0, n2 = -1, l4 = 0;
  const i = t4.keys();
  let o2 = i.next();
  for (; !o2.done; )
    l4 = t4.get(o2.value), l4 > e4 && (n2 = o2.value, e4 = l4), o2 = i.next();
  return n2;
}
function I(t4, e4, n2) {
  if (0 === n2)
    return;
  const l4 = t4.get(e4);
  1 === l4 ? t4.delete(e4) : t4.set(e4, l4 - 1);
}
function _(t4, e4, n2) {
  0 !== n2 && t4.set(e4, t4.has(e4) ? t4.get(e4) + 1 : 1);
}
function W(t4, e4, i) {
  let { x: o2, y: s9 } = e4;
  const { width: r3, height: h4 } = i;
  if (0 === o2 && 0 === s9 && h4 === t4.height && r3 === t4.width)
    return t4;
  const { width: f5, height: c4 } = t4, u6 = Math.max(0, s9), p5 = Math.max(0, o2), x4 = Math.min(o2 + r3, f5), m6 = Math.min(s9 + h4, c4);
  if (x4 < 0 || m6 < 0 || !a2(t4))
    return null;
  o2 = Math.max(0, -o2), s9 = Math.max(0, -s9);
  const { pixels: g5 } = t4, d4 = r3 * h4, y5 = g5.length, w5 = [];
  for (let n2 = 0; n2 < y5; n2++) {
    const e5 = g5[n2], i2 = m2.createEmptyBand(t4.pixelType, d4);
    for (let t5 = u6; t5 < m6; t5++) {
      const n3 = t5 * f5;
      let l4 = (t5 + s9 - u6) * r3 + o2;
      for (let t6 = p5; t6 < x4; t6++)
        i2[l4++] = e5[n3 + t6];
    }
    w5.push(i2);
  }
  const k3 = new Uint8Array(d4), M4 = e(t4.mask);
  for (let n2 = u6; n2 < m6; n2++) {
    const t5 = n2 * f5;
    let e5 = (n2 + s9 - u6) * r3 + o2;
    for (let n3 = p5; n3 < x4; n3++)
      k3[e5++] = M4 ? M4[t5 + n3] : 1;
  }
  const A3 = new m2({ width: i.width, height: i.height, pixelType: t4.pixelType, pixels: w5, mask: k3 });
  return A3.updateStatistics(), A3;
}
function E(e4, n2 = true) {
  if (!a2(e4))
    return null;
  const { pixels: i, width: o2, height: s9, mask: r3, pixelType: h4 } = e4, f5 = [], c4 = Math.round(o2 / 2), u6 = Math.round(s9 / 2), p5 = s9 - 1, x4 = o2 - 1;
  for (let t4 = 0; t4 < i.length; t4++) {
    const e5 = i[t4], r4 = m2.createEmptyBand(h4, c4 * u6);
    let a4 = 0;
    for (let t5 = 0; t5 < s9; t5 += 2)
      for (let l4 = 0; l4 < o2; l4 += 2) {
        const i2 = e5[t5 * o2 + l4];
        if (n2) {
          const n3 = l4 === x4 ? i2 : e5[t5 * o2 + l4 + 1], s10 = t5 === p5 ? i2 : e5[t5 * o2 + l4 + o2], h5 = l4 === x4 ? s10 : t5 === p5 ? n3 : e5[t5 * o2 + l4 + o2 + 1];
          r4[a4++] = (i2 + n3 + s10 + h5) / 4;
        } else
          r4[a4++] = i2;
      }
    f5.push(r4);
  }
  let m6 = null;
  if (r(r3)) {
    m6 = new Uint8Array(c4 * u6);
    let t4 = 0;
    for (let e5 = 0; e5 < s9; e5 += 2)
      for (let l4 = 0; l4 < o2; l4 += 2) {
        const i2 = r3[e5 * o2 + l4];
        if (n2) {
          const n3 = l4 === x4 ? i2 : r3[e5 * o2 + l4 + 1], s10 = e5 === p5 ? i2 : r3[e5 * o2 + l4 + o2], a4 = l4 === x4 ? s10 : e5 === p5 ? n3 : r3[e5 * o2 + l4 + o2 + 1];
          m6[t4++] = i2 * n3 * s10 * a4 ? 1 : 0;
        } else
          m6[t4++] = i2;
      }
  }
  return new m2({ width: c4, height: u6, pixelType: h4, pixels: f5, mask: m6 });
}
function R2(t4, e4, n2) {
  if (!a2(t4))
    return null;
  const { width: l4, height: i } = e4;
  let { width: o2, height: s9 } = t4;
  const r3 = /* @__PURE__ */ new Map(), h4 = { x: 0, y: 0 }, f5 = null == n2 ? 1 : 1 + n2;
  let c4 = t4;
  for (let a4 = 0; a4 < f5; a4++) {
    const t5 = Math.ceil(o2 / l4), n3 = Math.ceil(s9 / i);
    for (let o3 = 0; o3 < n3; o3++) {
      h4.y = o3 * i;
      for (let n4 = 0; n4 < t5; n4++) {
        h4.x = n4 * l4;
        const t6 = W(c4, h4, e4);
        r3.set(`${a4}/${o3}/${n4}`, t6);
      }
    }
    a4 < f5 - 1 && (c4 = E(c4)), o2 = Math.round(o2 / 2), s9 = Math.round(s9 / 2);
  }
  return r3;
}
function j(t4, e4, n2, l4, i = 0) {
  const { width: o2, height: s9 } = t4, { width: r3, height: a4 } = e4, h4 = l4.cols, f5 = l4.rows, c4 = Math.ceil(r3 / h4 - 0.1 / h4), u6 = Math.ceil(a4 / f5 - 0.1 / f5);
  let p5, x4, m6, g5, d4, y5, w5;
  const k3 = c4 * h4, M4 = k3 * u6 * f5, A3 = new Float32Array(M4), U3 = new Float32Array(M4), T2 = new Uint32Array(M4), C2 = new Uint32Array(M4);
  let b3, P3, S3 = 0;
  for (let B2 = 0; B2 < u6; B2++)
    for (let t5 = 0; t5 < c4; t5++) {
      p5 = 12 * (B2 * c4 + t5), x4 = n2[p5], m6 = n2[p5 + 1], g5 = n2[p5 + 2], d4 = n2[p5 + 3], y5 = n2[p5 + 4], w5 = n2[p5 + 5];
      for (let e5 = 0; e5 < f5; e5++) {
        S3 = (B2 * f5 + e5) * k3 + t5 * h4, P3 = (e5 + 0.5) / f5;
        for (let t6 = 0; t6 < e5; t6++)
          b3 = (t6 + 0.5) / h4, A3[S3 + t6] = (x4 * b3 + m6 * P3 + g5) * o2 + i, U3[S3 + t6] = (d4 * b3 + y5 * P3 + w5) * s9 + i, T2[S3 + t6] = Math.floor(A3[S3 + t6]), C2[S3 + t6] = Math.floor(U3[S3 + t6]);
      }
      p5 += 6, x4 = n2[p5], m6 = n2[p5 + 1], g5 = n2[p5 + 2], d4 = n2[p5 + 3], y5 = n2[p5 + 4], w5 = n2[p5 + 5];
      for (let e5 = 0; e5 < f5; e5++) {
        S3 = (B2 * f5 + e5) * k3 + t5 * h4, P3 = (e5 + 0.5) / f5;
        for (let t6 = e5; t6 < h4; t6++)
          b3 = (t6 + 0.5) / h4, A3[S3 + t6] = (x4 * b3 + m6 * P3 + g5) * o2 + i, U3[S3 + t6] = (d4 * b3 + y5 * P3 + w5) * s9 + i, T2[S3 + t6] = Math.floor(A3[S3 + t6]), C2[S3 + t6] = Math.floor(U3[S3 + t6]);
      }
    }
  return { offsets_x: A3, offsets_y: U3, offsets_xi: T2, offsets_yi: C2, gridWidth: k3 };
}
function D(t4, e4) {
  const { coefficients: n2, spacing: l4 } = e4, { offsets_x: i, offsets_y: o2, gridWidth: s9 } = j(t4, t4, n2, { rows: l4[0], cols: l4[1] }), { width: r3, height: a4 } = t4, h4 = new Float32Array(r3 * a4), f5 = 180 / Math.PI;
  for (let c4 = 0; c4 < a4; c4++)
    for (let t5 = 0; t5 < r3; t5++) {
      const e5 = c4 * s9 + t5, n3 = 0 === c4 ? e5 : e5 - s9, l5 = c4 === a4 - 1 ? e5 : e5 + s9, u6 = i[n3] - i[l5], p5 = o2[l5] - o2[n3];
      if (isNaN(u6) || isNaN(p5))
        h4[c4 * r3 + t5] = 90;
      else {
        let e6 = Math.atan2(p5, u6) * f5;
        e6 = (360 + e6) % 360, h4[c4 * r3 + t5] = e6;
      }
    }
  return h4;
}
function F(e4, n2, i, o2, s9 = "nearest") {
  if (!a2(e4))
    return null;
  "majority" === s9 && (e4 = B(e4));
  const { pixels: r3, mask: h4, pixelType: f5 } = e4, c4 = e4.width, u6 = e4.height, p5 = m2.getPixelArrayConstructor(f5), x4 = r3.length, { width: m6, height: g5 } = n2;
  let d4 = false;
  for (let t4 = 0; t4 < i.length; t4 += 3)
    -1 === i[t4] && -1 === i[t4 + 1] && -1 === i[t4 + 2] && (d4 = true);
  const { offsets_x: y5, offsets_y: w5, offsets_xi: k3, offsets_yi: M4, gridWidth: A3 } = j({ width: c4, height: u6 }, n2, i, o2, "majority" === s9 ? 0.5 : 0);
  let U3;
  const T2 = (t4, e5, n3) => {
    const l4 = t4 instanceof Float32Array || t4 instanceof Float64Array ? 0 : 0.5;
    for (let i2 = 0; i2 < g5; i2++) {
      U3 = i2 * A3;
      for (let o3 = 0; o3 < m6; o3++) {
        if (y5[U3] < 0 || w5[U3] < 0)
          t4[i2 * m6 + o3] = 0;
        else if (n3)
          t4[i2 * m6 + o3] = e5[k3[U3] + M4[U3] * c4];
        else {
          const n4 = Math.floor(y5[U3]), s10 = Math.floor(w5[U3]), r4 = Math.ceil(y5[U3]), a4 = Math.ceil(w5[U3]), f6 = y5[U3] - n4, u7 = w5[U3] - s10;
          if (!h4 || h4[n4 + s10 * c4] && h4[n4 + s10 * c4] && h4[n4 + a4 * c4] && h4[r4 + a4 * c4]) {
            const h5 = (1 - f6) * e5[n4 + s10 * c4] + f6 * e5[r4 + s10 * c4], p6 = (1 - f6) * e5[n4 + a4 * c4] + f6 * e5[r4 + a4 * c4];
            t4[i2 * m6 + o3] = (1 - u7) * h5 + u7 * p6 + l4;
          } else
            t4[i2 * m6 + o3] = e5[k3[U3] + M4[U3] * c4];
        }
        U3++;
      }
    }
  }, C2 = [];
  let b3;
  for (let t4 = 0; t4 < x4; t4++)
    b3 = new p5(m6 * g5), T2(b3, r3[t4], "nearest" === s9 || "majority" === s9), C2.push(b3);
  const P3 = new m2({ width: m6, height: g5, pixelType: f5, pixels: C2 });
  if (r(h4))
    P3.mask = new Uint8Array(m6 * g5), T2(P3.mask, h4, true);
  else if (d4) {
    P3.mask = new Uint8Array(m6 * g5);
    for (let t4 = 0; t4 < m6 * g5; t4++)
      P3.mask[t4] = y5[t4] < 0 || w5[t4] < 0 ? 0 : 1;
  }
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var s7 = /* @__PURE__ */ new Map();
s7.set("meter-per-second", 1), s7.set("kilometer-per-hour", 0.277778), s7.set("knots", 0.514444), s7.set("feet-per-second", 0.3048), s7.set("mile-per-hour", 0.44704);
var a3 = 180 / Math.PI;
var h2 = 5;
var c2 = new s4({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function l3(t4, e4) {
  return s7.get(t4) / s7.get(e4) || 1;
}
function u4(t4) {
  return (450 - t4) % 360;
}
function f3(t4, e4 = "geographic") {
  const [n2, r3] = t4, o2 = Math.sqrt(n2 * n2 + r3 * r3);
  let i = Math.atan2(r3, n2) * a3;
  return i = (360 + i) % 360, "geographic" === e4 && (i = u4(i)), [o2, i];
}
function p3(t4, e4 = "geographic") {
  let n2 = t4[1];
  "geographic" === e4 && (n2 = u4(n2)), n2 %= 360;
  const r3 = t4[0];
  return [r3 * Math.cos(n2 / a3), r3 * Math.sin(n2 / a3)];
}
function m4(t4, r3, o2, s9 = "geographic") {
  if (!a2(t4) || t(o2))
    return t4;
  const a4 = "vector-magdir" === r3 ? t4.clone() : e(d2(t4, r3)), h4 = a4.pixels[1];
  for (let e4 = 0; e4 < h4.length; e4++)
    h4[e4] = "geographic" === s9 ? (h4[e4] + o2[e4] + 270) % 360 : (h4[e4] + 360 - o2[e4]) % 360;
  return "vector-magdir" === r3 ? a4 : d2(a4, "vector-magdir");
}
function d2(t4, e4, n2 = "geographic", r3 = 1) {
  if (!a2(t4))
    return t4;
  const { pixels: s9, width: a4, height: h4 } = t4, c4 = a4 * h4, l4 = s9[0], u6 = s9[1], m6 = t4.pixelType.startsWith("f") ? t4.pixelType : "f32", d4 = m2.createEmptyBand(m6, c4), g5 = m2.createEmptyBand(m6, c4);
  let x4 = 0;
  for (let o2 = 0; o2 < h4; o2++)
    for (let t5 = 0; t5 < a4; t5++)
      "vector-uv" === e4 ? ([d4[x4], g5[x4]] = f3([l4[x4], u6[x4]], n2), d4[x4] *= r3) : ([d4[x4], g5[x4]] = p3([l4[x4], u6[x4]], n2), d4[x4] *= r3, g5[x4] *= r3), x4++;
  const M4 = new m2({ pixelType: m6, width: t4.width, height: t4.height, mask: t4.mask, validPixelCount: t4.validPixelCount, maskIsAlpha: t4.maskIsAlpha, pixels: [d4, g5] });
  return M4.updateStatistics(), M4;
}
function g3(t4, e4, n2 = 1) {
  if (1 === n2 || !a2(t4))
    return t4;
  const r3 = t4.clone(), { pixels: o2, width: s9, height: a4 } = r3, h4 = o2[0], c4 = o2[1];
  let l4 = 0;
  for (let i = 0; i < a4; i++)
    for (let t5 = 0; t5 < s9; t5++)
      "vector-uv" === e4 ? (h4[l4] *= n2, c4[l4] *= n2) : h4[l4] *= n2, l4++;
  return r3.updateStatistics(), r3;
}
function x2(t4, n2, r3, o2, i) {
  if (t(i) || !i.spatialReference.equals(t4.spatialReference))
    return { extent: t4, width: Math.round(n2 / o2), height: Math.round(r3 / o2), resolution: t4.width / n2 };
  const s9 = i.xmin, a4 = i.ymax, h4 = (t4.xmax - t4.xmin) / n2 * o2, c4 = (t4.ymax - t4.ymin) / r3 * o2, l4 = (h4 + c4) / 2;
  return t4.xmin = s9 + Math.floor((t4.xmin - s9) / h4) * h4, t4.xmax = s9 + Math.ceil((t4.xmax - s9) / h4) * h4, t4.ymin = a4 + Math.floor((t4.ymin - a4) / c4) * c4, t4.ymax = a4 + Math.ceil((t4.ymax - a4) / c4) * c4, { extent: t4, width: Math.round(t4.width / h4), height: Math.round(t4.height / c4), resolution: l4 };
}
var M2 = k2(0, 0, 0);
function k2(t4 = 0, e4 = 0, n2 = Math.PI, r3 = true) {
  r3 && (n2 = (2 * Math.PI - n2) % (2 * Math.PI));
  const o2 = r3 ? -1 : 1, i = 13 * o2, s9 = -7 * o2, a4 = -2 * o2, h4 = -16 * o2, c4 = 21.75, [l4, u6] = y3(0, e4 + i, n2, c4), [f5, p5] = y3(t4 - 5.5, e4 + s9, n2, c4), [m6, d4] = y3(t4 + 5.5, e4 + s9, n2, c4), [g5, x4] = y3(t4 - 1.5, e4 + a4, n2, c4), [M4, k3] = y3(t4 + 1.5, e4 + a4, n2, c4), [w5, P3] = y3(t4 - 1.5, e4 + h4, n2, c4), [b3, v3] = y3(t4 + 1.5, e4 + h4, n2, c4);
  return [l4, u6, f5, p5, g5, x4, M4, k3, m6, d4, w5, P3, b3, v3];
}
function w3(t4 = 0, e4 = Math.PI, n2 = true) {
  n2 && (e4 = (2 * Math.PI - e4) % (2 * Math.PI));
  const r3 = 10, o2 = n2 ? -1 : 1, i = 5 * o2, s9 = 20 * o2, a4 = 25 * o2, c4 = 45, l4 = 0, u6 = 0, f5 = 2, p5 = 0, m6 = f5 * o2, d4 = n2 ? 1 : -1, g5 = r3 / 2 * d4;
  let [x4, M4] = [l4 + g5, u6 - s9], [k3, w5] = [x4 + f5 * d4, M4], [P3, b3] = [k3 - p5 * d4, w5 + m6], [v3, I3] = [l4 - g5, u6 - a4], [A3, _3] = [v3 + p5 * d4, I3 - m6], U3 = Math.ceil(t4 / h2), S3 = Math.floor(U3 / 10);
  U3 -= 8 * S3;
  const D3 = [], F3 = [];
  for (let h4 = 0; h4 < U3 / 2; h4++, S3--) {
    S3 <= 0 && U3 % 2 == 1 && h4 === (U3 - 1) / 2 && (v3 = l4, A3 = v3 + p5 * d4, I3 = (I3 + M4) / 2, _3 = I3 - m6);
    const [t5, n3] = y3(v3, I3, e4, c4);
    if (S3 > 0) {
      const [r4, o3] = y3(k3, I3, e4, c4), [i2, s10] = y3(x4, M4, e4, c4);
      D3.push(r4), D3.push(o3), D3.push(t5), D3.push(n3), D3.push(i2), D3.push(s10);
    } else {
      const [r4, o3] = y3(k3, w5, e4, c4), [i2, s10] = y3(P3, b3, e4, c4), [a5, h5] = y3(A3, _3, e4, c4);
      F3.push(t5), F3.push(n3), F3.push(a5), F3.push(h5), F3.push(i2), F3.push(s10), F3.push(r4), F3.push(o3);
    }
    I3 += i, M4 += i, w5 += i, b3 += i, _3 += i;
  }
  const [j3, N] = y3(l4 + g5, u6 + s9, e4, c4), J = (r3 / 2 + f5) * d4, [O, q] = y3(l4 + J, u6 + s9, e4, c4), [B2, E2] = y3(l4 + g5, u6 - a4, e4, c4), [T2, C2] = y3(l4 + J, u6 - a4, e4, c4);
  return { pennants: D3, barbs: F3, shaft: [j3, N, O, q, B2, E2, T2, C2] };
}
function y3(t4, e4, n2, r3 = 1) {
  const o2 = Math.sqrt(t4 * t4 + e4 * e4) / r3, i = (2 * Math.PI + Math.atan2(e4, t4)) % (2 * Math.PI);
  return [o2, (2 * Math.PI + i - n2) % (2 * Math.PI)];
}
var P2 = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var b2 = [0, 0.5, 1, 1.5, 2];
var v2 = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function I2(t4, e4, n2, r3) {
  const o2 = l3(r3 || "knots", n2);
  let i;
  for (i = 1; i < e4.length; i++)
    if (i === e4.length - 1) {
      if (t4 < e4[i] * o2)
        break;
    } else if (t4 <= e4[i] * o2)
      break;
  return Math.min(i - 1, e4.length - 2);
}
function A2(t4, e4, n2, r3, o2) {
  let i = 0;
  switch (e4) {
    case "beaufort_kn":
      i = I2(t4, P2, "knots", n2);
      break;
    case "beaufort_km":
      i = I2(t4, P2, "kilometer-per-hour", n2);
      break;
    case "beaufort_ft":
      i = I2(t4, P2, "feet-per-second", n2);
      break;
    case "beaufort_m":
      i = I2(t4, P2, "meter-per-second", n2);
      break;
    case "classified_arrow":
      i = I2(t4, o2 ?? [], r3, n2);
      break;
    case "ocean_current_m":
      i = I2(t4, b2, "meter-per-second", n2);
      break;
    case "ocean_current_kn":
      i = I2(t4, v2, "knots", n2);
  }
  return i;
}
function _2(t4, e4) {
  const { style: n2, inputUnit: o2, outputUnit: i, breakValues: s9 } = e4, a4 = c2.fromJSON(o2), h4 = c2.fromJSON(i), l4 = 7 * 6, u6 = 15;
  let f5 = 0, p5 = 0;
  const { width: m6, height: d4, mask: g5 } = t4, x4 = t4.pixels[0], w5 = t4.pixels[1], y5 = r(g5) ? g5.filter((t5) => t5 > 0).length : m6 * d4, P3 = new Float32Array(y5 * l4), b3 = new Uint32Array(u6 * y5), v3 = e4.invertDirection ? k2(0, 0, 0, false) : M2;
  for (let r3 = 0; r3 < d4; r3++)
    for (let t5 = 0; t5 < m6; t5++) {
      const e5 = r3 * m6 + t5;
      if (!g5 || g5[r3 * m6 + t5]) {
        const o3 = (w5[e5] + 360) % 360 / 180 * Math.PI, i2 = A2(x4[e5], n2, a4, h4, s9);
        for (let n3 = 0; n3 < v3.length; n3 += 2)
          P3[f5++] = (t5 + 0.5) / m6, P3[f5++] = (r3 + 0.5) / d4, P3[f5++] = v3[n3], P3[f5++] = v3[n3 + 1] + o3, P3[f5++] = i2, P3[f5++] = x4[e5];
        const c4 = 7 * (f5 / l4 - 1);
        b3[p5++] = c4, b3[p5++] = c4 + 1, b3[p5++] = c4 + 2, b3[p5++] = c4 + 0, b3[p5++] = c4 + 4, b3[p5++] = c4 + 3, b3[p5++] = c4 + 0, b3[p5++] = c4 + 2, b3[p5++] = c4 + 3, b3[p5++] = c4 + 2, b3[p5++] = c4 + 5, b3[p5++] = c4 + 3, b3[p5++] = c4 + 5, b3[p5++] = c4 + 6, b3[p5++] = c4 + 3;
      }
    }
  return { vertexData: P3, indexData: b3 };
}
var U2 = [];
function S2(t4, e4) {
  if (0 === U2.length)
    for (let h4 = 0; h4 < 30; h4++)
      U2.push(w3(5 * h4, 0, !e4.invertDirection));
  const n2 = l3(c2.fromJSON(e4.inputUnit), "knots"), { width: r3, height: o2, mask: i } = t4, s9 = t4.pixels[0], a4 = t4.pixels[1], u6 = 6, f5 = [], p5 = [];
  let m6 = 0, d4 = 0;
  for (let c4 = 0; c4 < o2; c4++)
    for (let t5 = 0; t5 < r3; t5++) {
      const e5 = c4 * r3 + t5, l4 = s9[e5] * n2;
      if ((!i || i[c4 * r3 + t5]) && l4 >= h2) {
        const n3 = (a4[e5] + 360) % 360 / 180 * Math.PI, { pennants: i2, barbs: s10, shaft: h4 } = U2[Math.min(Math.floor(l4 / 5), 29)];
        if (i2.length + s10.length === 0)
          continue;
        let g5 = f5.length / u6;
        const x4 = (t5 + 0.5) / r3, M4 = (c4 + 0.5) / o2;
        for (let t6 = 0; t6 < i2.length; t6 += 2)
          f5[m6++] = x4, f5[m6++] = M4, f5[m6++] = i2[t6], f5[m6++] = i2[t6 + 1] + n3, f5[m6++] = 0, f5[m6++] = l4;
        for (let t6 = 0; t6 < s10.length; t6 += 2)
          f5[m6++] = x4, f5[m6++] = M4, f5[m6++] = s10[t6], f5[m6++] = s10[t6 + 1] + n3, f5[m6++] = 0, f5[m6++] = l4;
        for (let t6 = 0; t6 < h4.length; t6 += 2)
          f5[m6++] = x4, f5[m6++] = M4, f5[m6++] = h4[t6], f5[m6++] = h4[t6 + 1] + n3, f5[m6++] = 0, f5[m6++] = l4;
        for (let t6 = 0; t6 < i2.length / 6; t6++)
          p5[d4++] = g5, p5[d4++] = g5 + 1, p5[d4++] = g5 + 2, g5 += 3;
        for (let t6 = 0; t6 < s10.length / 8; t6++)
          p5[d4++] = g5, p5[d4++] = g5 + 1, p5[d4++] = g5 + 2, p5[d4++] = g5 + 1, p5[d4++] = g5 + 2, p5[d4++] = g5 + 3, g5 += 4;
        p5[d4++] = g5 + 0, p5[d4++] = g5 + 1, p5[d4++] = g5 + 2, p5[d4++] = g5 + 1, p5[d4++] = g5 + 3, p5[d4++] = g5 + 2, g5 += 4;
      }
    }
  return { vertexData: new Float32Array(f5), indexData: new Uint32Array(p5) };
}
function D2(t4, e4) {
  const n2 = 4 * 6;
  let r3 = 0, o2 = 0;
  const { width: i, height: s9, mask: a4 } = t4, u6 = t4.pixels[0], f5 = [], p5 = [], m6 = l3(c2.fromJSON(e4.inputUnit), "knots"), d4 = "wind_speed" === e4.style ? h2 : Number.MAX_VALUE;
  for (let h4 = 0; h4 < s9; h4++)
    for (let t5 = 0; t5 < i; t5++) {
      const e5 = u6[h4 * i + t5] * m6;
      if ((!a4 || a4[h4 * i + t5]) && e5 < d4) {
        for (let n3 = 0; n3 < 4; n3++)
          f5[r3++] = (t5 + 0.5) / i, f5[r3++] = (h4 + 0.5) / s9, f5[r3++] = n3 < 2 ? -0.5 : 0.5, f5[r3++] = n3 % 2 == 0 ? -0.5 : 0.5, f5[r3++] = 0, f5[r3++] = e5;
        const a5 = 4 * (r3 / n2 - 1);
        p5[o2++] = a5, p5[o2++] = a5 + 1, p5[o2++] = a5 + 2, p5[o2++] = a5 + 1, p5[o2++] = a5 + 2, p5[o2++] = a5 + 3;
      }
    }
  return { vertexData: new Float32Array(f5), indexData: new Uint32Array(p5) };
}
function F2(t4, e4) {
  return "simple_scalar" === e4.style ? D2(t4, e4) : "wind_speed" === e4.style ? S2(t4, e4) : _2(t4, e4);
}
function j2(t4, e4, n2, r3 = [0, 0], i = 0.5) {
  const { width: s9, height: a4, mask: h4 } = t4, [c4, l4] = t4.pixels, [u6, m6] = r3, d4 = Math.round((s9 - u6) / n2), g5 = Math.round((a4 - m6) / n2), x4 = d4 * g5, M4 = new Float32Array(x4), k3 = new Float32Array(x4), w5 = new Uint8Array(x4), y5 = "vector-uv" === e4;
  for (let o2 = 0; o2 < g5; o2++)
    for (let t5 = 0; t5 < d4; t5++) {
      let e5 = 0;
      const r4 = o2 * d4 + t5, g6 = Math.max(0, o2 * n2 + m6), x5 = Math.max(0, t5 * n2 + u6), P4 = Math.min(a4, g6 + n2), b3 = Math.min(s9, x5 + n2);
      for (let t6 = g6; t6 < P4; t6++)
        for (let n3 = x5; n3 < b3; n3++) {
          const o3 = t6 * s9 + n3;
          if (!h4 || h4[o3]) {
            e5++;
            const t7 = y5 ? [c4[o3], l4[o3]] : [c4[o3], (360 + l4[o3]) % 360], [n4, i2] = y5 ? t7 : p3(t7);
            M4[r4] += n4, k3[r4] += i2;
          }
        }
      if (e5 >= (P4 - g6) * (b3 - x5) * (1 - i)) {
        w5[r4] = 1;
        const [t6, n3] = f3([M4[r4] / e5, k3[r4] / e5]);
        M4[r4] = t6, k3[r4] = n3;
      } else
        w5[r4] = 0, M4[r4] = 0, k3[r4] = 0;
    }
  const P3 = new m2({ width: d4, height: g5, pixels: [M4, k3], mask: w5 });
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var s8 = s.getLogger("esri.views.2d.engine.flow.dataUtils");
var c3 = 10;
async function f4(t4, e4, n2, r3) {
  const i = performance.now(), l4 = u5(e4, n2), a4 = performance.now(), f5 = m5(e4, l4, n2.width, n2.height), h4 = performance.now(), d4 = w4(f5, true), y5 = performance.now(), x4 = "Streamlines" === t4 ? p4(d4, c3) : g4(d4), M4 = performance.now();
  return has("esri-2d-profiler") && (s8.info("I.1", "_createFlowFieldFromData (ms)", Math.round(a4 - i)), s8.info("I.2", "_getStreamlines (ms)", Math.round(h4 - a4)), s8.info("I.3", "createAnimatedLinesData (ms)", Math.round(y5 - h4)), s8.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M4 - y5)), s8.info("I.5", "createFlowMesh (ms)", Math.round(M4 - i)), s8.info("I.6", "Mesh size (bytes)", x4.vertexData.buffer.byteLength + x4.indexData.buffer.byteLength)), await Promise.resolve(), f(r3), x4;
}
function u5(t4, e4) {
  const n2 = d3(e4.data, e4.width, e4.height, t4.smoothing);
  if (t4.interpolate) {
    return (t5, r3) => {
      const o2 = Math.floor(t5), i = Math.floor(r3);
      if (o2 < 0 || o2 >= e4.width)
        return [0, 0];
      if (i < 0 || i >= e4.height)
        return [0, 0];
      const l4 = t5 - o2, a4 = r3 - i, s9 = o2, c4 = i, f5 = o2 < e4.width - 1 ? o2 + 1 : o2, u6 = i < e4.height - 1 ? i + 1 : i, h4 = n2[2 * (c4 * e4.width + s9)], m6 = n2[2 * (c4 * e4.width + f5)], d4 = n2[2 * (u6 * e4.width + s9)], w5 = n2[2 * (u6 * e4.width + f5)], p5 = n2[2 * (c4 * e4.width + s9) + 1], g5 = n2[2 * (c4 * e4.width + f5) + 1];
      return [(h4 * (1 - a4) + d4 * a4) * (1 - l4) + (m6 * (1 - a4) + w5 * a4) * l4, (p5 * (1 - a4) + n2[2 * (u6 * e4.width + s9) + 1] * a4) * (1 - l4) + (g5 * (1 - a4) + n2[2 * (u6 * e4.width + f5) + 1] * a4) * l4];
    };
  }
  return (t5, r3) => {
    const o2 = Math.round(t5), i = Math.round(r3);
    return o2 < 0 || o2 >= e4.width || i < 0 || i >= e4.height ? [0, 0] : [n2[2 * (i * e4.width + o2) + 0], n2[2 * (i * e4.width + o2) + 1]];
  };
}
function h3(t4, e4, n2, r3, o2, i, l4, a4, s9) {
  const c4 = [];
  let f5 = n2, u6 = r3, h4 = 0, [m6, d4] = e4(f5, u6);
  m6 *= t4.velocityScale, d4 *= t4.velocityScale;
  const w5 = Math.sqrt(m6 * m6 + d4 * d4);
  let p5, g5;
  c4.push({ x: f5, y: u6, t: h4, speed: w5 });
  for (let y5 = 0; y5 < t4.verticesPerLine; y5++) {
    let [n3, r4] = e4(f5, u6);
    n3 *= t4.velocityScale, r4 *= t4.velocityScale;
    const m7 = Math.sqrt(n3 * n3 + r4 * r4);
    if (m7 < t4.minSpeedThreshold)
      return c4;
    const d5 = n3 / m7, w6 = r4 / m7;
    f5 += d5 * t4.segmentLength, u6 += w6 * t4.segmentLength;
    if (h4 += t4.segmentLength / m7, Math.acos(d5 * p5 + w6 * g5) > t4.maxTurnAngle)
      return c4;
    if (t4.collisions) {
      const t5 = Math.round(f5 * s9), e5 = Math.round(u6 * s9);
      if (t5 < 0 || t5 > l4 - 1 || e5 < 0 || e5 > a4 - 1)
        return c4;
      const n4 = i[e5 * l4 + t5];
      if (-1 !== n4 && n4 !== o2)
        return c4;
      i[e5 * l4 + t5] = o2;
    }
    c4.push({ x: f5, y: u6, t: h4, speed: m7 }), p5 = d5, g5 = w6;
  }
  return c4;
}
function m5(t4, e4, n2, r3) {
  const o2 = [], l4 = new t2(), a4 = 1 / Math.max(t4.lineCollisionWidth, 1), s9 = Math.round(n2 * a4), c4 = Math.round(r3 * a4), f5 = new Int32Array(s9 * c4);
  for (let i = 0; i < f5.length; i++)
    f5[i] = -1;
  const u6 = [];
  for (let i = 0; i < r3; i += t4.lineSpacing)
    for (let e5 = 0; e5 < n2; e5 += t4.lineSpacing)
      u6.push({ x: e5, y: i, sort: l4.getFloat() });
  u6.sort((t5, e5) => t5.sort - e5.sort);
  for (const { x: i, y: m6 } of u6)
    if (l4.getFloat() < t4.density) {
      const n3 = h3(t4, e4, i, m6, o2.length, f5, s9, c4, a4);
      if (n3.length < 2)
        continue;
      o2.push(n3);
    }
  return o2;
}
function d3(t4, e4, n2, r3) {
  if (0 === r3)
    return t4;
  const o2 = Math.round(3 * r3), i = new Array(2 * o2 + 1);
  let l4 = 0;
  for (let c4 = -o2; c4 <= o2; c4++) {
    const t5 = Math.exp(-c4 * c4 / (r3 * r3));
    i[c4 + o2] = t5, l4 += t5;
  }
  for (let c4 = -o2; c4 <= o2; c4++)
    i[c4 + o2] /= l4;
  const a4 = new Float32Array(t4.length);
  for (let c4 = 0; c4 < n2; c4++)
    for (let n3 = 0; n3 < e4; n3++) {
      let r4 = 0, l5 = 0;
      for (let a5 = -o2; a5 <= o2; a5++) {
        if (n3 + a5 < 0 || n3 + a5 >= e4)
          continue;
        const s10 = i[a5 + o2];
        r4 += s10 * t4[2 * (c4 * e4 + (n3 + a5)) + 0], l5 += s10 * t4[2 * (c4 * e4 + (n3 + a5)) + 1];
      }
      a4[2 * (c4 * e4 + n3) + 0] = r4, a4[2 * (c4 * e4 + n3) + 1] = l5;
    }
  const s9 = new Float32Array(t4.length);
  for (let c4 = 0; c4 < e4; c4++)
    for (let t5 = 0; t5 < n2; t5++) {
      let r4 = 0, l5 = 0;
      for (let s10 = -o2; s10 <= o2; s10++) {
        if (t5 + s10 < 0 || t5 + s10 >= n2)
          continue;
        const f5 = i[s10 + o2];
        r4 += f5 * a4[2 * ((t5 + s10) * e4 + c4) + 0], l5 += f5 * a4[2 * ((t5 + s10) * e4 + c4) + 1];
      }
      s9[2 * (t5 * e4 + c4) + 0] = r4, s9[2 * (t5 * e4 + c4) + 1] = l5;
    }
  return s9;
}
function w4(t4, e4) {
  const n2 = new t2(), r3 = t4.reduce((t5, e5) => t5 + e5.length, 0), o2 = new Float32Array(4 * r3), l4 = new Array(t4.length);
  let a4 = 0, s9 = 0;
  for (const i of t4) {
    const t5 = a4;
    for (const e5 of i)
      o2[4 * a4 + 0] = e5.x, o2[4 * a4 + 1] = e5.y, o2[4 * a4 + 2] = e5.t, o2[4 * a4 + 3] = e5.speed, a4++;
    l4[s9++] = { startVertex: t5, numberOfVertices: i.length, totalTime: i[i.length - 1].t, timeSeed: e4 ? n2.getFloat() : 0 };
  }
  return { lineVertices: o2, lineDescriptors: l4 };
}
function p4(t4, e4) {
  const n2 = 9, { lineVertices: r3, lineDescriptors: o2 } = t4;
  let i = 0, l4 = 0;
  for (const m6 of o2) {
    i += 2 * m6.numberOfVertices;
    l4 += 6 * (m6.numberOfVertices - 1);
  }
  const a4 = new Float32Array(i * n2), s9 = new Uint32Array(l4);
  let c4 = 0, f5 = 0;
  function u6() {
    s9[f5++] = c4 - 2, s9[f5++] = c4, s9[f5++] = c4 - 1, s9[f5++] = c4, s9[f5++] = c4 + 1, s9[f5++] = c4 - 1;
  }
  function h4(t5, e5, r4, o3, i2, l5, s10, f6) {
    const u7 = c4 * n2;
    let h5 = 0;
    a4[u7 + h5++] = t5, a4[u7 + h5++] = e5, a4[u7 + h5++] = 1, a4[u7 + h5++] = r4, a4[u7 + h5++] = l5, a4[u7 + h5++] = s10, a4[u7 + h5++] = o3 / 2, a4[u7 + h5++] = i2 / 2, a4[u7 + h5++] = f6, c4++, a4[u7 + h5++] = t5, a4[u7 + h5++] = e5, a4[u7 + h5++] = -1, a4[u7 + h5++] = r4, a4[u7 + h5++] = l5, a4[u7 + h5++] = s10, a4[u7 + h5++] = -o3 / 2, a4[u7 + h5++] = -i2 / 2, a4[u7 + h5++] = f6, c4++;
  }
  for (const m6 of o2) {
    const { totalTime: t5, timeSeed: n3 } = m6;
    let o3 = null, i2 = null, l5 = null, a5 = null, s10 = null, c5 = null;
    for (let f6 = 0; f6 < m6.numberOfVertices; f6++) {
      const d4 = r3[4 * (m6.startVertex + f6) + 0], w5 = r3[4 * (m6.startVertex + f6) + 1], p5 = r3[4 * (m6.startVertex + f6) + 2], g5 = r3[4 * (m6.startVertex + f6) + 3];
      let y5 = null, x4 = null, M4 = null, A3 = null;
      if (f6 > 0) {
        y5 = d4 - o3, x4 = w5 - i2;
        const r4 = Math.sqrt(y5 * y5 + x4 * x4);
        if (y5 /= r4, x4 /= r4, f6 > 1) {
          let t6 = y5 + s10, n4 = x4 + c5;
          const r5 = Math.sqrt(t6 * t6 + n4 * n4);
          t6 /= r5, n4 /= r5;
          const o4 = Math.min(1 / (t6 * y5 + n4 * x4), e4);
          t6 *= o4, n4 *= o4, M4 = -n4, A3 = t6;
        } else
          M4 = -x4, A3 = y5;
        null !== M4 && null !== A3 && (h4(o3, i2, l5, M4, A3, t5, n3, g5), u6());
      }
      o3 = d4, i2 = w5, l5 = p5, s10 = y5, c5 = x4, a5 = g5;
    }
    h4(o3, i2, l5, -c5, s10, t5, n3, a5);
  }
  return { vertexData: a4, indexData: s9 };
}
function g4(t4) {
  const e4 = 16, n2 = 1, r3 = 2, { lineVertices: o2, lineDescriptors: i } = t4;
  let l4 = 0, a4 = 0;
  for (const j3 of i) {
    const t5 = j3.numberOfVertices - 1;
    l4 += 4 * t5 * 2, a4 += 6 * t5 * 2;
  }
  const s9 = new Float32Array(l4 * e4), c4 = new Uint32Array(a4);
  let f5, u6, h4, m6, d4, w5, p5, g5, y5, x4, M4, A3, I3, V, F3 = 0, D3 = 0;
  function b3() {
    c4[D3++] = F3 - 8, c4[D3++] = F3 - 7, c4[D3++] = F3 - 6, c4[D3++] = F3 - 7, c4[D3++] = F3 - 5, c4[D3++] = F3 - 6, c4[D3++] = F3 - 4, c4[D3++] = F3 - 3, c4[D3++] = F3 - 2, c4[D3++] = F3 - 3, c4[D3++] = F3 - 1, c4[D3++] = F3 - 2;
  }
  function v3(t5, o3, i2, l5, a5, c5, f6, u7, h5, m7, d5, w6, p6, g6) {
    const y6 = F3 * e4;
    let x5 = 0;
    for (const e5 of [n2, r3])
      for (const n3 of [1, 2, 3, 4])
        s9[y6 + x5++] = t5, s9[y6 + x5++] = o3, s9[y6 + x5++] = i2, s9[y6 + x5++] = l5, s9[y6 + x5++] = f6, s9[y6 + x5++] = u7, s9[y6 + x5++] = h5, s9[y6 + x5++] = m7, s9[y6 + x5++] = e5, s9[y6 + x5++] = n3, s9[y6 + x5++] = p6, s9[y6 + x5++] = g6, s9[y6 + x5++] = a5 / 2, s9[y6 + x5++] = c5 / 2, s9[y6 + x5++] = d5 / 2, s9[y6 + x5++] = w6 / 2, F3++;
  }
  function S3(t5, e5) {
    let n3 = y5 + M4, r4 = x4 + A3;
    const o3 = Math.sqrt(n3 * n3 + r4 * r4);
    n3 /= o3, r4 /= o3;
    const i2 = y5 * n3 + x4 * r4;
    n3 /= i2, r4 /= i2;
    let l5 = M4 + I3, a5 = A3 + V;
    const s10 = Math.sqrt(l5 * l5 + a5 * a5);
    l5 /= s10, a5 /= s10;
    const c5 = M4 * l5 + A3 * a5;
    l5 /= c5, a5 /= c5, v3(f5, u6, h4, m6, -r4, n3, d4, w5, p5, g5, -a5, l5, t5, e5), b3();
  }
  function k3(t5, e5, n3, r4, o3, i2) {
    if (y5 = M4, x4 = A3, M4 = I3, A3 = V, null == y5 && null == x4 && (y5 = M4, x4 = A3), null != d4 && null != w5) {
      I3 = t5 - d4, V = e5 - w5;
      const n4 = Math.sqrt(I3 * I3 + V * V);
      I3 /= n4, V /= n4;
    }
    null != y5 && null != x4 && S3(o3, i2), f5 = d4, u6 = w5, h4 = p5, m6 = g5, d4 = t5, w5 = e5, p5 = n3, g5 = r4;
  }
  function L(t5, e5) {
    y5 = M4, x4 = A3, M4 = I3, A3 = V, null == y5 && null == x4 && (y5 = M4, x4 = A3), null != y5 && null != x4 && S3(t5, e5);
  }
  for (const j3 of i) {
    f5 = null, u6 = null, h4 = null, m6 = null, d4 = null, w5 = null, p5 = null, g5 = null, y5 = null, x4 = null, M4 = null, A3 = null, I3 = null, V = null;
    const { totalTime: t5, timeSeed: e5 } = j3;
    for (let n3 = 0; n3 < j3.numberOfVertices; n3++) {
      k3(o2[4 * (j3.startVertex + n3) + 0], o2[4 * (j3.startVertex + n3) + 1], o2[4 * (j3.startVertex + n3) + 2], o2[4 * (j3.startVertex + n3) + 3], t5, e5);
    }
    L(t5, e5);
  }
  return { vertexData: s9, indexData: c4 };
}
function y4(t4, n2) {
  const r3 = n2.pixels, { width: o2, height: i } = n2, l4 = new Float32Array(o2 * i * 2), a4 = n2.mask || new Uint8Array(o2 * i * 2);
  if (n2.mask || a4.fill(255), "vector-uv" === t4)
    for (let e4 = 0; e4 < o2 * i; e4++)
      l4[2 * e4 + 0] = r3[0][e4], l4[2 * e4 + 1] = -r3[1][e4];
  else if ("vector-magdir" === t4)
    for (let s9 = 0; s9 < o2 * i; s9++) {
      const t5 = r3[0][s9], n3 = m(r3[1][s9]), o3 = Math.cos(n3 - Math.PI / 2), i2 = Math.sin(n3 - Math.PI / 2);
      l4[2 * s9 + 0] = o3 * t5, l4[2 * s9 + 1] = i2 * t5;
    }
  return { data: l4, mask: a4, width: o2, height: i };
}
async function x3(t4, e4, n2, r3, o2, i) {
  const c4 = performance.now(), f5 = R(e4.spatialReference);
  if (!f5) {
    const l4 = await M3(t4, e4, n2, r3, o2, i);
    return has("esri-2d-profiler") && s8.info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c4)), has("esri-2d-profiler") && s8.info("I.9", "Number of parts", 1), l4;
  }
  const [u6, h4] = f5.valid, m6 = h4 - u6, d4 = Math.ceil(e4.width / m6), w5 = e4.width / d4, p5 = Math.round(n2 / d4);
  let g5 = e4.xmin;
  const y5 = [], x4 = performance.now();
  for (let l4 = 0; l4 < d4; l4++) {
    const n3 = new w({ xmin: g5, xmax: g5 + w5, ymin: e4.ymin, ymax: e4.ymax, spatialReference: e4.spatialReference });
    y5.push(M3(t4, n3, p5, r3, o2, i)), g5 += w5;
  }
  const A3 = await Promise.all(y5);
  has("esri-2d-profiler") && s8.info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - x4)), has("esri-2d-profiler") && s8.info("I.9", "Number of parts", A3.length);
  const I3 = { data: new Float32Array(n2 * r3 * 2), mask: new Uint8Array(n2 * r3), width: n2, height: r3 };
  let V = 0;
  for (const l4 of A3) {
    for (let t5 = 0; t5 < l4.height; t5++)
      for (let e5 = 0; e5 < l4.width; e5++)
        V + e5 >= n2 || (I3.data[2 * (t5 * n2 + V + e5) + 0] = l4.data[2 * (t5 * l4.width + e5) + 0], I3.data[2 * (t5 * n2 + V + e5) + 1] = l4.data[2 * (t5 * l4.width + e5) + 1], I3.mask[t5 * n2 + V + e5] = l4.mask[t5 * l4.width + e5]);
    V += l4.width;
  }
  return has("esri-2d-profiler") && s8.info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c4)), I3;
}
async function M3(t4, e4, o2, i, l4, a4) {
  const s9 = { requestProjectedLocalDirections: true, signal: a4 };
  if (r(l4) && (s9.timeExtent = l4), "imagery" === t4.type) {
    await t4.load({ signal: a4 });
    const r3 = t4.rasterInfo.dataType, l5 = await t4.fetchImage(e4, o2, i, s9);
    return !l5 || t(l5.pixelData) || t(l5.pixelData.pixelBlock) ? { data: new Float32Array(o2 * i * 2), mask: new Uint8Array(o2 * i), width: o2, height: i } : y4(r3, l5.pixelData.pixelBlock);
  }
  await t4.load({ signal: a4 });
  const c4 = t4.rasterInfo.dataType, f5 = await t4.fetchPixels(e4, o2, i, s9);
  return !f5 || t(f5.pixelBlock) ? { data: new Float32Array(o2 * i * 2), mask: new Uint8Array(o2 * i), width: o2, height: i } : y4(c4, f5.pixelBlock);
}

export {
  s5 as s,
  u,
  m2 as m,
  o,
  s6 as s2,
  r2 as r,
  a2 as a,
  h,
  f2 as f,
  c,
  u3 as u2,
  p2 as p,
  x,
  m3 as m2,
  g2 as g,
  k,
  M,
  A,
  T,
  b,
  S,
  R2 as R,
  D,
  F,
  c2,
  l3 as l,
  f3 as f2,
  m4 as m3,
  d2 as d,
  g3 as g2,
  x2,
  D2,
  F2,
  j2 as j,
  f4 as f3,
  x3
};
//# sourceMappingURL=chunk-OC742RJZ.js.map

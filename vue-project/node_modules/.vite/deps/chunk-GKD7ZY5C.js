import {
  D,
  G,
  L,
  M,
  P,
  U,
  t as t2,
  u
} from "./chunk-4M3AMTD4.js";
import {
  r as r2
} from "./chunk-3DBV4JBL.js";
import {
  c
} from "./chunk-JT54I3AY.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  e,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var o = s.getLogger("esri.views.webgl.checkWebGLError");
function t3(e2, r3) {
  switch (r3) {
    case e2.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e2.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e2.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e2.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e2.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e2.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var n = !!has("enable-feature:webgl-debug");
function a() {
  return n;
}
function c2() {
  return n;
}
function u2(r3) {
  if (a()) {
    const n2 = r3.getError();
    if (n2) {
      const a2 = t3(r3, n2), c4 = new Error().stack;
      o.error(new s2("webgl-error", "WebGL error occured", { message: a2, stack: c4 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/Texture.js
var u3 = { target: M.TEXTURE_2D, samplingMode: L.LINEAR, wrapMode: D.REPEAT, flipped: false, hasMipmap: false, isOpaque: false, unpackAlignment: 4, preMultiplyAlpha: false, isImmutable: false };
var c3 = 4;
var E = class {
  constructor(t4, e2, i = null) {
    this._context = t4, this.type = "texture", this._glName = null, this._samplingModeDirty = false, this._wrapModeDirty = false, this._wasImmutablyAllocated = false, t4.instanceCounter.increment(t2.Texture, this), this._descriptor = { ...u3, ...e2 };
    for (const r3 in u3) {
      void 0 === this._descriptor[r3] && (this._descriptor[r3] = u3[r3]);
    }
    if (t4.type !== r2.WEBGL2 && (this._descriptor.isImmutable && (this._descriptor.isImmutable = false), A(this._descriptor.target)))
      throw new Error("3D and array textures are not supported in WebGL1");
    this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(i) : this.setData(i);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty;
  }
  dispose() {
    this._context.gl && this._glName && (this._context.unbindTexture(this), this._context.gl.deleteTexture(this._glName), this._glName = null, this._context.instanceCounter.decrement(t2.Texture, this));
  }
  release() {
    this.dispose();
  }
  resize(t4, e2) {
    const i = this._descriptor;
    if (i.width !== t4 || i.height !== e2) {
      if (this._wasImmutablyAllocated)
        throw new Error("Immutable textures can't be resized!");
      i.width = t4, i.height = e2, this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  _setDataCubeMap(t4 = null) {
    for (let e2 = M.TEXTURE_CUBE_MAP_POSITIVE_X; e2 <= M.TEXTURE_CUBE_MAP_NEGATIVE_Z; e2++)
      this._setData(t4, e2);
  }
  setData(t4) {
    this._setData(t4);
  }
  _setData(t4, i) {
    if (!this._context || !this._context.gl)
      return;
    const r3 = this._context.gl;
    this._glName || (this._glName = r3.createTexture()), void 0 === t4 && (t4 = null);
    const s3 = this._descriptor, a2 = i ?? s3.target, n2 = A(a2);
    null === t4 && (s3.width = s3.width || c3, s3.height = s3.height || c3, n2 && (s3.depth = s3.depth ?? 1));
    const l = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES), E._validateTexture(this._context, s3), this._configurePixelStorage(), u2(r3);
    const h = s3.pixelFormat;
    let p = s3.internalFormat ?? this._deriveInternalFormat(h, s3.dataType);
    if (f(t4)) {
      let e2 = t4.width, i2 = t4.height;
      const l2 = 1;
      t4 instanceof HTMLVideoElement && (e2 = t4.videoWidth, i2 = t4.videoHeight), s3.width && s3.height, n2 && s3.depth, s3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(a2, p, s3.hasMipmap, e2, i2, l2), this._texImage(a2, 0, p, e2, i2, l2, t4), u2(r3), s3.hasMipmap && this.generateMipmap(), void 0 === s3.width && (s3.width = e2), void 0 === s3.height && (s3.height = i2), n2 && void 0 === s3.depth && (s3.depth = l2);
    } else {
      const { width: i2, height: l2, depth: h2 } = s3;
      if (null == i2 || null == l2)
        throw new Error("Width and height must be specified!");
      if (n2 && null == h2)
        throw new Error("Depth must be specified!");
      if (s3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(a2, p, s3.hasMipmap, i2, l2, h2), r3.DEPTH24_STENCIL8 && p === r3.DEPTH_STENCIL && (p = r3.DEPTH24_STENCIL8), x(t4)) {
        const o2 = t4.levels, n3 = w(a2, i2, l2, h2), _ = Math.min(n3 - 1, o2.length - 1);
        r(this._context.gl2) ? r3.texParameteri(s3.target, this._context.gl2.TEXTURE_MAX_LEVEL, _) : s3.hasMipmap = s3.hasMipmap && n3 === o2.length;
        const m = p;
        if (!T(m))
          throw new Error("Attempting to use compressed data with an umcompressed format!");
        this._forEachMipmapLevel((t5, e2, i3, r4) => {
          const s4 = o2[Math.min(t5, o2.length - 1)];
          this._compressedTexImage(a2, t5, m, e2, i3, r4, s4);
        }, _);
      } else
        r(t4) ? (this._texImage(a2, 0, p, i2, l2, h2, t4), u2(r3), s3.hasMipmap && this.generateMipmap()) : this._forEachMipmapLevel((t5, e2, i3, s4) => {
          this._texImage(a2, t5, p, e2, i3, s4, null), u2(r3);
        });
    }
    E._applySamplingMode(r3, this._descriptor), E._applyWrapMode(r3, this._descriptor), E._applyAnisotropicFilteringParameters(this._context, this._descriptor), u2(r3), this._context.bindTexture(l, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData(t4, r3, o2, s3, a2, n2, l = 0) {
    n2 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const h = this._context.gl, p = this._descriptor, { pixelFormat: _, dataType: m, target: d, isImmutable: u4 } = p, c4 = p.internalFormat ?? this._deriveInternalFormat(_, m);
    if (u4 && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    const g2 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES, true);
    if ((r3 < 0 || o2 < 0 || s3 > p.width || a2 > p.height || r3 + s3 > p.width || o2 + a2 > p.height) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), l) {
      if (t(this._context.gl2))
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      h.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS, l);
    }
    if (f(n2) ? r(this._context.gl2) ? this._context.gl2.texSubImage2D(d, t4, r3, o2, s3, a2, _, m, n2) : h.texSubImage2D(d, t4, r3, o2, _, m, n2) : x(n2) ? h.compressedTexSubImage2D(d, t4, r3, o2, s3, a2, c4, n2.levels[t4]) : h.texSubImage2D(d, t4, r3, o2, s3, a2, _, m, n2), l) {
      if (t(this._context.gl2))
        return void console.error("Webgl2 must be enabled to use dataRowOffset!");
      h.pixelStorei(this._context.gl2.UNPACK_SKIP_ROWS, 0);
    }
    this._context.bindTexture(g2, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(t4, e2, r3, o2, s3, a2, n2, l) {
    l || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const h = this._context.gl2;
    if (t(h))
      throw new Error("3D textures are not supported in WebGL1");
    const p = this._descriptor, { pixelFormat: _, dataType: m, isImmutable: d, target: u4 } = p, c4 = p.internalFormat ?? this._deriveInternalFormat(_, m);
    if (d && !this._wasImmutablyAllocated)
      throw new Error("Cannot update immutable texture before allocation!");
    A(u4) || console.warn("Attempting to set 3D texture data on a non-3D texture");
    const g2 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    if (this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES), (e2 < 0 || r3 < 0 || o2 < 0 || s3 > p.width || a2 > p.height || n2 > p.depth || e2 + s3 > p.width || r3 + a2 > p.height || o2 + n2 > p.depth) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage(), x(l))
      l = l.levels[t4], h.compressedTexSubImage3D(u4, t4, e2, r3, o2, s3, a2, n2, c4, l);
    else {
      const i = l;
      h.texSubImage3D(u4, t4, e2, r3, o2, s3, a2, n2, _, m, i);
    }
    this._context.bindTexture(g2, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const t4 = this._descriptor;
    if (!t4.hasMipmap) {
      if (this._wasImmutablyAllocated)
        throw new Error("Cannot add mipmaps to immutable texture after allocation");
      t4.hasMipmap = true, this._samplingModeDirty = true, E._validateTexture(this._context, t4);
    }
    t4.samplingMode === L.LINEAR ? (this._samplingModeDirty = true, t4.samplingMode = L.LINEAR_MIPMAP_NEAREST) : t4.samplingMode === L.NEAREST && (this._samplingModeDirty = true, t4.samplingMode = L.NEAREST_MIPMAP_NEAREST);
    const e2 = this._context.bindTexture(this, E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.setActiveTexture(E.TEXTURE_UNIT_FOR_UPDATES);
    this._context.gl.generateMipmap(t4.target), this._context.bindTexture(e2, E.TEXTURE_UNIT_FOR_UPDATES);
  }
  setSamplingMode(t4) {
    t4 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t4, this._samplingModeDirty = true);
  }
  setWrapMode(t4) {
    t4 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t4, E._validateTexture(this._context, this._descriptor), this._wrapModeDirty = true);
  }
  applyChanges() {
    const t4 = this._context.gl, e2 = this._descriptor;
    this._samplingModeDirty && (E._applySamplingMode(t4, e2), this._samplingModeDirty = false), this._wrapModeDirty && (E._applyWrapMode(t4, e2), this._wrapModeDirty = false);
  }
  _deriveInternalFormat(t4, e2) {
    if (this._context.type === r2.WEBGL1)
      return t4;
    switch (e2) {
      case G.FLOAT:
        switch (t4) {
          case P.RGBA:
            return U.RGBA32F;
          case P.RGB:
            return U.RGB32F;
          default:
            throw new Error("Unable to derive format");
        }
      case G.UNSIGNED_BYTE:
        switch (t4) {
          case P.RGBA:
            return U.RGBA8;
          case P.RGB:
            return U.RGB8;
        }
      default:
        return t4;
    }
  }
  _configurePixelStorage() {
    const t4 = this._context.gl, { unpackAlignment: e2, flipped: i, preMultiplyAlpha: r3 } = this._descriptor;
    t4.pixelStorei(t4.UNPACK_ALIGNMENT, e2), t4.pixelStorei(t4.UNPACK_FLIP_Y_WEBGL, i ? 1 : 0), t4.pixelStorei(t4.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r3 ? 1 : 0);
  }
  _texStorage(t4, e2, r3, o2, s3, a2) {
    const n2 = this._context.gl2;
    if (t(n2))
      throw new Error("Immutable textures are not supported in WebGL1");
    if (!g(e2))
      throw new Error("Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable)
      return;
    const l = r3 ? w(t4, o2, s3, a2) : 1;
    if (A(t4)) {
      if (null == a2)
        throw new Error("Missing depth dimension for 3D texture upload");
      n2.texStorage3D(t4, l, e2, o2, s3, a2);
    } else
      n2.texStorage2D(t4, l, e2, o2, s3);
    this._wasImmutablyAllocated = true;
  }
  _texImage(t4, i, o2, a2, n2, l, h) {
    const p = this._context.gl;
    let _ = null;
    const m = this._context.type === r2.WEBGL2, d = A(t4), { isImmutable: u4, pixelFormat: c4, dataType: E2 } = this._descriptor;
    if (m && (_ = p), m || !f(h))
      if (u4) {
        if (r(h)) {
          const e2 = h;
          if (d) {
            if (null == l)
              throw new Error("Missing depth dimension for 3D texture upload");
            _.texSubImage3D(t4, i, 0, 0, 0, a2, n2, l, c4, E2, e2);
          } else
            p.texSubImage2D(t4, i, 0, 0, a2, n2, c4, E2, e2);
        }
      } else {
        const e2 = e(h);
        if (d) {
          if (null == l)
            throw new Error("Missing depth dimension for 3D texture upload");
          _.texImage3D(t4, i, o2, a2, n2, l, 0, c4, E2, e2);
        } else
          p.texImage2D(t4, i, o2, a2, n2, 0, c4, E2, e2);
      }
    else
      p.texImage2D(t4, 0, o2, c4, E2, h);
  }
  _compressedTexImage(t4, i, r3, o2, a2, n2, l) {
    const h = this._context.gl;
    let p = null;
    const _ = A(t4), m = this._descriptor.isImmutable;
    if (_) {
      if (this._context.type !== r2.WEBGL2)
        throw new Error("3D textures are not supported in WebGL1");
      p = h;
    }
    if (m) {
      if (r(l))
        if (_) {
          if (null == n2)
            throw new Error("Missing depth dimension for 3D texture upload");
          p.compressedTexSubImage3D(t4, i, 0, 0, 0, o2, a2, n2, r3, l);
        } else
          h.compressedTexSubImage2D(t4, i, 0, 0, o2, a2, r3, l);
    } else if (_) {
      if (null == n2)
        throw new Error("Missing depth dimension for 3D texture upload");
      p.compressedTexImage3D(t4, i, r3, o2, a2, n2, 0, l);
    } else
      h.compressedTexImage2D(t4, i, r3, o2, a2, 0, l);
  }
  _forEachMipmapLevel(t4, e2 = 1 / 0) {
    let { width: i, height: r3, depth: o2, hasMipmap: s3, target: n2 } = this._descriptor;
    const l = n2 === M.TEXTURE_3D;
    if (null == i || null == r3 || l && null == o2)
      throw new Error("Missing texture dimensions for mipmap calculation");
    for (let a2 = 0; t4(a2, i, r3, o2), s3 && (1 !== i || 1 !== r3 || l && 1 !== o2) && !(a2 >= e2); ++a2)
      i = Math.max(1, i >> 1), r3 = Math.max(1, r3 >> 1), l && (o2 = Math.max(1, o2 >> 1));
  }
  static _validateTexture(e2, i) {
    (null != i.width && i.width < 0 || null != i.height && i.height < 0 || null != i.depth && i.depth < 0) && console.error("Negative dimension parameters are not allowed!");
    const r3 = e2.type === r2.WEBGL2, o2 = null != i.width && c(i.width) && null != i.height && c(i.height);
    r3 || !i.isImmutable && !A(i.target) || console.error("Immutable and 3D-like textures are not supported in WebGL1!"), r3 || o2 || ("number" == typeof i.wrapMode ? i.wrapMode !== D.CLAMP_TO_EDGE && console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!") : i.wrapMode.s === D.CLAMP_TO_EDGE && i.wrapMode.t === D.CLAMP_TO_EDGE || console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"), i.hasMipmap && console.error("Mipmapping requires power-of-two textures!"));
  }
  static _applySamplingMode(t4, e2) {
    let i = e2.samplingMode, r3 = e2.samplingMode;
    i === L.LINEAR_MIPMAP_NEAREST || i === L.LINEAR_MIPMAP_LINEAR ? (i = L.LINEAR, e2.hasMipmap || (r3 = L.LINEAR)) : i !== L.NEAREST_MIPMAP_NEAREST && i !== L.NEAREST_MIPMAP_LINEAR || (i = L.NEAREST, e2.hasMipmap || (r3 = L.NEAREST)), t4.texParameteri(e2.target, t4.TEXTURE_MAG_FILTER, i), t4.texParameteri(e2.target, t4.TEXTURE_MIN_FILTER, r3);
  }
  static _applyWrapMode(t4, e2) {
    "number" == typeof e2.wrapMode ? (t4.texParameteri(e2.target, t4.TEXTURE_WRAP_S, e2.wrapMode), t4.texParameteri(e2.target, t4.TEXTURE_WRAP_T, e2.wrapMode)) : (t4.texParameteri(e2.target, t4.TEXTURE_WRAP_S, e2.wrapMode.s), t4.texParameteri(e2.target, t4.TEXTURE_WRAP_T, e2.wrapMode.t));
  }
  static _applyAnisotropicFilteringParameters(t4, e2) {
    const i = t4.capabilities.textureFilterAnisotropic;
    if (!i)
      return;
    t4.gl.texParameterf(e2.target, i.TEXTURE_MAX_ANISOTROPY, e2.maxAnisotropy ?? 1);
  }
};
function g(t4) {
  return t4 in U;
}
function T(t4) {
  return t4 in u;
}
function x(t4) {
  return r(t4) && "type" in t4 && "compressed" === t4.type;
}
function M2(t4) {
  return r(t4) && "byteLength" in t4;
}
function f(t4) {
  return r(t4) && !x(t4) && !M2(t4);
}
function A(t4) {
  return t4 === M.TEXTURE_3D || t4 === M.TEXTURE_2D_ARRAY;
}
function w(t4, e2, i, r3 = 1) {
  let o2 = Math.max(e2, i);
  return t4 === M.TEXTURE_3D && (o2 = Math.max(o2, r3)), Math.round(Math.log(o2) / Math.LN2) + 1;
}
E.TEXTURE_UNIT_FOR_UPDATES = 0;

export {
  a,
  c2 as c,
  u2 as u,
  E
};
//# sourceMappingURL=chunk-GKD7ZY5C.js.map

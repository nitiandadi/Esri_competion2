import {
  n as n2
} from "./chunk-75NMPQ6B.js";
import {
  i as i4
} from "./chunk-3L7LAMFR.js";
import {
  d,
  s as s3
} from "./chunk-MFCHTJOK.js";
import {
  i as i3,
  r as r4
} from "./chunk-RPLKMGIJ.js";
import {
  v as v4
} from "./chunk-FQONAW2G.js";
import {
  t as t2
} from "./chunk-6N2I7LNE.js";
import {
  T
} from "./chunk-UNUPXPO6.js";
import {
  f as f2,
  i as i2,
  s as s2
} from "./chunk-WVLEGBEW.js";
import {
  g
} from "./chunk-NUSLMJR5.js";
import {
  y as y2
} from "./chunk-QX5IKXT7.js";
import {
  a as a2
} from "./chunk-FXMJJBXP.js";
import {
  U
} from "./chunk-QJXSE36Y.js";
import {
  j
} from "./chunk-SZO7ZKE4.js";
import {
  i as i5
} from "./chunk-3UXY2S4E.js";
import {
  n
} from "./chunk-CPUYSXBP.js";
import {
  i
} from "./chunk-MJFFZ3MM.js";
import {
  c,
  v as v3
} from "./chunk-B6GJAETG.js";
import {
  $,
  f2 as f,
  r as r3,
  w2 as w
} from "./chunk-H2ENCYR3.js";
import {
  o
} from "./chunk-SVHG5VY2.js";
import {
  l as l2
} from "./chunk-DLM7WQKI.js";
import {
  a2 as a,
  e,
  v2,
  y3 as y
} from "./chunk-7GTATSRF.js";
import {
  r as r2,
  v
} from "./chunk-PXVSWY3C.js";
import {
  E,
  x
} from "./chunk-QLY5H3XF.js";
import {
  s2 as s
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  l,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/renderers/support/clickToleranceUtils.js
function t3(t4, e3) {
  return e3 ? "xoffset" in e3 && e3.xoffset ? Math.max(t4, Math.abs(e3.xoffset)) : "yoffset" in e3 && e3.yoffset ? Math.max(t4, Math.abs(e3.yoffset || 0)) : t4 : t4;
}
function e2(t4) {
  let e3 = 0, n4 = 0;
  for (let r6 = 0; r6 < t4.length; r6++) {
    const s6 = t4[r6].size;
    "number" == typeof s6 && (e3 += s6, n4++);
  }
  return e3 / n4;
}
function n3(t4, n4) {
  return "number" == typeof t4 ? t4 : t4 && t4.stops && t4.stops.length ? e2(t4.stops) : n4;
}
function r5(t4, e3) {
  if (!e3)
    return t4;
  const r6 = e3.filter((t5) => "size" === t5.type).map((e4) => {
    const { maxSize: r7, minSize: s7 } = e4;
    return (n3(r7, t4) + n3(s7, t4)) / 2;
  });
  let s6 = 0;
  const o2 = r6.length;
  if (0 === o2)
    return t4;
  for (let n4 = 0; n4 < o2; n4++)
    s6 += r6[n4];
  const f5 = Math.floor(s6 / o2);
  return Math.max(f5, t4);
}
function s4(e3) {
  var _a;
  const n4 = e3 && e3.renderer, s6 = "touch" === (e3 && e3.event && e3.event.pointerType) ? 9 : 6;
  if (!n4)
    return s6;
  const o2 = "visualVariables" in n4 ? r5(s6, n4.visualVariables) : s6;
  if ("simple" === n4.type)
    return t3(o2, n4.symbol);
  if ("unique-value" === n4.type) {
    let e4 = o2;
    return (_a = n4.uniqueValueInfos) == null ? void 0 : _a.forEach((n5) => {
      e4 = t3(e4, n5.symbol);
    }), e4;
  }
  if ("class-breaks" === n4.type) {
    let e4 = o2;
    return n4.classBreakInfos.forEach((n5) => {
      e4 = t3(e4, n5.symbol);
    }), e4;
  }
  return "dot-density" === n4.type || n4.type, o2;
}

// node_modules/@arcgis/core/rest/operations/identify.js
var l3 = (e3) => e3.spatialReference.wkid || JSON.stringify(e3.spatialReference);
function a3(r6, t4) {
  const { dpi: n4, gdbVersion: s6, geometry: o2, geometryPrecision: a7, height: p3, layerOption: m4, mapExtent: y4, maxAllowableOffset: c2, returnFieldName: u2, returnGeometry: d2, returnUnformattedValues: g2, returnZ: x2, spatialReference: b, timeExtent: h, tolerance: E2, width: O } = r6.toJSON(), { dynamicLayers: S2, layerDefs: j2, layerIds: N } = f3(r6), J = t4 && r(t4.geometry) ? t4.geometry : null, R2 = { geometryPrecision: a7, maxAllowableOffset: c2, returnFieldName: u2, returnGeometry: d2, returnUnformattedValues: g2, returnZ: x2, tolerance: E2 }, $2 = J && J.toJSON() || o2;
  if (R2.imageDisplay = `${O},${p3},${n4}`, s6 && (R2.gdbVersion = s6), $2 && (delete $2.spatialReference, R2.geometry = JSON.stringify($2), R2.geometryType = c($2)), b ? R2.sr = b.wkid || JSON.stringify(b) : $2 && $2.spatialReference ? R2.sr = l3($2) : y4 && y4.spatialReference && (R2.sr = l3(y4)), R2.time = h ? [h.start, h.end].join(",") : null, y4) {
    const { xmin: e3, ymin: r7, xmax: t5, ymax: i6 } = y4;
    R2.mapExtent = `${e3},${r7},${t5},${i6}`;
  }
  return j2 && (R2.layerDefs = j2), S2 && !j2 && (R2.dynamicLayers = S2), R2.layers = "popup" === m4 ? "visible" : m4, N && !S2 && (R2.layers += `:${N.join(",")}`), R2;
}
function f3(r6) {
  var _a, _b;
  const { mapExtent: t4, floors: i6, width: l4, sublayers: a7, layerIds: f5, layerOption: m4, gdbVersion: y4 } = r6, c2 = (_b = (_a = a7 == null ? void 0 : a7.find((e3) => null != e3.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u2 = "popup" === m4, d2 = {}, g2 = i3({ extent: t4, width: l4, spatialReference: t4 == null ? void 0 : t4.spatialReference }), x2 = [], b = (e3) => {
    const r7 = 0 === g2, t5 = 0 === e3.minScale || g2 <= e3.minScale, i7 = 0 === e3.maxScale || g2 >= e3.maxScale;
    if (e3.visible && (r7 || t5 && i7))
      if (e3.sublayers)
        e3.sublayers.forEach(b);
      else {
        if (false === (f5 == null ? void 0 : f5.includes(e3.id)) || u2 && (!e3.popupTemplate || !e3.popupEnabled))
          return;
        x2.unshift(e3);
      }
  };
  if (a7 == null ? void 0 : a7.forEach(b), a7 && !x2.length)
    d2.layerIds = [];
  else {
    const r7 = i4(x2, c2, y4), t5 = x2.map((e3) => {
      const r8 = n2(i6, e3);
      return e3.toExportImageJSON(r8);
    });
    if (r7)
      d2.dynamicLayers = JSON.stringify(t5);
    else {
      if (a7) {
        let e3 = x2.map(({ id: e4 }) => e4);
        f5 && (e3 = e3.filter((e4) => f5.includes(e4))), d2.layerIds = e3;
      } else
        (f5 == null ? void 0 : f5.length) && (d2.layerIds = f5);
      const r8 = p(i6, x2);
      if (r(r8) && r8.length) {
        const e3 = {};
        for (const t6 of r8)
          t6.definitionExpression && (e3[t6.id] = t6.definitionExpression);
        Object.keys(e3).length && (d2.layerDefs = JSON.stringify(e3));
      }
    }
  }
  return d2;
}
function p(e3, i6) {
  const n4 = !!(e3 == null ? void 0 : e3.length), o2 = i6.filter((e4) => null != e4.definitionExpression || n4 && null != e4.floorInfo);
  return o2.length ? o2.map((i7) => {
    const n5 = n2(e3, i7), o3 = t2(n5, i7.definitionExpression);
    return { id: i7.id, definitionExpression: l(o3, void 0) };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var m;
var a4 = m = class extends l2 {
  static from(t4) {
    return v(m, t4);
  }
  constructor(t4) {
    super(t4), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
};
e([y({ type: Number, json: { write: true } })], a4.prototype, "dpi", void 0), e([y()], a4.prototype, "floors", void 0), e([y({ type: String, json: { write: true } })], a4.prototype, "gdbVersion", void 0), e([y({ types: n, json: { read: v3, write: true } })], a4.prototype, "geometry", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "height", void 0), e([y({ type: [Number], json: { write: true } })], a4.prototype, "layerIds", void 0), e([y({ type: ["top", "visible", "all", "popup"], json: { write: true } })], a4.prototype, "layerOption", void 0), e([y({ type: w, json: { write: true } })], a4.prototype, "mapExtent", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "maxAllowableOffset", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnFieldName", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnM", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnUnformattedValues", void 0), e([y({ type: Boolean, json: { write: true } })], a4.prototype, "returnZ", void 0), e([y({ type: f, json: { write: true } })], a4.prototype, "spatialReference", void 0), e([y()], a4.prototype, "sublayers", void 0), e([y({ type: T, json: { write: true } })], a4.prototype, "timeExtent", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "tolerance", void 0), e([y({ type: Number, json: { write: true } })], a4.prototype, "width", void 0), a4 = m = e([a("esri.rest.support.IdentifyParameters")], a4);
var u = a4;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var m2 = class extends l2 {
  constructor(r6) {
    super(r6), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r6, t4) {
    return g.fromJSON({ attributes: { ...t4.attributes }, geometry: { ...t4.geometry } });
  }
  writeFeature(r6, e3) {
    if (!r6)
      return;
    const { attributes: t4, geometry: s6 } = r6;
    t4 && (e3.attributes = { ...t4 }), r(s6) && (e3.geometry = s6.toJSON(), e3.geometryType = i.toJSON(s6.type));
  }
};
e([y({ type: String, json: { write: true } })], m2.prototype, "displayFieldName", void 0), e([y({ type: g })], m2.prototype, "feature", void 0), e([o("feature", ["attributes", "geometry"])], m2.prototype, "readFeature", null), e([r3("feature")], m2.prototype, "writeFeature", null), e([y({ type: Number, json: { write: true } })], m2.prototype, "layerId", void 0), e([y({ type: String, json: { write: true } })], m2.prototype, "layerName", void 0), m2 = e([a("esri.rest.support.IdentifyResult")], m2);
var y3 = m2;

// node_modules/@arcgis/core/rest/identify.js
async function f4(u2, i6, f5) {
  const c2 = (i6 = a5(i6)).geometry ? [i6.geometry] : [], l4 = f2(u2);
  return l4.path += "/identify", v4(c2).then((e3) => {
    const t4 = a3(i6, { geometry: e3 && e3[0] }), u3 = s2({ ...l4.query, f: "json", ...t4 }), a7 = i2(u3, f5);
    return U(l4.path, a7).then(m3).then((r6) => p2(r6, i6.sublayers));
  });
}
function m3(r6) {
  const e3 = r6.data;
  return e3.results = e3.results || [], e3.exceededTransferLimit = Boolean(e3.exceededTransferLimit), e3.results = e3.results.map((r7) => y3.fromJSON(r7)), e3;
}
function a5(r6) {
  return r6 = u.from(r6);
}
function p2(r6, e3) {
  if (!(e3 == null ? void 0 : e3.length))
    return r6;
  const t4 = /* @__PURE__ */ new Map();
  function o2(r7) {
    t4.set(r7.id, r7), r7.sublayers && r7.sublayers.forEach(o2);
  }
  e3.forEach(o2);
  for (const s6 of r6.results)
    s6.feature.sourceLayer = t4.get(s6.layerId);
  return r6;
}

// node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var G = null;
function P(e3, t4) {
  return "tile" === t4.type || "map-image" === t4.type;
}
var S = class extends v2 {
  constructor(e3) {
    super(e3), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = x(async (e4) => {
      this.destroyed || this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e4).catch(() => {
      }));
    });
  }
  initialize() {
    const e3 = (e4) => {
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e4).catch(() => {
      })), this.updateHighlightedFeatures(this._highlightGeometriesResolution);
    };
    this.addHandles([a2(() => this.highlightGraphics, "change", (t4) => e3(t4.added), { onListenerAdd: (t4) => e3(t4) })]);
  }
  async fetchPopupFeatures(e3, t4) {
    var _a, _b;
    const { layerView: { layer: r6, view: { scale: s6 } } } = this;
    if (!e3)
      throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r6 });
    const o2 = _(r6.sublayers, s6, t4);
    if (!o2.length)
      return [];
    const a7 = await R(r6, o2);
    if (!((((_b = (_a = r6.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsIdentify) ?? true) && r6.version >= 10.5) && !a7)
      throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r6 });
    return a7 ? this._fetchPopupFeaturesUsingQueries(e3, o2, t4) : this._fetchPopupFeaturesUsingIdentify(e3, o2, t4);
  }
  clearHighlights() {
    var _a;
    (_a = this.highlightGraphics) == null ? void 0 : _a.removeAll();
  }
  highlight(e3) {
    const r6 = this.highlightGraphics;
    if (!r6)
      return { remove() {
      } };
    let i6 = null;
    if (e3 instanceof g ? i6 = [e3] : j.isCollection(e3) && e3.length > 0 ? i6 = e3.toArray() : Array.isArray(e3) && e3.length > 0 && (i6 = e3), i6 = i6 == null ? void 0 : i6.filter(r), !i6 || !i6.length)
      return { remove: () => {
      } };
    for (const t4 of i6) {
      const e4 = t4.sourceLayer;
      null != e4 && "geometryType" in e4 && "point" === e4.geometryType && (t4.visible = false);
    }
    return r6.addMany(i6), { remove: () => {
      r6.removeMany(i6 ?? []);
    } };
  }
  async _updateHighlightedFeaturesSymbols(e3) {
    const { layerView: { view: t4 }, highlightGraphics: r6, highlightGraphicUpdated: s6 } = this;
    if (r6 && s6)
      for (const i6 of e3) {
        const e4 = i6.sourceLayer && "renderer" in i6.sourceLayer && i6.sourceLayer.renderer;
        i6.sourceLayer && "geometryType" in i6.sourceLayer && "point" === i6.sourceLayer.geometryType && e4 && "getSymbolAsync" in e4 && e4.getSymbolAsync(i6).then(async (o2) => {
          var _a;
          o2 || (o2 = new y2());
          let a7 = null;
          const n4 = "visualVariables" in e4 ? (_a = e4.visualVariables) == null ? void 0 : _a.find((e5) => "size" === e5.type) : void 0;
          n4 && (G || (G = (await import("./visualVariableUtils-BSRIYA6E.js")).getSize), a7 = G(n4, i6, { view: t4.type, scale: t4.scale, shape: "simple-marker" === o2.type ? o2.style : null })), a7 || (a7 = "width" in o2 && "height" in o2 && null != o2.width && null != o2.height ? Math.max(o2.width, o2.height) : "size" in o2 ? o2.size : 16), r6.includes(i6) && (i6.symbol = new y2({ style: "square", size: a7, xoffset: "xoffset" in o2 ? o2.xoffset : 0, yoffset: "yoffset" in o2 ? o2.yoffset : 0 }), s6(i6, "symbol"), i6.visible = true);
        });
      }
  }
  async _updateHighlightedFeaturesGeometries(e3) {
    const { layerView: { layer: t4, view: r6 }, highlightGraphics: s6, highlightGraphicUpdated: i6 } = this;
    if (this._highlightGeometriesResolution = e3, !i6 || !(s6 == null ? void 0 : s6.length) || !t4.capabilities.operations.supportsQuery)
      return;
    const a7 = this._getTargetResolution(e3), n4 = /* @__PURE__ */ new Map();
    for (const c2 of s6)
      if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > a7) {
        const e4 = c2.sourceLayer;
        r2(n4, e4, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
      }
    const l4 = Array.from(n4, ([e4, t5]) => {
      const s7 = e4.createQuery();
      return s7.objectIds = [...t5.keys()], s7.outFields = [e4.objectIdField], s7.returnGeometry = true, s7.maxAllowableOffset = a7, s7.outSpatialReference = r6.spatialReference, e4.queryFeatures(s7);
    }), p3 = await Promise.all(l4);
    if (!this.destroyed)
      for (const { features: o2 } of p3)
        for (const e4 of o2) {
          const t5 = e4.sourceLayer, r7 = n4.get(t5).get(e4.getObjectId());
          r7 && s6.includes(r7) && (r7.geometry = e4.geometry, i6(r7, "geometry"), this._featuresResolutions.set(r7, a7));
        }
  }
  _getTargetResolution(e3) {
    const t4 = e3 * $(this.layerView.view.spatialReference), r6 = t4 / 16;
    return r6 <= 10 ? 0 : e3 / t4 * r6;
  }
  async _fetchPopupFeaturesUsingIdentify(e3, t4, r6) {
    const s6 = await this._createIdentifyParameters(e3, t4, r6);
    if (t(s6))
      return [];
    const { results: i6 } = await f4(this.layerView.layer.parsedUrl, s6);
    return i6.map((e4) => e4.feature);
  }
  async _createIdentifyParameters(e3, t4, r6) {
    const { floors: s6, layer: i6, timeExtent: o2, view: { spatialReference: n4, scale: l4 } } = this.layerView, p3 = r(r6) ? r6.event : null;
    if (!t4.length)
      return null;
    await Promise.all(t4.map(({ sublayer: e4 }) => e4.load().catch(() => {
    })));
    const c2 = Math.min(has("mapservice-popup-identify-max-tolerance"), i6.allSublayers.reduce((e4, t5) => t5.renderer ? s4({ renderer: t5.renderer, event: p3 }) : e4, 2)), u2 = this.createFetchPopupFeaturesQueryGeometry(e3, c2), h = r4(l4, n4), y4 = Math.round(u2.width / h), d2 = new w({ xmin: u2.center.x - h * y4, ymin: u2.center.y - h * y4, xmax: u2.center.x + h * y4, ymax: u2.center.y + h * y4, spatialReference: u2.spatialReference });
    return new u({ floors: s6, gdbVersion: "gdbVersion" in i6 ? i6.gdbVersion : void 0, geometry: e3, height: y4, layerOption: "popup", mapExtent: d2, returnGeometry: true, spatialReference: n4, sublayers: i6.sublayers, timeExtent: o2, tolerance: c2, width: y4 });
  }
  async _fetchPopupFeaturesUsingQueries(e3, t4, r6) {
    const { layerView: { floors: s6, timeExtent: i6 } } = this, o2 = r(r6) ? r6.event : null, n4 = t4.map(async ({ sublayer: t5, popupTemplate: r7 }) => {
      if (await t5.load().catch(() => {
      }), t5.capabilities && !t5.capabilities.operations.supportsQuery)
        return [];
      const n5 = t5.createQuery(), l4 = s4({ renderer: t5.renderer, event: o2 }), p3 = this.createFetchPopupFeaturesQueryGeometry(e3, l4);
      if (n5.geometry = p3, n5.outFields = await d(t5, r7), n5.timeExtent = i6, s6) {
        const e4 = s6.clone(), r8 = n2(e4, t5);
        r(r8) && (n5.where = n5.where ? `(${n5.where}) AND (${r8})` : r8);
      }
      const c2 = this._getTargetResolution(p3.width / l4), u2 = await U2(r7), h = "point" === t5.geometryType || u2 && u2.arcadeUtils.hasGeometryOperations(r7);
      h || (n5.maxAllowableOffset = c2);
      let { features: y4 } = await t5.queryFeatures(n5);
      const m4 = h ? 0 : c2;
      y4 = await A(t5, y4);
      for (const e4 of y4)
        this._featuresResolutions.set(e4, m4);
      return y4;
    });
    return (await E(n4)).reverse().reduce((e4, t5) => t5.value ? [...e4, ...t5.value] : e4, []).filter((e4) => null != e4);
  }
};
function _(e3, t4, r6) {
  const s6 = [], i6 = (e4) => {
    const o2 = 0 === e4.minScale || t4 <= e4.minScale, n4 = 0 === e4.maxScale || t4 >= e4.maxScale;
    if (e4.visible && o2 && n4) {
      if (e4.sublayers)
        e4.sublayers.forEach(i6);
      else if (e4.popupEnabled) {
        const t5 = s3(e4, { ...r6, defaultPopupTemplateEnabled: false });
        r(t5) && s6.unshift({ sublayer: e4, popupTemplate: t5 });
      }
    }
  };
  return ((e3 == null ? void 0 : e3.toArray()) ?? []).reverse().map(i6), s6;
}
function U2(e3) {
  var _a;
  return ((_a = e3.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e3.content) && e3.content.some((e4) => "expression" === e4.type) ? i5() : Promise.resolve();
}
async function R(e3, t4) {
  var _a, _b;
  if ((_b = (_a = e3.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery)
    return true;
  try {
    return await Promise.any(t4.map(({ sublayer: e4 }) => e4.load().then(() => e4.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function A(e3, t4) {
  const r6 = e3.renderer;
  return r6 && "defaultSymbol" in r6 && !r6.defaultSymbol && (t4 = r6.valueExpression ? await Promise.all(t4.map((e4) => r6.getSymbolAsync(e4).then((t5) => t5 ? e4 : null))).then((e4) => e4.filter((e5) => null != e5)) : t4.filter((e4) => null != r6.getSymbol(e4))), t4;
}
e([y({ constructOnly: true })], S.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), e([y({ constructOnly: true })], S.prototype, "layerView", void 0), e([y({ constructOnly: true })], S.prototype, "highlightGraphics", void 0), e([y({ constructOnly: true })], S.prototype, "highlightGraphicUpdated", void 0), e([y({ constructOnly: true })], S.prototype, "updatingHandles", void 0), S = e([a("esri.views.layers.support.MapService")], S);

// node_modules/@arcgis/core/views/support/drapedUtils.js
function a6(t4, n4, a7, o2 = new w()) {
  let s6 = 0;
  if ("2d" === a7.type)
    s6 = n4 * (a7.resolution ?? 0);
  else if ("3d" === a7.type) {
    const i6 = a7.overlayPixelSizeInMapUnits(t4), o3 = a7.basemapSpatialReference;
    s6 = r(o3) && !o3.equals(a7.spatialReference) ? $(o3) / $(a7.spatialReference) : n4 * i6;
  }
  const m4 = t4.x - s6, p3 = t4.y - s6, c2 = t4.x + s6, l4 = t4.y + s6, { spatialReference: f5 } = a7;
  return o2.xmin = Math.min(m4, c2), o2.ymin = Math.min(p3, l4), o2.xmax = Math.max(m4, c2), o2.ymax = Math.max(p3, l4), o2.spatialReference = f5, o2;
}
var s5 = new w();

export {
  P,
  S,
  a6 as a
};
//# sourceMappingURL=chunk-HUSXYJVO.js.map

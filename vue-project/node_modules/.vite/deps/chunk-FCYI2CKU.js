import {
  e2 as e5,
  o as o3,
  r as r4,
  t as t3
} from "./chunk-CAMNTH77.js";
import {
  c as c3
} from "./chunk-IFTSKDKP.js";
import {
  v,
  x,
  y as y2
} from "./chunk-HSVY6GEC.js";
import {
  e as e4
} from "./chunk-4BQ7IEED.js";
import {
  e as e3,
  o
} from "./chunk-LIRZ5PLW.js";
import {
  e as e2
} from "./chunk-QEKBHUVW.js";
import {
  T,
  i
} from "./chunk-DLJVYYNK.js";
import {
  B as B2,
  a as a2,
  g,
  o as o2
} from "./chunk-M2DTCG2D.js";
import {
  Zn,
  xn
} from "./chunk-UBZEFQ76.js";
import {
  B,
  C,
  P as P2,
  c as c2,
  f,
  h
} from "./chunk-FI2SN5P7.js";
import {
  $,
  L,
  N,
  P,
  c2 as c,
  s2,
  u,
  w
} from "./chunk-A5CTLI5A.js";
import {
  b,
  m
} from "./chunk-BF3T2CWA.js";
import {
  F,
  O,
  S,
  n,
  r as r2,
  r2 as r3,
  t as t2,
  z
} from "./chunk-PTCP7EIR.js";
import {
  l
} from "./chunk-CPSZPA6H.js";
import {
  a2 as a,
  e,
  y3 as y
} from "./chunk-Y54MR3BP.js";
import {
  s
} from "./chunk-C2WY74GI.js";
import {
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/geometry/support/axisAngleDegrees.js
function a3(n2 = b2) {
  return [n2[0], n2[1], n2[2], n2[3]];
}
function k2(n2, r6, t4 = a3()) {
  return r3(g2(t4), n2), t4[3] = r6, t4;
}
function v2(r6, c4, f2 = a3()) {
  return v(d, g2(r6), x2(r6)), v(w2, g2(c4), x2(c4)), y2(d, w2, d), U(f2, b(x(g2(f2), d)));
}
function g2(n2) {
  return n2;
}
function x2(n2) {
  return m(n2[3]);
}
function U(n2, r6) {
  return n2[3] = r6, n2;
}
var b2 = [0, 0, 1, 0];
var d = e4();
var w2 = e4();
var y3 = a3();

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var T2;
var q = T2 = class extends l {
  constructor(r6) {
    super(r6), this.origin = n(), this.translation = n(), this.rotation = a3(), this.scale = r2(1, 1, 1), this.geographic = true;
  }
  get localMatrix() {
    const r6 = e3();
    return v(B3, g2(this.rotation), x2(this.rotation)), P2(r6, B3, this.translation, this.scale), r6;
  }
  get localMatrixInverse() {
    return h(e3(), this.localMatrix);
  }
  applyLocal(r6, o4) {
    return O(o4, r6, this.localMatrix);
  }
  applyLocalInverse(r6, o4) {
    return O(o4, r6, this.localMatrixInverse);
  }
  project(r6, o4) {
    const t4 = new Float64Array(r6.length), s3 = T.fromTypedArray(t4), e6 = T.fromTypedArray(r6);
    if (this.geographic) {
      const r7 = c3(o4), i3 = e3();
      return Zn(o4, this.origin, i3, r7), c2(i3, i3, this.localMatrix), t3(s3, e6, i3), xn(t4, r7, 0, t4, o4, 0, t4.length / 3), t4;
    }
    const { localMatrix: i2, origin: a4 } = this;
    C(i2, o) ? e5(s3, e6) : t3(s3, e6, i2);
    for (let n2 = 0; n2 < t4.length; n2 += 3)
      t4[n2 + 0] += a4[0], t4[n2 + 1] += a4[1], t4[n2 + 2] += a4[2];
    return t4;
  }
  getOriginPoint(r6) {
    const [o4, t4, s3] = this.origin;
    return new w({ x: o4, y: t4, z: s3, spatialReference: r6 });
  }
  equals(r6) {
    return r(r6) && this.geographic === r6.geographic && F(this.origin, r6.origin) && B(this.localMatrix, r6.localMatrix);
  }
  clone() {
    const r6 = { origin: t2(this.origin), translation: t2(this.translation), rotation: a3(this.rotation), scale: t2(this.scale), geographic: this.geographic };
    return new T2(r6);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "origin", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "rotation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], q.prototype, "scale", void 0), e([y({ type: Boolean, nonNullable: true, json: { write: true } })], q.prototype, "geographic", void 0), e([y()], q.prototype, "localMatrix", null), e([y()], q.prototype, "localMatrixInverse", null), q = T2 = e([a("esri.geometry.support.MeshTransform")], q);
var B3 = e4();
var L2 = q;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r5(r6, e6) {
  return r6.isGeographic || r6.isWebMercator && ((e6 == null ? void 0 : e6.geographic) ?? true);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g3 = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function j(r6, e6, o4, t4, n2) {
  return B4(t4) ? (b3(U2.TO_PCPF, i.fromTypedArray(r6), T.fromTypedArray(e6), T.fromTypedArray(o4), t4, i.fromTypedArray(n2)), n2) : (g3.error("Cannot convert spatial reference to PCPF"), n2);
}
function h2(r6, e6, o4, t4, n2) {
  return B4(t4) ? (b3(U2.FROM_PCPF, i.fromTypedArray(r6), T.fromTypedArray(e6), T.fromTypedArray(o4), t4, i.fromTypedArray(n2)), n2) : (g3.error("Cannot convert to spatial reference from PCPF"), n2);
}
function M(r6, e6, o4) {
  return xn(r6, e6, 0, o4, c3(e6), 0, r6.length / 3), o4;
}
function R(r6, e6, o4) {
  return xn(r6, c3(o4), 0, e6, o4, 0, r6.length / 3), e6;
}
function O2(r6, o4, t4) {
  if (t(r6))
    return o4;
  const n2 = T.fromTypedArray(r6), f2 = T.fromTypedArray(o4);
  return t3(f2, n2, t4), o4;
}
function v3(r6, n2, f2) {
  if (t(r6))
    return n2;
  g(x3, f2);
  const a4 = i.fromTypedArray(r6), s3 = i.fromTypedArray(n2);
  return r4(s3, a4, x3), B2(x3) || o3(s3, s3), n2;
}
function V(r6, n2, f2) {
  if (t(r6))
    return n2;
  g(x3, f2);
  const a4 = i.fromTypedArray(r6, 4 * Float32Array.BYTES_PER_ELEMENT), s3 = i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT);
  if (r4(s3, a4, x3), B2(x3) || o3(s3, s3), r6 !== n2)
    for (let e6 = 3; e6 < r6.length; e6 += 4)
      n2[e6] = r6[e6];
  return n2;
}
function k3(r6, e6, o4, t4, n2) {
  if (!B4(t4))
    return g3.error("Cannot convert spatial reference to PCPF"), n2;
  b3(U2.TO_PCPF, i.fromTypedArray(r6, 4 * Float32Array.BYTES_PER_ELEMENT), T.fromTypedArray(e6), T.fromTypedArray(o4), t4, i.fromTypedArray(n2, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f2 = 3; f2 < r6.length; f2 += 4)
    n2[f2] = r6[f2];
  return n2;
}
function L3(r6, e6, o4, t4, n2) {
  if (!B4(t4))
    return g3.error("Cannot convert to spatial reference from PCPF"), n2;
  b3(U2.FROM_PCPF, i.fromTypedArray(r6, 16), T.fromTypedArray(e6), T.fromTypedArray(o4), t4, i.fromTypedArray(n2, 16));
  for (let f2 = 3; f2 < r6.length; f2 += 4)
    n2[f2] = r6[f2];
  return n2;
}
function b3(r6, e6, o4, t4, a4, s3) {
  if (!e6)
    return;
  const i2 = o4.count, y4 = c3(a4);
  if (S2(a4))
    for (let m2 = 0; m2 < i2; m2++)
      t4.getVec(m2, Y), e6.getVec(m2, w3), Zn(y4, Y, W, y4), a2(x3, W), r6 === U2.FROM_PCPF && o2(x3, x3), S(w3, w3, x3), s3.setVec(m2, w3);
  else
    for (let u2 = 0; u2 < i2; u2++) {
      t4.getVec(u2, Y), e6.getVec(u2, w3), Zn(y4, Y, W, y4), a2(x3, W);
      const a5 = c(o4.get(u2, 1));
      let i3 = Math.cos(a5);
      r6 === U2.TO_PCPF && (i3 = 1 / i3), x3[0] *= i3, x3[1] *= i3, x3[2] *= i3, x3[3] *= i3, x3[4] *= i3, x3[5] *= i3, r6 === U2.FROM_PCPF && o2(x3, x3), S(w3, w3, x3), z(w3, w3), s3.setVec(u2, w3);
    }
  return s3;
}
function B4(r6) {
  return S2(r6) || N2(r6);
}
function S2(r6) {
  return r6.isWGS84 || u(r6) || P(r6) || s2(r6);
}
function N2(r6) {
  return r6.isWebMercator;
}
var U2;
!function(r6) {
  r6[r6.TO_PCPF = 0] = "TO_PCPF", r6[r6.FROM_PCPF = 1] = "FROM_PCPF";
}(U2 || (U2 = {}));
var Y = n();
var w3 = n();
var W = e3();
var x3 = e2();

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function x4(n2, r6, t4) {
  return r5(r6.spatialReference, t4) ? B5(n2, r6, t4) : P3(n2, r6, t4);
}
function k4(t4, o4, e6) {
  const { position: a4, normal: i2, tangent: l2 } = t4;
  if (t(o4))
    return { position: a4, normal: i2, tangent: l2 };
  const s3 = o4.localMatrix;
  return x4({ position: O2(a4, new Float64Array(a4.length), s3), normal: r(i2) ? v3(i2, new Float32Array(i2.length), s3) : null, tangent: r(l2) ? V(l2, new Float32Array(l2.length), s3) : null }, o4.getOriginPoint(e6), { geographic: o4.geographic });
}
function _2(n2, r6, t4) {
  if (t4 == null ? void 0 : t4.useTransform) {
    const { position: o4, normal: e6, tangent: a4 } = n2;
    return { vertexAttributes: { position: o4, normal: e6, tangent: a4 }, transform: new L2({ origin: [r6.x, r6.y, r6.z ?? 0], geographic: r5(r6.spatialReference, t4) }) };
  }
  return { vertexAttributes: x4(n2, r6, t4), transform: null };
}
function b4(n2, r6, t4) {
  return r5(r6.spatialReference, t4) ? Y2(n2, r6, t4) : U3(n2, r6, t4);
}
function M2(r6, t4, o4, e6) {
  if (t(t4))
    return b4(r6, o4, e6);
  const a4 = k4(r6, t4, o4.spatialReference);
  return o4.equals(t4.getOriginPoint(o4.spatialReference)) ? U3(a4, o4, e6) : b4(a4, o4, e6);
}
function P3(n2, r6, t4) {
  const o4 = new Float64Array(n2.position.length), e6 = n2.position, a4 = r6.x, i2 = r6.y, l2 = r6.z || 0, { horizontal: s3, vertical: f2 } = C2(t4 ? t4.unit : null, r6.spatialReference);
  for (let c4 = 0; c4 < e6.length; c4 += 3)
    o4[c4 + 0] = e6[c4 + 0] * s3 + a4, o4[c4 + 1] = e6[c4 + 1] * s3 + i2, o4[c4 + 2] = e6[c4 + 2] * f2 + l2;
  return { position: o4, normal: n2.normal, tangent: n2.tangent };
}
function B5(n2, r6, t4) {
  const o4 = r6.spatialReference, e6 = G(r6, t4, D), a4 = new Float64Array(n2.position.length), i2 = L4(n2.position, e6, o4, a4), l2 = g(I, e6);
  return { position: i2, normal: N3(i2, a4, n2.normal, l2, o4), tangent: S3(i2, a4, n2.tangent, l2, o4) };
}
function L4(n2, r6, t4, o4) {
  t3(T.fromTypedArray(o4), T.fromTypedArray(n2), r6);
  const e6 = new Float64Array(n2.length);
  return R(o4, e6, t4);
}
function N3(r6, t4, o4, e6, a4) {
  if (t(o4))
    return null;
  const i2 = new Float32Array(o4.length);
  return r4(i.fromTypedArray(i2), i.fromTypedArray(o4), e6), h2(i2, r6, t4, a4, i2), i2;
}
function S3(r6, t4, o4, e6, a4) {
  if (t(o4))
    return null;
  const i2 = new Float32Array(o4.length);
  r4(i.fromTypedArray(i2, 4 * Float32Array.BYTES_PER_ELEMENT), i.fromTypedArray(o4, 4 * Float32Array.BYTES_PER_ELEMENT), e6);
  for (let n2 = 3; n2 < i2.length; n2 += 4)
    i2[n2] = o4[n2];
  return L3(i2, r6, t4, a4, i2), i2;
}
function U3(n2, r6, t4) {
  const o4 = new Float64Array(n2.position.length), e6 = n2.position, a4 = r6.x, i2 = r6.y, l2 = r6.z || 0, { horizontal: s3, vertical: f2 } = C2(t4 ? t4.unit : null, r6.spatialReference);
  for (let c4 = 0; c4 < e6.length; c4 += 3)
    o4[c4 + 0] = (e6[c4 + 0] - a4) / s3, o4[c4 + 1] = (e6[c4 + 1] - i2) / s3, o4[c4 + 2] = (e6[c4 + 2] - l2) / f2;
  return { position: o4, normal: n2.normal, tangent: n2.tangent };
}
function Y2(n2, r6, t4) {
  const o4 = r6.spatialReference;
  G(r6, t4, D);
  const e6 = h(H, D), a4 = new Float64Array(n2.position.length), l2 = O3(n2.position, o4, e6, a4), s3 = g(I, e6);
  return { position: l2, normal: q2(n2.normal, n2.position, a4, o4, s3), tangent: V2(n2.tangent, n2.position, a4, o4, s3) };
}
function G(n2, r6, t4) {
  Zn(n2.spatialReference, [n2.x, n2.y, n2.z || 0], t4, c3(n2.spatialReference));
  const { horizontal: o4, vertical: e6 } = C2(r6 ? r6.unit : null, n2.spatialReference);
  return f(t4, t4, [o4, o4, e6]), t4;
}
function O3(n2, r6, t4, o4) {
  const e6 = M(n2, r6, o4), a4 = T.fromTypedArray(e6), i2 = new Float64Array(e6.length), l2 = T.fromTypedArray(i2);
  return t3(l2, a4, t4), i2;
}
function q2(r6, t4, o4, e6, a4) {
  if (t(r6))
    return null;
  const i2 = j(r6, t4, o4, e6, new Float32Array(r6.length)), l2 = i.fromTypedArray(i2);
  return r4(l2, l2, a4), i2;
}
function V2(r6, t4, o4, e6, a4) {
  if (t(r6))
    return null;
  const i2 = k3(r6, t4, o4, e6, new Float32Array(r6.length)), l2 = i.fromTypedArray(i2, 4 * Float32Array.BYTES_PER_ELEMENT);
  return r4(l2, l2, a4), i2;
}
function C2(r6, a4) {
  if (t(r6))
    return J;
  const i2 = a4.isGeographic ? 1 : $(a4), l2 = a4.isGeographic ? 1 : L(a4), s3 = N(1, r6, "meters");
  return { horizontal: s3 * i2, vertical: s3 * l2 };
}
var D = e3();
var H = e3();
var I = e2();
var J = { horizontal: 1, vertical: 1 };

export {
  a3 as a,
  k2 as k,
  v2 as v,
  g2 as g,
  x2 as x,
  L2 as L,
  r5 as r,
  j,
  h2 as h,
  M,
  R,
  k3 as k2,
  L3 as L2,
  x4 as x2,
  k4 as k3,
  _2 as _,
  b4 as b,
  M2
};
//# sourceMappingURL=chunk-FCYI2CKU.js.map

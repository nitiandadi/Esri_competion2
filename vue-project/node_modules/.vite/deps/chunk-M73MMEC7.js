import {
  M,
  c3 as c,
  f2 as f,
  p3 as p2,
  p4 as p3,
  w,
  w2
} from "./chunk-A5CTLI5A.js";
import {
  r as r2
} from "./chunk-GMLVDTS4.js";
import {
  a2 as a,
  e,
  y3 as y
} from "./chunk-Y54MR3BP.js";
import {
  p
} from "./chunk-XPATKIHO.js";
import {
  i
} from "./chunk-MKHZ5X6F.js";
import {
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h(h7, a4, s5 = false) {
  let { hasM: t4, hasZ: e5 } = h7;
  Array.isArray(a4) ? 4 !== a4.length || t4 || e5 ? 3 === a4.length && s5 && !t4 ? (e5 = true, t4 = false) : 3 === a4.length && t4 && e5 && (t4 = false, e5 = false) : (t4 = true, e5 = true) : (e5 = !e5 && a4.hasZ && (!t4 || a4.hasM), t4 = !t4 && a4.hasM && (!e5 || a4.hasZ)), h7.hasZ = e5, h7.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Multipoint.js
var h2;
function l(t4) {
  return (s5, e5) => null == s5 ? e5 : null == e5 ? s5 : t4(s5, e5);
}
function c2(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
var m = h2 = class extends p2 {
  constructor(...t4) {
    super(...t4), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t4, s5) {
    if (!t4 && !s5)
      return {};
    const e5 = {};
    Array.isArray(t4) ? (e5.points = t4, e5.spatialReference = s5) : c2(t4) ? e5.spatialReference = t4 : (t4.points && (e5.points = t4.points), t4.spatialReference && (e5.spatialReference = t4.spatialReference), t4.hasZ && (e5.hasZ = t4.hasZ), t4.hasM && (e5.hasM = t4.hasM));
    const i5 = e5.points && e5.points[0];
    return i5 && (void 0 === e5.hasZ && void 0 === e5.hasM ? (e5.hasZ = i5.length > 2, e5.hasM = false) : void 0 === e5.hasZ ? e5.hasZ = i5.length > 3 : void 0 === e5.hasM && (e5.hasM = i5.length > 3)), e5;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t4 = this.points;
    if (!t4.length)
      return null;
    const s5 = new w2(), e5 = this.hasZ, i5 = this.hasM, r7 = e5 ? 3 : 2, n2 = t4[0], a4 = l(Math.min), p5 = l(Math.max);
    let h7, c7, m4, u6, [f6, y3] = n2, [d2, g4] = n2;
    for (let o5 = 0, l5 = t4.length; o5 < l5; o5++) {
      const s6 = t4[o5], [n3, l6] = s6;
      if (f6 = a4(f6, n3), y3 = a4(y3, l6), d2 = p5(d2, n3), g4 = p5(g4, l6), e5 && s6.length > 2) {
        const t5 = s6[2];
        h7 = a4(h7, t5), m4 = p5(m4, t5);
      }
      if (i5 && s6.length > r7) {
        const t5 = s6[r7];
        c7 = a4(c7, t5), u6 = p5(u6, t5);
      }
    }
    return s5.xmin = f6, s5.ymin = y3, s5.xmax = d2, s5.ymax = g4, s5.spatialReference = this.spatialReference, e5 ? (s5.zmin = h7, s5.zmax = m4) : (s5.zmin = void 0, s5.zmax = void 0), i5 ? (s5.mmin = c7, s5.mmax = u6) : (s5.mmin = void 0, s5.mmax = void 0), s5;
  }
  writePoints(t4, e5) {
    e5.points = p(this.points);
  }
  addPoint(t4) {
    return h(this, t4), Array.isArray(t4) ? this.points.push(t4) : this.points.push(t4.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t4 = { points: p(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t4.hasZ = true), this.hasM && (t4.hasM = true), new h2(t4);
  }
  getPoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = this.points[t4], e5 = { x: s5[0], y: s5[1], spatialReference: this.spatialReference };
    let i5 = 2;
    return this.hasZ && (e5.z = s5[2], i5 = 3), this.hasM && (e5.m = s5[i5]), new w(e5);
  }
  removePoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s5 = new w(this.points.splice(t4, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s5;
  }
  setPoint(t4, s5) {
    return this._validateInputs(t4) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.points[t4] = s5, this.notifyChange("points"), this) : this;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _validateInputs(t4) {
    return null != t4 && t4 >= 0 && t4 < this.points.length;
  }
};
e([y({ readOnly: true })], m.prototype, "cache", null), e([y()], m.prototype, "extent", null), e([y({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r2("points")], m.prototype, "writePoints", null), m = h2 = e([a("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u = m;

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function n(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function t2(n2) {
  return void 0 !== n2.points;
}
function i2(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function o(n2) {
  return void 0 !== n2.paths;
}
function e2(n2) {
  return void 0 !== n2.rings;
}
function r3(n2) {
  function t4(t5, i5) {
    return null == t5 ? i5 : null == i5 ? t5 : n2(t5, i5);
  }
  return t4;
}
var u2 = r3(Math.min);
var l2 = r3(Math.max);
function c3(r7, u6) {
  return o(u6) ? h3(r7, u6.paths, false, false) : e2(u6) ? h3(r7, u6.rings, false, false) : t2(u6) ? g(r7, u6.points, false, false, false, false) : n(u6) ? s(r7, u6) : (i2(u6) && (r7[0] = u6.x, r7[1] = u6.y, r7[2] = u6.x, r7[3] = u6.y), r7);
}
function f2(r7, u6) {
  return o(u6) ? h3(r7, u6.paths, true, false) : e2(u6) ? h3(r7, u6.rings, true, false) : t2(u6) ? g(r7, u6.points, true, false, true, false) : n(u6) ? s(r7, u6, true, false, true, false) : (i2(u6) && (r7[0] = u6.x, r7[1] = u6.y, r7[2] = u6.z, r7[3] = u6.x, r7[4] = u6.y, r7[5] = u6.z), r7);
}
function h3(n2, t4, i5, o5) {
  const e5 = i5 ? 3 : 2;
  if (!t4.length || !t4[0].length)
    return null;
  let r7, c7, f6, h7, [s5, g4] = t4[0][0], [x3, m4] = t4[0][0];
  for (let a4 = 0; a4 < t4.length; a4++) {
    const n3 = t4[a4];
    for (let t5 = 0; t5 < n3.length; t5++) {
      const a5 = n3[t5], [d2, v3] = a5;
      if (s5 = u2(s5, d2), g4 = u2(g4, v3), x3 = l2(x3, d2), m4 = l2(m4, v3), i5 && a5.length > 2) {
        const n4 = a5[2];
        r7 = u2(r7, n4), c7 = l2(c7, n4);
      }
      if (o5 && a5.length > e5) {
        const n4 = a5[e5];
        f6 = u2(r7, n4), h7 = l2(c7, n4);
      }
    }
  }
  return i5 ? o5 ? (n2[0] = s5, n2[1] = g4, n2[2] = r7, n2[3] = f6, n2[4] = x3, n2[5] = m4, n2[6] = c7, n2[7] = h7, n2.length = 8, n2) : (n2[0] = s5, n2[1] = g4, n2[2] = r7, n2[3] = x3, n2[4] = m4, n2[5] = c7, n2.length = 6, n2) : o5 ? (n2[0] = s5, n2[1] = g4, n2[2] = f6, n2[3] = x3, n2[4] = m4, n2[5] = h7, n2.length = 6, n2) : (n2[0] = s5, n2[1] = g4, n2[2] = x3, n2[3] = m4, n2.length = 4, n2);
}
function s(n2, t4, i5, o5, e5, r7) {
  const u6 = t4.xmin, l5 = t4.xmax, c7 = t4.ymin, f6 = t4.ymax;
  let h7 = t4.zmin, s5 = t4.zmax, g4 = t4.mmin, x3 = t4.mmax;
  return e5 ? (h7 = h7 || 0, s5 = s5 || 0, r7 ? (g4 = g4 || 0, x3 = x3 || 0, n2[0] = u6, n2[1] = c7, n2[2] = h7, n2[3] = g4, n2[4] = l5, n2[5] = f6, n2[6] = s5, n2[7] = x3, n2) : (n2[0] = u6, n2[1] = c7, n2[2] = h7, n2[3] = l5, n2[4] = f6, n2[5] = s5, n2)) : r7 ? (g4 = g4 || 0, x3 = x3 || 0, n2[0] = u6, n2[1] = c7, n2[2] = g4, n2[3] = l5, n2[4] = f6, n2[5] = x3, n2) : (n2[0] = u6, n2[1] = c7, n2[2] = l5, n2[3] = f6, n2);
}
function g(n2, t4, i5, o5, e5, r7) {
  const c7 = i5 ? 3 : 2, f6 = o5 && r7, h7 = i5 && e5;
  if (!t4.length || !t4[0].length)
    return null;
  let s5, g4, x3, m4, [a4, d2] = t4[0], [v3, y3] = t4[0];
  for (let p5 = 0; p5 < t4.length; p5++) {
    const n3 = t4[p5], [i6, o6] = n3;
    if (a4 = u2(a4, i6), d2 = u2(d2, o6), v3 = l2(v3, i6), y3 = l2(y3, o6), h7 && n3.length > 2) {
      const t5 = n3[2];
      s5 = u2(s5, t5), g4 = l2(g4, t5);
    }
    if (f6 && n3.length > c7) {
      const t5 = n3[c7];
      x3 = u2(s5, t5), m4 = l2(g4, t5);
    }
  }
  return e5 ? (s5 = s5 || 0, g4 = g4 || 0, r7 ? (x3 = x3 || 0, m4 = m4 || 0, n2[0] = a4, n2[1] = d2, n2[2] = s5, n2[3] = x3, n2[4] = v3, n2[5] = y3, n2[6] = g4, n2[7] = m4, n2) : (n2[0] = a4, n2[1] = d2, n2[2] = s5, n2[3] = v3, n2[4] = y3, n2[5] = g4, n2)) : r7 ? (x3 = x3 || 0, m4 = m4 || 0, n2[0] = a4, n2[1] = d2, n2[2] = x3, n2[3] = v3, n2[4] = y3, n2[5] = m4, n2) : (n2[0] = a4, n2[1] = d2, n2[2] = v3, n2[3] = y3, n2);
}

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function r4(t4, n2) {
  const e5 = n2[0] - t4[0], r7 = n2[1] - t4[1];
  if (t4.length > 2 && n2.length > 2) {
    const i5 = t4[2] - n2[2];
    return Math.sqrt(e5 * e5 + r7 * r7 + i5 * i5);
  }
  return Math.sqrt(e5 * e5 + r7 * r7);
}
function i3(t4, n2, e5) {
  const r7 = t4[0] + e5 * (n2[0] - t4[0]), i5 = t4[1] + e5 * (n2[1] - t4[1]);
  return t4.length > 2 && n2.length > 2 ? [r7, i5, t4[2] + e5 * (n2[2] - t4[2])] : [r7, i5];
}
function o2(t4, n2, e5, r7) {
  const [i5, o5] = n2, [s5, l5] = e5[r7], [f6, u6] = e5[r7 + 1], c7 = f6 - s5, h7 = u6 - l5, a4 = c7 * c7 + h7 * h7, g4 = (i5 - s5) * c7 + (o5 - l5) * h7, p5 = Math.min(1, Math.max(0, g4 / a4));
  return t4[0] = s5 + c7 * p5, t4[1] = l5 + h7 * p5, t4;
}
function s2(t4, n2, e5) {
  const r7 = e5.rings;
  let i5, o5, s5 = false, f6 = 1 / 0;
  for (let u6 = 0; u6 < r7.length; u6++) {
    const e6 = r7[u6];
    for (let r8 = 0, u7 = e6.length - 1; r8 < e6.length; u7 = r8++)
      i5 = e6[r8], o5 = e6[u7], i5[1] > n2 != o5[1] > n2 && t4 < (o5[0] - i5[0]) * (n2 - i5[1]) / (o5[1] - i5[1]) + i5[0] && (s5 = !s5), f6 = Math.min(f6, l3(t4, n2, i5, o5));
  }
  return 0 === f6 ? 0 : (s5 ? 1 : -1) * Math.sqrt(f6);
}
function l3(t4, n2, e5, r7) {
  let i5 = e5[0], o5 = e5[1], s5 = r7[0] - i5, l5 = r7[1] - o5;
  if (0 !== s5 || 0 !== l5) {
    const e6 = ((t4 - i5) * s5 + (n2 - o5) * l5) / (s5 * s5 + l5 * l5);
    e6 > 1 ? (i5 = r7[0], o5 = r7[1]) : e6 > 0 && (i5 += s5 * e6, o5 += l5 * e6);
  }
  return s5 = t4 - i5, l5 = n2 - o5, s5 * s5 + l5 * l5;
}
function f3(t4, n2) {
  return i3(t4, n2, 0.5);
}
function h4(t4, n2, e5) {
  const r7 = t4.length;
  let i5 = 0, o5 = 0, s5 = 0;
  for (let l5 = 0; l5 < r7; l5++) {
    const f6 = t4[l5], u6 = t4[(l5 + 1) % r7];
    let c7 = 2;
    i5 += f6[0] * u6[1] - u6[0] * f6[1], f6.length > 2 && u6.length > 2 && e5 && (o5 += f6[0] * u6[2] - u6[0] * f6[2], c7 = 3), f6.length > c7 && u6.length > c7 && n2 && (s5 += f6[0] * u6[c7] - u6[0] * f6[c7]);
  }
  return i5 <= 0 && o5 <= 0 && s5 <= 0;
}
function a2(n2) {
  const e5 = n2.length;
  return e5 > 2 && i(n2[0], n2[e5 - 1]);
}
function g2(t4) {
  if ("rings" in t4 && (p4(t4), t4.rings.length > 0 && !h4(t4.rings[0], t4.hasM ?? false, t4.hasZ ?? false)))
    for (const n2 of t4.rings)
      n2.reverse();
}
function p4(t4) {
  if ("rings" in t4)
    for (const n2 of t4.rings)
      a2(n2) || n2.push(n2[0].slice());
}
function M2(t4) {
  if (!t4 || t4.length < 3)
    return 0;
  let n2 = 0;
  const e5 = t4.length - 1;
  for (let r7 = 0; r7 < e5; r7++)
    n2 += (t4[r7][0] - t4[r7 + 1][0]) * (t4[r7][1] + t4[r7 + 1][1]);
  return n2 += (t4[e5][0] - t4[0][0]) * (t4[e5][1] + t4[0][1]), -0.5 * n2;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function e3(n2) {
  return n2 ? n2.hasZ ? [n2.xmax - n2.xmin / 2, n2.ymax - n2.ymin / 2, n2.zmax - n2.zmin / 2] : [n2.xmax - n2.xmin / 2, n2.ymax - n2.ymin / 2] : null;
}
function r5(n2) {
  return n2 ? o3(n2.rings, n2.hasZ ?? false) : null;
}
function o3(n2, t4) {
  if (!n2 || !n2.length)
    return null;
  const l5 = [], e5 = [], r7 = t4 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o5 = 0, i5 = n2.length; o5 < i5; o5++) {
    const l6 = u3(n2[o5], t4, r7);
    l6 && e5.push(l6);
  }
  if (e5.sort((n3, l6) => {
    let e6 = n3[2] - l6[2];
    return 0 === e6 && t4 && (e6 = n3[4] - l6[4]), e6;
  }), e5.length && (l5[0] = e5[0][0], l5[1] = e5[0][1], t4 && (l5[2] = e5[0][3]), (l5[0] < r7[0] || l5[0] > r7[1] || l5[1] < r7[2] || l5[1] > r7[3] || t4 && (l5[2] < r7[4] || l5[2] > r7[5])) && (l5.length = 0)), !l5.length) {
    const e6 = n2[0] && n2[0].length ? i4(n2[0], t4) : null;
    if (!e6)
      return null;
    l5[0] = e6[0], l5[1] = e6[1], t4 && e6.length > 2 && (l5[2] = e6[2]);
  }
  return l5;
}
function u3(n2, t4, l5) {
  let e5 = 0, r7 = 0, o5 = 0, u6 = 0, i5 = 0;
  const s5 = n2.length ? n2[0][0] : 0, g4 = n2.length ? n2[0][1] : 0, h7 = n2.length && t4 ? n2[0][2] : 0;
  for (let f6 = 0; f6 < n2.length; f6++) {
    const c8 = n2[f6], m4 = n2[(f6 + 1) % n2.length], [x3, a4, y3] = c8, p5 = x3 - s5, z = a4 - g4, [Z, d2, j2] = m4, U = Z - s5, b = d2 - g4, k = p5 * b - U * z;
    if (u6 += k, e5 += (p5 + U) * k, r7 += (z + b) * k, t4 && c8.length > 2 && m4.length > 2) {
      const n3 = y3 - h7, t5 = j2 - h7, l6 = p5 * t5 - U * n3;
      o5 += (n3 + t5) * l6, i5 += l6;
    }
    x3 < l5[0] && (l5[0] = x3), x3 > l5[1] && (l5[1] = x3), a4 < l5[2] && (l5[2] = a4), a4 > l5[3] && (l5[3] = a4), t4 && (y3 < l5[4] && (l5[4] = y3), y3 > l5[5] && (l5[5] = y3));
  }
  if (u6 > 0 && (u6 *= -1), i5 > 0 && (i5 *= -1), !u6)
    return null;
  u6 *= 0.5, i5 *= 0.5;
  const c7 = [e5 / (6 * u6) + s5, r7 / (6 * u6) + g4, u6];
  return t4 && (l5[4] === l5[5] || 0 === i5 ? (c7[3] = (l5[4] + l5[5]) / 2, c7[4] = 0) : (c7[3] = o5 / (6 * i5) + h7, c7[4] = i5)), c7;
}
function i4(l5, e5) {
  const r7 = e5 ? [0, 0, 0] : [0, 0], o5 = e5 ? [0, 0, 0] : [0, 0];
  let u6 = 0, i5 = 0, s5 = 0, g4 = 0;
  for (let h7 = 0, c7 = l5.length; h7 < c7 - 1; h7++) {
    const c8 = l5[h7], f6 = l5[h7 + 1];
    if (c8 && f6) {
      r7[0] = c8[0], r7[1] = c8[1], o5[0] = f6[0], o5[1] = f6[1], e5 && c8.length > 2 && f6.length > 2 && (r7[2] = c8[2], o5[2] = f6[2]);
      const l6 = r4(r7, o5);
      if (l6) {
        u6 += l6;
        const n2 = f3(c8, f6);
        i5 += l6 * n2[0], s5 += l6 * n2[1], e5 && n2.length > 2 && (g4 += l6 * n2[2]);
      }
    }
  }
  return u6 > 0 ? e5 ? [i5 / u6, s5 / u6, g4 / u6] : [i5 / u6, s5 / u6] : l5.length ? l5[0] : null;
}
var s3 = 1e-6;
function g3(n2) {
  if (!n2 || !n2.rings)
    return null;
  const { rings: t4 } = n2;
  let e5 = 0;
  for (let o5 = 0; o5 < t4.length; o5++)
    e5 += M2(t4[o5]);
  if (e5 < s3)
    return o3(t4, false);
  const r7 = [0, 0], u6 = t4[0][0];
  for (let l5 = 0; l5 < t4.length; l5++)
    c4(r7, u6, t4[l5]);
  return r7[0] *= 1 / e5, r7[1] *= 1 / e5, r7[0] += u6[0], r7[1] += u6[1], r7;
}
var h5 = 1 / 3;
function c4(n2, t4, e5) {
  if (!n2 || !e5 || e5.length < 3)
    return null;
  const r7 = e5[0], o5 = [0, 0], u6 = [e5[1][0] - r7[0], e5[1][1] - r7[1]];
  let i5;
  for (let l5 = 2; l5 < e5.length; l5++)
    o5[0] = e5[l5][0] - r7[0], o5[1] = e5[l5][1] - r7[1], i5 = 0.5 * h5 * (o5[0] * u6[1] - o5[1] * u6[0]), n2[0] += i5 * (u6[0] + o5[0]), n2[1] += i5 * (u6[1] + o5[1]), u6[0] = o5[0], u6[1] = o5[1];
  const s5 = M2(e5), g4 = [r7[0], r7[1]];
  return g4[0] -= t4[0], g4[1] -= t4[1], g4[0] *= s5, g4[1] *= s5, n2[0] += g4[0], n2[1] += g4[1], n2;
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function u4(n2) {
  return void 0 !== n2.points;
}
function m2(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function o4(n2) {
  return void 0 !== n2.paths;
}
function r6(n2) {
  return void 0 !== n2.rings;
}
var x = [];
function a3(n2, i5, t4, u6) {
  return { xmin: n2, ymin: i5, xmax: t4, ymax: u6 };
}
function c5(n2, i5, t4, u6, m4, o5) {
  return { xmin: n2, ymin: i5, zmin: t4, xmax: u6, ymax: m4, zmax: o5 };
}
function s4(n2, i5, t4, u6, m4, o5) {
  return { xmin: n2, ymin: i5, mmin: t4, xmax: u6, ymax: m4, mmax: o5 };
}
function e4(n2, i5, t4, u6, m4, o5, r7, x3) {
  return { xmin: n2, ymin: i5, zmin: t4, mmin: u6, xmax: m4, ymax: o5, zmax: r7, mmax: x3 };
}
function f4(n2, i5 = false, t4 = false) {
  return i5 ? t4 ? e4(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5], n2[6], n2[7]) : c5(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : t4 ? s4(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : a3(n2[0], n2[1], n2[2], n2[3]);
}
function l4(n2) {
  return n2 ? t3(n2) ? n2 : m2(n2) ? d(n2) : r6(n2) ? v(n2) : o4(n2) ? h6(n2) : u4(n2) ? y2(n2) : null : null;
}
function y2(i5) {
  const { hasZ: t4, hasM: u6, points: m4 } = i5;
  return f4(g(x, m4, t4 ?? false, u6 ?? false), t4, u6);
}
function d(n2) {
  const { x: i5, y: t4, z: u6, m: m4 } = n2, o5 = null != m4;
  return null != u6 ? o5 ? e4(i5, t4, u6, m4, i5, t4, u6, m4) : c5(i5, t4, u6, i5, t4, u6) : o5 ? s4(i5, t4, m4, i5, t4, m4) : a3(i5, t4, i5, t4);
}
function v(n2) {
  const { hasZ: t4, hasM: u6, rings: m4 } = n2, o5 = h3(x, m4, t4 ?? false, u6 ?? false);
  return o5 ? f4(o5, t4, u6) : null;
}
function h6(n2) {
  const { hasZ: t4, hasM: u6, paths: m4 } = n2, o5 = h3(x, m4, t4 ?? false, u6 ?? false);
  return o5 ? f4(o5, t4, u6) : null;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var x2;
function j(t4) {
  return !Array.isArray(t4[0]);
}
var w3 = x2 = class extends p2 {
  static fromExtent(t4) {
    const r7 = t4.clone().normalize(), e5 = t4.spatialReference;
    let s5 = false, i5 = false;
    for (const o5 of r7)
      o5.hasZ && (s5 = true), o5.hasM && (i5 = true);
    const n2 = { rings: r7.map((t5) => {
      const r8 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s5 && t5.hasZ) {
        const e6 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < r8.length; t6++)
          r8[t6].push(e6);
      }
      if (i5 && t5.hasM) {
        const e6 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < r8.length; t6++)
          r8[t6].push(e6);
      }
      return r8;
    }), spatialReference: e5 };
    return s5 && (n2.hasZ = true), i5 && (n2.hasM = true), new x2(n2);
  }
  constructor(...t4) {
    super(...t4), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(t4, r7) {
    let e5, s5, i5 = null, n2 = null;
    return t4 && !Array.isArray(t4) ? (i5 = t4.rings ? t4.rings : null, r7 || (t4.spatialReference ? r7 = t4.spatialReference : t4.rings || (r7 = t4)), e5 = t4.hasZ, s5 = t4.hasM) : i5 = t4, i5 = i5 || [], r7 = r7 || f.WGS84, i5.length && i5[0] && null != i5[0][0] && "number" == typeof i5[0][0] && (i5 = [i5]), n2 = i5[0] && i5[0][0], n2 && (void 0 === e5 && void 0 === s5 ? (e5 = n2.length > 2, s5 = n2.length > 3) : void 0 === e5 ? e5 = s5 ? n2.length > 3 : n2.length > 2 : void 0 === s5 && (s5 = e5 ? n2.length > 3 : n2.length > 2)), { rings: i5, spatialReference: r7, hasZ: e5, hasM: s5 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = r5(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2]))
      return null;
    const r7 = new w();
    return r7.x = t4[0], r7.y = t4[1], r7.spatialReference = this.spatialReference, this.hasZ && (r7.z = t4[2]), r7;
  }
  get extent() {
    const { spatialReference: t4 } = this, r7 = v(this);
    if (!r7)
      return null;
    const e5 = new w2(r7);
    return e5.spatialReference = t4, e5;
  }
  get isSelfIntersecting() {
    return p3(this.rings);
  }
  writeRings(t4, r7) {
    r7.rings = p(this.rings);
  }
  addRing(t4) {
    if (!t4)
      return;
    const r7 = this.rings, e5 = r7.length;
    if (j(t4)) {
      const s5 = [];
      for (let r8 = 0, e6 = t4.length; r8 < e6; r8++)
        s5[r8] = t4[r8].toArray();
      r7[e5] = s5;
    } else
      r7[e5] = t4.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new x2();
    return t4.spatialReference = this.spatialReference, t4.rings = p(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (t(t4))
      return false;
    const e5 = this.spatialReference, n2 = t4.spatialReference;
    if (r(e5) !== r(n2))
      return false;
    if (r(e5) && r(n2) && !e5.equals(n2))
      return false;
    if (this.rings.length !== t4.rings.length)
      return false;
    const o5 = ([t5, r7, e6, s5], [i5, n3, o6, a4]) => t5 === i5 && r7 === n3 && (null == e6 && null == o6 || e6 === o6) && (null == s5 && null == a4 || s5 === a4);
    for (let s5 = 0; s5 < this.rings.length; s5++) {
      const e6 = this.rings[s5], i5 = t4.rings[s5];
      if (!i(e6, i5, o5))
        return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4)
      return false;
    const r7 = M(t4, this.spatialReference);
    return c(this, r(r7) ? r7 : t4);
  }
  isClockwise(t4) {
    let r7;
    return r7 = j(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4, h4(r7, this.hasM, this.hasZ);
  }
  getPoint(t4, r7) {
    if (!this._validateInputs(t4, r7))
      return null;
    const e5 = this.rings[t4][r7], s5 = this.hasZ, i5 = this.hasM;
    return s5 && !i5 ? new w(e5[0], e5[1], e5[2], void 0, this.spatialReference) : i5 && !s5 ? new w(e5[0], e5[1], void 0, e5[2], this.spatialReference) : s5 && i5 ? new w(e5[0], e5[1], e5[2], e5[3], this.spatialReference) : new w(e5[0], e5[1], this.spatialReference);
  }
  insertPoint(t4, r7, e5) {
    return this._validateInputs(t4, r7, true) ? (h(this, e5), Array.isArray(e5) || (e5 = e5.toArray()), this.rings[t4].splice(r7, 0, e5), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, r7) {
    if (!this._validateInputs(t4, r7))
      return null;
    const e5 = new w(this.rings[t4].splice(r7, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e5;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const r7 = this.rings.splice(t4, 1)[0], e5 = this.spatialReference, s5 = r7.map((t5) => new w(t5, e5));
    return this.notifyChange("rings"), s5;
  }
  setPoint(t4, r7, e5) {
    return this._validateInputs(t4, r7) ? (h(this, e5), Array.isArray(e5) || (e5 = e5.toArray()), this.rings[t4][r7] = e5, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, r7, e5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length)
      return false;
    if (null != r7) {
      const s5 = this.rings[t4];
      if (e5 && (r7 < 0 || r7 > s5.length))
        return false;
      if (!e5 && (r7 < 0 || r7 >= s5.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], w3.prototype, "cache", null), e([y({ readOnly: true })], w3.prototype, "centroid", null), e([y({ readOnly: true })], w3.prototype, "extent", null), e([y({ readOnly: true })], w3.prototype, "isSelfIntersecting", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], w3.prototype, "rings", void 0), e([r2("rings")], w3.prototype, "writeRings", null), w3 = x2 = e([a("esri.geometry.Polygon")], w3), w3.prototype.toJSON.isDefaultToJSON = true;
var v2 = w3;

// node_modules/@arcgis/core/geometry/Polyline.js
var c6;
function u5(t4) {
  return !Array.isArray(t4[0]);
}
var f5 = c6 = class extends p2 {
  constructor(...t4) {
    super(...t4), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t4, e5) {
    let s5, r7, i5 = null, a4 = null;
    return t4 && !Array.isArray(t4) ? (i5 = t4.paths ? t4.paths : null, e5 || (t4.spatialReference ? e5 = t4.spatialReference : t4.paths || (e5 = t4)), s5 = t4.hasZ, r7 = t4.hasM) : i5 = t4, i5 = i5 || [], e5 = e5 || f.WGS84, i5.length && i5[0] && null != i5[0][0] && "number" == typeof i5[0][0] && (i5 = [i5]), a4 = i5[0] && i5[0][0], a4 && (void 0 === s5 && void 0 === r7 ? (s5 = a4.length > 2, r7 = false) : void 0 === s5 ? s5 = !r7 && a4.length > 3 : void 0 === r7 && (r7 = !s5 && a4.length > 3)), { paths: i5, spatialReference: e5, hasZ: s5, hasM: r7 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t4 } = this, e5 = h6(this);
    if (!e5)
      return null;
    const s5 = new w2(e5);
    return s5.spatialReference = t4, s5;
  }
  writePaths(t4, s5) {
    s5.paths = p(this.paths);
  }
  addPath(t4) {
    if (!t4)
      return;
    const e5 = this.paths, s5 = e5.length;
    if (u5(t4)) {
      const r7 = [];
      for (let e6 = 0, s6 = t4.length; e6 < s6; e6++)
        r7[e6] = t4[e6].toArray();
      e5[s5] = r7;
    } else
      e5[s5] = t4.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c6();
    return t4.spatialReference = this.spatialReference, t4.paths = p(this.paths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e5) {
    if (!this._validateInputs(t4, e5))
      return null;
    const s5 = this.paths[t4][e5], r7 = this.hasZ, i5 = this.hasM;
    return r7 && !i5 ? new w(s5[0], s5[1], s5[2], void 0, this.spatialReference) : i5 && !r7 ? new w(s5[0], s5[1], void 0, s5[2], this.spatialReference) : r7 && i5 ? new w(s5[0], s5[1], s5[2], s5[3], this.spatialReference) : new w(s5[0], s5[1], this.spatialReference);
  }
  insertPoint(t4, e5, s5) {
    return this._validateInputs(t4, e5, true) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4].splice(e5, 0, s5), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e5 = this.paths.splice(t4, 1)[0], s5 = this.spatialReference, r7 = e5.map((t5) => new w(t5, s5));
    return this.notifyChange("paths"), r7;
  }
  removePoint(t4, e5) {
    if (!this._validateInputs(t4, e5))
      return null;
    const s5 = new w(this.paths[t4].splice(e5, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s5;
  }
  setPoint(t4, e5, s5) {
    return this._validateInputs(t4, e5) ? (h(this, s5), Array.isArray(s5) || (s5 = s5.toArray()), this.paths[t4][e5] = s5, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e5, s5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length)
      return false;
    if (null != e5) {
      const r7 = this.paths[t4];
      if (s5 && (e5 < 0 || e5 > r7.length))
        return false;
      if (!s5 && (e5 < 0 || e5 >= r7.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], f5.prototype, "cache", null), e([y({ readOnly: true })], f5.prototype, "extent", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], f5.prototype, "paths", void 0), e([r2("paths")], f5.prototype, "writePaths", null), f5 = c6 = e([a("esri.geometry.Polyline")], f5), f5.prototype.toJSON.isDefaultToJSON = true;
var m3 = f5;

export {
  u,
  o2 as o,
  s2 as s,
  h4 as h,
  g2 as g,
  p4 as p,
  M2 as M,
  e3 as e,
  r5 as r,
  o3 as o2,
  u3 as u2,
  g3 as g2,
  c3 as c,
  f2 as f,
  g as g3,
  l4 as l,
  v,
  v2,
  m3 as m
};
//# sourceMappingURL=chunk-M73MMEC7.js.map

import {
  l
} from "./chunk-TQCVRALN.js";
import {
  b
} from "./chunk-ZH4VVE2N.js";
import {
  n
} from "./chunk-EALW5DHT.js";
import {
  j
} from "./chunk-LJAKPJDJ.js";
import {
  a2 as a,
  e,
  y3 as y
} from "./chunk-3PPVODAA.js";
import {
  C
} from "./chunk-WTKFW2TD.js";
import {
  s
} from "./chunk-UG2OEDEE.js";

// node_modules/@arcgis/core/support/collectionUtils.js
function t(t2) {
  return new l({ getCollections: () => [t2.tables, t2.layers], getChildrenFunction: (e2) => {
    const t3 = [];
    return "tables" in e2 && t3.push(e2.tables), "layers" in e2 && t3.push(e2.layers), t3;
  }, itemFilterFunction: (e2) => {
    const t3 = e2.parent;
    return !!t3 && "tables" in t3 && t3.tables.includes(e2);
  } });
}

// node_modules/@arcgis/core/support/LayersMixin.js
function n2(e2, r, t2) {
  let s2, o;
  if (e2)
    for (let a3 = 0, i = e2.length; a3 < i; a3++) {
      if (s2 = e2.getItemAt(a3), s2[r] === t2)
        return s2;
      if ("group" === (s2 == null ? void 0 : s2.type) && (o = n2(s2.layers, r, t2), o))
        return o;
    }
}
var d = (d2) => {
  let y2 = class extends d2 {
    constructor(...e2) {
      super(...e2), this.layers = new j();
      const t2 = (e3) => {
        e3.parent && "remove" in e3.parent && e3.parent.remove(e3);
      }, o = (e3) => {
        e3.parent = this, this.layerAdded(e3), "elevation" !== e3.type && "base-elevation" !== e3.type || s.getLogger(this.declaredClass).error(`Layer 'title:${e3.title}, id:${e3.id}' of type '${e3.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, a3 = (e3) => {
        e3.parent = null, this.layerRemoved(e3);
      };
      this.layers.on("before-add", (e3) => t2(e3.item)), this.layers.on("after-add", (e3) => o(e3.item)), this.layers.on("after-remove", (e3) => a3(e3.item));
    }
    destroy() {
      const e2 = this.layers.removeAll();
      for (const r of e2)
        this.layerRemoved(r), r.destroy();
      this.layers.destroy();
    }
    set layers(e2) {
      this._set("layers", n(e2, this._get("layers")));
    }
    add(e2, r) {
      const t2 = this.layers;
      if (r = t2.getNextIndex(r), e2 instanceof b) {
        const s2 = e2;
        s2.parent === this ? this.reorder(s2, r) : t2.add(s2, r);
      } else
        C(e2) ? e2.then((e3) => {
          this.destroyed || this.add(e3, r);
        }) : s.getLogger(this.declaredClass).error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(e2, r) {
      const t2 = this.layers;
      let s2 = t2.getNextIndex(r);
      e2.slice().forEach((e3) => {
        e3.parent !== this ? (t2.add(e3, s2), s2 += 1) : this.reorder(e3, s2);
      });
    }
    findLayerById(e2) {
      return n2(this.layers, "id", e2);
    }
    findLayerByUid(e2) {
      return n2(this.layers, "uid", e2);
    }
    remove(e2) {
      return this.layers.remove(e2);
    }
    removeMany(e2) {
      return this.layers.removeMany(e2);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(e2, r) {
      return this.layers.reorder(e2, r);
    }
    layerAdded(e2) {
    }
    layerRemoved(e2) {
    }
  };
  return e([y()], y2.prototype, "layers", null), y2 = e([a("esri.support.LayersMixin")], y2), y2;
};

// node_modules/@arcgis/core/support/TablesMixin.js
function a2(t2, e2, r) {
  if (t2)
    for (let s2 = 0, o = t2.length; s2 < o; s2++) {
      const o2 = t2.getItemAt(s2);
      if (o2[e2] === r)
        return o2;
      if ("group" === (o2 == null ? void 0 : o2.type)) {
        const t3 = a2(o2.tables, e2, r);
        if (t3)
          return t3;
      }
    }
}
var l2 = (l3) => {
  let n3 = class extends l3 {
    constructor(...t2) {
      super(...t2), this.tables = new j(), this.tables.on("after-add", (t3) => {
        const e2 = t3.item;
        e2.parent && e2.parent !== this && "tables" in e2.parent && e2.parent.tables.remove(e2), e2.parent = this, "feature" !== e2.type && s.getLogger(this.declaredClass).error(`Layer 'title:${e2.title}, id:${e2.id}' of type '${e2.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (t3) => {
        t3.item.parent = null;
      });
    }
    destroy() {
      const t2 = this.tables.removeAll();
      for (const e2 of t2)
        e2.destroy();
      this.tables.destroy();
    }
    set tables(t2) {
      this._set("tables", n(t2, this._get("tables")));
    }
    findTableById(t2) {
      return a2(this.tables, "id", t2);
    }
    findTableByUid(t2) {
      return a2(this.tables, "uid", t2);
    }
  };
  return e([y()], n3.prototype, "tables", null), n3 = e([a("esri.support.TablesMixin")], n3), n3;
};

export {
  t,
  d,
  l2 as l
};
//# sourceMappingURL=chunk-NC6SXEMY.js.map

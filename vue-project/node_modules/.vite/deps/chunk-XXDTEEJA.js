import {
  e
} from "./chunk-OPQ632ST.js";
import {
  s as s4,
  t as t2
} from "./chunk-U6GC73UT.js";
import {
  q,
  w
} from "./chunk-XF2RZJFH.js";
import {
  o
} from "./chunk-HRFBINZY.js";
import {
  f,
  l,
  s as s3,
  y
} from "./chunk-2ZX6RZTI.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  i,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function g(t3, e2) {
  return t3 ? e2 ? 4 : 3 : e2 ? 3 : 2;
}
var y2 = s.getLogger("esri.layers.graphics.featureConversionUtils");
var p = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0 };
var I = (t3, e2, o2, n, r2, s5) => {
  t3[o2] = r2, t3[o2 + 1] = s5;
};
var b = (t3, e2, o2, n, r2, s5) => {
  t3[o2] = r2, t3[o2 + 1] = s5, t3[o2 + 2] = e2[n + 2];
};
var w2 = (t3, e2, o2, n, r2, s5) => {
  t3[o2] = r2, t3[o2 + 1] = s5, t3[o2 + 2] = e2[n + 3];
};
var M = (t3, e2, o2, n, r2, s5) => {
  t3[o2] = r2, t3[o2 + 1] = s5, t3[o2 + 2] = e2[n + 2], t3[o2 + 3] = e2[n + 3];
};
function N(t3, e2, o2, n) {
  if (t3) {
    if (o2)
      return e2 && n ? M : b;
    if (e2 && n)
      return w2;
  } else if (e2 && n)
    return b;
  return I;
}
function G({ scale: t3, translate: e2 }, o2) {
  return Math.round((o2 - e2[0]) / t3[0]);
}
function T({ scale: t3, translate: e2 }, o2) {
  return Math.round((e2[1] - o2) / t3[1]);
}
function x({ scale: t3, translate: e2 }, o2, n) {
  return o2 * t3[n] + e2[n];
}
function j(t3, e2, o2) {
  return t3 ? e2 ? o2 ? V(t3) : v(t3) : o2 ? z(t3) : Z(t3) : null;
}
function Z(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1] };
}
function k(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3;
}
function v(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2] };
}
function E(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3;
}
function z(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], m: e2[2] };
}
function S(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.m, t3;
}
function V(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2], m: e2[3] };
}
function Y(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3.coords[3] = e2.m, t3;
}
function _(t3, e2, n, r2) {
  let s5 = Z;
  n && r2 ? s5 = V : n ? s5 = v : r2 && (s5 = z);
  for (const c of e2) {
    const { geometry: e3, attributes: n2 } = c, r3 = r(e3) ? s5(e3) : null;
    t3.push({ attributes: n2, geometry: r3 });
  }
  return t3;
}
function L(t3, e2) {
  return t3 && e2 ? Y : t3 ? E : e2 ? S : k;
}
function O(t3, e2, n, r2, s5) {
  const c = L(n, r2);
  for (const { geometry: u, attributes: i2 } of e2) {
    const e3 = r(u) ? c(new t2(), u) : null;
    t3.push(new s4(e3, i2, null, s5 ? i2[s5] : void 0));
  }
  return t3;
}
function U(t3, e2, o2 = L(null != e2.z, null != e2.m)) {
  return o2(t3, e2);
}
function A(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c } of e2)
    t3.push({ attributes: c, geometry: r(s5) ? q2(s5, n, r2) : null });
  return t3;
}
function q2(t3, e2, o2) {
  if (t(t3))
    return null;
  const r2 = g(e2, o2), s5 = [];
  for (let n = 0; n < t3.coords.length; n += r2) {
    const e3 = [];
    for (let o3 = 0; o3 < r2; o3++)
      e3.push(t3.coords[n + o3]);
    s5.push(e3);
  }
  return e2 ? o2 ? { points: s5, hasZ: e2, hasM: o2 } : { points: s5, hasZ: e2 } : o2 ? { points: s5, hasM: o2 } : { points: s5 };
}
function R(t3, e2, n, r2, s5) {
  const c = g(n, r2);
  for (const { geometry: u, attributes: i2 } of e2) {
    const e3 = r(u) ? $(new t2(), u, c) : null;
    t3.push(new s4(e3, i2, null, s5 ? i2[s5] : void 0));
  }
  return t3;
}
function $(t3, e2, o2 = g(e2.hasZ, e2.hasM)) {
  t3.lengths[0] = e2.points.length;
  const n = t3.coords;
  let r2 = 0;
  for (const s5 of e2.points)
    for (let t4 = 0; t4 < o2; t4++)
      n[r2++] = s5[t4];
  return t3;
}
function B(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c } of e2)
    t3.push({ attributes: c, geometry: r(s5) ? C(s5, n, r2) : null });
  return t3;
}
function C(t3, e2, o2) {
  if (!t3)
    return null;
  const n = g(e2, o2), { coords: r2, lengths: s5 } = t3, c = [];
  let u = 0;
  for (const i2 of s5) {
    const t4 = [];
    for (let e3 = 0; e3 < i2; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[u++]);
      t4.push(e4);
    }
    c.push(t4);
  }
  return e2 ? o2 ? { paths: c, hasZ: e2, hasM: o2 } : { paths: c, hasZ: e2 } : o2 ? { paths: c, hasM: o2 } : { paths: c };
}
function D(t3, e2, n, r2, s5) {
  const c = g(n, r2);
  for (const { geometry: u, attributes: i2 } of e2) {
    const e3 = r(u) ? H(new t2(), u, c) : null;
    t3.push(new s4(e3, i2, null, s5 ? i2[s5] : void 0));
  }
  return t3;
}
function H(t3, e2, o2 = g(e2.hasZ, e2.hasM)) {
  const { lengths: n, coords: r2 } = t3;
  let s5 = 0;
  for (const c of e2.paths) {
    for (const t4 of c)
      for (let e3 = 0; e3 < o2; e3++)
        r2[s5++] = t4[e3];
    n.push(c.length);
  }
  return t3;
}
function J(t3, e2, n, r2) {
  for (const { geometry: s5, attributes: c, centroid: u } of e2) {
    const e3 = r(s5) ? K(s5, n, r2) : null;
    if (r(u)) {
      const o2 = Z(u);
      t3.push({ attributes: c, centroid: o2, geometry: e3 });
    } else
      t3.push({ attributes: c, geometry: e3 });
  }
  return t3;
}
function K(t3, e2, o2) {
  if (!t3)
    return null;
  const n = g(e2, o2), { coords: r2, lengths: s5 } = t3, c = [];
  let u = 0;
  for (const i2 of s5) {
    const t4 = [];
    for (let e3 = 0; e3 < i2; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[u++]);
      t4.push(e4);
    }
    c.push(t4);
  }
  return e2 ? o2 ? { rings: c, hasZ: e2, hasM: o2 } : { rings: c, hasZ: e2 } : o2 ? { rings: c, hasM: o2 } : { rings: c };
}
function Q(t3, e2, n, r2, s5) {
  for (const { geometry: c, centroid: u, attributes: i2 } of e2) {
    const e3 = r(c) ? W(new t2(), c, n, r2) : null, l2 = s5 ? i2[s5] : void 0;
    r(u) ? t3.push(new s4(e3, i2, k(new t2(), u), l2)) : t3.push(new s4(e3, i2, null, l2));
  }
  return t3;
}
function W(t3, e2, o2 = e2.hasZ, n = e2.hasM) {
  return X(t3, e2.rings, o2, n), t3;
}
function X(t3, e2, o2, n) {
  const r2 = g(o2, n), { lengths: s5, coords: c } = t3;
  let u = 0;
  xt(t3);
  for (const i2 of e2) {
    for (const t4 of i2)
      for (let e3 = 0; e3 < r2; e3++)
        c[u++] = t4[e3];
    s5.push(i2.length);
  }
  return t3;
}
var tt = [];
var et = [];
function ot(t3, e2, o2, n, r2) {
  tt[0] = t3;
  const [s5] = nt(et, tt, e2, o2, n, r2);
  return jt(tt), jt(et), s5;
}
function nt(e2, o2, n, r2, s5, c) {
  if (jt(e2), !n) {
    for (const t3 of o2) {
      const o3 = c ? t3.attributes[c] : void 0;
      e2.push(new s4(null, t3.attributes, null, o3));
    }
    return e2;
  }
  switch (n) {
    case "esriGeometryPoint":
      return O(e2, o2, r2, s5, c);
    case "esriGeometryMultipoint":
      return R(e2, o2, r2, s5, c);
    case "esriGeometryPolyline":
      return D(e2, o2, r2, s5, c);
    case "esriGeometryPolygon":
      return Q(e2, o2, r2, s5, c);
    default:
      y2.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`)), jt(e2);
  }
  return e2;
}
function rt(e2, o2, n, r2, s5, c) {
  const u = e2.length;
  switch (n) {
    case "esriGeometryPoint":
      O(e2, o2, r2, s5, c);
      break;
    case "esriGeometryMultipoint":
      R(e2, o2, r2, s5, c);
      break;
    case "esriGeometryPolyline":
      D(e2, o2, r2, s5, c);
      break;
    case "esriGeometryPolygon":
      Q(e2, o2, r2, s5, c);
      break;
    default:
      y2.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`));
  }
  for (let t3 = 0; t3 < o2.length; t3++)
    e2[t3 + u].geometryType = n, e2[t3 + u].insertAfter = o2[t3].insertAfter, e2[t3 + u].groupId = o2[t3].groupId;
  return e2;
}
function st(t3, e2, o2, n) {
  et[0] = t3, lt(tt, et, e2, o2, n);
  const r2 = tt[0];
  return jt(tt), jt(et), r2;
}
function ct(e2, o2, r2) {
  if (t(e2))
    return null;
  const s5 = new t2();
  if ("hasZ" in e2 && null == o2 && (o2 = e2.hasZ), "hasM" in e2 && null == r2 && (r2 = e2.hasM), s3(e2)) {
    return L(null != o2 ? o2 : null != e2.z, null != r2 ? r2 : null != e2.m)(s5, e2);
  }
  return y(e2) ? W(s5, e2, o2, r2) : f(e2) ? H(s5, e2, g(o2, r2)) : l(e2) ? $(s5, e2, g(o2, r2)) : void y2.error("convertFromGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${e2}'`));
}
function ut(e2, o2, r2, s5) {
  const c = e2 && ("coords" in e2 ? e2 : e2.geometry);
  if (t(c))
    return null;
  switch (o2) {
    case "esriGeometryPoint": {
      let t3 = Z;
      return r2 && s5 ? t3 = V : r2 ? t3 = v : s5 && (t3 = z), t3(c);
    }
    case "esriGeometryMultipoint":
      return q2(c, r2, s5);
    case "esriGeometryPolyline":
      return C(c, r2, s5);
    case "esriGeometryPolygon":
      return K(c, r2, s5);
    default:
      return y2.error("convertToGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o2}'`)), null;
  }
}
function it(t3, e2) {
  for (const o2 of e2)
    t3.push({ attributes: o2.attributes });
  return t3;
}
function lt(e2, o2, r2, s5, c) {
  if (jt(e2), t(r2))
    return it(e2, o2);
  switch (r2) {
    case "esriGeometryPoint":
      return _(e2, o2, s5, c);
    case "esriGeometryMultipoint":
      return A(e2, o2, s5, c);
    case "esriGeometryPolyline":
      return B(e2, o2, s5, c);
    case "esriGeometryPolygon":
      return J(e2, o2, s5, c);
    default:
      y2.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${r2}'`));
  }
  return e2;
}
function ft(t3) {
  const { objectIdFieldName: e2, spatialReference: o2, transform: n, fields: r2, hasM: s5, hasZ: c, features: u, geometryType: i2, exceededTransferLimit: l2, uniqueIdField: f2, queryGeometry: a, queryGeometryType: h } = t3, d = { features: lt([], u, i2, c, s5), fields: r2, geometryType: i2, objectIdFieldName: e2, spatialReference: o2, uniqueIdField: f2, queryGeometry: ut(a, h, false, false) };
  return n && (d.transform = n), l2 && (d.exceededTransferLimit = l2), s5 && (d.hasM = s5), c && (d.hasZ = c), d;
}
function at(e2, o2) {
  const n = new e(), { hasM: r2, hasZ: s5, features: c, objectIdFieldName: u, spatialReference: i2, geometryType: l2, exceededTransferLimit: f2, transform: a, fields: h } = e2;
  return h && (n.fields = h), n.geometryType = l2 ?? null, n.objectIdFieldName = u ?? o2 ?? null, n.spatialReference = i2 ?? null, n.objectIdFieldName ? (c && nt(n.features, c, l2, s5, r2, n.objectIdFieldName), f2 && (n.exceededTransferLimit = f2), r2 && (n.hasM = r2), s5 && (n.hasZ = s5), a && (n.transform = a), n) : (y2.error(new s2("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), n);
}
function ht(t3) {
  const { transform: e2, features: n, hasM: r2, hasZ: s5 } = t3;
  if (!e2)
    return t3;
  for (const c of n)
    r(c.geometry) && wt(c.geometry, c.geometry, r2, s5, e2), r(c.centroid) && wt(c.centroid, c.centroid, r2, s5, e2);
  return t3.transform = null, t3;
}
function dt(t3, e2) {
  const { geometryType: o2, features: n, hasM: r2, hasZ: s5 } = e2;
  if (!t3)
    return e2;
  for (let c = 0; c < n.length; c++) {
    const e3 = n[c], u = e3.weakClone();
    u.geometry = new t2(), mt(u.geometry, e3.geometry, r2, s5, o2, t3), e3.centroid && (u.centroid = new t2(), mt(u.centroid, e3.centroid, r2, s5, "esriGeometryPoint", t3)), n[c] = u;
  }
  return e2.transform = t3, e2;
}
function mt(t3, e2, o2, r2, s5, c, u = o2, i2 = r2) {
  if (xt(t3), t(e2) || !e2.coords.length)
    return null;
  const l2 = p[s5], { coords: f2, lengths: a } = e2, h = g(o2, r2), d = g(o2 && u, r2 && i2), m = N(o2, r2, u, i2);
  if (!a.length)
    return m(t3.coords, f2, 0, 0, G(c, f2[0]), T(c, f2[1])), xt(t3, h, 0), t3;
  let y3, I2, b2, w3, M2 = 0, F = 0, P = F;
  for (const n of a) {
    if (n < l2)
      continue;
    let e3 = 0;
    F = P, b2 = y3 = G(c, f2[M2]), w3 = I2 = T(c, f2[M2 + 1]), m(t3.coords, f2, F, M2, b2, w3), e3++, M2 += h, F += d;
    for (let o3 = 1; o3 < n; o3++, M2 += h)
      b2 = G(c, f2[M2]), w3 = T(c, f2[M2 + 1]), b2 === y3 && w3 === I2 || (m(t3.coords, f2, F, M2, b2 - y3, w3 - I2), F += d, e3++, y3 = b2, I2 = w3);
    e3 >= l2 && (t3.lengths.push(e3), P = F);
  }
  return jt(t3.coords, P), t3.coords.length ? t3 : null;
}
function gt(t3, e2, o2, n, r2, s5, c = o2, u = n) {
  if (xt(t3), !e2 || !e2.coords.length)
    return null;
  const i2 = p[r2], { coords: l2, lengths: f2 } = e2, a = g(o2, n), h = g(o2 && c, n && u), d = N(o2, n, c, u);
  if (!f2.length)
    return d(t3.coords, l2, 0, 0, l2[0], l2[1]), xt(t3, a, 0), t3;
  let m = 0;
  const y3 = s5 * s5;
  for (const g2 of f2) {
    if (g2 < i2) {
      m += g2 * a;
      continue;
    }
    const e3 = t3.coords.length / h, o3 = m, n2 = m + (g2 - 1) * a;
    d(t3.coords, l2, t3.coords.length, o3, l2[o3], l2[o3 + 1]), pt(t3.coords, l2, a, y3, d, o3, n2), d(t3.coords, l2, t3.coords.length, n2, l2[n2], l2[n2 + 1]);
    const r3 = t3.coords.length / h - e3;
    r3 >= i2 ? t3.lengths.push(r3) : jt(t3.coords, e3 * h), m += g2 * a;
  }
  return t3.coords.length ? t3 : null;
}
function yt(t3, e2, o2, n) {
  const r2 = t3[e2], s5 = t3[e2 + 1], c = t3[o2], u = t3[o2 + 1], i2 = t3[n], l2 = t3[n + 1];
  let f2 = c, a = u, h = i2 - f2, d = l2 - a;
  if (0 !== h || 0 !== d) {
    const t4 = ((r2 - f2) * h + (s5 - a) * d) / (h * h + d * d);
    t4 > 1 ? (f2 = i2, a = l2) : t4 > 0 && (f2 += h * t4, a += d * t4);
  }
  return h = r2 - f2, d = s5 - a, h * h + d * d;
}
function pt(t3, e2, o2, n, r2, s5, c) {
  let u, i2 = n, l2 = 0;
  for (let f2 = s5 + o2; f2 < c; f2 += o2)
    u = yt(e2, f2, s5, c), u > i2 && (l2 = f2, i2 = u);
  i2 > n && (l2 - s5 > o2 && pt(t3, e2, o2, n, r2, s5, l2), r2(t3, e2, t3.length, l2, e2[l2], e2[l2 + 1]), c - l2 > o2 && pt(t3, e2, o2, n, r2, l2, c));
}
function It(t3, e2, o2, r2) {
  if (t(e2) || !e2.coords || !e2.coords.length)
    return null;
  const i2 = g(o2, r2);
  let l2 = Number.POSITIVE_INFINITY, f2 = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, h = Number.NEGATIVE_INFINITY;
  if (e2 && e2.coords) {
    const t4 = e2.coords;
    for (let e3 = 0; e3 < t4.length; e3 += i2) {
      const o3 = t4[e3], n = t4[e3 + 1];
      l2 = Math.min(l2, o3), a = Math.max(a, o3), f2 = Math.min(f2, n), h = Math.max(h, n);
    }
  }
  return w(t3) ? q(t3, l2, f2, a, h) : o(l2, f2, a, h, t3), t3;
}
function wt(t3, e2, o2, n, s5) {
  const { coords: c, lengths: u } = e2, i2 = g(o2, n);
  if (!c.length)
    return t3 !== e2 && xt(t3), t3;
  i(s5);
  const { originPosition: l2, scale: f2, translate: a } = s5, h = Zt;
  h.originPosition = l2;
  const d = h.scale;
  d[0] = f2[0] ?? 1, d[1] = -(f2[1] ?? 1), d[2] = f2[2] ?? 1, d[3] = f2[3] ?? 1;
  const m = h.translate;
  if (m[0] = a[0] ?? 0, m[1] = a[1] ?? 0, m[2] = a[2] ?? 0, m[3] = a[3] ?? 0, !u.length) {
    for (let e3 = 0; e3 < i2; ++e3)
      t3.coords[e3] = x(h, c[e3], e3);
    return t3 !== e2 && xt(t3, i2, 0), t3;
  }
  let y3 = 0;
  for (let r2 = 0; r2 < u.length; r2++) {
    const e3 = u[r2];
    t3.lengths[r2] = e3;
    for (let r3 = 0; r3 < i2; ++r3)
      t3.coords[y3 + r3] = x(h, c[y3 + r3], r3);
    let o3 = t3.coords[y3], n2 = t3.coords[y3 + 1];
    y3 += i2;
    for (let r3 = 1; r3 < e3; r3++, y3 += i2) {
      o3 += c[y3] * d[0], n2 += c[y3 + 1] * d[1], t3.coords[y3] = o3, t3.coords[y3 + 1] = n2;
      for (let e4 = 2; e4 < i2; ++e4)
        t3.coords[y3 + e4] = x(h, c[y3 + e4], e4);
    }
  }
  return t3 !== e2 && xt(t3, c.length, u.length), t3;
}
function Mt(t3, e2, o2, n, r2, s5) {
  if (xt(t3), t3.lengths.push(...e2.lengths), o2 === r2 && n === s5)
    for (let c = 0; c < e2.coords.length; c++)
      t3.coords.push(e2.coords[c]);
  else {
    const c = g(o2, n), u = N(o2, n, r2, s5), i2 = e2.coords;
    for (let e3 = 0; e3 < i2.length; e3 += c)
      u(t3.coords, i2, t3.coords.length, e3, i2[e3], i2[e3 + 1]);
  }
  return t3;
}
function Gt(t3, e2, o2, n) {
  let r2 = 0, s5 = t3[n * e2], c = t3[n * (e2 + 1)];
  for (let u = 1; u < o2; u++) {
    const o3 = s5 + t3[n * (e2 + u)], i2 = c + t3[n * (e2 + u) + 1], l2 = (o3 - s5) * (i2 + c);
    s5 = o3, c = i2, r2 += l2;
  }
  return 0.5 * r2;
}
function Tt(t3, e2) {
  const { coords: o2, lengths: n } = t3;
  let r2 = 0, s5 = 0;
  for (let c = 0; c < n.length; c++) {
    const t4 = n[c];
    s5 += Gt(o2, r2, t4, e2), r2 += t4;
  }
  return Math.abs(s5);
}
function Pt(t3, e2) {
  if (t(t3))
    return null;
  const o2 = t3.clone(), r2 = t3.coords, s5 = t3.lengths;
  let c = 0;
  for (let n = 0; n < s5.length; n++) {
    const t4 = s5[n];
    let u = r2[e2 * c], i2 = r2[e2 * c + 1];
    for (let n2 = 1; n2 < t4; n2++) {
      const t5 = u + r2[e2 * (c + n2)], s6 = i2 + r2[e2 * (c + n2) + 1];
      o2.coords[e2 * (c + n2)] = t5, o2.coords[e2 * (c + n2) + 1] = s6, u = t5, i2 = s6;
    }
    c += t4;
  }
  return o2;
}
function xt(t3, e2 = 0, o2 = 0) {
  jt(t3.lengths, o2), jt(t3.coords, e2);
}
function jt(t3, e2 = 0) {
  t3.length !== e2 && (t3.length = e2);
}
var Zt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };

export {
  G,
  T,
  j,
  U,
  q2 as q,
  C,
  H,
  K,
  W,
  X,
  ot,
  nt,
  rt,
  st,
  ct,
  ut,
  ft,
  at,
  ht,
  dt,
  mt,
  gt,
  It,
  wt,
  Mt,
  Tt,
  Pt
};
//# sourceMappingURL=chunk-XXDTEEJA.js.map

import {
  T
} from "./chunk-6THMFCX4.js";
import {
  t as t2
} from "./chunk-IEBU4QQL.js";
import {
  O
} from "./chunk-CPQSD22U.js";
import {
  C
} from "./chunk-4M3AMTD4.js";
import {
  r as r2
} from "./chunk-XCHMTTFV.js";
import {
  l,
  m
} from "./chunk-JT54I3AY.js";
import {
  H,
  P,
  _,
  e2 as e,
  n,
  o,
  r2 as r,
  u2 as u,
  x,
  z
} from "./chunk-TNTTCGVB.js";
import {
  p,
  t
} from "./chunk-MGJMBJDY.js";

// node_modules/@arcgis/core/views/3d/support/buffer/glUtil.js
function o2(t4, o4 = 0) {
  const n3 = t4.stride;
  return t4.fieldNames.filter((e3) => {
    const o5 = t4.fields.get(e3).optional;
    return !(o5 && o5.glPadding);
  }).map((i) => {
    const s = t4.fields.get(i), l3 = s.constructor.ElementCount, u5 = r3(s.constructor.ElementType), f3 = s.offset, c2 = !(!s.optional || !s.optional.glNormalized);
    return new t2(i, l3, u5, f3, n3, c2, o4);
  });
}
function r3(t4) {
  const e3 = n2[t4];
  if (e3)
    return e3;
  throw new Error("BufferType not supported in WebGL");
}
var n2 = { u8: C.UNSIGNED_BYTE, u16: C.UNSIGNED_SHORT, u32: C.UNSIGNED_INT, i8: C.BYTE, i16: C.SHORT, i32: C.INT, f32: C.FLOAT };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var A = T().vec3f(O.POSITION).u16(O.COMPONENTINDEX).u16(O.U16PADDING);
var e2 = T().vec2u8(O.SIDENESS);
var T2 = o2(e2);
var E = T().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u8(O.VARIANTOFFSET, { glNormalized: true }).u8(O.VARIANTSTROKE).u8(O.VARIANTEXTENSION, { glNormalized: true }).u8(O.U8PADDING, { glPadding: true }).u16(O.U16PADDING, { glPadding: true });
var S = E.clone().vec3f(O.NORMAL);
var r4 = E.clone().vec3f(O.NORMALA).vec3f(O.NORMALB);
var o3 = /* @__PURE__ */ new Map([[O.POSITION0, 0], [O.POSITION1, 1], [O.COMPONENTINDEX, 2], [O.VARIANTOFFSET, 3], [O.VARIANTSTROKE, 4], [O.VARIANTEXTENSION, 5], [O.NORMAL, 6], [O.NORMALA, 6], [O.NORMALB, 7], [O.SIDENESS, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var m2 = -1;
var u2;
function p2(n3, a3, i, l3 = V) {
  const f3 = n3.vertices.position, g3 = n3.vertices.componentIndex, u5 = m(l3.anglePlanar), p5 = m(l3.angleSignificantEdge), y3 = Math.cos(p5), E2 = Math.cos(u5), N = I.edge, S2 = N.position0, x2 = N.position1, j = N.faceNormal0, D = N.faceNormal1, F = w(n3), L = d(n3), b = L.length / 4, k = a3.allocate(b);
  let C2 = 0;
  const H2 = b, K = i.allocate(H2);
  let M = 0, O2 = 0, P2 = 0;
  const T3 = p(0, b), U = new Float32Array(b);
  U.forEach((e3, t4, n4) => {
    f3.getVec(L[4 * t4 + 0], S2), f3.getVec(L[4 * t4 + 1], x2), n4[t4] = x(S2, x2);
  }), T3.sort((e3, t4) => U[t4] - U[e3]);
  const q = new Array(), z2 = new Array();
  for (let e3 = 0; e3 < b; e3++) {
    const t4 = T3[e3], n4 = U[t4], o4 = L[4 * t4 + 0], l4 = L[4 * t4 + 1], p6 = L[4 * t4 + 2], d4 = L[4 * t4 + 3], w3 = d4 === m2;
    if (f3.getVec(o4, S2), f3.getVec(l4, x2), w3)
      o(j, F[3 * p6 + 0], F[3 * p6 + 1], F[3 * p6 + 2]), r(D, j), N.componentIndex = g3.get(o4), N.cosAngle = P(j, D);
    else {
      if (o(j, F[3 * p6 + 0], F[3 * p6 + 1], F[3 * p6 + 2]), o(D, F[3 * d4 + 0], F[3 * d4 + 1], F[3 * d4 + 2]), N.componentIndex = g3.get(o4), N.cosAngle = P(j, D), v(N, E2))
        continue;
      N.cosAngle < -0.9999 && r(D, j);
    }
    O2 += n4, P2++, w3 || h(N, y3) ? (a3.write(k, C2++, N), q.push(n4)) : A2(N, u5) && (i.write(K, M++, N), z2.push(n4));
  }
  const B = new Float32Array(q.reverse()), G = new Float32Array(z2.reverse());
  return { regular: { instancesData: a3.trim(k, C2), lodInfo: { lengths: B } }, silhouette: { instancesData: i.trim(K, M), lodInfo: { lengths: G } }, averageEdgeLength: O2 / P2 };
}
function h(e3, t4) {
  return e3.cosAngle < t4;
}
function v(e3, t4) {
  return e3.cosAngle > t4;
}
function A2(e3, t4) {
  const o4 = l(e3.cosAngle), r5 = I.fwd, c2 = I.ortho;
  H(r5, e3.position1, e3.position0);
  return o4 * (P(_(c2, e3.faceNormal0, e3.faceNormal1), r5) > 0 ? -1 : 1) > t4;
}
function d(e3) {
  const t4 = e3.faces.length / 3, n3 = e3.faces, o4 = e3.neighbors;
  let r5 = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e4 = o4[3 * a3 + 0], t5 = o4[3 * a3 + 1], c3 = o4[3 * a3 + 2], s2 = n3[3 * a3 + 0], i = n3[3 * a3 + 1], l3 = n3[3 * a3 + 2];
    r5 += e4 === m2 || s2 < i ? 1 : 0, r5 += t5 === m2 || i < l3 ? 1 : 0, r5 += c3 === m2 || l3 < s2 ? 1 : 0;
  }
  const c2 = new Int32Array(4 * r5);
  let s = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e4 = o4[3 * a3 + 0], t5 = o4[3 * a3 + 1], r6 = o4[3 * a3 + 2], i = n3[3 * a3 + 0], l3 = n3[3 * a3 + 1], f3 = n3[3 * a3 + 2];
    (e4 === m2 || i < l3) && (c2[s++] = i, c2[s++] = l3, c2[s++] = a3, c2[s++] = e4), (t5 === m2 || l3 < f3) && (c2[s++] = l3, c2[s++] = f3, c2[s++] = a3, c2[s++] = t5), (r6 === m2 || f3 < i) && (c2[s++] = f3, c2[s++] = i, c2[s++] = a3, c2[s++] = r6);
  }
  return c2;
}
function w(e3) {
  const t4 = e3.faces.length / 3, n3 = e3.vertices.position, o4 = e3.faces, r5 = y.v0, c2 = y.v1, s = y.v2, a3 = new Float32Array(3 * t4);
  for (let g3 = 0; g3 < t4; g3++) {
    const e4 = o4[3 * g3 + 0], t5 = o4[3 * g3 + 1], m5 = o4[3 * g3 + 2];
    n3.getVec(e4, r5), n3.getVec(t5, c2), n3.getVec(m5, s), e(c2, c2, r5), e(s, s, r5), _(r5, c2, s), z(r5, r5), a3[3 * g3 + 0] = r5[0], a3[3 * g3 + 1] = r5[1], a3[3 * g3 + 2] = r5[2];
  }
  return a3;
}
!function(e3) {
  e3[e3.SOLID = 0] = "SOLID", e3[e3.SKETCH = 1] = "SKETCH";
}(u2 || (u2 = {}));
var I = { edge: { position0: n(), position1: n(), faceNormal0: n(), faceNormal1: n(), componentIndex: 0, cosAngle: 0 }, ortho: n(), fwd: n() };
var y = { v0: n(), v1: n(), v2: n() };
var V = { anglePlanar: 4, angleSignificantEdge: 35 };

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t3(t4, o4, n3) {
  const r5 = o4 / 3, c2 = new Uint32Array(n3 + 1), e3 = new Uint32Array(n3 + 1), s = (t5, o5) => {
    t5 < o5 ? c2[t5 + 1]++ : e3[o5 + 1]++;
  };
  for (let x2 = 0; x2 < r5; x2++) {
    const o5 = t4[3 * x2], n4 = t4[3 * x2 + 1], r6 = t4[3 * x2 + 2];
    s(o5, n4), s(n4, r6), s(r6, o5);
  }
  let f3 = 0, l3 = 0;
  for (let x2 = 0; x2 < n3; x2++) {
    const t5 = c2[x2 + 1], o5 = e3[x2 + 1];
    c2[x2 + 1] = f3, e3[x2 + 1] = l3, f3 += t5, l3 += o5;
  }
  const i = new Uint32Array(6 * r5), a3 = c2[n3], w3 = (t5, o5, n4) => {
    if (t5 < o5) {
      const r6 = c2[t5 + 1]++;
      i[2 * r6] = o5, i[2 * r6 + 1] = n4;
    } else {
      const r6 = e3[o5 + 1]++;
      i[2 * a3 + 2 * r6] = t5, i[2 * a3 + 2 * r6 + 1] = n4;
    }
  };
  for (let x2 = 0; x2 < r5; x2++) {
    const o5 = t4[3 * x2], n4 = t4[3 * x2 + 1], r6 = t4[3 * x2 + 2];
    w3(o5, n4, x2), w3(n4, r6, x2), w3(r6, o5, x2);
  }
  const y3 = (t5, o5) => {
    const n4 = 2 * t5, r6 = o5 - t5;
    for (let c3 = 1; c3 < r6; c3++) {
      const t6 = i[n4 + 2 * c3], o6 = i[n4 + 2 * c3 + 1];
      let r7 = c3 - 1;
      for (; r7 >= 0 && i[n4 + 2 * r7] > t6; r7--)
        i[n4 + 2 * r7 + 2] = i[n4 + 2 * r7], i[n4 + 2 * r7 + 3] = i[n4 + 2 * r7 + 1];
      i[n4 + 2 * r7 + 2] = t6, i[n4 + 2 * r7 + 3] = o6;
    }
  };
  for (let x2 = 0; x2 < n3; x2++)
    y3(c2[x2], c2[x2 + 1]), y3(a3 + e3[x2], a3 + e3[x2 + 1]);
  const A3 = new Int32Array(3 * r5), U = (o5, n4) => o5 === t4[3 * n4] ? 0 : o5 === t4[3 * n4 + 1] ? 1 : o5 === t4[3 * n4 + 2] ? 2 : -1, u5 = (t5, o5) => {
    const n4 = U(t5, o5);
    A3[3 * o5 + n4] = -1;
  }, p5 = (t5, o5, n4, r6) => {
    const c3 = U(t5, o5);
    A3[3 * o5 + c3] = r6;
    const e4 = U(n4, r6);
    A3[3 * r6 + e4] = o5;
  };
  for (let x2 = 0; x2 < n3; x2++) {
    let t5 = c2[x2];
    const o5 = c2[x2 + 1];
    let n4 = e3[x2];
    const r6 = e3[x2 + 1];
    for (; t5 < o5 && n4 < r6; ) {
      const o6 = i[2 * t5], r7 = i[2 * a3 + 2 * n4];
      o6 === r7 ? (p5(x2, i[2 * t5 + 1], r7, i[2 * a3 + 2 * n4 + 1]), t5++, n4++) : o6 < r7 ? (u5(x2, i[2 * t5 + 1]), t5++) : (u5(r7, i[2 * a3 + 2 * n4 + 1]), n4++);
    }
    for (; t5 < o5; )
      u5(x2, i[2 * t5 + 1]), t5++;
    for (; n4 < r6; ) {
      u5(i[2 * a3 + 2 * n4], i[2 * a3 + 2 * n4 + 1]), n4++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a = class {
  updateSettings(t4) {
    this.settings = t4, this._edgeHashFunction = t4.reducedPrecision ? f : p3;
  }
  write(t4, o4, e3) {
    const n3 = this._edgeHashFunction(e3);
    y2.seed = n3;
    const i = y2.getIntRange(0, 255), r5 = y2.getIntRange(0, this.settings.variants - 1), s = 0.7, a3 = y2.getFloat(), c2 = 255 * (0.5 * g(-(1 - Math.min(a3 / s, 1)) + Math.max(0, a3 - s) / (1 - s), 1.2) + 0.5);
    t4.position0.setVec(o4, e3.position0), t4.position1.setVec(o4, e3.position1), t4.componentIndex.set(o4, e3.componentIndex), t4.variantOffset.set(o4, i), t4.variantStroke.set(o4, r5), t4.variantExtension.set(o4, c2);
  }
  trim(t4, o4) {
    return t4.slice(0, o4);
  }
};
var c = new Float32Array(6);
var m3 = new Uint32Array(c.buffer);
var u3 = new Uint32Array(1);
function p3(t4) {
  const o4 = c;
  o4[0] = t4.position0[0], o4[1] = t4.position0[1], o4[2] = t4.position0[2], o4[3] = t4.position1[0], o4[4] = t4.position1[1], o4[5] = t4.position1[2], u3[0] = 5381;
  for (let e3 = 0; e3 < m3.length; e3++)
    u3[0] = 31 * u3[0] + m3[e3];
  return u3[0];
}
function f(t4) {
  const o4 = c;
  o4[0] = h2(t4.position0[0]), o4[1] = h2(t4.position0[1]), o4[2] = h2(t4.position0[2]), o4[3] = h2(t4.position1[0]), o4[4] = h2(t4.position1[1]), o4[5] = h2(t4.position1[2]), u3[0] = 5381;
  for (let e3 = 0; e3 < m3.length; e3++)
    u3[0] = 31 * u3[0] + m3[e3];
  return u3[0];
}
var l2 = 1e4;
function h2(t4) {
  return Math.round(t4 * l2) / l2;
}
function g(t4, o4) {
  const e3 = t4 < 0 ? -1 : 1;
  return Math.abs(t4) ** o4 * e3;
}
var d2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return S.createBuffer(t4);
  }
  write(t4, n3, i) {
    this._commonWriter.write(t4, n3, i), u(_2, i.faceNormal0, i.faceNormal1), z(_2, _2), t4.normal.setVec(n3, _2);
  }
  trim(t4, o4) {
    return this._commonWriter.trim(t4, o4);
  }
};
d2.Layout = S, d2.glLayout = o2(S, 1);
var w2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return r4.createBuffer(t4);
  }
  write(t4, o4, e3) {
    this._commonWriter.write(t4, o4, e3), t4.normalA.setVec(o4, e3.faceNormal0), t4.normalB.setVec(o4, e3.faceNormal1);
  }
  trim(t4, o4) {
    return this._commonWriter.trim(t4, o4);
  }
};
w2.Layout = r4, w2.glLayout = o2(r4, 1);
var _2 = n();
var y2 = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function f2(e3) {
  const t4 = u4(e3.data, e3.skipDeduplicate, e3.indices, e3.indicesLength);
  return p4.updateSettings(e3.writerSettings), d3.updateSettings(e3.writerSettings), p2(t4, p4, d3);
}
function u4(i, r5, n3, o4) {
  if (r5) {
    const e3 = t3(n3, o4, i.count);
    return new g2(n3, o4, e3, i);
  }
  const c2 = r2(i.buffer, i.stride / 4, { originalIndices: n3, originalIndicesLength: o4 }), f3 = t3(c2.indices, o4, c2.uniqueCount);
  return { faces: c2.indices, facesLength: c2.indices.length, neighbors: f3, vertices: A.createView(c2.buffer) };
}
var g2 = class {
  constructor(e3, t4, i, r5) {
    this.faces = e3, this.facesLength = t4, this.neighbors = i, this.vertices = r5;
  }
};
var p4 = new d2();
var d3 = new w2();
var a2 = T().vec3f(O.POSITION0).vec3f(O.POSITION1);
var m4 = T().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u16(O.U16PADDING, { glPadding: true });

export {
  A,
  p2 as p,
  f2 as f,
  u4 as u,
  a2 as a,
  m4 as m
};
//# sourceMappingURL=chunk-NB5UUPKK.js.map

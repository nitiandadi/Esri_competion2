import {
  I,
  e as e4,
  r as r4
} from "./chunk-HSGAK4MW.js";
import {
  s
} from "./chunk-IUNR7SKI.js";
import {
  t as t3
} from "./chunk-UHA44FM7.js";
import {
  e as e3
} from "./chunk-XSQFM27N.js";
import {
  e as e2
} from "./chunk-R5TZJ3KJ.js";
import {
  e
} from "./chunk-A7PY25IH.js";
import {
  He
} from "./chunk-JPG2AHMD.js";
import {
  x
} from "./chunk-763HXOZK.js";
import {
  n as n2,
  r as r3
} from "./chunk-FGXNBIU5.js";
import {
  b
} from "./chunk-YZRPNTZZ.js";
import {
  u as u2
} from "./chunk-LSUFI7PR.js";
import {
  U
} from "./chunk-YT74S35I.js";
import {
  r as r2
} from "./chunk-U5I7FQWJ.js";
import {
  n,
  t as t2
} from "./chunk-TNTTCGVB.js";
import {
  E,
  w
} from "./chunk-QLY5H3XF.js";
import {
  a2 as a,
  u2 as u
} from "./chunk-MGJMBJDY.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/support/capabilities.js
var t4 = { analytics: { supportsCacheHint: false }, attachment: { supportsContentType: false, supportsExifInfo: false, supportsKeywords: false, supportsName: false, supportsSize: false, supportsCacheHint: false, supportsResize: false }, data: { isVersioned: false, supportsAttachment: false, supportsM: false, supportsZ: false }, editing: { supportsDeleteByAnonymous: false, supportsDeleteByOthers: false, supportsGeometryUpdate: false, supportsGlobalId: false, supportsReturnServiceEditsInSourceSpatialReference: false, supportsRollbackOnFailure: false, supportsUpdateByAnonymous: false, supportsUpdateByOthers: false, supportsUpdateWithoutM: false, supportsUploadWithItemId: false }, metadata: { supportsAdvancedFieldProperties: false }, operations: { supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsAdd: false, supportsDelete: false, supportsEditing: false, supportsChangeTracking: false, supportsQuery: false, supportsQueryAnalytics: false, supportsQueryAttachments: false, supportsQueryTopFeatures: false, supportsResizeAttachments: false, supportsSync: false, supportsUpdate: false, supportsExceedsLimitStatistics: false }, queryRelated: { supportsCount: false, supportsOrderBy: false, supportsPagination: false, supportsCacheHint: false }, queryTopFeatures: { supportsCacheHint: false }, query: { maxRecordCount: 0, maxRecordCountFactor: 0, standardMaxRecordCount: 0, supportsCacheHint: false, supportsCentroid: false, supportsCompactGeometry: false, supportsDefaultSpatialReference: false, supportsFullTextSearch: false, supportsDisjointSpatialRelationship: false, supportsDistance: false, supportsDistinct: false, supportsExtent: false, supportsFormatPBF: false, supportsGeometryProperties: false, supportsHavingClause: false, supportsHistoricMoment: false, supportsMaxRecordCountFactor: false, supportsOrderBy: false, supportsPagination: false, supportsPercentileStatistics: false, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryByOthers: false, supportsQueryGeometry: false, supportsResultType: false, supportsSqlExpression: false, supportsStandardizedQueriesOnly: false, supportsTopFeaturesQuery: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsStatistics: false, tileMaxRecordCount: 0 } };

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
var s2 = 1;
var c = 5 - s2;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/interfaces.js
var A;
!function(A2) {
  A2[A2.INVISIBLE = 0] = "INVISIBLE", A2[A2.TRANSPARENT = 1] = "TRANSPARENT", A2[A2.OPAQUE = 2] = "OPAQUE";
}(A || (A = {}));

// node_modules/@arcgis/core/views/3d/layers/support/edgeUtils.js
function m(e9) {
  return { ...g, ...e9, type: "solid" };
}
var g = { color: r3(0, 0, 0, 0.2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: A.OPAQUE, hasSlicePlane: false };
var d = { color: r3(0, 0, 0, 0.2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: A.OPAQUE, hasSlicePlane: false };

// node_modules/@arcgis/core/views/3d/support/orientedBoundingBox.js
var E3 = e3();
var F = n();
var H = n();
var J2 = n2();
var K = e();
function N(e9 = [0, 0, 0], t6 = [-1, -1, -1], a3 = e3()) {
  return { center: t2(e9), halfSize: t3(t6), quaternion: r4(a3) };
}
var _ = (() => {
  const e9 = new Int8Array(162);
  let t6 = 0;
  const a3 = (a4) => {
    for (let n6 = 0; n6 < a4.length; n6++)
      e9[t6 + n6] = a4[n6];
    t6 += 6;
  };
  return a3([6, 2, 3, 1, 5, 4]), a3([0, 2, 3, 1, 5, 4]), a3([0, 2, 3, 7, 5, 4]), a3([0, 1, 3, 2, 6, 4]), a3([0, 1, 3, 2, 0, 0]), a3([0, 1, 5, 7, 3, 2]), a3([0, 1, 3, 7, 6, 4]), a3([0, 1, 3, 7, 6, 2]), a3([0, 1, 5, 7, 6, 2]), a3([0, 1, 5, 4, 6, 2]), a3([0, 1, 5, 4, 0, 0]), a3([0, 1, 3, 7, 5, 4]), a3([0, 2, 6, 4, 0, 0]), a3([0, 0, 0, 0, 0, 0]), a3([1, 3, 7, 5, 0, 0]), a3([2, 3, 7, 6, 4, 0]), a3([2, 3, 7, 6, 0, 0]), a3([2, 3, 1, 5, 7, 6]), a3([0, 1, 5, 7, 6, 2]), a3([0, 1, 5, 7, 6, 4]), a3([0, 1, 3, 7, 6, 4]), a3([4, 5, 7, 6, 2, 0]), a3([4, 5, 7, 6, 0, 0]), a3([4, 5, 1, 3, 7, 6]), a3([0, 2, 3, 7, 5, 4]), a3([6, 2, 3, 7, 5, 4]), a3([6, 2, 3, 1, 5, 4]), e9;
})();
var re = n();
var se = n();
var ie = n();
var fe = e3();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
var ee = u2();
var re2;
function ue(t6, r7, n6, o4, a3) {
  const i = [];
  for (const e9 of r7)
    if (e9 && a3.includes(e9.name)) {
      const r8 = `${t6}/nodes/${n6}/attributes/${e9.key}/0`;
      i.push({ url: r8, storageInfo: e9 });
    }
  return E(i.map((t7) => U(t7.url, { responseType: "array-buffer" }).then((e9) => I(t7.storageInfo, e9.data)))).then((e9) => {
    const t7 = [];
    for (const r8 of o4) {
      const n7 = {};
      for (let t8 = 0; t8 < e9.length; t8++) {
        const o5 = e9[t8].value;
        null != o5 && (n7[i[t8].storageInfo.name] = me(o5, r8));
      }
      t7.push(n7);
    }
    return t7;
  });
}
!function(e9) {
  e9[e9.OUTSIDE = 0] = "OUTSIDE", e9[e9.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e9[e9.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e9[e9.INSIDE = 3] = "INSIDE";
}(re2 || (re2 = {}));
var fe2 = -32768;
var pe = -(2 ** 31);
function me(e9, t6) {
  if (!e9)
    return null;
  const r7 = e9[t6];
  if (u(e9))
    return r7 === fe2 ? null : r7;
  if (a(e9))
    return r7 === pe ? null : r7;
  return r7 != r7 ? null : r7;
}
var Ue = m({ color: [0, 0, 0, 0], opacity: 0 });
var Ae = new Array(24);
var De = new s(Ae, 3, true);
var Fe = n();
var _e = n();
var Oe = e();
var Je = e2();
var Ve = e4();
var Ye = u2();
var et = u2();
var tt = N();
var rt = n();
var nt = { data: new Array(72), size: 3, exclusive: true, stride: 3 };
var ot = e2();

// node_modules/@arcgis/core/layers/support/FetchAssociatedFeatureLayer.js
var l4 = class {
  constructor(t6, r7, e9, a3) {
    var _a;
    this._parsedUrl = t6, this._portalItem = r7, this._apiKey = e9, this.signal = a3, this._rootDocument = null;
    const i = (_a = this._parsedUrl) == null ? void 0 : _a.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);
    i && (this._urlParts = { root: i[1], layerId: parseInt(i[2], 10) });
  }
  async fetch() {
    if (!this._urlParts)
      return null;
    const t6 = this._portalItem ?? await this._portalItemFromServiceItemId();
    if (t(t6))
      return this._loadFromUrl();
    const r7 = await this._findAndLoadRelatedPortalItem(t6);
    return t(r7) ? null : this._loadFeatureLayerFromPortalItem(r7);
  }
  async fetchPortalItem() {
    if (!this._urlParts)
      return null;
    const t6 = this._portalItem ?? await this._portalItemFromServiceItemId();
    return t(t6) ? null : this._findAndLoadRelatedPortalItem(t6);
  }
  async _fetchRootDocument() {
    if (r(this._rootDocument))
      return this._rootDocument;
    if (t(this._urlParts))
      return this._rootDocument = {}, {};
    const t6 = { query: { f: "json", token: this._apiKey }, responseType: "json", signal: this.signal }, i = `${this._urlParts.root}/SceneServer`;
    try {
      const e9 = await U(i, t6);
      this._rootDocument = e9.data;
    } catch {
      this._rootDocument = {};
    }
    return this._rootDocument;
  }
  async _fetchServiceOwningPortalUrl() {
    var _a, _b;
    const e9 = (_a = this._parsedUrl) == null ? void 0 : _a.path, a3 = e9 ? (_b = r2) == null ? void 0 : _b.findServerInfo(e9) : null;
    if (a3 == null ? void 0 : a3.owningSystemUrl)
      return a3.owningSystemUrl;
    const s5 = e9 ? e9.replace(/(.*\/rest)\/.*/i, "$1") + "/info" : null;
    try {
      const t6 = (await U(s5, { query: { f: "json" }, responseType: "json", signal: this.signal })).data.owningSystemUrl;
      if (t6)
        return t6;
    } catch (n6) {
      w(n6);
    }
    return null;
  }
  async _findAndLoadRelatedPortalItem(t6) {
    try {
      return (await t6.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: this.signal })).find((t7) => "Feature Service" === t7.type) || null;
    } catch (r7) {
      return w(r7), null;
    }
  }
  async _loadFeatureLayerFromPortalItem(t6) {
    await t6.load({ signal: this.signal });
    const r7 = await this._findMatchingAssociatedSublayerUrl(t6.url ?? "");
    return new He({ url: r7, portalItem: t6 }).load({ signal: this.signal });
  }
  async _loadFromUrl() {
    var _a;
    const t6 = await this._findMatchingAssociatedSublayerUrl(`${(_a = this._urlParts) == null ? void 0 : _a.root}/FeatureServer`);
    return new He({ url: t6 }).load({ signal: this.signal });
  }
  async _findMatchingAssociatedSublayerUrl(t6) {
    var _a;
    const e9 = t6.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i, "$1"), a3 = { query: { f: "json" }, responseType: "json", authMode: "no-prompt", signal: this.signal }, i = (_a = this._urlParts) == null ? void 0 : _a.layerId, s5 = this._fetchRootDocument(), n6 = U(e9, a3), [o4, l5] = await Promise.all([n6, s5]), c4 = l5 && l5.layers, u6 = o4.data && o4.data.layers;
    if (!Array.isArray(u6))
      throw new Error("expected layers array");
    if (Array.isArray(c4))
      for (let r7 = 0; r7 < Math.min(c4.length, u6.length); r7++) {
        if (c4[r7].id === i)
          return `${e9}/${u6[r7].id}`;
      }
    else if (null != i && i < u6.length)
      return `${e9}/${u6[i].id}`;
    throw new Error("could not find matching associated sublayer");
  }
  async _portalItemFromServiceItemId() {
    const t6 = (await this._fetchRootDocument()).serviceItemId;
    if (!t6)
      return null;
    const r7 = new x({ id: t6, apiKey: this._apiKey }), e9 = await this._fetchServiceOwningPortalUrl();
    r(e9) && (r7.portal = new b({ url: e9 }));
    try {
      return r7.load({ signal: this.signal });
    } catch (s5) {
      return w(s5), null;
    }
  }
};

export {
  t4 as t,
  ue,
  l4 as l
};
//# sourceMappingURL=chunk-RRQNF2QS.js.map

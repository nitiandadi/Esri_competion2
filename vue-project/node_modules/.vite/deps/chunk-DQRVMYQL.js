import {
  t
} from "./chunk-XCZVGB7V.js";
import {
  v
} from "./chunk-VOUOLBXG.js";
import {
  r as r2
} from "./chunk-UXCEKL3W.js";
import {
  U
} from "./chunk-MKMLHQNH.js";
import {
  L,
  V
} from "./chunk-P6SQPYDS.js";
import {
  c
} from "./chunk-QGRPG4XS.js";
import {
  r
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/rest/query/operations/queryTopFeatures.js
var l = "Layer does not support extent calculation.";
function y(t2, r3) {
  var _a, _b;
  const o = t2.geometry, i = t2.toJSON(), s = i;
  if (r(o) && (s.geometry = JSON.stringify(o), s.geometryType = c(o), s.inSR = o.spatialReference.wkid || JSON.stringify(o.spatialReference)), ((_a = i.topFilter) == null ? void 0 : _a.groupByFields) && (s.topFilter.groupByFields = i.topFilter.groupByFields.join(",")), ((_b = i.topFilter) == null ? void 0 : _b.orderByFields) && (s.topFilter.orderByFields = i.topFilter.orderByFields.join(",")), i.topFilter && (s.topFilter = JSON.stringify(s.topFilter)), i.objectIds && (s.objectIds = i.objectIds.join(",")), i.orderByFields && (s.orderByFields = i.orderByFields.join(",")), i.outFields && !((r3 == null ? void 0 : r3.returnCountOnly) || (r3 == null ? void 0 : r3.returnExtentOnly) || (r3 == null ? void 0 : r3.returnIdsOnly)) ? i.outFields.includes("*") ? s.outFields = "*" : s.outFields = i.outFields.join(",") : delete s.outFields, i.outSR ? s.outSR = i.outSR.wkid || JSON.stringify(i.outSR) : o && i.returnGeometry && (s.outSR = s.inSR), i.returnGeometry && delete i.returnGeometry, i.timeExtent) {
    const t3 = i.timeExtent, { start: e, end: r4 } = t3;
    null == e && null == r4 || (s.time = e === r4 ? e : `${e ?? "null"},${r4 ?? "null"}`), delete i.timeExtent;
  }
  return s;
}
async function d(t2, e, r3, o) {
  const n = await c2(t2, e, "json", o);
  return r2(e, r3, n.data), n;
}
async function m(t2, r3, o) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? { data: { objectIds: [] } } : c2(t2, r3, "json", o, { returnIdsOnly: true });
}
async function p(t2, r3, o) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? { data: { count: 0, extent: null } } : c2(t2, r3, "json", o, { returnExtentOnly: true, returnCountOnly: true }).then((t3) => {
    const e = t3.data;
    if (e.hasOwnProperty("extent"))
      return t3;
    if (e.features)
      throw new Error(l);
    if (e.hasOwnProperty("count"))
      throw new Error(l);
    return t3;
  });
}
function a(t2, r3, o) {
  return r(r3.timeExtent) && r3.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : c2(t2, r3, "json", o, { returnIdsOnly: true, returnCountOnly: true });
}
function c2(n, u, l2, d2 = {}, m2 = {}) {
  const p2 = "string" == typeof n ? L(n) : n, a2 = u.geometry ? [u.geometry] : [];
  return d2.responseType = "pbf" === l2 ? "array-buffer" : "json", v(a2, null, d2).then((r3) => {
    const n2 = r3 && r3[0];
    r(n2) && ((u = u.clone()).geometry = n2);
    const i = t({ ...p2.query, f: l2, ...m2, ...y(u, m2) });
    return U(V(p2.path, "queryTopFeatures"), { ...d2, query: { ...i, ...d2.query } });
  });
}

export {
  d,
  m,
  p,
  a
};
//# sourceMappingURL=chunk-DQRVMYQL.js.map

import {
  e as e2
} from "./chunk-6CHYNNZQ.js";
import {
  g,
  i
} from "./chunk-OFMRQG54.js";
import {
  c as c2
} from "./chunk-KK7UXBV2.js";
import {
  o
} from "./chunk-3H5NJQM5.js";
import {
  t as t2
} from "./chunk-5BAT5OP4.js";
import {
  l as l2
} from "./chunk-6SCM5LCL.js";
import {
  V
} from "./chunk-63WRUMNA.js";
import {
  L,
  S
} from "./chunk-WAPZ634R.js";
import {
  q
} from "./chunk-RRNRSHX3.js";
import {
  d,
  m as m2
} from "./chunk-KIR65PYA.js";
import {
  t as t3
} from "./chunk-DP34NAR5.js";
import {
  c2 as c
} from "./chunk-OP7TT6MW.js";
import {
  m
} from "./chunk-XS2IGMN6.js";
import {
  u
} from "./chunk-HRFBINZY.js";
import {
  u as u2
} from "./chunk-BQXNXAP2.js";
import {
  v2 as v
} from "./chunk-5Q7F7FJ6.js";
import {
  R
} from "./chunk-XFNXUG2G.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  has
} from "./chunk-PR6SXADK.js";
import {
  e,
  l,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/vvFlagUtils.js
function e3(e4) {
  if (!e4)
    return L.NONE;
  let r3 = 0;
  for (const i4 of e4)
    if ("size" === i4.type) {
      const t4 = l2(i4);
      r3 |= t4, "outline" === i4.target && (r3 |= t4 << 4);
    } else
      "color" === i4.type ? r3 |= L.COLOR : "opacity" === i4.type ? r3 |= L.OPACITY : "rotation" === i4.type && (r3 |= L.ROTATION);
  return r3;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var f2 = 512;
var g2 = 50;
function u3(e4, t4) {
  const n2 = R(t4);
  if (!n2)
    return null;
  const [i4, s3] = n2.valid;
  return e4[2] > s3 ? [u([e4[0], e4[1], s3, e4[3]]), u([i4, e4[1], i4 + e4[2] - s3, e4[3]])] : e4[0] < i4 ? [u([i4, e4[1], e4[2], e4[3]]), u([s3 - (i4 - e4[0]), e4[1], s3, e4[3]])] : null;
}
function p(e4) {
  return "text" === e4 || "esriTS" === e4;
}
function h(e4) {
  return "simple-marker" === e4 || "picture-marker" === e4 || "esriSMS" === e4 || "esriPMS" === e4;
}
function y(e4) {
  switch (e(e4.geometry).type) {
    case "point":
    case "multipoint":
      return 0;
    case "polyline":
      return 1;
    case "polygon":
    case "extent":
      return 2;
  }
  return 0;
}
function x(e4) {
  if (!e4)
    return null;
  const { xmin: t4, ymin: n2, xmax: r3, ymax: o2, spatialReference: s3 } = e4;
  return new v({ rings: [[[t4, n2], [t4, o2], [r3, o2], [r3, n2], [t4, n2]]], spatialReference: s3 });
}

// node_modules/@arcgis/core/views/2d/layers/features/support/pixelBuffering.js
function m3(t4, e4) {
  if (!("visualVariables" in t4))
    return 0;
  if (!t4.hasVisualVariables("size"))
    return 0;
  const r3 = t4.getVisualVariablesForType("size");
  if (!r3[0])
    return 0;
  const i4 = r3[0];
  if (e4 && "cluster_count" === i4.field && "cluster" === e4.type)
    return e4.clusterMaxSize;
  if ("outline" === i4.target)
    return 0;
  if ("stops" === i4.transformationType)
    return i4.stops.map((t5) => t5.size).reduce(g3, 0);
  if ("clamped-linear" === i4.transformationType) {
    let t5 = -1 / 0, e5 = -1 / 0;
    return t5 = "number" == typeof i4.maxSize ? i4.maxSize : i4.maxSize.stops.map((t6) => t6.size).reduce(g3, 0), e5 = "number" == typeof i4.minSize ? i4.minSize : i4.minSize.stops.map((t6) => t6.size).reduce(g3, 0), Math.max(t5, e5);
  }
  return "real-world-size" === i4.transformationType ? 30 : void 0;
}
var y2 = { sdf: true, code: 99, metrics: q.metrics, rect: new t2(0, 0, 24, 24), page: 0, textureBinding: 2 };
function g3(t4, e4) {
  return Math.max(t4, e4);
}

// node_modules/@arcgis/core/views/2d/layers/features/schemaUtils.js
var T = s.getLogger("esri.views.2d.layers.features.schemaUtils");
var S3 = "ValidationError";
function E(e4) {
  return e4;
}
function w(e4, t4) {
  let i4 = 0, n2 = 0, s3 = S.DEFAULT;
  if (r(e4)) {
    if (n2 = m3(e4, t4), "visualVariables" in e4 && (i4 = e3(e4.visualVariables || []), "dot-density" === e4.type && (s3 = S.DOT_DENSITY)), "heatmap" === e4.type && (s3 = S.HEATMAP), "dictionary" === e4.type)
      return { maxVVSize: n2, vvFlags: i4, symbologyType: S.DEFAULT };
    if ("pie-chart" === e4.type)
      return { maxVVSize: n2, vvFlags: i4, symbologyType: S.PIE_CHART };
    if (s3 !== S.DOT_DENSITY && s3 !== S.HEATMAP) {
      const t5 = e4.getSymbols();
      "backgroundFillSymbol" in e4 && e4.backgroundFillSymbol && t5.push(e4.backgroundFillSymbol);
      let r3 = true, i5 = true;
      for (const e5 of t5)
        if ("cim" === e5.type && (i5 = false), "simple-fill" === e5.type || "picture-fill" === e5.type) {
          const t6 = e5.outline, n3 = t6 && "none" !== t6.style && "solid" !== t6.style, s4 = "simple-fill" === e5.type && "none" !== e5.style && "solid" !== e5.style;
          n3 && (r3 = false), ("picture-fill" === e5.type || s4 || n3) && (i5 = false);
        }
      r3 ? s3 = i5 ? S.OUTLINE_FILL_SIMPLE : S.OUTLINE_FILL : i5 && (s3 = S.SIMPLE);
    }
  }
  return { vvFlags: i4, maxVVSize: n2, symbologyType: s3 };
}
var F = null;
function I(e4) {
  if (has("esri-2d-update-debug")) {
    const t4 = V2(e4, true);
    console.debug("Created new schema", t4), console.debug("Schema diff", m(F, t4)), F = t4;
  }
  return V2(e4);
}
function V2(e4, t4 = false) {
  var _a, _b;
  try {
    const n2 = A(e4, t4), s3 = C(e4), l3 = {};
    n2.map((t5) => O(l3, e4, t5));
    const a = r(e4.subtypeCode) ? `${e4.subtypeField} = ${e4.subtypeCode}` : null, u4 = e(t3(e4.definitionExpression, a));
    return { source: { definitionExpression: u4, fields: e4.fields.map((e5) => e5.toJSON()), gdbVersion: e4.gdbVersion, historicMoment: (_a = e4.historicMoment) == null ? void 0 : _a.getTime(), outFields: e4.availableFields, pixelBuffer: e4.pixelBuffer, spatialReference: e4.spatialReference.toJSON(), timeExtent: (_b = e4.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: e4.customParameters }, attributes: { fields: {}, indexCount: 0 }, processors: n2, tileRenderer: s3, targets: l3 };
  } catch (n2) {
    if (n2.fieldName === S3)
      return T.error(n2), null;
    throw n2;
  }
}
function O(t4, r3, i4) {
  switch (i4.target) {
    case "feature":
      return void L2(t4, N(r3), i4);
    case "aggregate": {
      if (!("featureReduction" in r3))
        return;
      const n2 = r3.featureReduction;
      switch (n2 == null ? void 0 : n2.type) {
        case "selection":
          throw new s2(S3, "Mapview does not support `selection` reduction type", n2);
        case "binning":
          return L2(t4, N(r3), i4), void j2(t4, n2, r3.fields.map((e4) => e4.toJSON()), i4);
        case "cluster":
          return L2(t4, N(r3), i4), void R2(t4, n2, r3.fields.map((e4) => e4.toJSON()), i4);
      }
    }
  }
}
function z(e4, t4) {
  var _a, _b;
  for (const r3 in t4) {
    const i4 = t4[r3];
    if (i4.target !== e4.name)
      continue;
    const n2 = e4.attributes[r3];
    if (n2 == null ? void 0 : n2.context) {
      const e5 = n2.context;
      e5.mesh = e5.mesh || ((_a = i4.context) == null ? void 0 : _a.mesh), e5.storage = e5.storage || ((_b = i4.context) == null ? void 0 : _b.storage);
    } else
      e4.attributes[r3] = i4;
  }
  return e4;
}
function N(e4) {
  var _a, _b, _c;
  return [((_a = e(e4.filter)) == null ? void 0 : _a.toJSON()) ?? null, ((_c = e((_b = e(e4.featureEffect)) == null ? void 0 : _b.filter)) == null ? void 0 : _c.toJSON()) ?? null];
}
function L2(e4, t4, r3) {
  return e4.feature || (e4.feature = { name: "feature", input: "source", filters: t4, attributes: {} }), z(e4.feature, r3.attributes.fields), e4;
}
function M(t4, r3) {
  const { onStatisticExpression: i4, onStatisticField: n2, statisticType: s3 } = t4;
  switch (s3) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (i4) {
        const { returnType: r4 } = i4;
        return r4 ? "string" === r4 ? "esriFieldTypeString" : "esriFieldTypeDouble" : (T.error(new s2(S3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", t4)), "esriFieldTypeString");
      }
      const s4 = r3.find((e4) => e4.name === n2);
      return s4 ? s4.type : (T.error(new s2(S3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", t4)), "esriFieldTypeString");
    }
  }
}
function j2(e4, t4, r3, i4) {
  return e4.aggregate || (e4.aggregate = { name: "aggregate", type: "bin", filters: null, input: "feature", params: { fixedBinLevel: t4.fixedBinLevel, fields: (t4.fields ?? []).map((e5) => ({ ...e5.toJSON(), type: M(e5, r3) })) }, attributes: {} }), z(e4.aggregate, i4.attributes.fields), e4;
}
function R2(e4, t4, r3, i4) {
  var _a;
  return e4.aggregate || (e4.aggregate = { name: "aggregate", type: "cluster", input: "feature", filters: null, attributes: {}, params: { clusterRadius: u2(t4.clusterRadius / 2), clusterPixelBuffer: 64 * Math.ceil(u2(t4.clusterMaxSize) / 64), fields: (_a = t4.fields ?? []) == null ? void 0 : _a.map((e5) => ({ ...e5.toJSON(), type: M(e5, r3) })) } }), z(e4.aggregate, i4.attributes.fields), e4;
}
function U(e4, t4) {
  return t4.field ? B(e4, { ...t4, type: "field", field: t4.field }) : t4.valueExpression ? B(e4, { ...t4, type: "expression", valueExpression: t4.valueExpression }) : { field: void 0, fieldIndex: void 0 };
}
function B(e4, t4) {
  switch (t4.type) {
    case "expression": {
      const r3 = E(t4.valueExpression);
      if (!e4.fields[r3]) {
        const i4 = e4.indexCount++;
        e4.fields[r3] = { ...t4, name: r3, fieldIndex: i4 };
      }
      return { fieldIndex: e4.fields[r3].fieldIndex };
    }
    case "label-expression": {
      const r3 = E(JSON.stringify(t4.label));
      if (!e4.fields[r3]) {
        const i4 = e4.indexCount++;
        e4.fields[r3] = { ...t4, name: r3, fieldIndex: i4 };
      }
      return { fieldIndex: e4.fields[r3].fieldIndex };
    }
    case "field": {
      const r3 = t4.field;
      return "aggregate" === t4.target && e4.fields[r3] || (e4.fields[r3] = { ...t4, name: r3 }), { field: r3 };
    }
    case "statistic":
      return e4.fields[t4.name] = { ...t4 }, { field: t4.name };
  }
}
function A(e4, t4 = false) {
  const r3 = new Array();
  let i4 = 0;
  return r3.push(k(e4, i4++, t4)), r3;
}
function D(e4, t4, r3, i4, n2, s3 = false) {
  const l3 = B(e4, { type: "label-expression", target: r3, context: { mesh: true }, resultType: "string", label: { labelExpression: t4.labelExpression, labelExpressionInfo: t4.labelExpressionInfo ? { expression: t4.labelExpressionInfo.expression } : null, symbol: !!t4.symbol, where: t4.where } }), { fieldIndex: o2 } = l3;
  return { ...o(t4, n2, s3), fieldIndex: o2, target: r3, index: i4 };
}
function P(t4, r3, i4) {
  var _a;
  const n2 = "featureReduction" in r3 && r3.featureReduction;
  if (!n2)
    return { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
  const s3 = "aggregate", l3 = [];
  let o2 = null, a = e2(r3.geometryType), d3 = [], f3 = null;
  if (n2)
    switch (n2.type) {
      case "selection":
        return T.error(new s2(S3, "Mapview does not support `selection` reduction type", n2)), { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
      case "cluster":
      case "binning":
        if (l3.push(...n2.fields ?? []), "cluster" === n2.type ? a = "esriGeometryPoint" : "binning" === n2.type && (a = "esriGeometryPolygon"), n2.renderer && !((_a = n2.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
          if ("cluster" === n2.type) {
            const { renderer: e5 } = m2(n2.renderer, n2, null);
            f3 = e5;
          } else
            f3 = n2.renderer;
          const e4 = w(n2.renderer, n2);
          o2 = $(t4, s3, n2.renderer, e4, i4), d3 = n2 && n2.labelsVisible && n2.labelingInfo || [];
        } else if ("cluster" === n2.type) {
          if (f3 = d(l3, r3.renderer, n2, null, true), n2.symbol) {
            const e4 = w(f3, n2);
            o2 = { type: "simple", symbol: o(n2.symbol, e4, i4), symbologyType: e4.symbologyType };
          }
          d3 = n2 && n2.labelsVisible && n2.labelingInfo || [];
        }
    }
  q2(t4, l3);
  return { labels: c(d3, "binning" === n2.type ? "esriGeometryPolygon" : a), matcher: o2, fields: l3, rendererOverride: f3 };
}
function k(t4, i4, n2 = false) {
  var _a;
  const s3 = { indexCount: 0, fields: {} }, l3 = "featureReduction" in t4 ? t4.featureReduction ?? void 0 : void 0, o2 = l3 ? "aggregate" : "feature";
  if ("sublayers" in t4) {
    const i5 = { type: "subtype", subtypeField: t4.subtypeField, renderers: {}, symbologyType: S.DEFAULT }, l4 = { type: "subtype", mapping: {}, target: "feature", subtypeField: t4.subtypeField }, a2 = { type: "subtype", classes: {} }, u4 = { type: "symbol", target: "feature", aggregateFields: [], attributes: s3, storage: l4, mesh: { matcher: i5, aggregateMatcher: null, labels: a2, sortKey: null } }, f4 = /* @__PURE__ */ new Set();
    let p3 = 0;
    for (const { renderer: y4, subtypeCode: m5, labelingInfo: g4, labelsVisible: b2 } of t4.sublayers) {
      let t5 = 0;
      "visualVariables" in y4 && y4.visualVariables && (y4.visualVariables.some((e4) => "rotation" !== e4.type) && T.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."), t5 = e3(y4.visualVariables.filter((e4) => "size" !== e4.type)));
      const u5 = { symbologyType: S.DEFAULT, vvFlags: t5, maxVVSize: 0 }, x3 = $(s3, o2, y4, u5, n2), v3 = _(s3, o2, y4), h2 = b2 && g4;
      if ("dictionary" === x3.type)
        throw new s2(S3, "Dictionary renderer is not supported in subtype layers");
      if ("subtype" === x3.type)
        throw new s2(S3, "Nested subtype renderers is not supported");
      if (r(v3) && "subtype" === v3.type)
        throw new s2(S3, "Nested subtype storage is not supported");
      if (r(v3) && r(v3.attributeMapping))
        throw new s2(S3, "Non-visual-variable attributes are not supported in subtype layers");
      if ("heatmap" === x3.type)
        throw new s2(S3, "Heatmaps are not supported in subtype layers");
      if ("pie-chart" === x3.type)
        throw new s2(S3, "Pie-charts are not supported in subtype layers");
      if (f4.has(m5))
        throw new s2(S3, "Subtype codes for sublayers must be unique");
      f4.add(m5), i5.renderers[m5] = x3, l4.mapping[m5] = v3, h2 && (a2.classes[m5] = h2.map((e4) => D(s3, e4, "feature", p3++, u5, n2)));
    }
    return u4;
  }
  if ("heatmap" === ((_a = t4.renderer) == null ? void 0 : _a.type) && "raster" === g()) {
    const { radius: e4, fieldOffset: r3, field: i5 } = t4.renderer;
    return { type: "heatmap", aggregateFields: [], attributes: s3, target: o2, storage: null, mesh: { radius: e4, fieldOffset: r3, field: U(s3, { target: o2, field: i5, resultType: "numeric" }).field } };
  }
  const a = P(s3, t4, n2), f3 = e2(t4.geometryType), p2 = a.rendererOverride ?? t4.renderer, y3 = w(p2, l3), m4 = $(s3, o2, p2, y3, n2), b = _(s3, o2, p2), x2 = J(s3, t4.orderBy, t4.renderer, l3), v2 = t4.labelsVisible && t4.labelingInfo || [], E2 = c(v2, f3);
  let F2 = 0;
  const I2 = [...E2.map((e4) => D(s3, e4, "feature", F2++, y3, n2)), ...a.labels.map((e4) => D(s3, e4, "aggregate", F2++, y3, n2))];
  return { type: "symbol", target: o2, attributes: s3, aggregateFields: a.fields, storage: b, mesh: { matcher: m4, labels: { type: "simple", classes: I2 }, aggregateMatcher: a.matcher, sortKey: x2 } };
}
function C(e4) {
  var _a;
  return "heatmap" === ((_a = e4.renderer) == null ? void 0 : _a.type) && "raster" === g() ? { type: "heatmap" } : { type: "symbol" };
}
function J(t4, i4, n2, s3) {
  if (r(s3))
    return null;
  if (r(i4) && i4.length) {
    i4.length > 1 && T.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i4.length}. All but the first will be discarded`);
    const r3 = i4[0], n3 = "ascending" === r3.order ? "asc" : "desc";
    if (r3.field)
      return { field: r3.field, order: n3 };
    if (r3.valueExpression) {
      return { fieldIndex: B(t4, { type: "expression", target: "feature", valueExpression: r3.valueExpression, resultType: "numeric" }).fieldIndex, order: n3 };
    }
    return T.error(new s2(S3, "Expected to find a field or valueExpression for OrderByInfo", r3)), null;
  }
  if (r(n2) && "unique-value" === n2.type && n2.orderByClassesEnabled) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function q2(e4, t4) {
  const r3 = { mesh: true, storage: true };
  for (const i4 of t4) {
    const { name: t5, onStatisticField: n2, onStatisticExpression: s3, statisticType: l3 } = i4;
    let o2, a;
    const u4 = "numeric", d3 = "feature";
    if (s3) {
      a = B(e4, { type: "expression", target: d3, valueExpression: s3.expression, resultType: u4 }).fieldIndex;
    } else {
      o2 = B(e4, { type: "field", target: d3, field: n2, resultType: u4 }).field;
    }
    B(e4, { type: "statistic", target: "aggregate", name: t5, context: r3, inField: o2, inFieldIndex: a, statisticType: l3 });
  }
}
function _(e4, t4, r3) {
  let i4;
  switch (r3.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      i4 = { visualVariables: true, attributes: null };
      break;
    default:
      i4 = c2(r3).getStorageSpec(r3);
  }
  return G(e4, t4, i4, r3);
}
function G(e4, t4, i4, s3) {
  if (t(i4))
    return null;
  const { visualVariables: l3, attributes: o2 } = i4;
  let a = null;
  l3 && "visualVariables" in s3 && (a = H(e4, t4, s3.visualVariables));
  const u4 = r(a) ? 4 : 0;
  let d3 = null;
  return r(o2) && (d3 = o2.map((r3, i5) => {
    const { field: n2, fieldIndex: s4 } = U(e4, { valueExpression: r3.valueExpression, field: r3.field, resultType: "numeric", target: t4 });
    return { binding: i5 + u4, field: n2, fieldIndex: s4 };
  })), { type: "simple", target: t4, attributeMapping: d3, vvMapping: a };
}
function H(e4, t4, i4) {
  if (!i4 || !i4.length)
    return [];
  const n2 = { storage: true }, s3 = "numeric";
  return i(i4).map((r3) => {
    const i5 = V(r3.type), { field: l3, fieldIndex: o2 } = U(e4, { target: t4, valueExpression: r3.valueExpression, field: r3.field, context: n2, resultType: s3 });
    switch (r3.type) {
      case "size":
        return "$view.scale" === r3.valueExpression ? null : { type: "size", binding: i5, field: l3, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r3.normalizationField, context: n2, resultType: s3 }).field, valueRepresentation: r3.valueRepresentation ?? null };
      case "color":
        return { type: "color", binding: i5, field: l3, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r3.normalizationField, context: n2, resultType: s3 }).field };
      case "opacity":
        return { type: "opacity", binding: i5, field: l3, fieldIndex: o2, normalizationField: U(e4, { target: t4, field: r3.normalizationField, context: n2, resultType: s3 }).field };
      case "rotation":
        return { type: "rotation", binding: i5, field: l3, fieldIndex: o2 };
    }
  }).filter(r);
}
function $(e4, t4, r3, i4, n2 = false) {
  const l3 = l(e4, { indexCount: 0, fields: {} });
  switch (r3.type) {
    case "simple":
    case "dot-density":
      return K(l3, r3, i4, n2);
    case "class-breaks":
      return Q(l3, t4, r3, i4, n2);
    case "unique-value":
      return W(l3, t4, r3, i4, n2);
    case "dictionary":
      return X(l3, r3, i4, n2);
    case "heatmap":
      return Z(l3, r3, i4, n2);
    case "pie-chart":
      return Y(l3, r3, i4, n2);
  }
}
function K(e4, t4, r3, i4 = false) {
  const n2 = t4.getSymbols(), s3 = n2.length ? n2[0] : null;
  return { type: "simple", symbol: o(s3, r3, i4), symbologyType: r3.symbologyType };
}
function Y(e4, t4, r3, i4 = false) {
  const n2 = t4.getSymbols(), s3 = n2[0], l3 = n2.length > 1 ? n2[1] : null;
  return { type: "pie-chart", markerSymbol: o(s3, r3, i4), fillSymbol: o(l3, r3, i4), symbologyType: r3.symbologyType };
}
function Q(e4, t4, r3, i4, n2 = false) {
  const s3 = { mesh: true, use: "renderer.field" }, l3 = r3.backgroundFillSymbol, { field: o2, fieldIndex: a } = U(e4, { target: t4, field: r3.field, valueExpression: r3.valueExpression, resultType: "numeric", context: s3 }), u4 = r3.normalizationType, d3 = "log" === u4 ? "esriNormalizeByLog" : "percent-of-total" === u4 ? "esriNormalizeByPercentOfTotal" : "field" === u4 ? "esriNormalizeByField" : null, f3 = r3.classBreakInfos.map((e5) => ({ symbol: o(e5.symbol, i4, n2), min: e5.minValue, max: e5.maxValue })).sort((e5, t5) => e5.min - t5.min);
  return { type: "interval", attributes: e4.fields, field: o2, fieldIndex: a, backgroundFillSymbol: o(l3, i4, n2), defaultSymbol: o(r3.defaultSymbol, i4, n2), intervals: f3, normalizationField: r3.normalizationField, normalizationTotal: r3.normalizationTotal, normalizationType: d3, isMaxInclusive: r3.isMaxInclusive, symbologyType: i4.symbologyType };
}
function W(t4, r3, i4, n2, s3 = false) {
  const l3 = [], o2 = i4.backgroundFillSymbol, a = { target: r3, context: { mesh: true }, resultType: "string" };
  if (i4.field && "string" != typeof i4.field)
    throw new s2(S3, "Expected renderer.field to be a string", i4);
  const { field: u4, fieldIndex: d3 } = U(t4, { ...a, field: i4.field, valueExpression: i4.valueExpression });
  for (const e4 of i4.uniqueValueInfos ?? [])
    l3.push({ value: "" + e4.value, symbol: o(e4.symbol, n2, s3) });
  return { type: "map", attributes: t4.fields, field: u4, fieldIndex: d3, field2: U(t4, { ...a, field: i4.field2 }).field, field3: U(t4, { ...a, field: i4.field3 }).field, fieldDelimiter: i4.fieldDelimiter ?? void 0, backgroundFillSymbol: o(o2, n2), defaultSymbol: o(i4.defaultSymbol, n2), map: l3, symbologyType: n2.symbologyType };
}
function X(e4, t4, r3, i4 = false) {
  return { type: "dictionary", config: t4.config, fieldMap: t4.fieldMap, scaleExpression: t4.scaleExpression, url: t4.url, symbolOptions: r3, symbologyType: r3.symbologyType };
}
function Z(e4, t4, r3, i4 = false) {
  const n2 = t4.getSymbols(), s3 = n2.length ? n2[0] : null;
  return { type: "heatmap", symbol: o(s3, r3, i4), symbologyType: r3.symbologyType };
}

export {
  f2 as f,
  g2 as g,
  u3 as u,
  p,
  h,
  y,
  x,
  w,
  I,
  $
};
//# sourceMappingURL=chunk-G3IR6EOM.js.map

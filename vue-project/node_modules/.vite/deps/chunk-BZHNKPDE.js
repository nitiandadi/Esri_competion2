import {
  T
} from "./chunk-QE6RY3R6.js";
import {
  e
} from "./chunk-OGEJGMAT.js";
import {
  c as c2
} from "./chunk-VQUDNY75.js";
import {
  ut
} from "./chunk-X7NPMCZZ.js";
import {
  t as t2
} from "./chunk-MI7FJDLG.js";
import {
  v
} from "./chunk-QGRPG4XS.js";
import {
  has
} from "./chunk-XPATKIHO.js";
import {
  c,
  l,
  r,
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t3 = class {
  static fromBuffer(e2, s) {
    return new t3(e2, s);
  }
  static create(e2, s = 4294967295) {
    const r2 = new Uint32Array(Math.ceil(e2 / 32));
    return new t3(r2, s);
  }
  constructor(t4, e2) {
    this._mask = 0, this._buf = t4, this._mask = e2;
  }
  _getIndex(t4) {
    return Math.floor(t4 / 32);
  }
  has(t4) {
    const e2 = this._mask & t4;
    return !!(this._buf[this._getIndex(e2)] & 1 << e2 % 32);
  }
  hasRange(t4, e2) {
    let s = t4, r2 = e2;
    for (; s % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      s++;
    }
    for (; r2 % 32 && s !== r2; ) {
      if (this.has(s))
        return true;
      r2--;
    }
    if (s === r2)
      return false;
    for (let h = s / 32; h !== r2 / 32; h++) {
      if (this._buf[h])
        return true;
    }
    return false;
  }
  set(t4) {
    const e2 = this._mask & t4, s = this._getIndex(e2), r2 = 1 << e2 % 32;
    this._buf[s] |= r2;
  }
  setRange(t4, e2) {
    let s = t4, r2 = e2;
    for (; s % 32 && s !== r2; )
      this.set(s++);
    for (; r2 % 32 && s !== r2; )
      this.set(r2--);
    if (s !== r2)
      for (let h = s / 32; h !== r2 / 32; h++)
        this._buf[h] = 4294967295;
  }
  unset(t4) {
    const e2 = this._mask & t4, s = this._getIndex(e2), r2 = 1 << e2 % 32;
    this._buf[s] &= 4294967295 ^ r2;
  }
  resize(t4) {
    const e2 = this._buf, s = new Uint32Array(Math.ceil(t4 / 32));
    s.set(e2), this._buf = s;
  }
  or(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= t4._buf[e2];
    return this;
  }
  and(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= t4._buf[e2];
    return this;
  }
  xor(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= t4._buf[e2];
    return this;
  }
  ior(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] |= ~t4._buf[e2];
    return this;
  }
  iand(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] &= ~t4._buf[e2];
    return this;
  }
  ixor(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] ^= ~t4._buf[e2];
    return this;
  }
  any() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      if (this._buf[t4])
        return true;
    return false;
  }
  copy(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++)
      this._buf[e2] = t4._buf[e2];
    return this;
  }
  clone() {
    return new t3(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      this._buf[t4] = 0;
  }
  forEachSet(t4) {
    for (let e2 = 0; e2 < this._buf.length; e2++) {
      let s = this._buf[e2], r2 = 32 * e2;
      if (s)
        for (; s; ) {
          1 & s && t4(r2), s >>>= 1, r2++;
        }
    }
  }
  countSet() {
    let t4 = 0;
    return this.forEachSet((e2) => {
      t4++;
    }), t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var c3 = 0;
var l2 = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var m = l2[0];
var f = l2[1];
var g = l2[2];
var y = l2[3];
var _ = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var p = _[0];
var x = _[1];
var I = _[2];
var A = has("featurelayer-simplify-mobile-factor") ?? 2;
var S = has("esri-mobile");
var b = class {
  constructor(e2, t4) {
    this.type = "FeatureSetReader", this.arcadeDeclaredClass = "esri.arcade.Feature", this.seen = false, this.instance = 0, this._tx = 0, this._ty = 0, this._sx = 1, this._sy = 1, this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._level = 0, this._datetimeMetadata = null, this.contextTimeReference = null, this.instance = e2, this._layerSchema = t4;
  }
  static createInstance() {
    return c3++, c3 = c3 > 65535 ? 0 : c3, c3;
  }
  get isEmpty() {
    return r(this._deleted) && this._deleted.countSet() === this.getSize();
  }
  set level(e2) {
    this._level = e2;
  }
  getAreaSimplificationThreshold(e2, t4) {
    let r2 = 1;
    const s = S ? A : 1;
    t4 > 4e6 ? r2 = I * s : t4 > 1e6 ? r2 = x * s : t4 > 5e5 ? r2 = p * s : t4 > 1e5 && (r2 = s);
    let i = 0;
    e2 > 4e3 ? i = y * r2 : e2 > 2e3 ? i = g * r2 : e2 > 100 ? i = f : e2 > 15 && (i = m);
    let n = 8;
    return this._level < 4 ? n = 1 : this._level < 5 ? n = 2 : this._level < 6 && (n = 4), i * n;
  }
  createQuantizedExtrudedQuad(e2, t4) {
    return new t2([5], [e2 - 1, t4, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  setArcadeSpatialReference(e2) {
    this._arcadeSpatialReference = e2;
  }
  attachStorage(e2) {
    this._storage = e2;
  }
  getQuantizationTransform() {
    throw new Error("Unable to find transform for featureSet");
  }
  getStorage() {
    return this._storage;
  }
  getComputedNumeric(e2) {
    return this.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e2, t4) {
    return this.setComputedNumericAtIndex(t4, 0);
  }
  getComputedString(e2) {
    return this.getComputedStringAtIndex(0);
  }
  setComputedString(e2, t4) {
    return this.setComputedStringAtIndex(0, t4);
  }
  getComputedNumericAtIndex(e2) {
    return this._storage.getComputedNumericAtIndex(this.getDisplayId(), e2);
  }
  setComputedNumericAtIndex(e2, t4) {
    this._storage.setComputedNumericAtIndex(this.getDisplayId(), e2, t4);
  }
  getComputedStringAtIndex(e2) {
    return this._storage.getComputedStringAtIndex(this.getDisplayId(), e2);
  }
  setComputedStringAtIndex(e2, t4) {
    return this._storage.setComputedStringAtIndex(this.getDisplayId(), e2, t4);
  }
  transform(e2, t4, r2, s) {
    const i = this.copy();
    return i._tx += e2, i._ty += t4, i._sx *= r2, i._sy *= s, i;
  }
  readAttribute(e2, t4 = false) {
    const r2 = this._readAttribute(e2, t4);
    if (void 0 !== r2)
      return r2;
    for (const s of this._joined) {
      s.setIndex(this.getIndex());
      const r3 = s._readAttribute(e2, t4);
      if (void 0 !== r3)
        return r3;
    }
  }
  readAttributes() {
    const e2 = this._readAttributes();
    for (const t4 of this._joined) {
      t4.setIndex(this.getIndex());
      const r2 = t4._readAttributes();
      for (const t5 of Object.keys(r2))
        e2[t5] = r2[t5];
    }
    return e2;
  }
  joinAttributes(e2) {
    this._joined.push(e2);
  }
  readArcadeFeature() {
    return this;
  }
  geometry() {
    const e2 = this.readHydratedGeometry(), t4 = ut(e2, this.geometryType, this.hasZ, this.hasM), r2 = v(t4);
    return r2 && (r2.spatialReference = this._arcadeSpatialReference), r2;
  }
  get dateTimeReferenceFieldIndex() {
    return this._datetimeMetadata || (this._datetimeMetadata = T.create(this._layerSchema.fields, this._layerSchema)), this._datetimeMetadata;
  }
  autocastArcadeDate(t4, r2) {
    var _a;
    return r2 && r2 instanceof Date ? this.isUnknownDateTimeField(t4) ? c2.unknownDateJSToArcadeDate(r2) : c2.dateJSAndZoneToArcadeDate(r2, ((_a = this.contextTimeReference) == null ? void 0 : _a.timeZone) ?? "system") : r2;
  }
  isUnknownDateTimeField(e2) {
    var _a;
    return "unknown" === ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2));
  }
  fieldSourceTimeZone(e2) {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2)) ?? "";
  }
  get layerPreferredTimeZone() {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.layerPreferredTimeZone) ?? "";
  }
  field(e2) {
    if (this.hasField(e2))
      return this.autocastArcadeDate(e2, this.readAttribute(e2, true));
    for (const t4 of this._joined)
      if (t4.setIndex(this.getIndex()), t4.hasField(e2)) {
        const r2 = t4._readAttribute(e2, true);
        return this.autocastArcadeDate(e2, r2);
      }
    throw new Error(`Field ${e2} does not exist`);
  }
  setField(e2, t4) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.getFieldNames();
  }
  castToText(e2 = false) {
    if (!e2)
      return JSON.stringify(this.readLegacyFeature());
    const t4 = this.readLegacyFeature();
    if (!t4)
      return JSON.stringify(null);
    const r2 = { geometry: t4.geometry, attributes: { ...t4.attributes ? t4.attributes : {} } };
    for (const s in r2.attributes) {
      const e3 = r2.attributes[s];
      e3 instanceof Date && (r2.attributes[s] = e3.getTime());
    }
    return JSON.stringify(r2);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this._layerSchema;
  }
  castAsJson(e2 = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e2 == null ? void 0 : e2.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e2 = null, t4 = null) {
    return Promise.resolve(this.castAsJson(t4));
  }
  removeIds(e2) {
    if (t(this._objectIdToIndex)) {
      const e3 = /* @__PURE__ */ new Map(), t5 = this.getCursor();
      for (; t5.next(); ) {
        const r2 = c(t5.getObjectId());
        e3.set(r2, t5.getIndex());
      }
      this._objectIdToIndex = e3;
    }
    const t4 = this._objectIdToIndex;
    for (const r2 of e2)
      t4.has(r2) && this.removeAtIndex(t4.get(r2));
  }
  removeAtIndex(e2) {
    t(this._deleted) && (this._deleted = t3.create(this.getSize())), this._deleted.set(e2);
  }
  readGeometryForDisplay() {
    return this.readUnquantizedGeometry(true);
  }
  readLegacyGeometryForDisplay() {
    return this.readLegacyGeometry(true);
  }
  *features() {
    const e2 = this.getCursor();
    for (; e2.next(); )
      yield e2.readOptimizedFeature();
  }
  _getExists() {
    return t(this._deleted) || !this._deleted.has(this.getIndex());
  }
  _computeCentroid() {
    if ("esriGeometryPolygon" !== this.geometryType)
      return null;
    const e2 = this.readUnquantizedGeometry();
    if (!e2 || e2.hasIndeterminateRingOrder)
      return null;
    const t4 = l(this.getQuantizationTransform(), null);
    return e(new t2(), e2, this.hasM, this.hasZ, t4);
  }
  copyInto(e2) {
    e2.seen = this.seen, e2._storage = this._storage, e2._arcadeSpatialReference = this._arcadeSpatialReference, e2._joined = this._joined, e2._tx = this._tx, e2._ty = this._ty, e2._sx = this._sx, e2._sy = this._sy, e2._deleted = this._deleted, e2._objectIdToIndex = this._objectIdToIndex;
  }
};

export {
  t3 as t,
  b
};
//# sourceMappingURL=chunk-BZHNKPDE.js.map

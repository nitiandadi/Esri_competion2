import {
  E
} from "./chunk-RFBUNXCZ.js";
import {
  D,
  G,
  L,
  M,
  P,
  U,
  o
} from "./chunk-DNXRTHCH.js";
import {
  r
} from "./chunk-LUSFZCEU.js";
import {
  f
} from "./chunk-2KKFAUOD.js";
import {
  t
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/views/webgl/rasterUtils.js
function c(e, t2, f2 = "nearest", c2 = false) {
  var _a;
  const l2 = !(c2 && "u8" === t2.pixelType), _2 = l2 ? G.FLOAT : G.UNSIGNED_BYTE, p2 = null == t2.pixels || 0 === t2.pixels.length ? null : l2 ? t2.getAsRGBAFloat() : t2.getAsRGBA(), g2 = (_a = e.capabilities.textureFloat) == null ? void 0 : _a.textureFloatLinear, T2 = { width: t2.width, height: t2.height, target: M.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: e.type === r.WEBGL2 && l2 ? U.RGBA32F : P.RGBA, samplingMode: !g2 || "bilinear" !== f2 && "cubic" !== f2 ? L.NEAREST : L.LINEAR, dataType: _2, wrapMode: D.CLAMP_TO_EDGE, flipped: false };
  return new E(e, T2, p2);
}
function l(e, t2) {
  const { spacing: f2, offsets: c2, coefficients: l2, size: [_2, p2] } = t2, g2 = f2[0] > 1, T2 = { width: g2 ? 4 * _2 : _2, height: p2, target: M.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: e.type === r.WEBGL2 ? U.RGBA32F : P.RGBA, dataType: G.FLOAT, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, flipped: false }, E3 = new Float32Array(g2 ? _2 * p2 * 16 : 2 * c2.length);
  if (g2 && null != l2)
    for (let n = 0, a = 0; n < l2.length; n++)
      E3[a++] = l2[n], n % 3 == 2 && (E3[a++] = 1);
  else
    for (let n = 0; n < p2; n++)
      for (let e2 = 0; e2 < _2; e2++) {
        const t3 = 4 * (n * _2 + e2), a = 2 * (e2 * p2 + n);
        E3[t3] = c2[a], E3[t3 + 1] = c2[a + 1], E3[t3 + 3] = -1 === c2[a] ? 0 : 1;
      }
  return new E(e, T2, E3);
}
function _(e, t2) {
  const n = { width: t2.length / 4, height: 1, target: M.TEXTURE_2D, pixelFormat: P.RGBA, internalFormat: P.RGBA, dataType: G.UNSIGNED_BYTE, samplingMode: L.NEAREST, wrapMode: D.CLAMP_TO_EDGE, flipped: false };
  return new E(e, n, t2);
}
function p(e, n, a, r2 = 1, i = true) {
  return { u_flipY: i, u_applyTransform: !!e, u_opacity: r2, u_transformSpacing: e ? e.spacing : f, u_transformGridSize: e ? e.size : f, u_targetImageSize: n, u_srcImageSize: a };
}
function g(e, t2) {
  return { u_colormapOffset: t2 || 0, u_colormapMaxIndex: e ? e.length / 4 - 1 : 0 };
}
function T(e, t2) {
  return { u_scale: e, u_offset: t2 };
}
function E2(e) {
  return { u_bandCount: e.bandCount, u_minOutput: e.outMin, u_maxOutput: e.outMax, u_minCutOff: e.minCutOff, u_maxCutOff: e.maxCutOff, u_factor: e.factor, u_useGamma: e.useGamma, u_gamma: e.gamma, u_gammaCorrection: e.gammaCorrection };
}
function A(e) {
  return { u_hillshadeType: e.hillshadeType, u_sinZcosAs: e.sinZcosAs, u_sinZsinAs: e.sinZsinAs, u_cosZs: e.cosZs, u_weights: e.weights, u_factor: e.factor, u_minValue: e.minValue, u_maxValue: e.maxValue };
}
function h(t2, n) {
  const a = t2.gl, r2 = n.glName, i = /* @__PURE__ */ new Map();
  if (t(r2))
    return i;
  const o2 = a.getProgramParameter(r2, a.ACTIVE_UNIFORMS);
  let s;
  for (let e = 0; e < o2; e++)
    s = a.getActiveUniform(r2, e), s && i.set(s.name, { location: a.getUniformLocation(r2, s.name), info: s });
  return i;
}
function O(e, t2, n) {
  Object.keys(n).forEach((a) => {
    const r2 = t2.get(a) || t2.get(a + "[0]");
    r2 && x(e, a, n[a], r2);
  });
}
function d(e, t2, n, a) {
  n.length === a.length && (a.some((e2) => null == e2) || n.some((e2) => null == e2) || n.forEach((n2, r2) => {
    t2.setUniform1i(n2, r2), e.bindTexture(a[r2], r2);
  }));
}
function x(e, t2, n, a) {
  if (null === a || null == n)
    return false;
  const { info: r2 } = a;
  switch (r2.type) {
    case o.FLOAT:
      r2.size > 1 ? e.setUniform1fv(t2, n) : e.setUniform1f(t2, n);
      break;
    case o.FLOAT_VEC2:
      e.setUniform2fv(t2, n);
      break;
    case o.FLOAT_VEC3:
      e.setUniform3fv(t2, n);
      break;
    case o.FLOAT_VEC4:
      e.setUniform4fv(t2, n);
      break;
    case o.FLOAT_MAT3:
      e.setUniformMatrix3fv(t2, n);
      break;
    case o.FLOAT_MAT4:
      e.setUniformMatrix4fv(t2, n);
      break;
    case o.INT:
      r2.size > 1 ? e.setUniform1iv(t2, n) : e.setUniform1i(t2, n);
      break;
    case o.BOOL:
      e.setUniform1i(t2, n ? 1 : 0);
      break;
    case o.INT_VEC2:
    case o.BOOL_VEC2:
      e.setUniform2iv(t2, n);
      break;
    case o.INT_VEC3:
    case o.BOOL_VEC3:
      e.setUniform3iv(t2, n);
      break;
    case o.INT_VEC4:
    case o.BOOL_VEC4:
      e.setUniform4iv(t2, n);
      break;
    default:
      return false;
  }
  return true;
}

export {
  c,
  l,
  _,
  p,
  g,
  T,
  E2 as E,
  A,
  h,
  O,
  d
};
//# sourceMappingURL=chunk-T6WYSB4E.js.map

import {
  r as r5
} from "./chunk-TQAOUM4T.js";
import {
  g as g4,
  p as p4
} from "./chunk-U3OZH4NK.js";
import "./chunk-NOKW5M7T.js";
import {
  r as r3
} from "./chunk-XCHMTTFV.js";
import "./chunk-MJIX5E4D.js";
import {
  L as L2,
  L2 as L3,
  M,
  R,
  _,
  a as a3,
  b,
  g as g2,
  h as h2,
  j,
  k,
  k2,
  r as r4,
  v as v2,
  x,
  x2
} from "./chunk-6V3GILBW.js";
import "./chunk-H5ZFTV2L.js";
import {
  c
} from "./chunk-UZMMVJXR.js";
import "./chunk-KKFB57KI.js";
import "./chunk-XSQFM27N.js";
import {
  e as e4
} from "./chunk-R5TZJ3KJ.js";
import {
  e as e3
} from "./chunk-A7PY25IH.js";
import "./chunk-T2D6QF55.js";
import "./chunk-TW64FC7J.js";
import {
  a as a2
} from "./chunk-PRXITTX7.js";
import "./chunk-JGIZLXNQ.js";
import {
  x as x3
} from "./chunk-G356VNM2.js";
import {
  Zn,
  gn
} from "./chunk-SLPOHICA.js";
import {
  p as p3
} from "./chunk-REIXEATJ.js";
import "./chunk-7YGY53FV.js";
import {
  a as a4
} from "./chunk-IGOXVXHJ.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-GGTMSDMZ.js";
import "./chunk-ICG3HFWD.js";
import {
  g as g3
} from "./chunk-2OJTWNQ6.js";
import {
  l
} from "./chunk-2UAIGHM2.js";
import "./chunk-Z5QBM3A6.js";
import "./chunk-MRALC5D7.js";
import "./chunk-CYZ4XVBT.js";
import "./chunk-LVRAFE6T.js";
import "./chunk-XF2RZJFH.js";
import "./chunk-HRFBINZY.js";
import "./chunk-WAN4YZSB.js";
import "./chunk-EALW5DHT.js";
import "./chunk-EAKUFEPO.js";
import "./chunk-EQMIUIFH.js";
import {
  m as m2
} from "./chunk-KK57CPHE.js";
import "./chunk-7MMTDLQQ.js";
import "./chunk-TJWUU7NW.js";
import "./chunk-Q62HELM6.js";
import "./chunk-BQXNXAP2.js";
import "./chunk-BHQVXYUV.js";
import "./chunk-DKH5QOVM.js";
import "./chunk-JT54I3AY.js";
import "./chunk-DC3QI5ZE.js";
import {
  O,
  S,
  e2,
  f as f3,
  g,
  n,
  o,
  r as r2,
  u2 as u,
  z
} from "./chunk-TNTTCGVB.js";
import "./chunk-EGHLQERQ.js";
import {
  m
} from "./chunk-6CVKQGVU.js";
import "./chunk-2HZTCGYV.js";
import "./chunk-Z3YY72G4.js";
import {
  Ct,
  G
} from "./chunk-M3KO43BW.js";
import "./chunk-LRFOTULU.js";
import "./chunk-HPP5IXU5.js";
import "./chunk-UADQEL54.js";
import "./chunk-4D6JGHEF.js";
import "./chunk-CT6YILLI.js";
import "./chunk-LJAKPJDJ.js";
import "./chunk-CCWBAM3L.js";
import "./chunk-TKWZACTO.js";
import "./chunk-6K5VVUVI.js";
import "./chunk-DOQX2NNO.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-2ZX6RZTI.js";
import {
  h,
  v2 as v
} from "./chunk-5Q7F7FJ6.js";
import {
  f2,
  p3 as p2,
  w,
  w2
} from "./chunk-XFNXUG2G.js";
import "./chunk-27R7KBOL.js";
import "./chunk-RDTHWDIE.js";
import "./chunk-EAFLFTSD.js";
import "./chunk-DOVXDFWE.js";
import "./chunk-M4BAPJ3L.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-KGIB6IYW.js";
import {
  a2 as a,
  e,
  y3
} from "./chunk-3PPVODAA.js";
import "./chunk-MTJ2HM2W.js";
import "./chunk-PXVSWY3C.js";
import {
  L,
  f,
  p,
  y as y2
} from "./chunk-WTKFW2TD.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import "./chunk-PR6SXADK.js";
import {
  y
} from "./chunk-MGJMBJDY.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DoubleArray.js
function n2(n3, t2 = false) {
  return n3 <= y ? t2 ? new Array(n3).fill(0) : new Array(n3) : new Float64Array(n3);
}
function a5(r6, n3, t2) {
  return Array.isArray(r6) ? r6.slice(n3, n3 + t2) : r6.subarray(n3, n3 + t2);
}

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function i(t2) {
  const r6 = l2(t2.rings, t2.hasZ, f4.CCW_IS_HOLE), i2 = new Array();
  let c5 = 0, h6 = 0;
  for (const e5 of r6.polygons) {
    const t3 = e5.count, s4 = e5.index, l6 = a5(r6.position, 3 * s4, 3 * t3), f9 = e5.holeIndices.map((n3) => n3 - s4), g9 = new Uint32Array(r5(l6, f9, 3));
    i2.push({ position: l6, faces: g9 }), c5 += l6.length, h6 += g9.length;
  }
  const g8 = s3(i2, c5, h6), a7 = Array.isArray(g8.position) ? r3(g8.position, 3, { originalIndices: g8.faces }) : r3(g8.position.buffer, 6, { originalIndices: g8.faces });
  return g8.position = new Float64Array(a7.buffer), g8.faces = a7.indices, g8;
}
function s3(n3, t2, e5) {
  if (1 === n3.length)
    return n3[0];
  const o2 = n2(t2), i2 = new Uint32Array(e5);
  let s4 = 0, l6 = 0, c5 = 0;
  for (const r6 of n3) {
    for (let n4 = 0; n4 < r6.position.length; n4++)
      o2[s4++] = r6.position[n4];
    for (let n4 = 0; n4 < r6.faces.length; n4++)
      i2[l6++] = r6.faces[n4] + c5;
    c5 = s4 / 3;
  }
  return { position: o2, faces: i2 };
}
function l2(n3, t2, e5) {
  const o2 = n3.length, i2 = new Array(o2), s4 = new Array(o2), l6 = new Array(o2);
  let g8 = 0, a7 = 0, u5 = 0, p9 = 0;
  for (let r6 = 0; r6 < o2; ++r6)
    p9 += n3[r6].length;
  const d4 = n2(3 * p9);
  let y8 = 0;
  for (let r6 = o2 - 1; r6 >= 0; r6--) {
    const p10 = n3[r6], A4 = e5 === f4.CCW_IS_HOLE && h3(p10);
    if (A4 && 1 !== o2)
      i2[g8++] = p10;
    else {
      let n4 = p10.length;
      for (let t3 = 0; t3 < g8; ++t3)
        n4 += i2[t3].length;
      const e6 = { index: y8, pathLengths: new Array(g8 + 1), count: n4, holeIndices: new Array(g8) };
      e6.pathLengths[0] = p10.length, p10.length > 0 && (l6[u5++] = { index: y8, count: p10.length }), y8 = A4 ? c2(p10, p10.length - 1, -1, d4, y8, p10.length, t2) : c2(p10, 0, 1, d4, y8, p10.length, t2);
      for (let o3 = 0; o3 < g8; ++o3) {
        const n5 = i2[o3];
        e6.holeIndices[o3] = y8, e6.pathLengths[o3 + 1] = n5.length, n5.length > 0 && (l6[u5++] = { index: y8, count: n5.length }), y8 = c2(n5, 0, 1, d4, y8, n5.length, t2);
      }
      g8 = 0, e6.count > 0 && (s4[a7++] = e6);
    }
  }
  for (let r6 = 0; r6 < g8; ++r6) {
    const n4 = i2[r6];
    n4.length > 0 && (l6[u5++] = { index: y8, count: n4.length }), y8 = c2(n4, 0, 1, d4, y8, n4.length, t2);
  }
  return s4.length = a7, l6.length = u5, { position: d4, polygons: s4, outlines: l6 };
}
function c2(n3, t2, e5, o2, r6, i2, s4) {
  r6 *= 3;
  for (let l6 = 0; l6 < i2; ++l6) {
    const i3 = n3[t2];
    o2[r6++] = i3[0], o2[r6++] = i3[1], o2[r6++] = s4 ? i3[2] : 0, t2 += e5;
  }
  return r6 / 3;
}
function h3(n3) {
  return !h(n3, false, false);
}
var f4;
!function(n3) {
  n3[n3.NONE = 0] = "NONE", n3[n3.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(f4 || (f4 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var a6 = s.getLogger("esri.geometry.support.meshUtils.centerAt");
function c3(e5, r6, i2) {
  if (!e5.vertexAttributes || !e5.vertexAttributes.position)
    return;
  const n3 = (i2 == null ? void 0 : i2.origin) ?? e5.origin;
  if (r(e5.transform))
    null != (i2 == null ? void 0 : i2.geographic) && i2.geographic !== e5.transform.geographic && a6.warn(`Specifying the 'geographic' parameter (${i2.geographic}) different from the Mesh transform setting (${e5.transform.geographic}) is not supported`), f5(e5.transform, r6, n3);
  else {
    r4(e5.spatialReference, i2) ? p5(e5, r6, n3) : g5(e5, r6, n3);
  }
}
function f5(e5, t2, r6) {
  const i2 = t2.x - r6.x, o2 = t2.y - r6.y, n3 = t2.hasZ && r6.hasZ ? t2.z - r6.z : 0, s4 = e5.origin;
  e5.origin = [s4[0] + i2, s4[1] + o2, s4[2] + n3];
}
function p5(e5, t2, r6) {
  const i2 = b(e5.vertexAttributes, r6, { geographic: true }), { position: o2, normal: a7, tangent: c5 } = x2(i2, t2, { geographic: true });
  e5.vertexAttributes.position = o2, e5.vertexAttributes.normal = a7, e5.vertexAttributes.tangent = c5, e5.vertexAttributesChanged();
}
function g5(e5, t2, r6) {
  const o2 = h4, n3 = l3;
  if (gn(t2, n3, e5.spatialReference)) {
    if (!gn(r6, o2, e5.spatialReference)) {
      const t3 = e5.origin;
      o2[0] = t3.x, o2[1] = t3.y, o2[2] = t3.z, a6.error(`Failed to project specified origin (wkid:${r6.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid}).`);
    }
    m3(e5.vertexAttributes.position, n3, o2), e5.vertexAttributesChanged();
  } else
    a6.error(`Failed to project centerAt location (wkid:${t2.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid})`);
}
function m3(e5, t2, r6) {
  if (e5)
    for (let i2 = 0; i2 < e5.length; i2 += 3)
      for (let o2 = 0; o2 < 3; o2++)
        e5[i2 + o2] += t2[o2] - r6[o2];
}
var l3 = n();
var h4 = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function u2(e5, s4, o2) {
  const { loadGLTFMesh: n3 } = await y2(import("./loadGLTFMesh-FJXTAQLR.js"), o2), a7 = await m4(s4, o2), i2 = n3(new w({ x: 0, y: 0, z: 0, spatialReference: e5.spatialReference }), a7.url, { resolveFile: f6(a7), useTransform: true, signal: r(o2) ? o2.signal : null });
  i2.then(() => a7.dispose(), () => a7.dispose());
  const { vertexAttributes: l6, components: u5 } = await i2;
  e5.vertexAttributes = l6, e5.components = u5;
}
function f6(e5) {
  const t2 = Ct(e5.url);
  return (s4) => {
    const r6 = G(s4, t2, t2), o2 = r6 ? r6.replace(/^ *\.\//, "") : null;
    return (o2 ? e5.files.get(o2) : null) ?? s4;
  };
}
async function m4(e5, t2) {
  return e5 instanceof Blob ? y4.fromBlob(e5) : "string" == typeof e5 ? new y4(e5) : Array.isArray(e5) ? p6(e5, t2) : w3(e5, t2);
}
async function p6(t2, r6) {
  const i2 = /* @__PURE__ */ new Map();
  let l6 = null;
  const c5 = await L(t2.map(async (e5) => ({ name: e5.name, source: await m4(e5 instanceof Blob ? e5 : e5.source, r6) }))), u5 = [];
  for (const e5 of c5)
    e5 && (p(r6) ? e5.source.dispose() : u5.push(e5));
  f(r6);
  for (const { name: e5, source: o2 } of u5)
    (t(l6) || /\.(gltf|glb)/i.test(e5)) && (l6 = o2.url), i2.set(e5, o2.url), o2.files && o2.files.forEach((e6, t3) => i2.set(t3, e6));
  if (t(l6))
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new y4(l6, () => u5.forEach(({ source: e5 }) => e5.dispose()), i2);
}
async function w3(e5, t2) {
  const { default: s4 } = await y2(import("./request-M7NLGE3R.js"), t2), o2 = "string" == typeof e5.multipart[0] ? await Promise.all(e5.multipart.map(async (e6) => (await s4(e6, { responseType: "array-buffer" })).data)) : e5.multipart;
  return y4.fromBlob(new Blob(o2));
}
var y4 = class {
  constructor(e5, t2 = () => {
  }, s4 = /* @__PURE__ */ new Map()) {
    this.url = e5, this.dispose = t2, this.files = s4;
  }
  static fromBlob(e5) {
    const t2 = URL.createObjectURL(e5);
    return new y4(t2, () => URL.revokeObjectURL(t2));
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
function x4(r6, o2, i2) {
  if (r6.vertexAttributes && r6.vertexAttributes.position)
    if (r(r6.transform))
      null != (i2 == null ? void 0 : i2.geographic) && i2.geographic !== r6.transform.geographic && s.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${i2.geographic}) different from the Mesh transform setting (${r6.transform.geographic}) is not supported`), A(r6.transform, o2);
    else {
      r4(r6.spatialReference, i2) ? v3(r6, o2) : b2(r6, o2);
    }
}
function A(t2, e5) {
  const r6 = t2.origin;
  t2.origin = u(n(), r6, e5);
}
function v3(t2, o2) {
  const i2 = t2.spatialReference, s4 = t2.vertexAttributes.position, a7 = t2.vertexAttributes.normal, c5 = t2.vertexAttributes.tangent, x7 = new Float64Array(s4.length), A4 = r(a7) ? new Float32Array(a7.length) : null, v5 = r(c5) ? new Float32Array(c5.length) : null, b4 = t2.extent.center, F2 = d;
  Zn(i2, [b4.x, b4.y, b4.z], k3, c(i2)), a2(w4, k3), S(F2, o2, w4), M(s4, i2, x7), r(a7) && r(A4) && j(a7, s4, x7, i2, A4), r(c5) && r(v5) && k2(c5, s4, x7, i2, v5), y5(x7, F2), R(x7, s4, i2), r(a7) && r(A4) && h2(A4, s4, x7, i2, a7), r(c5) && r(v5) && L3(v5, s4, x7, i2, c5), t2.vertexAttributesChanged();
}
function b2(t2, e5) {
  y5(t2.vertexAttributes.position, e5), t2.vertexAttributesChanged();
}
function y5(t2, e5) {
  if (t2)
    for (let r6 = 0; r6 < t2.length; r6 += 3)
      for (let o2 = 0; o2 < 3; o2++)
        t2[r6 + o2] += e5[o2];
}
var d = n();
var k3 = e4();
var w4 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c4() {
  const { faceDescriptions: t2, faceVertexOffsets: e5, uvScales: n3 } = d2, r6 = 4 * t2.length, o2 = new Float64Array(3 * r6), s4 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i2 = new Uint32Array(2 * t2.length * 3);
  let c5 = 0, l6 = 0, f9 = 0, u5 = 0;
  for (let h6 = 0; h6 < t2.length; h6++) {
    const r7 = t2[h6], p9 = c5 / 3;
    for (const t3 of e5)
      i2[u5++] = p9 + t3;
    const m7 = r7.corners;
    for (let t3 = 0; t3 < 4; t3++) {
      const e6 = m7[t3];
      let i3 = 0;
      a7[f9++] = 0.25 * n3[t3][0] + r7.uvOrigin[0], a7[f9++] = r7.uvOrigin[1] - 0.25 * n3[t3][1];
      for (let t4 = 0; t4 < 3; t4++)
        0 !== r7.axis[t4] ? (o2[c5++] = 0.5 * r7.axis[t4], s4[l6++] = r7.axis[t4]) : (o2[c5++] = 0.5 * e6[i3++], s4[l6++] = 0);
    }
  }
  return { position: o2, normal: s4, uv: a7, faces: i2 };
}
function l4(e5, n3) {
  const r6 = e5.components[0], o2 = r6.faces, a7 = M2[n3], i2 = 6 * a7, c5 = new Array(6), l6 = new Array(o2.length - 6);
  let f9 = 0, u5 = 0;
  for (let t2 = 0; t2 < o2.length; t2++)
    t2 >= i2 && t2 < i2 + 6 ? c5[f9++] = o2[t2] : l6[u5++] = o2[t2];
  if (r(e5.vertexAttributes.uv)) {
    const t2 = new Float32Array(e5.vertexAttributes.uv), n4 = 4 * a7 * 2, r7 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let e6 = 0; e6 < r7.length; e6++)
      t2[n4 + e6] = r7[e6];
    e5.vertexAttributes.uv = t2;
  }
  return e5.components = [new g4({ faces: c5, material: r6.material }), new g4({ faces: l6 })], e5;
}
function f7(t2 = 0) {
  const e5 = Math.round(8 * 2 ** t2), n3 = 2 * e5, r6 = (e5 - 1) * (n3 + 1) + 2 * n3, o2 = new Float64Array(3 * r6), s4 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i2 = new Uint32Array(3 * ((e5 - 1) * n3 * 2));
  let c5 = 0, l6 = 0, f9 = 0, u5 = 0;
  for (let h6 = 0; h6 <= e5; h6++) {
    const t3 = h6 / e5 * Math.PI + 0.5 * Math.PI, r7 = Math.cos(t3), p9 = Math.sin(t3);
    F[2] = p9;
    const m7 = 0 === h6 || h6 === e5, w7 = m7 ? n3 - 1 : n3;
    for (let v5 = 0; v5 <= w7; v5++) {
      const t4 = v5 / w7 * 2 * Math.PI;
      F[0] = -Math.sin(t4) * r7, F[1] = Math.cos(t4) * r7;
      for (let e6 = 0; e6 < 3; e6++)
        o2[c5] = 0.5 * F[e6], s4[c5] = F[e6], ++c5;
      a7[l6++] = (v5 + (m7 ? 0.5 : 0)) / n3, a7[l6++] = h6 / e5, 0 !== h6 && v5 !== n3 && (h6 !== e5 && (i2[f9++] = u5, i2[f9++] = u5 + 1, i2[f9++] = u5 - n3), 1 !== h6 && (i2[f9++] = u5, i2[f9++] = u5 - n3, i2[f9++] = u5 - n3 - 1)), u5++;
    }
  }
  return { position: o2, normal: s4, uv: a7, faces: i2 };
}
function u3(t2 = 0) {
  const e5 = 5, n3 = Math.round(16 * 2 ** t2), r6 = (e5 - 1) * (n3 + 1) + 2 * n3, o2 = new Float64Array(3 * r6), s4 = new Float32Array(3 * r6), a7 = new Float32Array(2 * r6), i2 = new Uint32Array(3 * (4 * n3));
  let c5 = 0, l6 = 0, f9 = 0, u5 = 0, h6 = 0;
  for (let p9 = 0; p9 <= e5; p9++) {
    const t3 = 0 === p9 || p9 === e5, r7 = p9 <= 1 || p9 >= e5 - 1, m7 = 2 === p9 || 4 === p9, w7 = t3 ? n3 - 1 : n3;
    for (let v5 = 0; v5 <= w7; v5++) {
      const g8 = v5 / w7 * 2 * Math.PI, A4 = t3 ? 0 : 0.5;
      F[0] = A4 * Math.sin(g8), F[1] = A4 * -Math.cos(g8), F[2] = p9 <= 2 ? 0.5 : -0.5;
      for (let t4 = 0; t4 < 3; t4++)
        o2[c5++] = F[t4], s4[l6++] = r7 ? 2 === t4 ? p9 <= 1 ? 1 : -1 : 0 : 2 === t4 ? 0 : F[t4] / A4;
      a7[f9++] = (v5 + (t3 ? 0.5 : 0)) / n3, a7[f9++] = p9 <= 1 ? 1 * p9 / 3 : p9 <= 3 ? 1 * (p9 - 2) / 3 + 1 / 3 : 1 * (p9 - 4) / 3 + 2 / 3, m7 || 0 === p9 || v5 === n3 || (p9 !== e5 && (i2[u5++] = h6, i2[u5++] = h6 + 1, i2[u5++] = h6 - n3), 1 !== p9 && (i2[u5++] = h6, i2[u5++] = h6 - n3, i2[u5++] = h6 - n3 - 1)), h6++;
    }
  }
  return { position: o2, normal: s4, uv: a7, faces: i2 };
}
function h5(t2, e5) {
  const n3 = "number" == typeof e5 ? e5 : null != e5 ? e5.width : 1, r6 = "number" == typeof e5 ? e5 : null != e5 ? e5.height : 1;
  switch (t2) {
    case "up":
    case "down":
      return { width: n3, depth: r6 };
    case "north":
    case "south":
      return { width: n3, height: r6 };
    case "east":
    case "west":
      return { depth: n3, height: r6 };
  }
}
function p7(t2) {
  const e5 = g6.facingAxisOrderSwap[t2], n3 = g6.position, r6 = g6.normal, o2 = new Float64Array(n3.length), s4 = new Float32Array(r6.length);
  let a7 = 0;
  for (let i2 = 0; i2 < 4; i2++) {
    const t3 = a7;
    for (let i3 = 0; i3 < 3; i3++) {
      const c5 = e5[i3], l6 = Math.abs(c5) - 1, f9 = c5 >= 0 ? 1 : -1;
      o2[a7] = n3[t3 + l6] * f9, s4[a7] = r6[t3 + l6] * f9, a7++;
    }
  }
  return { position: o2, normal: s4, uv: new Float32Array(g6.uv), faces: new Uint32Array(g6.faces), isPlane: true };
}
var m5 = 1;
var w5 = 2;
var v4 = 3;
var g6 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [v4, m5, w5], west: [-v4, -m5, w5], north: [-m5, v4, w5], south: [m5, -v4, w5], up: [m5, w5, v4], down: [m5, -w5, -v4] } };
function A2(t2, e5, n3) {
  t2.isPlane || y6(t2), x5(t2, n3 == null ? void 0 : n3.size);
  const { vertexAttributes: r6, transform: o2 } = _(t2, e5, n3);
  return { vertexAttributes: new p4({ ...r6, uv: t2.uv }), transform: o2, components: [new g4({ faces: t2.faces, material: n3 && n3.material || null })], spatialReference: e5.spatialReference };
}
function y6(t2) {
  for (let e5 = 0; e5 < t2.position.length; e5 += 3)
    t2.position[e5 + 2] += 0.5;
}
function x5(t2, e5) {
  if (null == e5)
    return;
  const o2 = "number" == typeof e5 ? [e5, e5, e5] : [null != e5.width ? e5.width : 1, null != e5.depth ? e5.depth : 1, null != e5.height ? e5.height : 1];
  O2[0] = o2[0], O2[4] = o2[1], O2[8] = o2[2];
  for (let r6 = 0; r6 < t2.position.length; r6 += 3) {
    for (let e6 = 0; e6 < 3; e6++)
      F[e6] = t2.position[r6 + e6];
    S(F, F, O2);
    for (let e6 = 0; e6 < 3; e6++)
      t2.position[r6 + e6] = F[e6];
  }
  if (o2[0] !== o2[1] || o2[1] !== o2[2]) {
    O2[0] = 1 / o2[0], O2[4] = 1 / o2[1], O2[8] = 1 / o2[2];
    for (let e6 = 0; e6 < t2.normal.length; e6 += 3) {
      for (let n3 = 0; n3 < 3; n3++)
        F[n3] = t2.normal[e6 + n3];
      S(F, F, O2), z(F, F);
      for (let n3 = 0; n3 < 3; n3++)
        t2.normal[e6 + n3] = F[n3];
    }
  }
}
var d2 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var M2 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var F = n();
var O2 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var $ = s.getLogger("esri.geometry.support.meshUtils.rotate");
function U(t2, r6, o2) {
  if (!t2.vertexAttributes || !t2.vertexAttributes.position || 0 === r6[3])
    return;
  const i2 = t2.spatialReference;
  if (r(t2.transform)) {
    null != (o2 == null ? void 0 : o2.geographic) && o2.geographic !== t2.transform.geographic && $.warn(`Specifying the 'geographic' parameter (${o2.geographic}) different from the Mesh transform setting (${t2.transform.geographic}) is not supported`);
    const e5 = (o2 == null ? void 0 : o2.origin) ?? t2.transform.getOriginPoint(i2);
    z2(t2.transform, r6, e5);
  } else {
    const e5 = (o2 == null ? void 0 : o2.origin) ?? t2.origin;
    r4(t2.spatialReference, o2) ? C(t2, r6, e5) : I(t2, r6, e5);
  }
}
function z2(t2, e5, r6) {
  const o2 = o(E, r6.x, r6.y, r6.z), i2 = e2(E, o2, t2.origin);
  t2.applyLocalInverse(i2, M3), t2.rotation = v2(t2.rotation, e5, a3()), t2.applyLocalInverse(i2, i2), e2(i2, i2, M3), t2.translation = u(n(), t2.translation, i2);
}
function C(t2, r6, i2) {
  const s4 = t2.spatialReference, n3 = c(s4), a7 = Z;
  gn(i2, a7, n3) || gn(t2.origin, a7, n3);
  const c5 = t2.vertexAttributes.position, f9 = t2.vertexAttributes.normal, m7 = t2.vertexAttributes.tangent, g8 = new Float64Array(c5.length), l6 = r(f9) ? new Float32Array(f9.length) : null, v5 = r(m7) ? new Float32Array(m7.length) : null;
  Zn(n3, a7, P, n3), a2(S2, P);
  const x7 = O3;
  S(g2(O3), g2(r6), S2), x7[3] = r6[3], M(c5, s4, g8), r(f9) && r(l6) && j(f9, c5, g8, s4, l6), r(m7) && r(v5) && k2(m7, c5, g8, s4, v5), D(g8, x7, 3, a7), R(g8, c5, s4), r(f9) && r(l6) && (D(l6, x7, 3), h2(l6, c5, g8, s4, f9)), r(m7) && r(v5) && (D(v5, x7, 4), L3(v5, c5, g8, s4, m7)), t2.vertexAttributesChanged();
}
function I(t2, e5, r6) {
  const o2 = Z;
  if (!gn(r6, o2, t2.spatialReference)) {
    const e6 = t2.origin;
    o2[0] = e6.x, o2[1] = e6.y, o2[2] = e6.z, $.error(`Failed to project specified origin (wkid:${r6.spatialReference.wkid}) to mesh spatial reference (wkid:${t2.spatialReference.wkid}).`);
  }
  D(t2.vertexAttributes.position, e5, 3, o2), D(t2.vertexAttributes.normal, e5, 3), D(t2.vertexAttributes.tangent, e5, 4), t2.vertexAttributesChanged();
}
function D(t2, e5, o2, i2 = f3) {
  if (!t(t2)) {
    p3(P, x(e5), g2(e5));
    for (let e6 = 0; e6 < t2.length; e6 += o2) {
      for (let r6 = 0; r6 < 3; r6++)
        E[r6] = t2[e6 + r6] - i2[r6];
      O(E, E, P);
      for (let r6 = 0; r6 < 3; r6++)
        t2[e6 + r6] = E[r6] + i2[r6];
    }
  }
}
var E = n();
var M3 = n();
var O3 = a3();
var P = e4();
var S2 = e3();
var Z = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var d3 = s.getLogger("esri.geometry.support.meshUtils.scale");
function j2(e5, r6, o2) {
  if (!e5.vertexAttributes || !e5.vertexAttributes.position)
    return;
  const i2 = e5.spatialReference;
  if (r(e5.transform)) {
    null != (o2 == null ? void 0 : o2.geographic) && o2.geographic !== e5.transform.geographic && d3.warn(`Specifying the 'geographic' parameter (${o2.geographic}) different from the Mesh transform setting (${e5.transform.geographic}) is not supported`);
    const t2 = (o2 == null ? void 0 : o2.origin) ?? e5.transform.getOriginPoint(i2);
    x6(e5.transform, r6, t2);
  } else {
    const t2 = r4(e5.spatialReference, o2), i3 = o2 && o2.origin || e5.origin;
    t2 ? A3(e5, r6, i3) : b3(e5, r6, i3);
  }
}
function x6(e5, t2, a7) {
  const c5 = o(w6, a7.x, a7.y, a7.z), p9 = e2(w6, c5, e5.origin);
  e5.applyLocalInverse(p9, R2);
  const l6 = g(n(), e5.scale, t2);
  e5.scale = l6, e5.applyLocalInverse(p9, p9), e2(p9, p9, R2), e5.translation = u(n(), e5.translation, p9);
}
function A3(e5, r6, o2) {
  const i2 = e5.spatialReference, n3 = c(i2), s4 = k4;
  gn(o2, s4, n3) || gn(e5.origin, s4, n3);
  const a7 = e5.vertexAttributes.position, l6 = e5.vertexAttributes.normal, d4 = e5.vertexAttributes.tangent, j3 = new Float64Array(a7.length), x7 = r(l6) ? new Float32Array(l6.length) : null, A4 = r(d4) ? new Float32Array(d4.length) : null;
  M(a7, i2, j3), r(l6) && r(x7) && j(l6, a7, j3, i2, x7), r(d4) && r(A4) && k2(d4, a7, j3, i2, A4), y7(j3, r6, s4), R(j3, a7, i2), r(l6) && r(x7) && h2(x7, a7, j3, i2, l6), r(d4) && r(A4) && L3(A4, a7, j3, i2, d4), e5.vertexAttributesChanged();
}
function b3(e5, t2, r6) {
  const o2 = k4;
  if (!gn(r6, o2, e5.spatialReference)) {
    const t3 = e5.origin;
    o2[0] = t3.x, o2[1] = t3.y, o2[2] = t3.z, d3.error(`Failed to project specified origin (wkid:${r6.spatialReference.wkid}) to mesh spatial reference (wkid:${e5.spatialReference.wkid}).`);
  }
  y7(e5.vertexAttributes.position, t2, o2), e5.vertexAttributesChanged();
}
function y7(e5, t2, r6 = f3) {
  if (e5)
    for (let o2 = 0; o2 < e5.length; o2 += 3) {
      for (let t3 = 0; t3 < 3; t3++)
        w6[t3] = e5[o2 + t3] - r6[t3];
      g(w6, w6, t2);
      for (let t3 = 0; t3 < 3; t3++)
        e5[o2 + t3] = w6[t3] + r6[t3];
    }
}
var w6 = n();
var R2 = n();
var k4 = n();

// node_modules/@arcgis/core/geometry/Mesh.js
var G2;
var I2 = "esri.geometry.Mesh";
var B = G2 = class extends a4(m2.LoadableMixin(m(p2))) {
  constructor(e5) {
    super(e5), this.components = null, this.transform = null, this.external = null, this.hasZ = true, this.hasM = false, this.vertexAttributes = new p4(), this.type = "mesh";
  }
  initialize() {
    (t(this.external) || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.handles.add(l(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e5) => e5.clone()) };
      }, () => this._set("external", null), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    return !this.loaded && r(this.external) && r(this.external.extent) || this.loaded && this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0);
  }
  get _boundingInfo() {
    const e5 = this.vertexAttributes.position, t2 = this.spatialReference;
    if (0 === e5.length || this.components && 0 === this.components.length)
      return { extent: new w2({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t2 }), center: new w({ x: 0, y: 0, z: 0, spatialReference: t2 }) };
    const r6 = r(this.transform) ? this.transform.project(e5, t2) : e5;
    let o2 = 1 / 0, n3 = 1 / 0, s4 = 1 / 0, a7 = -1 / 0, l6 = -1 / 0, c5 = -1 / 0, p9 = 0, m7 = 0, h6 = 0;
    const f9 = r6.length, d4 = 1 / (f9 / 3);
    let x7 = 0;
    for (; x7 < f9; ) {
      const e6 = r6[x7++], t3 = r6[x7++], i2 = r6[x7++];
      o2 = Math.min(o2, e6), n3 = Math.min(n3, t3), s4 = Math.min(s4, i2), a7 = Math.max(a7, e6), l6 = Math.max(l6, t3), c5 = Math.max(c5, i2), p9 += d4 * e6, m7 += d4 * t3, h6 += d4 * i2;
    }
    return { extent: new w2({ xmin: o2, ymin: n3, zmin: s4, xmax: a7, ymax: l6, zmax: c5, spatialReference: t2 }), center: new w({ x: p9, y: m7, z: h6, spatialReference: t2 }) };
  }
  get anchor() {
    if (r(this.transform))
      return this.transform.getOriginPoint(this.spatialReference);
    const e5 = this._boundingInfo;
    return new w({ x: e5.center.x, y: e5.center.y, z: e5.extent.zmin, spatialReference: this.spatialReference });
  }
  get origin() {
    return r(this.transform) ? this.transform.getOriginPoint(this.spatialReference) : this._boundingInfo.center;
  }
  get extent() {
    return !this.loaded && r(this.external) && r(this.external.extent) ? this.external.extent.clone() : this._boundingInfo.extent;
  }
  addComponent(e5) {
    this.loaded ? (this.components || (this.components = []), this.components.push(g4.from(e5)), this.notifyChange("components")) : s.getLogger(this.declaredClass).error("addComponent()", "Mesh must be loaded before applying operations");
  }
  removeComponent(e5) {
    if (this.loaded) {
      if (this.components) {
        const t2 = this.components.indexOf(e5);
        if (-1 !== t2)
          return this.components.splice(t2, 1), void this.notifyChange("components");
      }
      s.getLogger(this.declaredClass).error("removeComponent()", "Provided component is not part of the list of components");
    } else
      s.getLogger(this.declaredClass).error("removeComponent()", "Mesh must be loaded before applying operations");
  }
  rotate(e5, t2, r6, o2) {
    return k(k5.x, e5, D2), k(k5.y, t2, W), k(k5.z, r6, Z2), v2(D2, W, D2), v2(D2, Z2, D2), U(this, D2, o2), this;
  }
  offset(e5, t2, r6, o2) {
    return this.loaded ? (H[0] = e5, H[1] = t2, H[2] = r6, x4(this, H, o2), this) : (s.getLogger(this.declaredClass).error("offset()", "Mesh must be loaded before applying operations"), this);
  }
  scale(e5, t2) {
    return this.loaded ? (j2(this, e5, t2), this) : (s.getLogger(this.declaredClass).error("scale()", "Mesh must be loaded before applying operations"), this);
  }
  centerAt(e5, t2) {
    return this.loaded ? (c3(this, e5, t2), this) : (s.getLogger(this.declaredClass).error("centerAt()", "Mesh must be loaded before applying operations"), this);
  }
  load(e5) {
    return r(this.external) && this.addResolvingPromise(u2(this, this.external.source, e5)), Promise.resolve(this);
  }
  updateExternalSource(e5) {
    this._set("external", e5);
  }
  clone() {
    let e5 = null;
    if (this.components) {
      const t3 = /* @__PURE__ */ new Map(), r6 = /* @__PURE__ */ new Map();
      e5 = this.components.map((e6) => e6.cloneWithDeduplication(t3, r6));
    }
    const t2 = { components: e5, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), transform: r(this.transform) ? this.transform.clone() : null, external: r(this.external) ? { source: this.external.source, extent: r(this.external.extent) ? this.external.extent.clone() : null } : null };
    return new G2(t2);
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e5) {
    const t2 = import("./gltfexport-QGLV7XKH.js"), r6 = this.load(), o2 = await Promise.all([t2, r6]), { toBinaryGLTF: n3 } = o2[0];
    return n3(this, e5);
  }
  static createBox(e5, t2) {
    if (!(e5 instanceof w))
      return s.getLogger(I2).error(".createBox()", "expected location to be a Point instance"), null;
    const r6 = new G2(A2(c4(), e5, t2));
    return t2 && t2.imageFace && "all" !== t2.imageFace ? l4(r6, t2.imageFace) : r6;
  }
  static createSphere(e5, t2) {
    return e5 instanceof w ? new G2(A2(f7(t2 && t2.densificationFactor || 0), e5, t2)) : (s.getLogger(I2).error(".createSphere()", "expected location to be a Point instance"), null);
  }
  static createCylinder(e5, t2) {
    return e5 instanceof w ? new G2(A2(u3(t2 && t2.densificationFactor || 0), e5, t2)) : (s.getLogger(I2).error(".createCylinder()", "expected location to be a Point instance"), null);
  }
  static createPlane(e5, t2) {
    if (!(e5 instanceof w))
      return s.getLogger(I2).error(".createPlane()", "expected location to be a Point instance"), null;
    const r6 = (t2 == null ? void 0 : t2.facing) ?? "up", o2 = h5(r6, t2 == null ? void 0 : t2.size);
    return new G2(A2(p7(r6), e5, { ...t2, size: o2 }));
  }
  static createFromPolygon(e5, t2) {
    if (!(e5 instanceof v))
      return s.getLogger(I2).error(".createFromPolygon()", "expected polygon to be a Polygon instance"), null;
    const r6 = i(e5);
    return new G2({ vertexAttributes: new p4({ position: r6.position }), components: [new g4({ faces: r6.faces, shading: "flat", material: (t2 == null ? void 0 : t2.material) ?? null })], spatialReference: e5.spatialReference });
  }
  static async createFromGLTF(e5, r6, o2) {
    if (!(e5 instanceof w))
      throw s.getLogger(I2).error(".createfromGLTF()", "expected location to be a Point instance"), new s2("invalid-input", "Expected location to be a Point instance");
    const { loadGLTFMesh: s4 } = await y2(import("./loadGLTFMesh-FJXTAQLR.js"), o2);
    return new G2(await s4(e5, r6, o2));
  }
  static createWithExternalSource(e5, t2, r6) {
    var _a;
    const o2 = (r6 == null ? void 0 : r6.extent) ?? null, n3 = ((_a = r6 == null ? void 0 : r6.transform) == null ? void 0 : _a.clone()) ?? new L2();
    n3.origin = [e5.x, e5.y, e5.z ?? 0];
    const s4 = e5.spatialReference;
    return new G2({ external: { source: t2, extent: o2 }, transform: n3, spatialReference: s4 });
  }
  static createIncomplete(e5, r6) {
    var _a;
    const o2 = ((_a = r6 == null ? void 0 : r6.transform) == null ? void 0 : _a.clone()) ?? new L2();
    o2.origin = [e5.x, e5.y, e5.z ?? 0];
    const n3 = e5.spatialReference, s4 = new G2({ transform: o2, spatialReference: n3 });
    return s4.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), s4;
  }
};
e([y3({ type: [g4], json: { write: true } })], B.prototype, "components", void 0), e([y3({ type: L2, json: { write: true } })], B.prototype, "transform", void 0), e([y3({ constructOnly: true })], B.prototype, "external", void 0), e([y3({ readOnly: true })], B.prototype, "hasExtent", null), e([y3({ readOnly: true })], B.prototype, "_boundingInfo", null), e([y3({ readOnly: true })], B.prototype, "anchor", null), e([y3({ readOnly: true })], B.prototype, "origin", null), e([y3({ readOnly: true, json: { read: false } })], B.prototype, "extent", null), e([y3({ readOnly: true, json: { read: false, write: true, default: true } })], B.prototype, "hasZ", void 0), e([y3({ readOnly: true, json: { read: false, write: true, default: false } })], B.prototype, "hasM", void 0), e([y3({ type: p4, nonNullable: true, json: { write: true } })], B.prototype, "vertexAttributes", void 0), B = G2 = e([a(I2)], B);
var k5 = { x: r2(1, 0, 0), y: r2(0, 1, 0), z: r2(0, 0, 1) };
var D2 = a3();
var W = a3();
var Z2 = a3();
var H = n();
var N = B;

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
function u4(r6, n3, o2) {
  const a7 = o2.features;
  o2.features = [], delete o2.geometryType;
  const i2 = x3.fromJSON(o2);
  if (i2.geometryType = "mesh", !o2.assetMaps)
    return i2;
  const u5 = E2(n3, o2.assetMaps), m7 = i2.spatialReference ?? f2.WGS84, p9 = o2.globalIdFieldName, { outFields: g8 } = r6, D4 = r(g8) && g8.length > 0 ? l5(g8.includes("*") ? null : new Set(g8)) : () => ({});
  for (const s4 of a7) {
    const r7 = f8(s4, p9, m7, n3, u5);
    r(r7) && i2.features.push(new g3({ geometry: r7, attributes: D4(s4) }));
  }
  return i2;
}
function l5(t2) {
  return ({ attributes: e5 }) => {
    if (!e5)
      return {};
    if (!t2)
      return e5;
    for (const r6 in e5)
      t2.has(r6) || delete e5[r6];
    return e5;
  };
}
function f8(t2, e5, o2, s4, a7) {
  const i2 = t2.attributes[e5], c5 = a7.get(i2);
  if (null == c5 || c5.status === g7.FAILED || null == c5.url)
    return null;
  const u5 = m6(t2, o2, s4), l6 = w2.fromJSON(t2.geometry);
  l6.spatialReference = o2;
  const f9 = p8(t2.attributes, s4, c5.projectVertices);
  return c5.status === g7.PENDING ? N.createIncomplete(u5, { extent: l6, transform: f9 }) : N.createWithExternalSource(u5, [{ name: c5.name, source: c5.url }], { extent: l6, transform: f9 });
}
function m6({ attributes: t2 }, e5, { transformFieldRoles: r6 }) {
  return new w({ x: t2[r6.originX], y: t2[r6.originY], z: t2[r6.originZ], spatialReference: e5 });
}
function p8(t2, { transformFieldRoles: e5 }, r6) {
  return new L2({ translation: [t2[e5.translationX], -t2[e5.translationZ], t2[e5.translationY]], rotation: k([t2[e5.rotationX], t2[e5.rotationZ], t2[e5.rotationY]], t2[e5.rotationDeg]), scale: [t2[e5.scaleX], t2[e5.scaleY], t2[e5.scaleZ]], geographic: r6 });
}
var g7;
function E2(t2, e5) {
  const r6 = /* @__PURE__ */ new Map();
  for (const n3 of e5) {
    const t3 = n3.parentGlobalId;
    if (null == t3)
      continue;
    const e6 = n3.assetName, o2 = n3.assetURL, s4 = n3.conversionStatus;
    let a7 = r6.get(t3);
    if (null == a7)
      switch (a7 = { name: e6, status: g7.FAILED, url: o2, projectVertices: D3(n3.flags).projectVertices }, r6.set(t3, a7), s4) {
        case "COMPLETED":
        case "SUBMITTED":
          a7.status = g7.COMPLETED;
          break;
        case "INPROGRESS":
          a7.status = g7.PENDING;
          break;
        default:
          a7.status = g7.FAILED;
      }
    else
      console.warn(`Multiple asset parts not expected. Ignoring additional parts. conflicting assetname: ${n3.assetName}`);
  }
  return r6;
}
function D3(t2) {
  return { projectVertices: t2.includes("PROJECT_VERTICES") };
}
!function(t2) {
  t2[t2.FAILED = 0] = "FAILED", t2[t2.PENDING = 1] = "PENDING", t2[t2.COMPLETED = 2] = "COMPLETED";
}(g7 || (g7 = {}));
export {
  u4 as meshFeatureSetFromJSON
};
//# sourceMappingURL=meshFeatureSet-BT4OC6CZ.js.map

import {
  l
} from "./chunk-74O5RNN6.js";
import {
  x
} from "./chunk-APWPNAOK.js";
import {
  b
} from "./chunk-ZSE573CF.js";
import {
  b as b2
} from "./chunk-GEQPBGLO.js";
import {
  b as b3
} from "./chunk-EAKUFEPO.js";
import {
  p
} from "./chunk-EQMIUIFH.js";
import {
  U
} from "./chunk-2HZTCGYV.js";
import {
  r as r3
} from "./chunk-Z3YY72G4.js";
import {
  K,
  N,
  W
} from "./chunk-M3KO43BW.js";
import {
  r as r2
} from "./chunk-DOVXDFWE.js";
import {
  o
} from "./chunk-M4BAPJ3L.js";
import {
  a2,
  e,
  y3 as y
} from "./chunk-3PPVODAA.js";
import {
  f,
  j,
  w
} from "./chunk-WTKFW2TD.js";
import {
  s as s2,
  s2 as s3
} from "./chunk-UG2OEDEE.js";
import {
  s
} from "./chunk-IOCWNUEO.js";
import {
  a,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/layers/mixins/PortalLayer.js
var _ = (_2) => {
  let H = class extends _2 {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = true, this.userHasFullEditingPrivileges = false, this.userHasUpdateItemPrivileges = false;
    }
    destroy() {
      this.portalItem = a(this.portalItem);
    }
    set portalItem(t2) {
      t2 !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", t2));
    }
    readPortalItem(t2, e2, r4) {
      if (e2.itemId)
        return new x({ id: e2.itemId, portal: r4 && r4.portal });
    }
    writePortalItem(t2, e2) {
      t2 && t2.id && (e2.itemId = t2.id);
    }
    async loadFromPortal(t2, e2) {
      if (this.portalItem && this.portalItem.id)
        try {
          const r4 = await import("./layersLoader-2X5E47X3.js");
          return f(e2), await r4.load({ instance: this, supportedTypes: t2.supportedTypes, validateItem: t2.validateItem, supportsData: t2.supportsData, layerModuleTypeMap: t2.layerModuleTypeMap }, e2);
        } catch (r4) {
          throw j(r4) || s2.getLogger(this.declaredClass).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${r4}`), r4;
        }
    }
    async finishLoadEditablePortalLayer(t2) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(t2).catch((t3) => (w(t3), true)));
    }
    async _setUserPrivileges(t2, r4) {
      if (!s.userPrivilegesApplied)
        return this.finishLoadEditablePortalLayer(r4);
      if (this.url)
        try {
          const { features: { edit: e2, fullEdit: s4 }, content: { updateItem: i } } = await this._fetchUserPrivileges(t2, r4);
          this._set("userHasEditingPrivileges", e2), this._set("userHasFullEditingPrivileges", s4), this._set("userHasUpdateItemPrivileges", i);
        } catch (s4) {
          w(s4);
        }
    }
    async _fetchUserPrivileges(t2, e2) {
      var _a;
      let s4 = this.portalItem;
      if (!t2 || !s4 || !s4.loaded || s4.sourceUrl)
        return this._fetchFallbackUserPrivileges(e2);
      const i = t2 === s4.id;
      if (i && s4.portal.user)
        return l(s4);
      let o2, a3;
      if (i)
        o2 = s4.portal.url;
      else
        try {
          o2 = await b2(this.url, e2);
        } catch (c) {
          w(c);
        }
      if (!o2 || !N(o2, s4.portal.url))
        return this._fetchFallbackUserPrivileges(e2);
      try {
        const t3 = r(e2) ? e2.signal : null;
        a3 = await ((_a = r3) == null ? void 0 : _a.getCredential(`${o2}/sharing`, { prompt: false, signal: t3 }));
      } catch (c) {
        w(c);
      }
      const l2 = true, n = false, u = false;
      if (!a3)
        return { features: { edit: l2, fullEdit: n }, content: { updateItem: u } };
      try {
        if (i ? await s4.reload() : (s4 = new x({ id: t2, portal: { url: o2 } }), await s4.load(e2)), s4.portal.user)
          return l(s4);
      } catch (c) {
        w(c);
      }
      return { features: { edit: l2, fullEdit: n }, content: { updateItem: u } };
    }
    async _fetchFallbackUserPrivileges(t2) {
      let e2 = true;
      try {
        e2 = await this._fetchUserHasEditingPrivileges(t2);
      } catch (r4) {
        w(r4);
      }
      return { features: { edit: e2, fullEdit: false }, content: { updateItem: false } };
    }
    async _fetchUserHasEditingPrivileges(t2) {
      var _a;
      const e2 = this.url ? (_a = r3) == null ? void 0 : _a.findCredential(this.url) : null;
      if (!e2)
        return true;
      const s4 = b4.credential === e2 ? b4.user : await this._fetchEditingUser(t2);
      return b4.credential = e2, b4.user = s4, t(s4) || null == s4.privileges || s4.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(t2) {
      var _a, _b;
      const e2 = (_b = (_a = this.portalItem) == null ? void 0 : _a.portal) == null ? void 0 : _b.user;
      if (e2)
        return e2;
      const o2 = r3.findServerInfo(this.url ?? "");
      if (!(o2 == null ? void 0 : o2.owningSystemUrl))
        return null;
      const a3 = `${o2.owningSystemUrl}/sharing/rest`, l2 = b3.getDefault();
      if (l2 && l2.loaded && K(l2.restUrl) === K(a3))
        return l2.user;
      const n = `${a3}/community/self`, u = r(t2) ? t2.signal : null, c = await b(U(n, { authMode: "no-prompt", query: { f: "json" }, signal: u }));
      return c.ok ? p.fromJSON(c.value.data) : null;
    }
    read(t2, e2) {
      e2 && (e2.layer = this), super.read(t2, e2);
    }
    write(t2, e2) {
      const r4 = e2 && e2.portal, s4 = this.portalItem && this.portalItem.id && (this.portalItem.portal || b3.getDefault());
      return r4 && s4 && !W(s4.restUrl, r4.restUrl) ? (e2.messages && e2.messages.push(new s3("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(t2, { ...e2, layer: this });
    }
  };
  return e([y({ type: x })], H.prototype, "portalItem", null), e([o("web-document", "portalItem", ["itemId"])], H.prototype, "readPortalItem", null), e([r2("web-document", "portalItem", { itemId: { type: String } })], H.prototype, "writePortalItem", null), e([y({ clonable: false })], H.prototype, "resourceReferences", void 0), e([y({ type: Boolean, readOnly: true })], H.prototype, "userHasEditingPrivileges", void 0), e([y({ type: Boolean, readOnly: true })], H.prototype, "userHasFullEditingPrivileges", void 0), e([y({ type: Boolean, readOnly: true })], H.prototype, "userHasUpdateItemPrivileges", void 0), H = e([a2("esri.layers.mixins.PortalLayer")], H), H;
};
var b4 = { credential: null, user: null };

export {
  _
};
//# sourceMappingURL=chunk-L4RMMCLB.js.map

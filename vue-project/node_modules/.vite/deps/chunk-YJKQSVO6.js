import {
  n as n2,
  o as o3,
  r as r6,
  t as t3
} from "./chunk-5NPD3OIH.js";
import {
  c as c3,
  e as e2,
  r as r3,
  s as s3
} from "./chunk-MNYWPBDW.js";
import {
  C,
  D,
  E as E2,
  L as L3
} from "./chunk-4M3AMTD4.js";
import {
  o as o2,
  t as t2
} from "./chunk-MJIX5E4D.js";
import {
  e as e5
} from "./chunk-H5ZFTV2L.js";
import {
  x as x2
} from "./chunk-LMZ4ULJY.js";
import {
  e as e4
} from "./chunk-XSQFM27N.js";
import {
  e as e3,
  r as r4
} from "./chunk-R5TZJ3KJ.js";
import {
  A,
  B,
  E,
  F as F2,
  L as L2,
  O,
  V,
  c as c2,
  d as d2,
  g,
  i as i2,
  q,
  u,
  w as w2,
  x
} from "./chunk-LVBKIX3G.js";
import {
  r as r5
} from "./chunk-5OPLKRAS.js";
import {
  b
} from "./chunk-FAK3SJAD.js";
import {
  b as b2,
  c,
  d,
  f as f2,
  i
} from "./chunk-REIXEATJ.js";
import {
  n
} from "./chunk-CCAF47ZU.js";
import {
  U
} from "./chunk-QJXSE36Y.js";
import {
  F,
  nt,
  ot,
  tt
} from "./chunk-M3KO43BW.js";
import {
  r as r2
} from "./chunk-PXVSWY3C.js";
import {
  L,
  f,
  w
} from "./chunk-QLY5H3XF.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  e,
  o
} from "./chunk-MGJMBJDY.js";
import {
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/chunks/vec42.js
function t4(t11, r12, f9) {
  if (t11.count !== r12.count)
    return void e5.error("source and destination buffers need to have the same number of elements");
  const o8 = t11.count, n7 = f9[0], u4 = f9[1], d5 = f9[2], s5 = f9[3], c7 = f9[4], i5 = f9[5], a2 = f9[6], p2 = f9[7], y = f9[8], B2 = f9[9], m2 = f9[10], l3 = f9[11], S = f9[12], h = f9[13], b3 = f9[14], M = f9[15], v = t11.typedBuffer, g2 = t11.typedBufferStride, _ = r12.typedBuffer, j = r12.typedBufferStride;
  for (let e10 = 0; e10 < o8; e10++) {
    const t12 = e10 * g2, r13 = e10 * j, f10 = _[r13], o9 = _[r13 + 1], z2 = _[r13 + 2], O2 = _[r13 + 3];
    v[t12] = n7 * f10 + c7 * o9 + y * z2 + S * O2, v[t12 + 1] = u4 * f10 + i5 * o9 + B2 * z2 + h * O2, v[t12 + 2] = d5 * f10 + a2 * o9 + m2 * z2 + b3 * O2, v[t12 + 3] = s5 * f10 + p2 * o9 + l3 * z2 + M * O2;
  }
}
function r7(t11, r12, f9) {
  if (t11.count !== r12.count)
    return void e5.error("source and destination buffers need to have the same number of elements");
  const o8 = t11.count, n7 = f9[0], u4 = f9[1], d5 = f9[2], s5 = f9[3], c7 = f9[4], i5 = f9[5], a2 = f9[6], p2 = f9[7], y = f9[8], B2 = t11.typedBuffer, m2 = t11.typedBufferStride, l3 = r12.typedBuffer, S = r12.typedBufferStride;
  for (let e10 = 0; e10 < o8; e10++) {
    const t12 = e10 * m2, r13 = e10 * S, f10 = l3[r13], o9 = l3[r13 + 1], h = l3[r13 + 2], b3 = l3[r13 + 3];
    B2[t12] = n7 * f10 + s5 * o9 + a2 * h, B2[t12 + 1] = u4 * f10 + c7 * o9 + p2 * h, B2[t12 + 2] = d5 * f10 + i5 * o9 + y * h, B2[t12 + 3] = b3;
  }
}
function f3(e10, t11) {
  const r12 = Math.min(e10.count, t11.count), f9 = e10.typedBuffer, o8 = e10.typedBufferStride, n7 = t11.typedBuffer, u4 = t11.typedBufferStride;
  for (let d5 = 0; d5 < r12; d5++) {
    const e11 = d5 * o8, t12 = d5 * u4, r13 = n7[t12], s5 = n7[t12 + 1], c7 = n7[t12 + 2], i5 = r13 * r13 + s5 * s5 + c7 * c7;
    if (i5 > 0) {
      const t13 = 1 / Math.sqrt(i5);
      f9[e11] = t13 * r13, f9[e11 + 1] = t13 * s5, f9[e11 + 2] = t13 * c7;
    }
  }
}
function o4(e10, t11, r12) {
  const f9 = Math.min(e10.count, t11.count), o8 = e10.typedBuffer, n7 = e10.typedBufferStride, u4 = t11.typedBuffer, d5 = t11.typedBufferStride;
  for (let s5 = 0; s5 < f9; s5++) {
    const e11 = s5 * n7, t12 = s5 * d5;
    o8[e11] = r12 * u4[t12], o8[e11 + 1] = r12 * u4[t12 + 1], o8[e11 + 2] = r12 * u4[t12 + 2], o8[e11 + 3] = r12 * u4[t12 + 3];
  }
}
function n3(e10, t11, r12) {
  const f9 = Math.min(e10.count, t11.count), o8 = e10.typedBuffer, n7 = e10.typedBufferStride, u4 = t11.typedBuffer, d5 = t11.typedBufferStride;
  for (let s5 = 0; s5 < f9; s5++) {
    const e11 = s5 * n7, t12 = s5 * d5;
    o8[e11] = u4[t12] >> r12, o8[e11 + 1] = u4[t12 + 1] >> r12, o8[e11 + 2] = u4[t12 + 2] >> r12, o8[e11 + 3] = u4[t12 + 3] >> r12;
  }
}
var u2 = Object.freeze(Object.defineProperty({ __proto__: null, normalize: f3, scale: o4, shiftRight: n3, transformMat3: r7, transformMat4: t4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec22.js
function f4(e10, t11, r12) {
  const f9 = e10.typedBuffer, n7 = e10.typedBufferStride, d5 = t11.typedBuffer, o8 = t11.typedBufferStride, u4 = r12 ? r12.count : t11.count;
  let s5 = (r12 && r12.dstIndex ? r12.dstIndex : 0) * n7, c7 = (r12 && r12.srcIndex ? r12.srcIndex : 0) * o8;
  for (let p2 = 0; p2 < u4; ++p2)
    f9[s5] = d5[c7], f9[s5 + 1] = d5[c7 + 1], s5 += n7, c7 += o8;
}
function n4(n7, d5, o8) {
  const u4 = n7.typedBuffer, s5 = n7.typedBufferStride, c7 = d5.typedBuffer, p2 = d5.typedBufferStride, l3 = o8 ? o8.count : d5.count;
  let y = (o8 && o8.dstIndex ? o8.dstIndex : 0) * s5, i5 = (o8 && o8.srcIndex ? o8.srcIndex : 0) * p2;
  if (s3(d5.elementType)) {
    const e10 = r3(d5.elementType);
    if (c3(d5.elementType))
      for (let t11 = 0; t11 < l3; ++t11)
        u4[y] = Math.max(c7[i5] / e10, -1), u4[y + 1] = Math.max(c7[i5 + 1] / e10, -1), y += s5, i5 += p2;
    else
      for (let t11 = 0; t11 < l3; ++t11)
        u4[y] = c7[i5] / e10, u4[y + 1] = c7[i5 + 1] / e10, y += s5, i5 += p2;
  } else
    f4(n7, d5, o8);
  return n7;
}
function d3(e10, t11, r12, f9) {
  const n7 = e10.typedBuffer, d5 = e10.typedBufferStride, o8 = (f9 == null ? void 0 : f9.count) ?? e10.count;
  let u4 = ((f9 == null ? void 0 : f9.dstIndex) ?? 0) * d5;
  for (let s5 = 0; s5 < o8; ++s5)
    n7[u4] = t11, n7[u4 + 1] = r12, u4 += d5;
}
var o5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: f4, fill: d3, normalizeIntegerBuffer: n4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e6(e10, t11, f9) {
  const d5 = e10.typedBuffer, n7 = e10.typedBufferStride, o8 = t11.typedBuffer, r12 = t11.typedBufferStride, c7 = f9 ? f9.count : t11.count;
  let u4 = (f9 && f9.dstIndex ? f9.dstIndex : 0) * n7, l3 = (f9 && f9.srcIndex ? f9.srcIndex : 0) * r12;
  for (let s5 = 0; s5 < c7; ++s5)
    d5[u4] = o8[l3], d5[u4 + 1] = o8[l3 + 1], d5[u4 + 2] = o8[l3 + 2], d5[u4 + 3] = o8[l3 + 3], u4 += n7, l3 += r12;
}
function t5(e10, t11, f9, d5, n7, o8) {
  const r12 = e10.typedBuffer, c7 = e10.typedBufferStride, u4 = (o8 == null ? void 0 : o8.count) ?? e10.count;
  let l3 = ((o8 == null ? void 0 : o8.dstIndex) ?? 0) * c7;
  for (let s5 = 0; s5 < u4; ++s5)
    r12[l3] = t11, r12[l3 + 1] = f9, r12[l3 + 2] = d5, r12[l3 + 3] = n7, l3 += c7;
}
var f5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6, fill: t5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat32.js
function e7(e10, t11, r12) {
  const o8 = e10.typedBuffer, d5 = e10.typedBufferStride, f9 = t11.typedBuffer, n7 = t11.typedBufferStride, c7 = r12 ? r12.count : t11.count;
  let u4 = (r12 && r12.dstIndex ? r12.dstIndex : 0) * d5, l3 = (r12 && r12.srcIndex ? r12.srcIndex : 0) * n7;
  for (let p2 = 0; p2 < c7; ++p2) {
    for (let e11 = 0; e11 < 9; ++e11)
      o8[u4 + e11] = f9[l3 + e11];
    u4 += d5, l3 += n7;
  }
}
var t6 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e7 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat42.js
function e8(e10, t11, r12) {
  const o8 = e10.typedBuffer, d5 = e10.typedBufferStride, f9 = t11.typedBuffer, n7 = t11.typedBufferStride, c7 = r12 ? r12.count : t11.count;
  let u4 = (r12 && r12.dstIndex ? r12.dstIndex : 0) * d5, l3 = (r12 && r12.srcIndex ? r12.srcIndex : 0) * n7;
  for (let p2 = 0; p2 < c7; ++p2) {
    for (let e11 = 0; e11 < 16; ++e11)
      o8[u4 + e11] = f9[l3 + e11];
    u4 += d5, l3 += n7;
  }
}
var t7 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e8 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/scalar.js
function e9(e10, t11, r12) {
  const n7 = e10.typedBuffer, o8 = e10.typedBufferStride, c7 = t11.typedBuffer, d5 = t11.typedBufferStride, f9 = r12 ? r12.count : t11.count;
  let u4 = (r12 && r12.dstIndex ? r12.dstIndex : 0) * o8, s5 = (r12 && r12.srcIndex ? r12.srcIndex : 0) * d5;
  for (let p2 = 0; p2 < f9; ++p2)
    n7[u4] = c7[s5], u4 += o8, s5 += d5;
}
function t8(e10, t11) {
  const r12 = e10.count;
  t11 || (t11 = new e10.TypedArrayConstructor(r12));
  for (let n7 = 0; n7 < r12; n7++)
    t11[n7] = e10.get(n7);
  return t11;
}
var r8 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e9, makeDense: t8 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r9(s5, r12) {
  return new s5(new ArrayBuffer(r12 * s5.ElementCount * e2(s5.ElementType)));
}

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n5 = class {
  constructor(r12) {
    this._streamDataRequester = r12;
  }
  async loadJSON(r12, e10) {
    return this._load("json", r12, e10);
  }
  async loadBinary(r12, e10) {
    return tt(r12) ? (f(e10), nt(r12)) : this._load("binary", r12, e10);
  }
  async loadImage(r12, e10) {
    return this._load("image", r12, e10);
  }
  async _load(t11, i5, m2) {
    if (t(this._streamDataRequester))
      return (await U(i5, { responseType: c4[t11] })).data;
    const n7 = await b(this._streamDataRequester.request(i5, t11, m2));
    if (true === n7.ok)
      return n7.value;
    throw w(n7.error), new s2("", `Request for resource failed: ${n7.error}`);
  }
};
var c4 = { image: "image", binary: "array-buffer", json: "json" };

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function r10(e10 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e10 };
}
function l(r12, l3 = {}) {
  return { data: r12, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l3.wrap }, noUnpackFlip: true, mipmap: false, ...l3 } };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t9 = class {
  constructor(t11) {
    this._data = t11, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t11 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t11];
  }
  readUint8Array(t11) {
    const s5 = 4 * this._offset4;
    return this._offset4 += t11 / 4, new Uint8Array(this._data, s5, t11);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t10 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a = { pbrMetallicRoughness: t10, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l2 = { ESRI_externalColorMixMode: "tint" };
var i3 = (e10 = {}) => {
  const o8 = { ...t10, ...e10.pbrMetallicRoughness }, r12 = s4({ ...l2, ...e10.extras });
  return { ...a, ...e10, pbrMetallicRoughness: o8, extras: r12 };
};
function s4(o8) {
  switch (o8.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o8.ESRI_externalColorMixMode), o8.ESRI_externalColorMixMode = "tint";
  }
  return o8;
}
var n6 = { magFilter: L3.LINEAR, minFilter: L3.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var c5 = (e10) => ({ ...n6, ...e10 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r11(r12) {
  let e10, t11;
  return r12.replace(/^(.*\/)?([^/]*)$/, (r13, a2, i5) => (e10 = a2 || "", t11 = i5 || "", "")), { dirPart: e10, filePart: t11 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var K = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var Y = class {
  constructor(t11, r12, o8, n7) {
    if (this._context = t11, this.uri = r12, this.json = o8, this._glbBuffer = n7, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._supportedExtensions = ["KHR_texture_basisu"], this._baseUri = r11(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), null == o8.scenes)
      throw new s2("gltf-loader-unsupported-feature", "Scenes must be defined.");
    if (null == o8.meshes)
      throw new s2("gltf-loader-unsupported-feature", "Meshes must be defined");
    if (null == o8.nodes)
      throw new s2("gltf-loader-unsupported-feature", "Nodes must be defined.");
    this._computeNodeParents();
  }
  static async load(e10, t11, r12) {
    if (tt(t11)) {
      const r13 = ot(t11);
      if (r13 && "model/gltf-binary" !== r13.mediaType)
        try {
          const o10 = JSON.parse(r13.isBase64 ? atob(r13.data) : r13.data);
          return new Y(e10, t11, o10);
        } catch {
        }
      const o9 = nt(t11);
      if (Y._isGLBData(o9))
        return this._fromGLBData(e10, t11, o9);
    }
    if (t11.endsWith(".gltf")) {
      const o9 = await e10.loadJSON(t11, r12);
      return new Y(e10, t11, o9);
    }
    const o8 = await e10.loadBinary(t11, r12);
    if (Y._isGLBData(o8))
      return this._fromGLBData(e10, t11, o8);
    const i5 = await e10.loadJSON(t11, r12);
    return new Y(e10, t11, i5);
  }
  static _isGLBData(e10) {
    if (null == e10)
      return false;
    const t11 = new t9(e10);
    return t11.remainingBytes() >= 4 && t11.readUint32() === K.MAGIC;
  }
  static async _fromGLBData(e10, t11, r12) {
    const o8 = await Y._parseGLBData(r12);
    return new Y(e10, t11, o8.json, o8.binaryData);
  }
  static async _parseGLBData(r12) {
    const o8 = new t9(r12);
    if (o8.remainingBytes() < 12)
      throw new s2("gltf-loader-error", "GLB binary data is insufficiently large.");
    const n7 = o8.readUint32(), s5 = o8.readUint32(), a2 = o8.readUint32();
    if (n7 !== K.MAGIC)
      throw new s2("gltf-loader-error", "Magic first 4 bytes do not fit to expected GLB value.");
    if (r12.byteLength < a2)
      throw new s2("gltf-loader-error", "GLB binary data is smaller than header specifies.");
    if (2 !== s5)
      throw new s2("gltf-loader-unsupported-feature", "An unsupported GLB container version was detected. Only version 2 is supported.");
    let i5, u4, f9 = 0;
    for (; o8.remainingBytes() >= 8; ) {
      const r13 = o8.readUint32(), n8 = o8.readUint32();
      if (0 === f9) {
        if (n8 !== K.CHUNK_TYPE_JSON)
          throw new s2("gltf-loader-error", "First GLB chunk must be JSON.");
        if (r13 < 0)
          throw new s2("gltf-loader-error", "No JSON data found.");
        i5 = await r6(o8.readUint8Array(r13));
      } else if (1 === f9) {
        if (n8 !== K.CHUNK_TYPE_BIN)
          throw new s2("gltf-loader-unsupported-feature", "Second GLB chunk expected to be BIN.");
        u4 = o8.readUint8Array(r13);
      } else
        s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 GLB chunks detected. Skipping.");
      f9 += 1;
    }
    if (!i5)
      throw new s2("gltf-loader-error", "No GLB JSON chunk detected.");
    return { json: i5, binaryData: u4 };
  }
  async getBuffer(t11, r12) {
    const o8 = this.json.buffers[t11];
    if (null == o8.uri) {
      if (null == this._glbBuffer)
        throw new s2("gltf-loader-error", "GLB buffer not present");
      return this._glbBuffer;
    }
    const n7 = await this._getBufferLoader(t11, r12);
    if (n7.byteLength !== o8.byteLength)
      throw new s2("gltf-loader-error", "Buffer byte lengths should match.");
    return n7;
  }
  async _getBufferLoader(e10, t11) {
    const r12 = this._bufferLoaders.get(e10);
    if (r12)
      return r12;
    const o8 = this.json.buffers[e10].uri, n7 = this._context.loadBinary(this._resolveUri(o8), t11).then((e11) => new Uint8Array(e11));
    return this._bufferLoaders.set(e10, n7), n7;
  }
  async getAccessor(t11, r12) {
    if (!this.json.accessors)
      throw new s2("gltf-loader-unsupported-feature", "Accessors missing.");
    const o8 = this.json.accessors[t11];
    if (null == (o8 == null ? void 0 : o8.bufferView))
      throw new s2("gltf-loader-unsupported-feature", "Some accessor does not specify a bufferView.");
    if (o8.type in [A2.MAT2, A2.MAT3, A2.MAT4])
      throw new s2("gltf-loader-unsupported-feature", `AttributeType ${o8.type} is not supported`);
    const n7 = this.json.bufferViews[o8.bufferView], s5 = await this.getBuffer(n7.buffer, r12), a2 = X[o8.type], i5 = W[o8.componentType], u4 = a2 * i5, f9 = n7.byteStride || u4;
    return { raw: s5.buffer, byteStride: f9, byteOffset: s5.byteOffset + (n7.byteOffset || 0) + (o8.byteOffset || 0), entryCount: o8.count, isDenselyPacked: f9 === u4, componentCount: a2, componentByteSize: i5, componentType: o8.componentType, min: o8.min, max: o8.max, normalized: !!o8.normalized };
  }
  async getIndexData(e10, t11) {
    if (null == e10.indices)
      return;
    const r12 = await this.getAccessor(e10.indices, t11);
    if (r12.isDenselyPacked)
      switch (r12.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r12.raw, r12.byteOffset, r12.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r12.raw, r12.byteOffset, r12.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r12.raw, r12.byteOffset, r12.entryCount);
      }
    else
      switch (r12.componentType) {
        case C.UNSIGNED_BYTE:
          return t8(this._wrapAccessor(d2, r12));
        case C.UNSIGNED_SHORT:
          return t8(this._wrapAccessor(g, r12));
        case C.UNSIGNED_INT:
          return t8(this._wrapAccessor(B, r12));
      }
  }
  async getPositionData(t11, r12) {
    if (null == t11.attributes.POSITION)
      throw new s2("gltf-loader-unsupported-feature", "No POSITION vertex data found.");
    const o8 = await this.getAccessor(t11.attributes.POSITION, r12);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for POSITION vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "POSITION vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getNormalData(t11, r12) {
    if (null == t11.attributes.NORMAL)
      throw new s2("gltf-loader-error", "No NORMAL vertex data found.");
    const o8 = await this.getAccessor(t11.attributes.NORMAL, r12);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for NORMAL vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "NORMAL vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getTangentData(t11, r12) {
    if (null == t11.attributes.TANGENT)
      throw new s2("gltf-loader-error", "No TANGENT vertex data found.");
    const o8 = await this.getAccessor(t11.attributes.TANGENT, r12);
    if (o8.componentType !== C.FLOAT)
      throw new s2("gltf-loader-unsupported-feature", "Expected type FLOAT for TANGENT vertex attribute, but found " + C[o8.componentType]);
    if (4 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "TANGENT vertex attribute must have 4 components, but found " + o8.componentCount.toFixed());
    return new c2(o8.raw, o8.byteOffset, o8.byteStride, o8.byteOffset + o8.byteStride * o8.entryCount);
  }
  async getTextureCoordinates(t11, r12) {
    if (null == t11.attributes.TEXCOORD_0)
      throw new s2("gltf-loader-error", "No TEXCOORD_0 vertex data found.");
    const o8 = await this.getAccessor(t11.attributes.TEXCOORD_0, r12);
    if (2 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "TEXCOORD_0 vertex attribute must have 2 components, but found " + o8.componentCount.toFixed());
    if (o8.componentType === C.FLOAT)
      return this._wrapAccessor(u, o8);
    if (!o8.normalized)
      throw new s2("gltf-loader-unsupported-feature", "Integer component types are only supported for a normalized accessor for TEXCOORD_0.");
    return $(o8);
  }
  async getVertexColors(t11, r12) {
    if (null == t11.attributes.COLOR_0)
      throw new s2("gltf-loader-error", "No COLOR_0 vertex data found.");
    const o8 = await this.getAccessor(t11.attributes.COLOR_0, r12);
    if (4 !== o8.componentCount && 3 !== o8.componentCount)
      throw new s2("gltf-loader-unsupported-feature", "COLOR_0 attribute must have 3 or 4 components, but found " + o8.componentCount.toFixed());
    if (4 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(c2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(x, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(L2, o8);
    } else if (3 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(i2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(O, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(E, o8);
    }
    throw new s2("gltf-loader-unsupported-feature", "Unsupported component type for COLOR_0 attribute: " + C[o8.componentType]);
  }
  hasPositions(e10) {
    return void 0 !== e10.attributes.POSITION;
  }
  hasNormals(e10) {
    return void 0 !== e10.attributes.NORMAL;
  }
  hasVertexColors(e10) {
    return void 0 !== e10.attributes.COLOR_0;
  }
  hasTextureCoordinates(e10) {
    return void 0 !== e10.attributes.TEXCOORD_0;
  }
  hasTangents(e10) {
    return void 0 !== e10.attributes.TANGENT;
  }
  async getMaterial(e10, t11, r12) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let o8 = e10.material ? this._materialCache.get(e10.material) : void 0;
    if (!o8) {
      const n7 = null != e10.material ? i3(this.json.materials[e10.material]) : i3(), s5 = n7.pbrMetallicRoughness, a2 = this.hasVertexColors(e10), i5 = this.getTexture(s5.baseColorTexture, t11), u4 = this.getTexture(n7.normalTexture, t11), f9 = r12 ? this.getTexture(n7.occlusionTexture, t11) : void 0, c7 = r12 ? this.getTexture(n7.emissiveTexture, t11) : void 0, d5 = r12 ? this.getTexture(s5.metallicRoughnessTexture, t11) : void 0, l3 = null != e10.material ? e10.material : -1;
      o8 = { alphaMode: n7.alphaMode, alphaCutoff: n7.alphaCutoff, color: s5.baseColorFactor, doubleSided: !!n7.doubleSided, colorTexture: await i5, normalTexture: await u4, name: n7.name, id: l3, occlusionTexture: await f9, emissiveTexture: await c7, emissiveFactor: n7.emissiveFactor, metallicFactor: s5.metallicFactor, roughnessFactor: s5.roughnessFactor, metallicRoughnessTexture: await d5, hasVertexColors: a2, ESRI_externalColorMixMode: n7.extras.ESRI_externalColorMixMode, colorTextureTransform: (_b = (_a = s5 == null ? void 0 : s5.baseColorTexture) == null ? void 0 : _a.extensions) == null ? void 0 : _b.KHR_texture_transform, normalTextureTransform: (_d = (_c = n7.normalTexture) == null ? void 0 : _c.extensions) == null ? void 0 : _d.KHR_texture_transform, occlusionTextureTransform: (_f = (_e = n7.occlusionTexture) == null ? void 0 : _e.extensions) == null ? void 0 : _f.KHR_texture_transform, emissiveTextureTransform: (_h = (_g = n7.emissiveTexture) == null ? void 0 : _g.extensions) == null ? void 0 : _h.KHR_texture_transform, metallicRoughnessTextureTransform: (_j = (_i = s5 == null ? void 0 : s5.metallicRoughnessTexture) == null ? void 0 : _i.extensions) == null ? void 0 : _j.KHR_texture_transform };
    }
    return o8;
  }
  async getTexture(t11, o8) {
    if (!t11)
      return;
    if (0 !== (t11.texCoord || 0))
      throw new s2("gltf-loader-unsupported-feature", "Only TEXCOORD with index 0 is supported.");
    const n7 = t11.index, s5 = this.json.textures[n7], a2 = c5(null != s5.sampler ? this.json.samplers[s5.sampler] : {}), i5 = this._getTextureSourceId(s5), u4 = this.json.images[i5], f9 = await this._loadTextureImageData(n7, s5, o8);
    return r2(this._textureCache, n7, () => {
      const t12 = (e10) => 33071 === e10 || 33648 === e10 || 10497 === e10, r12 = (t13) => {
        throw new s2("gltf-loader-error", `Unexpected TextureSampler WrapMode: ${t13}`);
      };
      return { data: f9, wrapS: t12(a2.wrapS) ? a2.wrapS : r12(a2.wrapS), wrapT: t12(a2.wrapT) ? a2.wrapT : r12(a2.wrapT), minFilter: a2.minFilter, name: u4.name, id: n7 };
    });
  }
  getNodeTransform(e10) {
    if (void 0 === e10)
      return q2;
    let t11 = this._nodeTransformCache.get(e10);
    if (!t11) {
      const r12 = this.getNodeTransform(this._getNodeParent(e10)), o8 = this.json.nodes[e10];
      o8.matrix ? t11 = c(e3(), r12, o8.matrix) : o8.translation || o8.rotation || o8.scale ? (t11 = r4(r12), o8.translation && i(t11, t11, o8.translation), o8.rotation && (z[3] = x2(z, o8.rotation), b2(t11, t11, z[3], z)), o8.scale && f2(t11, t11, o8.scale)) : t11 = r4(r12), this._nodeTransformCache.set(e10, t11);
    }
    return t11;
  }
  _wrapAccessor(e10, t11) {
    return new e10(t11.raw, t11.byteOffset, t11.byteStride, t11.byteOffset + t11.byteStride * (t11.entryCount - 1) + t11.componentByteSize * t11.componentCount);
  }
  _resolveUri(e10) {
    return F(e10, this._baseUri);
  }
  _getNodeParent(e10) {
    return this._nodeParentMap.get(e10);
  }
  _checkVersionSupported() {
    const e10 = r5.parse(this.json.asset.version, "glTF");
    J.validate(e10);
  }
  _checkRequiredExtensionsSupported() {
    const t11 = this.json;
    if (t11.extensionsRequired) {
      if (!t11.extensionsRequired.every((e10) => this._supportedExtensions.includes(e10)))
        throw new s2("gltf-loader-unsupported-feature", "gltf loader was not able to load unsupported feature. Required extensions: " + t11.extensionsRequired.join(", "));
    }
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e10, t11) => {
      e10.children && e10.children.forEach((e11) => {
        this._nodeParentMap.set(e11, t11);
      });
    });
  }
  async _loadTextureImageData(e10, t11, r12) {
    const o8 = this._textureLoaders.get(e10);
    if (o8)
      return o8;
    const n7 = this._createTextureLoader(t11, r12);
    return this._textureLoaders.set(e10, n7), n7;
  }
  _getTextureSourceId(t11) {
    if (void 0 !== t11.extensions && null !== t11.extensions.KHR_texture_basisu)
      return t11.extensions.KHR_texture_basisu.source;
    if (null !== t11.source)
      return t11.source;
    throw new s2("gltf-loader-unsupported-feature", "Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");
  }
  async _createTextureLoader(t11, r12) {
    const o8 = this._getTextureSourceId(t11), n7 = this.json.images[o8];
    if (n7.uri) {
      if (n7.uri.endsWith(".ktx2")) {
        const e10 = await this._context.loadBinary(this._resolveUri(n7.uri), r12);
        return new n2(new Uint8Array(e10));
      }
      return this._context.loadImage(this._resolveUri(n7.uri), r12);
    }
    if (null == n7.bufferView)
      throw new s2("gltf-loader-unsupported-feature", "Image bufferView must be defined.");
    if (null == n7.mimeType)
      throw new s2("gltf-loader-unsupported-feature", "Image mimeType must be defined.");
    const s5 = this.json.bufferViews[n7.bufferView], a2 = await this.getBuffer(s5.buffer, r12);
    if (null != s5.byteStride)
      throw new s2("gltf-loader-unsupported-feature", "byteStride not supported for image buffer");
    const i5 = a2.byteOffset + (s5.byteOffset || 0);
    return o3(new Uint8Array(a2.buffer, i5, s5.byteLength), n7.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer)
      return this._glbBuffer.byteLength;
    const e10 = await L(Array.from(this._bufferLoaders.values())), t11 = await L(Array.from(this._textureLoaders.values()));
    return e10.reduce((e11, t12) => e11 + ((t12 == null ? void 0 : t12.byteLength) ?? 0), 0) + t11.reduce((e11, t12) => e11 + (t12 ? t3(t12) ? t12.data.byteLength : t12.width * t12.height * 4 : 0), 0);
  }
};
var q2 = d(e3(), Math.PI / 2);
var J = new r5(2, 0, "glTF");
var z = e4();
var X = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4 };
var W = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.UNSIGNED_INT]: 4 };
function $(e10) {
  switch (e10.componentType) {
    case C.BYTE:
      return new V(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.SHORT:
      return new q(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_SHORT:
      return new w2(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.UNSIGNED_INT:
      return new F2(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
    case C.FLOAT:
      return new u(e10.raw, e10.byteOffset, e10.byteStride, e10.byteOffset + e10.byteStride * e10.entryCount);
  }
}

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var u3 = 0;
async function m(s5, a2, i5 = {}, m2 = true) {
  const p2 = await Y.load(s5, a2, i5), f9 = "gltf_" + u3++, x3 = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: c6(p2) }, g2 = !(!p2.json.asset.extras || "symbolResource" !== p2.json.asset.extras.ESRI_type), h = /* @__PURE__ */ new Map();
  await d4(p2, async (s6, a3, n7, u4) => {
    const c7 = h.get(n7) ?? 0;
    h.set(n7, c7 + 1);
    const d5 = void 0 !== s6.mode ? s6.mode : E2.TRIANGLES, g3 = d5 === E2.TRIANGLES || d5 === E2.TRIANGLE_STRIP || d5 === E2.TRIANGLE_FAN ? d5 : null;
    if (t(g3))
      return void s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode (" + E2[d5] + "). Skipping primitive.");
    if (!p2.hasPositions(s6))
      return void s.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");
    const v2 = p2.getPositionData(s6, i5), w3 = p2.getMaterial(s6, i5, m2), R = p2.hasNormals(s6) ? p2.getNormalData(s6, i5) : null, S = p2.hasTangents(s6) ? p2.getTangentData(s6, i5) : null, _ = p2.hasTextureCoordinates(s6) ? p2.getTextureCoordinates(s6, i5) : null, E4 = p2.hasVertexColors(s6) ? p2.getVertexColors(s6, i5) : null, I = p2.getIndexData(s6, i5), M = { transform: r4(a3), attributes: { position: await v2, normal: R ? await R : null, texCoord0: _ ? await _ : null, color: E4 ? await E4 : null, tangent: S ? await S : null }, indices: await I, primitiveType: g3, material: T(x3, await w3, f9) };
    let F3 = null;
    r(x3.meta) && r(x3.meta.ESRI_lod) && "screenSpaceRadius" === x3.meta.ESRI_lod.metric && (F3 = x3.meta.ESRI_lod.thresholds[n7]), x3.lods[n7] = x3.lods[n7] || { parts: [], name: u4, lodThreshold: F3 }, x3.lods[n7].parts[c7] = M;
  });
  for (const e10 of x3.lods)
    e10.parts = e10.parts.filter((e11) => !!e11);
  const v = await p2.getLoadedBuffersSize();
  return { model: x3, meta: { isEsriSymbolResource: g2, uri: p2.uri }, customMeta: {}, size: v };
}
function c6(e10) {
  const t11 = e10.json;
  let r12 = null;
  return t11.nodes.forEach((e11) => {
    const t12 = e11.extras;
    r(t12) && (t12.ESRI_proxyEllipsoid || t12.ESRI_lod) && (r12 = t12);
  }), r12;
}
async function d4(o8, t11) {
  const r12 = o8.json, s5 = r12.scenes[r12.scene || 0].nodes, a2 = s5.length > 1, n7 = [];
  for (const e10 of s5) {
    const o9 = r12.nodes[e10];
    if (n7.push(i5(e10, 0)), p(o9) && !a2) {
      o9.extensions.MSFT_lod.ids.forEach((e11, o10) => i5(e11, o10 + 1));
    }
  }
  async function i5(s6, a3) {
    const l3 = r12.nodes[s6], u4 = o8.getNodeTransform(s6);
    if (null != l3.weights && s.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."), null != l3.mesh) {
      const e10 = r12.meshes[l3.mesh];
      for (const o9 of e10.primitives)
        n7.push(t11(o9, u4, a3, e10.name));
    }
    for (const e10 of l3.children || [])
      n7.push(i5(e10, a3));
  }
  await Promise.all(n7);
}
function p(e10) {
  return e10.extensions && e10.extensions.MSFT_lod && Array.isArray(e10.extensions.MSFT_lod.ids);
}
function T(e10, o8, t11) {
  const r12 = (o9) => {
    const r13 = `${t11}_tex_${o9 && o9.id}${o9 && o9.name ? "_" + o9.name : ""}`;
    if (o9 && !e10.textures.has(r13)) {
      const t12 = l(o9.data, { wrap: { s: o9.wrapS, t: o9.wrapT }, mipmap: f7.includes(o9.minFilter), noUnpackFlip: true });
      e10.textures.set(r13, t12);
    }
    return r13;
  }, n7 = `${t11}_mat_${o8.id}_${o8.name}`;
  if (!e10.materials.has(n7)) {
    const t12 = r10({ color: [o8.color[0], o8.color[1], o8.color[2]], opacity: o8.color[3], alphaMode: o8.alphaMode, alphaCutoff: o8.alphaCutoff, doubleSided: o8.doubleSided, colorMixMode: o8.ESRI_externalColorMixMode, textureColor: o8.colorTexture ? r12(o8.colorTexture) : void 0, textureNormal: o8.normalTexture ? r12(o8.normalTexture) : void 0, textureOcclusion: o8.occlusionTexture ? r12(o8.occlusionTexture) : void 0, textureEmissive: o8.emissiveTexture ? r12(o8.emissiveTexture) : void 0, textureMetallicRoughness: o8.metallicRoughnessTexture ? r12(o8.metallicRoughnessTexture) : void 0, emissiveFactor: [o8.emissiveFactor[0], o8.emissiveFactor[1], o8.emissiveFactor[2]], colorTextureTransform: o8.colorTextureTransform, normalTextureTransform: o8.normalTextureTransform, occlusionTextureTransform: o8.occlusionTextureTransform, emissiveTextureTransform: o8.emissiveTextureTransform, metallicRoughnessTextureTransform: o8.metallicRoughnessTextureTransform, metallicFactor: o8.metallicFactor, roughnessFactor: o8.roughnessFactor });
    e10.materials.set(n7, t12);
  }
  return n7;
}
var f7 = [L3.LINEAR_MIPMAP_LINEAR, L3.LINEAR_MIPMAP_NEAREST];

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function o6(r12, o8 = o2) {
  return "number" == typeof r12 ? o8(r12) : e(r12) || o(r12) ? new Uint32Array(r12) : r12;
}
function f8(e10) {
  const t11 = "number" == typeof e10 ? e10 : e10.length;
  if (t11 < 3)
    return [];
  const n7 = t11 - 2, o8 = t2(n7);
  if ("number" == typeof e10) {
    let e11 = 0;
    for (let t12 = 0; t12 < n7; t12 += 1)
      t12 % 2 == 0 ? (o8[e11++] = t12, o8[e11++] = t12 + 1, o8[e11++] = t12 + 2) : (o8[e11++] = t12 + 1, o8[e11++] = t12, o8[e11++] = t12 + 2);
  } else {
    let t12 = 0;
    for (let r12 = 0; r12 < n7; r12 += 1)
      if (r12 % 2 == 0) {
        const n8 = e10[r12], f9 = e10[r12 + 1], i5 = e10[r12 + 2];
        o8[t12++] = n8, o8[t12++] = f9, o8[t12++] = i5;
      } else {
        const n8 = e10[r12 + 1], f9 = e10[r12], i5 = e10[r12 + 2];
        o8[t12++] = n8, o8[t12++] = f9, o8[t12++] = i5;
      }
  }
  return o8;
}
function i4(e10) {
  const t11 = "number" == typeof e10 ? e10 : e10.length;
  if (t11 < 3)
    return new Uint16Array(0);
  const n7 = t11 - 2, r12 = n7 <= 65536 ? new Uint16Array(3 * n7) : new Uint32Array(3 * n7);
  if ("number" == typeof e10) {
    let e11 = 0;
    for (let t12 = 0; t12 < n7; ++t12)
      r12[e11++] = 0, r12[e11++] = t12 + 1, r12[e11++] = t12 + 2;
    return r12;
  }
  {
    const t12 = e10[0];
    let o8 = e10[1], f9 = 0;
    for (let i5 = 0; i5 < n7; ++i5) {
      const n8 = e10[i5 + 2];
      r12[f9++] = t12, r12[f9++] = o8, r12[f9++] = n8, o8 = n8;
    }
    return r12;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o7 = 2.1;

export {
  r7 as r,
  f3 as f,
  o4 as o,
  n3 as n,
  n4 as n2,
  d3 as d,
  e6 as e,
  t5 as t,
  r9 as r2,
  n5 as n3,
  m,
  o6 as o2,
  f8 as f2,
  i4 as i,
  o7 as o3
};
//# sourceMappingURL=chunk-YJKQSVO6.js.map

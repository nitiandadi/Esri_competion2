import {
  i as i2
} from "./chunk-X2II7CAR.js";
import {
  I
} from "./chunk-G3IR6EOM.js";
import {
  e as e4
} from "./chunk-6CHYNNZQ.js";
import {
  h as h3
} from "./chunk-OFMRQG54.js";
import {
  f as f3,
  u as u2
} from "./chunk-2PEMPHHT.js";
import {
  a as a4
} from "./chunk-BLQJFVYJ.js";
import {
  d as d2,
  s as s3
} from "./chunk-7OXAXJPF.js";
import {
  S
} from "./chunk-RRNRSHX3.js";
import {
  o as o3
} from "./chunk-75NMPQ6B.js";
import {
  l as l2
} from "./chunk-KYJD6PVR.js";
import {
  l as l3
} from "./chunk-D2UI2BQN.js";
import {
  l as l4
} from "./chunk-U3IHIDSP.js";
import {
  e as e3
} from "./chunk-34FJTA26.js";
import {
  w as w3,
  y as y2
} from "./chunk-QEAHRYXT.js";
import {
  b as b3,
  d,
  f as f2,
  g as g3,
  m
} from "./chunk-KIR65PYA.js";
import {
  u
} from "./chunk-BXCDE7OD.js";
import {
  x as x3
} from "./chunk-G356VNM2.js";
import {
  b as b2
} from "./chunk-RPT2LTMJ.js";
import {
  x as x2
} from "./chunk-IFB6JAZV.js";
import {
  g as g2
} from "./chunk-2OJTWNQ6.js";
import {
  v as v2
} from "./chunk-GEQPBGLO.js";
import {
  a as a3,
  h,
  j as j3,
  l,
  w as w2
} from "./chunk-2UAIGHM2.js";
import {
  _
} from "./chunk-6CVKQGVU.js";
import {
  D as D2,
  O,
  T,
  W,
  h as h2,
  j as j4,
  v as v3,
  w as w4,
  xe,
  z
} from "./chunk-4D6JGHEF.js";
import {
  i
} from "./chunk-CT6YILLI.js";
import {
  j as j2
} from "./chunk-LJAKPJDJ.js";
import {
  f2 as f,
  w2 as w
} from "./chunk-XFNXUG2G.js";
import {
  o as o2
} from "./chunk-M4BAPJ3L.js";
import {
  a2,
  e as e2,
  v2 as v,
  y3 as y
} from "./chunk-3PPVODAA.js";
import {
  D,
  E,
  b,
  g,
  j,
  x
} from "./chunk-WTKFW2TD.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  has,
  p as p2
} from "./chunk-PR6SXADK.js";
import {
  a,
  e,
  o,
  p,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p3 = class extends g2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e6 = false) {
    if (this.popupTemplate)
      return this.popupTemplate;
    const r3 = this.sourceLayer && this.sourceLayer.featureReduction;
    return r3 && "popupTemplate" in r3 && r3.popupEnabled ? r3.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
e2([y({ type: Boolean })], p3.prototype, "isAggregate", void 0), p3 = e2([a2("esri.AggregateGraphic")], p3);
var s4 = p3;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var r2 = class extends v {
  constructor(e6) {
    super(e6), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a4(e6), this._includedEffectView = new a4(e6);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e6) {
    this._get("featureEffect") !== e6 && this._transitionTo(e6);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = e(this.featureEffect)) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e6) {
    this._set("scale", e6), this._excludedEffectView.scale = e6, this._includedEffectView.scale = e6;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e6, t2) {
    this._set("scale", t2), this.transitioning ? (this._includedEffectView.transitionStep(e6, t2), this._excludedEffectView.transitionStep(e6, t2), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t2, this._includedEffectView.scale = t2);
  }
  endTransitions() {
    this._includedEffectView.endTransitions(), this._excludedEffectView.endTransitions(), this._filter = null;
  }
  _transitionTo(e6) {
    const t2 = this._get("featureEffect"), s6 = e(e6), f4 = e(s6 == null ? void 0 : s6.includedEffect), c3 = e(s6 == null ? void 0 : s6.excludedEffect), r3 = this._includedEffectView.canTransitionTo(f4) && this._excludedEffectView.canTransitionTo(c3);
    this._includedEffectView.effect = f4, this._excludedEffectView.effect = c3, this._set("featureEffect", s6), this._filter = (s6 == null ? void 0 : s6.filter) || (t2 == null ? void 0 : t2.filter) || null, r3 || this.endTransitions();
  }
};
e2([y()], r2.prototype, "_filter", void 0), e2([y()], r2.prototype, "_excludedEffectView", void 0), e2([y()], r2.prototype, "_includedEffectView", void 0), e2([y()], r2.prototype, "duration", void 0), e2([y()], r2.prototype, "excludedEffects", null), e2([y()], r2.prototype, "featureEffect", null), e2([y()], r2.prototype, "filter", null), e2([y()], r2.prototype, "hasEffects", null), e2([y()], r2.prototype, "includedEffects", null), e2([y({ value: 0 })], r2.prototype, "scale", null), e2([y()], r2.prototype, "transitioning", null), r2 = e2([a2("esri.layers.effects.FeatureEffectView")], r2);
var o4 = r2;

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var m2 = class extends x3 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e6, o5) {
    var _a;
    const s6 = f.fromJSON(o5.spatialReference), a6 = [];
    for (let p5 = 0; p5 < e6.length; p5++) {
      const o6 = e6[p5], c3 = s4.fromJSON(o6), m3 = o6.geometry && o6.geometry.spatialReference;
      r(c3.geometry) && !m3 && (c3.geometry.spatialReference = s6);
      const i5 = o6.aggregateGeometries, f4 = c3.aggregateGeometries;
      if (i5 && r(f4))
        for (const e7 in f4) {
          const r3 = f4[e7], o7 = (_a = i5[e7]) == null ? void 0 : _a.spatialReference;
          r(r3) && !o7 && (r3.spatialReference = s6);
        }
      a6.push(c3);
    }
    return a6;
  }
};
e2([y({ type: [s4], json: { write: true } })], m2.prototype, "features", void 0), e2([o2("features")], m2.prototype, "readFeatures", null), m2 = e2([a2("esri.rest.support.AggregateFeatureSet")], m2);
var i3 = m2;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers.js
async function e5(e6, r3) {
  if (!e6)
    return null;
  switch (e6.type) {
    case "symbol":
      return new (await import("./SymbolTileRenderer-5YEMCJS7.js")).default(r3);
    case "heatmap":
      return new (await import("./HeatmapTileRenderer-QVGCV7Y5.js")).default(r3);
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
function i4(e6) {
  return e6.some((e7) => e7.globalId);
}
function n(e6) {
  return e6.filter((e7) => !e7.error).map((e7) => e7.objectId ?? e7.globalId).filter((e7) => null != e7);
}
function d3(e6, t2) {
  const s6 = new Set(e6);
  for (const r3 of t2.values())
    s6.add(r3);
  return s6;
}
function a5(e6, t2) {
  const s6 = new Set(e6);
  for (const r3 of t2.values())
    s6.delete(r3);
  return s6;
}
var c = class extends v {
  constructor(e6) {
    super(e6), this._hasGlobalIds = false, this._notifyUpdating = () => {
      this.notifyChange("updating");
    };
  }
  normalizeCtorArgs(e6) {
    return this._queueProcessor = new l2({ concurrency: 1, process: e6.process }), {};
  }
  destroy() {
    this.clear();
  }
  get updating() {
    return this._queueProcessor.length > 0;
  }
  clear() {
    this._queueProcessor.clear();
  }
  push(e6) {
    const t2 = this._queueProcessor, s6 = t2.last();
    switch (e6.type) {
      case "update":
      case "refresh":
        if ((s6 == null ? void 0 : s6.type) === e6.type)
          return;
        t2.push(e6).then(this._notifyUpdating, this._notifyUpdating);
        break;
      case "edit": {
        const r3 = "processed-edit" === (s6 == null ? void 0 : s6.type) ? s6 : null;
        r3 && t2.popLast();
        const o5 = this._mergeEdits(r3, e6);
        for (const e7 of o5)
          e7 && t2.push(e7).then(this._notifyUpdating, this._notifyUpdating);
        break;
      }
    }
    this.notifyChange("updating");
  }
  _mergeEdits(e6, t2) {
    const { addedFeatures: s6, deletedFeatures: r3, updatedFeatures: o5 } = t2.edits;
    if (this._hasGlobalIds = this._hasGlobalIds || i4(s6) || i4(o5) || i4(r3), this._hasGlobalIds) {
      return [e6, { type: "processed-edit", edits: { addOrModified: [...s6, ...o5], removed: r3 } }];
    }
    const c3 = new Set(n((e6 == null ? void 0 : e6.edits.addOrModified) ?? [])), p5 = new Set(n((e6 == null ? void 0 : e6.edits.removed) ?? [])), u4 = /* @__PURE__ */ new Set([...n(s6), ...n(o5)]), l7 = new Set(n(r3));
    return [{ type: "processed-edit", edits: { addOrModified: Array.from(d3(a5(c3, l7), u4)).map((e7) => ({ objectId: e7 })), removed: Array.from(d3(a5(p5, u4), l7)).map((e7) => ({ objectId: e7 })) } }];
  }
};
e2([y({ readOnly: true })], c.prototype, "updating", null), e2([y()], c.prototype, "process", void 0), c = e2([a2("esri.views.2d.layers.support.FeatureCommandQueue")], c);
var p4 = c;

// node_modules/@arcgis/core/views/2d/layers/support/FeatureLayerProxy.js
function c2(e6) {
  return Array.isArray(e6);
}
var u3 = class extends _ {
  constructor(e6) {
    super(e6), this._startupResolver = D(), this.isReady = false;
  }
  initialize() {
    this._controller = new AbortController(), this.addResolvingPromise(this._startWorker(this._controller.signal));
  }
  destroy() {
    this._controller.abort(), this._connection && this._connection.close();
  }
  set tileRenderer(e6) {
    this.client.tileRenderer = e6;
  }
  get closed() {
    return this._connection.closed;
  }
  async startup(e6, t2, r3, s6) {
    await this.when();
    const o5 = this._controller.signal, i5 = c2(r3.source) ? { transferList: r3.source, signal: o5 } : void 0, n2 = { service: r3, config: t2, tileInfo: e6.tileInfo.toJSON(), tiles: s6 };
    await this._connection.invoke("startup", n2, i5), this._startupResolver.resolve(), this._set("isReady", true);
  }
  async updateTiles(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("updateTiles", e6));
  }
  async update(e6) {
    const t2 = { config: e6 };
    return await this._startupResolver.promise, this._connection.invoke("update", t2);
  }
  async applyUpdate(e6) {
    return await this._startupResolver.promise, this._connection.invoke("applyUpdate", e6);
  }
  async setHighlight(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.setHighlight", e6));
  }
  async stop() {
    if (await this._startupResolver.promise, !this.closed)
      return g(this._connection.invoke("stop"));
  }
  async refresh(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.refresh", e6));
  }
  async querySummaryStatistics(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.querySummaryStatistics", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryAggregateSummaryStatistics(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateSummaryStatistics", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryUniqueValues(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryUniqueValues", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryAggregateUniqueValues(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateUniqueValues", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryClassBreaks(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryClassBreaks", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryAggregateClassBreaks(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateClassBreaks", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryHistogram(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryHistogram", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryAggregateHistogram(e6, t2, r3) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateHistogram", { query: e6.toJSON(), params: t2 }, r3);
  }
  async queryFeatures(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatures", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryVisibleFeatures(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryVisibleFeatures", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryObjectIds(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryObjectIds", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryFeatureCount(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatureCount", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryExtent(e6, t2) {
    return this._connection.invoke("controller.queryExtent", e6.toJSON(), t2);
  }
  async queryLatestObservations(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryLatestObservations", e6.toJSON(), t2);
  }
  async queryStatistics(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryStatistics", e6);
  }
  async queryAggregates(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregates", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryAggregateCount(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateCount", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async queryAggregateIds(e6, t2) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateIds", e6 == null ? void 0 : e6.toJSON(), t2);
  }
  async getObjectId(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getObjectId", e6);
  }
  async getDisplayId(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getDisplayId", e6);
  }
  async getFeatures(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getFeatures", e6);
  }
  async getAggregates() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregates");
  }
  async getAggregateValueRanges() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregateValueRanges");
  }
  async mapValidDisplayIds(e6) {
    return await this._startupResolver.promise, this._connection.invoke("controller.mapValidDisplayIds", e6);
  }
  async onEdits(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.onEdits", e6));
  }
  async enableEvent(e6, t2) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.enableEvent", { name: e6, value: t2 }));
  }
  async pauseStream() {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.pauseStream"));
  }
  async resumeStream() {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.resumeStream"));
  }
  async sendMessageToSocket(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.sendMessageToSocket", e6));
  }
  async sendMessageToClient(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.sendMessageToClient", e6));
  }
  async updateCustomParameters(e6) {
    return await this._startupResolver.promise, g(this._connection.invoke("controller.updateCustomParameters", e6));
  }
  async _startWorker(e6) {
    try {
      this._connection = await u("Pipeline", { client: this.client, strategy: "dedicated", signal: e6 });
    } catch (t2) {
      b(t2);
    }
  }
};
e2([y()], u3.prototype, "isReady", void 0), e2([y({ constructOnly: true })], u3.prototype, "client", void 0), e2([y()], u3.prototype, "tileRenderer", null), u3 = e2([a2("esri.views.2d.layers.support.FeatureLayerProxy")], u3);
var l5 = u3;

// node_modules/@arcgis/core/views/2d/tiling/TileManager.js
var s5 = 1e-6;
var l6 = class {
  constructor(e6) {
    this._tiles = /* @__PURE__ */ new Map(), this.buffer = 0, this.acquireTile = e6.acquireTile, this.releaseTile = e6.releaseTile, this.tileInfoView = e6.tileInfoView, this.buffer = e6.buffer;
  }
  destroy() {
  }
  clear() {
    this._tiles.forEach((e6) => this._releaseTile(e6));
  }
  tileKeys() {
    const e6 = [];
    return this._tiles.forEach((i5, t2) => e6.push(t2)), e6;
  }
  update(e6) {
    const s6 = this.tileInfoView.getTileCoverage(e6.state, this.buffer, "closest"), { spans: l7, lodInfo: r3 } = s6, { level: a6 } = r3, o5 = [], d4 = [], h4 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
    for (const { row: i5, colFrom: c3, colTo: f4 } of l7)
      for (let e7 = c3; e7 <= f4; e7++) {
        const s7 = e3.getId(a6, i5, r3.normalizeCol(e7), r3.getWorldForColumn(e7)), l8 = this._getOrAcquireTile(o5, s7);
        h4.add(s7), l8.isReady ? l8.visible = true : n2.add(l8.key);
      }
    n2.forEach((e7) => this._addPlaceholders(h4, e7)), this._tiles.forEach((e7) => {
      h4.has(e7.key.id) || (d4.push(e7.key.id), this._releaseTile(e7));
    }), l3.pool.release(s6);
    return { hasMissingTiles: n2.size > 0, added: o5, removed: d4 };
  }
  _getOrAcquireTile(e6, i5) {
    if (!this._tiles.has(i5)) {
      const s6 = this.acquireTile(new e3(i5));
      e6.push(i5), this._tiles.set(i5, s6), s6.visible = false;
    }
    return this._tiles.get(i5);
  }
  _getTile(e6) {
    return this._tiles.get(e6);
  }
  _releaseTile(e6) {
    this._tiles.delete(e6.key.id), this.releaseTile(e6);
  }
  _addPlaceholders(e6, i5) {
    const t2 = this._addPlaceholderChildren(e6, i5);
    if (!(Math.abs(1 - t2) < s5)) {
      if (!this._addPlaceholderParent(e6, i5)) {
        this._getTile(i5.id).visible = true;
      }
    }
  }
  _addPlaceholderChildren(e6, i5) {
    let t2 = 0;
    return this._tiles.forEach((s6) => {
      t2 += this._addPlaceholderChild(e6, s6, i5);
    }), t2;
  }
  _addPlaceholderChild(e6, i5, t2) {
    if (i5.key.level <= t2.level || !i5.hasData || !t2.contains(i5.key))
      return 0;
    i5.visible = true, e6.add(i5.key.id);
    return 1 / (1 << 2 * (i5.key.level - t2.level));
  }
  _addPlaceholderParent(i5, t2) {
    let s6 = t2.getParentKey(), l7 = 0, r3 = null;
    for (; r(s6); ) {
      if (i5.has(s6.id))
        return true;
      const e6 = this._getTile(s6.id);
      if (e6 == null ? void 0 : e6.isReady) {
        for (const e7 of i5) {
          const i6 = this._getTile(e7);
          i6 && s6.contains(i6.key) && (i6.visible = false);
        }
        return e6.visible = true, i5.add(e6.key.id), true;
      }
      (e6 == null ? void 0 : e6.hasData) && e6.patchCount > l7 && (l7 = e6.patchCount, r3 = e6), s6 = s6.getParentKey();
    }
    return !!r3 && (r3.visible = true, i5.add(r3.key.id), true);
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var _2 = "esri.views.layers.FeatureLayerView";
var O2 = s.getLogger(_2);
var A = (r3) => {
  let A2 = class extends r3 {
    constructor(...e6) {
      super(...e6), this._updatingRequiredFieldsPromise = null, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.handles.add([l(() => {
        var _a;
        const e6 = this.layer;
        return [(_a = e6 == null ? void 0 : e6.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e6 && "displayField" in e6 ? e6.displayField : null, e6 && "timeInfo" in e6 && e6.timeInfo, e6 && "renderer" in e6 && e6.renderer, e6 && "labelingInfo" in e6 && e6.labelingInfo, e6 && "floorInfo" in e6 && e6.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), w2), a3(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), a3(() => {
        const e6 = this.layer;
        return e6 && "sublayers" in e6 ? e6.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e6, layer: { fieldsIndex: t2 }, requiredFields: r4 } = this;
      return "outFields" in e6 && e6.outFields ? T(t2, [...v3(t2, e6.outFields), ...r4]) : T(t2, r4);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e6) {
      this._override("featureEffect", e6);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e6) {
      O2.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e6) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e6 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t2 = r(this.filter) ? this.filter.createQuery(e6) : new x2(e6);
      if ("feature" === this.layer.type) {
        const e7 = o3(this);
        r(e7) && (t2.where = t2.where ? `(${t2.where}) AND (${e7})` : e7);
      }
      return r(this.timeExtent) && (t2.timeExtent = r(t2.timeExtent) ? t2.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t2;
    }
    createAggregateQuery() {
      const e6 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new x2(e6);
    }
    queryFeatures(e6, t2) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e6, t2) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e6, t2) {
      throw new Error("missing implementation");
    }
    queryExtent(e6, t2) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e6, t2) {
      const r4 = this.validateFetchPopupFeatures(t2);
      if (r4)
        throw r4;
      return this.fetchClientPopupFeatures(t2);
    }
    _loadArcadeModules(e6) {
      return e6.get("expressionInfos.length") || Array.isArray(e6.content) && e6.content.some((e7) => "expression" === e7.type) ? i() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e6 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e6), e6.then(() => {
        this._updatingRequiredFieldsPromise === e6 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e6 = "3d" === this.view.type, { layer: t2, layer: { fieldsIndex: r4, objectIdField: s6 } } = this, n2 = "renderer" in t2 && t2.renderer, a6 = "orderBy" in t2 && t2.orderBy, l7 = "featureReduction" in t2 ? t2.featureReduction : null, u4 = /* @__PURE__ */ new Set(), p5 = await E([n2 ? n2.collectRequiredFields(u4, r4) : null, W(u4, t2), e6 ? D2(u4, t2) : null, r(this.filter) ? j4(u4, t2, this.filter) : null, r(this.featureEffect) ? j4(u4, t2, this.featureEffect.filter) : null, l7 ? O(u4, t2, l7) : null, a6 ? z(u4, t2, a6) : null]);
      if ("timeInfo" in t2 && t2.timeInfo && this.timeExtent && h2(u4, t2.fieldsIndex, [t2.timeInfo.startField, t2.timeInfo.endField]), "feature" === t2.type && (t2.floorInfo && h2(u4, t2.fieldsIndex, [t2.floorInfo.floorField]), e6 && r(t2.infoFor3D) && (null == t2.globalIdField && O2.error("globalIdField missing on 3DObjectFeatureLayer"), h2(u4, t2.fieldsIndex, [t2.globalIdField]))), "subtype-group" === t2.type) {
        w4(u4, r4, t2.subtypeField);
        const e7 = t2.sublayers.map((e8) => {
          var _a;
          return Promise.all([(_a = e8.renderer) == null ? void 0 : _a.collectRequiredFields(u4, r4), W(u4, e8)]);
        });
        await E(e7);
      }
      for (const i5 of p5)
        i5.error && O2.error(i5.error);
      w4(u4, r4, s6), e6 && "displayField" in t2 && t2.displayField && w4(u4, r4, t2.displayField);
      const d4 = Array.from(u4).sort();
      this._set("requiredFields", d4);
    }
    validateFetchPopupFeatures(e6) {
      if (t(e6))
        return null;
      for (const r4 of e6.clientGraphics ?? []) {
        const i5 = r4.layer;
        if ("popupEnabled" in i5 && !i5.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i5 });
        if (r4.isAggregate) {
          const e7 = "featureReduction" in i5 ? i5.featureReduction : null;
          if (!(e7 && "popupTemplate" in e7 && e7.popupEnabled && e7.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i5 });
        } else if ("popupTemplate" in i5) {
          if (!s3(i5, e6))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i5 });
        }
      }
    }
    async fetchClientPopupFeatures(e6) {
      const t2 = r(e6) ? e6.clientGraphics : null;
      if (!t2 || 0 === t2.length)
        return [];
      const r4 = new Array(t2.length), o5 = /* @__PURE__ */ new Map(), n2 = await this.createPopupQuery(e6);
      for (let i5 = 0; i5 < t2.length; i5++) {
        const a6 = t2[i5];
        if (a6.isAggregate) {
          r4[i5] = a6;
          continue;
        }
        const l7 = a6.layer;
        if (!("popupEnabled" in l7))
          continue;
        const u4 = v3(this.layer.fieldsIndex, n2.outFields), p5 = s3(l7, e6);
        if (t(p5))
          continue;
        const d4 = await this._loadArcadeModules(p5);
        d4 && d4.arcadeUtils.hasGeometryOperations(p5) || !xe(u4, a6) ? o5.set(a6.getObjectId(), { graphic: a6, index: i5 }) : r4[i5] = a6;
      }
      if ("stream" === this.layer.type || 0 === o5.size)
        return r4.filter(Boolean);
      n2.objectIds = Array.from(o5.keys());
      try {
        const e7 = await this.layer.queryFeatures(n2);
        for (const t3 of e7.features) {
          const { graphic: { geometry: e8 }, index: i5 } = o5.get(t3.getObjectId());
          t3.geometry || (t3.geometry = e8), r4[i5] = t3;
        }
      } catch {
      }
      return r4.filter(Boolean);
    }
    async createPopupQuery(e6) {
      const t2 = this.layer.createQuery(), r4 = /* @__PURE__ */ new Set();
      let o5 = false;
      const n2 = r(e6) && e6.clientGraphics ? e6.clientGraphics.map((e7) => e7.layer) : [this.layer];
      for (const i5 of n2) {
        if (!("popupEnabled" in i5))
          continue;
        const t3 = s3(i5, e6);
        if (t(t3))
          continue;
        const n3 = await this._loadArcadeModules(t3), a6 = n3 && n3.arcadeUtils.hasGeometryOperations(t3);
        o5 = !("point" !== this.layer.geometryType && !a6);
        const l7 = await d2(this.layer, t3);
        for (const e7 of l7)
          r4.add(e7);
      }
      if (t2.returnGeometry = o5, t2.returnZ = o5, t2.returnM = o5, t2.outFields = Array.from(r4), t2.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e7 = o3(this);
        r(e7) && (t2.where = t2.where ? `(${t2.where}) AND (${e7})` : e7);
      }
      return t2;
    }
    canResume() {
      return !!super.canResume() && (!r(this.timeExtent) || !this.timeExtent.isEmpty);
    }
  };
  return e2([y()], A2.prototype, "_updatingRequiredFieldsPromise", void 0), e2([y({ readOnly: true })], A2.prototype, "availableFields", null), e2([y({ type: w3 })], A2.prototype, "featureEffect", null), e2([y({ type: y2 })], A2.prototype, "filter", void 0), e2([y(b2)], A2.prototype, "timeExtent", void 0), e2([y()], A2.prototype, "layer", void 0), e2([y({ type: Number })], A2.prototype, "maximumNumberOfFeatures", null), e2([y({ readOnly: true, type: Boolean })], A2.prototype, "maximumNumberOfFeaturesExceeded", null), e2([y({ readOnly: true })], A2.prototype, "requiredFields", void 0), e2([y()], A2.prototype, "suspended", void 0), e2([y()], A2.prototype, "view", void 0), A2 = e2([a2(_2)], A2), A2;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function $(e6) {
  return e6 && "openPorts" in e6;
}
var G = class extends A(i2(f3(u2))) {
  constructor() {
    super(...arguments), this._pipelineIsUpdating = true, this._commandsQueue = new p4({ process: (e6) => {
      switch (e6.type) {
        case "processed-edit":
          return this._doEdit(e6);
        case "refresh":
          return this._doRefresh(e6.dataChanged);
        case "update":
          return this._doUpdate();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightIds = /* @__PURE__ */ new Map(), this._updateHighlight = x(async () => this._proxy.setHighlight(Array.from(this._highlightIds.keys()))), this._uploadsLocked = false, this._needsClusterSizeUpdate = false, this.featureEffectView = new o4(), this._lastDefinitionExpression = null;
  }
  destroy() {
    var _a;
    o(this._updateClusterSizeTask, (e6) => e6.remove()), (_a = this._proxy) == null ? void 0 : _a.destroy(), this._commandsQueue.destroy();
  }
  initialize() {
    this.addResolvingPromise(Promise.all([this._initProxy(), this._initServiceOptions()])), this.addHandles([this.on("valueRangesChanged", (e6) => {
      this._set("_aggregateValueRanges", e6.valueRanges);
    }), l(() => this.featureEffect, (e6) => {
      this.featureEffectView.featureEffect = e6;
    }, w2)], "constructor"), this.featureEffectView.endTransitions();
  }
  async _initProxy() {
    var _a;
    const e6 = this.layer;
    if ("isTable" in e6 && e6.isTable)
      throw new s2("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: this.layer });
    if (("feature" === e6.type || "subtype-group" === e6.type) && !((_a = v2(e6)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s2("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e6 });
    this._proxy && this._proxy.destroy();
    const t2 = this._createClientOptions();
    return this._set("_proxy", new l5({ client: t2 })), this._proxy.when();
  }
  async _initServiceOptions() {
    return this._set("_serviceOptions", await this._createServiceOptions()), this._serviceOptions;
  }
  get _effectiveFeatureReduction() {
    if (!("featureReduction" in this.layer))
      return null;
    const e6 = this.layer.featureReduction;
    return e6 && (!("maxScale" in e6) || !e6.maxScale || e6.maxScale < this.view.scale) ? e6 : null;
  }
  get orderByFields() {
    var _a, _b;
    return "stream" !== ((_a = this._serviceOptions) == null ? void 0 : _a.type) ? (_b = this._serviceOptions) == null ? void 0 : _b.orderByFields : void 0;
  }
  get labelsVisible() {
    const e6 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer];
    return !this.suspended && e6.some((e7) => e7.labelingInfo && e7.labelsVisible);
  }
  get queryMode() {
    var _a;
    return (_a = this._serviceOptions) == null ? void 0 : _a.type;
  }
  get renderingConfigHash() {
    var _a, _b;
    if (!this.layer)
      return null;
    const e6 = this.availableFields, t2 = this.layer, r3 = this.view.floors, { definitionExpression: i5 } = t2, s6 = "subtype-group" !== this.layer.type && this.layer.labelsVisible && this.layer.labelingInfo, a6 = "renderer" in t2 && t2.renderer, n2 = "gdbVersion" in t2 ? t2.gdbVersion : void 0, o5 = "historicMoment" in t2 ? (_a = t2.historicMoment) == null ? void 0 : _a.getTime() : void 0, { timeExtent: u4 } = this, h4 = "customParameters" in t2 ? JSON.stringify(t2.customParameters) : void 0, d4 = "apiKey" in t2 ? t2.apiKey : void 0, c3 = "stream" === t2.type ? `${JSON.stringify(t2.geometryDefinition)}${t2.definitionExpression}` : null, p5 = JSON.stringify(this.clips), y3 = (_b = this._effectiveFeatureReduction) == null ? void 0 : _b.toJSON(), g4 = "orderBy" in this.layer && JSON.stringify(this.layer.orderBy), f4 = "sublayers" in this.layer && this.layer.sublayers.items.reduce((e7, t3) => e7 + `${t3.visible ? 1 : 0}.${JSON.stringify(t3.renderer)}.${t3.labelsVisible}
.${JSON.stringify(t3.labelingInfo)}`, ""), m3 = "subtypeCode" in this.layer && this.layer.subtypeCode;
    return JSON.stringify({ orderBy: g4, sublayerHash: f4, subtypeCode: m3, filterHash: r(this.filter) && this.filter.toJSON(), effectHash: r(this.featureEffect) && this.featureEffect.toJSON(), streamFilter: c3, gdbVersion: n2, definitionExpression: i5, historicMoment: o5, availableFields: e6, renderer: a6, labelingInfo: s6, timeExtent: u4, floors: r3, clipsHash: p5, featureReduction: y3, customParameters: h4, apiKey: d4 });
  }
  highlight(e6) {
    let t2;
    e6 instanceof g2 ? t2 = [e6.getObjectId()] : "number" == typeof e6 || "string" == typeof e6 ? t2 = [e6] : j2.isCollection(e6) && e6.length > 0 ? t2 = e6.map((e7) => e7 == null ? void 0 : e7.getObjectId()).toArray() : Array.isArray(e6) && e6.length > 0 && (t2 = "number" == typeof e6[0] || "string" == typeof e6[0] ? e6 : e6.map((e7) => e7 == null ? void 0 : e7.getObjectId()));
    const s6 = t2 == null ? void 0 : t2.filter(r);
    return s6 && s6.length ? (this._addHighlight(s6), { remove: () => this._removeHighlight(s6) }) : { remove: () => {
    } };
  }
  hasHighlight() {
    return !!this._highlightIds.size;
  }
  async hitTest(e6, i5) {
    if (!this.tileRenderer)
      return null;
    const s6 = await this.tileRenderer.hitTest(i5);
    if (0 === s6.length)
      return null;
    const { features: a6, aggregates: n2 } = await this._proxy.getFeatures(s6);
    return [...n2.map((r3) => this._createGraphicHit(e6, s4.fromJSON(r3))), ...a6.map((t2) => this._createGraphicHit(e6, g2.fromJSON(t2)))];
  }
  queryStatistics() {
    return this._proxy.queryStatistics();
  }
  async querySummaryStatistics(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.querySummaryStatistics(this._cleanUpQuery(e6), i5, r3);
  }
  async queryAggregateSummaryStatistics(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryAggregateSummaryStatistics(this._cleanUpAggregateQuery(e6), i5, r3);
  }
  async queryUniqueValues(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryUniqueValues(this._cleanUpQuery(e6), i5, r3);
  }
  async queryAggregateUniqueValues(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryAggregateUniqueValues(this._cleanUpAggregateQuery(e6), i5, r3);
  }
  async queryClassBreaks(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryClassBreaks(this._cleanUpQuery(e6), i5, r3);
  }
  async queryAggregateClassBreaks(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryAggregateClassBreaks(this._cleanUpAggregateQuery(e6), i5, r3);
  }
  async queryHistogram(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryHistogram(this._cleanUpQuery(e6), i5, r3);
  }
  async queryAggregateHistogram(e6, t2, r3) {
    const i5 = { ...t2, scale: this.view.scale };
    return this._proxy.queryAggregateHistogram(this._cleanUpAggregateQuery(e6), i5, r3);
  }
  queryFeatures(e6, t2) {
    return this.queryFeaturesJSON(e6, t2).then((e7) => {
      const t3 = x3.fromJSON(e7);
      return t3.features.forEach((e8) => this._setLayersForFeature(e8)), t3;
    });
  }
  queryVisibleFeatures(e6, t2) {
    return this._proxy.queryVisibleFeatures(this._cleanUpQuery(e6), t2).then((e7) => {
      const t3 = x3.fromJSON(e7);
      return t3.features.forEach((e8) => this._setLayersForFeature(e8)), t3;
    });
  }
  async queryAggregates(e6, t2) {
    const r3 = await this._proxy.queryAggregates(this._cleanUpAggregateQuery(e6), t2), i5 = i3.fromJSON(r3);
    return i5.features.forEach((e7) => this._setLayersForFeature(e7)), i5;
  }
  queryAggregateIds(e6, t2) {
    return this._proxy.queryAggregateIds(this._cleanUpAggregateQuery(e6), t2);
  }
  queryAggregateCount(e6, t2) {
    return this._proxy.queryAggregateCount(this._cleanUpAggregateQuery(e6), t2);
  }
  queryAggregateJSON(e6, t2) {
    return this._proxy.queryAggregates(this._cleanUpAggregateQuery(e6), t2);
  }
  queryFeaturesJSON(e6, t2) {
    return this._proxy.queryFeatures(this._cleanUpQuery(e6), t2);
  }
  queryObjectIds(e6, t2) {
    return this._proxy.queryObjectIds(this._cleanUpQuery(e6), t2);
  }
  queryFeatureCount(e6, t2) {
    return this._proxy.queryFeatureCount(this._cleanUpQuery(e6), t2);
  }
  queryExtent(e6, t2) {
    return this._proxy.queryExtent(this._cleanUpQuery(e6), t2).then((e7) => ({ count: e7.count, extent: w.fromJSON(e7.extent) }));
  }
  setVisibility(e6, t2) {
    t2 ? this._visibilityOverrides.delete(e6) : this._visibilityOverrides.add(e6), this._update();
  }
  update(e6) {
    if (!this._tileStrategy || !this.tileRenderer)
      return;
    const { hasMissingTiles: t2, added: r3, removed: i5 } = this._tileStrategy.update(e6);
    (r3.length || i5.length) && this._proxy.updateTiles({ added: r3, removed: i5 }), t2 && this.requestUpdate(), this.notifyChange("updating");
  }
  attach() {
    this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._tileStrategy = new l6({ acquireTile: (e6) => this._acquireTile(e6), releaseTile: (e6) => this._releaseTile(e6), tileInfoView: this.view.featuresTilingScheme, buffer: 0 }), this.addAttachHandles(l(() => this.renderingConfigHash, () => this._update(), h)), "stream" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e6) => this._edit(e6)));
  }
  detach() {
    var _a, _b;
    this._commandsQueue.clear(), (_a = this._proxy) == null ? void 0 : _a.stop(), this.container.removeAllChildren(), (_b = this.tileRenderer) == null ? void 0 : _b.uninstall(this.container), this.tileRenderer = null, this._tileStrategy = a(this._tileStrategy), this._tileRendererHash = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    var _a;
    const e6 = "renderer" in this.layer && null != this.layer.renderer, t2 = this._commandsQueue.updating, r3 = null != this._updatingRequiredFieldsPromise, i5 = !this._proxy || !this._proxy.isReady, s6 = this._pipelineIsUpdating, a6 = null == this.tileRenderer || ((_a = this.tileRenderer) == null ? void 0 : _a.updating), n2 = e6 && (t2 || r3 || i5 || s6 || a6);
    return has("esri-2d-log-updating") && console.log(`Updating FLV2D: ${n2}
  -> hasRenderer ${e6}
  -> hasPendingCommand ${t2}
  -> updatingRequiredFields ${r3}
  -> updatingProxy ${i5}
  -> updatingPipeline ${s6}
  -> updatingTileRenderer ${a6}
`), n2;
  }
  _createClientOptions() {
    return { setUpdating: (e6) => {
      this._set("_pipelineIsUpdating", e6);
    }, emitEvent: (e6) => {
      this.emit(e6.name, e6.event);
    } };
  }
  async _detectQueryMode(e6) {
    var _a;
    const t2 = "path" in e6, { layer: r3 } = this, i5 = "editingInfo" in r3 && ((_a = r3.editingInfo) == null ? void 0 : _a.lastEditDate), s6 = "refreshInterval" in r3 && !!r3.refreshInterval, a6 = !i5 && s6, o5 = v2(r3);
    if (t2 && ("feature" === r3.type || "subtype-group" === r3.type) && "point" === r3.geometryType && (o5 == null ? void 0 : o5.query.supportsPagination) && !(o5 == null ? void 0 : o5.operations.supportsEditing) && !a6 && has("featurelayer-snapshot-enabled"))
      try {
        const e7 = await r3.queryFeatureCount();
        if (e7 <= has("featurelayer-snapshot-point-min-threshold"))
          return { mode: "snapshot", featureCount: e7 };
        const t3 = has("featurelayer-snapshot-point-max-threshold"), i6 = has("featurelayer-snapshot-point-coverage"), s7 = this.view.extent, a7 = e(r3.fullExtent), n2 = a7 == null ? void 0 : a7.clone().intersection(s7), o6 = r(n2) ? n2.width * n2.height : 0, u4 = (a7 == null ? void 0 : a7.width) * (a7 == null ? void 0 : a7.height);
        if (e7 <= t3 && (0 === u4 ? 0 : o6 / u4) >= i6)
          return { mode: "snapshot", featureCount: e7 };
      } catch (u4) {
        s.getLogger(this.declaredClass).warn("mapview-feature-layer", "Encountered an error when querying for featureCount", { error: u4 });
      }
    return { mode: "on-demand" };
  }
  async _createServiceOptions() {
    var _a, _b, _c;
    const e6 = this.layer;
    if ("stream" === e6.type)
      return null;
    const t2 = v2(e6), { capabilities: r3, objectIdField: i5 } = e6, s6 = e6.fields.map((e7) => e7.toJSON()), n2 = r(e6.fullExtent) ? e6.fullExtent.toJSON() : null, o5 = e4(e6.geometryType), u4 = "timeInfo" in e6 && e6.timeInfo && e6.timeInfo.toJSON() || null, h4 = e6.spatialReference ? e6.spatialReference.toJSON() : null, d4 = "feature" === e6.type ? e6.globalIdField : null;
    let c3;
    "ogc-feature" === e6.type ? c3 = e6.source.getSource() : $(e6.source) ? c3 = await e6.source.openPorts() : e6.parsedUrl && (c3 = p2(e6.parsedUrl), "dynamicDataSource" in e6 && e6.dynamicDataSource && (c3.query = { layer: JSON.stringify({ source: e6.dynamicDataSource }) }));
    const p5 = "datesInUnknownTimezone" in this.layer && this.layer.datesInUnknownTimezone, y3 = ("subtypeField" in this.layer ? this.layer.subtypeField : null) ?? null, { mode: g4, featureCount: f4 } = await this._detectQueryMode(c3);
    let m3 = this.layer.objectIdField;
    if ("feature" === this.layer.type && r(this.layer.orderBy) && this.layer.orderBy.length) {
      const e7 = !this.layer.orderBy[0].valueExpression && this.layer.orderBy[0].field;
      e7 && (m3 = e7);
    }
    return { type: g4, timeReferenceUnknownClient: p5, subtypeField: y3, featureCount: f4, globalIdField: d4, maxRecordCount: r3.query.maxRecordCount, tileMaxRecordCount: r3.query.tileMaxRecordCount, capabilities: r3, effectiveCapabilities: t2, fields: s6, fullExtent: n2, geometryType: o5, objectIdField: i5, source: c3, timeInfo: u4, spatialReference: h4, orderByFields: m3, datesInUnknownTimezone: p5, dateFieldsTimeReference: ("dateFieldsTimeReference" in this.layer ? (_a = this.layer.dateFieldsTimeReference) == null ? void 0 : _a.toJSON() : null) || null, preferredTimeReference: ("preferredTimeReference" in this.layer ? (_b = this.layer.preferredTimeReference) == null ? void 0 : _b.toJSON() : null) || null, editFieldsInfo: "editFieldsInfo" in this.layer ? (_c = this.layer.editFieldsInfo) == null ? void 0 : _c.toJSON() : null };
  }
  async _createMemoryServiceOptions(e6) {
    const t2 = await e6.openPorts();
    return { ...this._createServiceOptions(), type: "memory", source: t2 };
  }
  _cleanUpQuery(e6) {
    const t2 = x2.from(e6) || this.createQuery();
    return t2.outSpatialReference || (t2.outSpatialReference = this.view.spatialReference), t2;
  }
  _cleanUpAggregateQuery(e6) {
    const t2 = x2.from(e6) || this.createAggregateQuery();
    return t2.outSpatialReference || (t2.outSpatialReference = this.view.spatialReference), t2;
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e6) {
    if (this.suspended)
      return void this._clearTiles();
    return this._validateEdit(e6) ? this._commandsQueue.push({ type: "edit", edits: e6 }) : void 0;
  }
  async doRefresh(e6) {
    if (this.attached && this._tileStrategy.tileKeys().length)
      return this.suspended && e6 ? void this._clearTiles() : this._commandsQueue.push({ type: "refresh", dataChanged: e6 });
  }
  _clearTiles() {
    this._tileStrategy.tileKeys().length && (this._proxy.updateTiles({ added: [], removed: this._tileStrategy.tileKeys() }), this._tileStrategy.clear(), this.requestUpdate(), this._commandsQueue.clear(), this._update());
  }
  _validateEdit(e6) {
    const t2 = "globalIdField" in this.layer && this.layer.globalIdField, r3 = e6.deletedFeatures.some((e7) => -1 === e7.objectId || !e7.objectId), i5 = t2 && this.availableFields.includes(t2);
    return r3 && !i5 ? (s.getLogger(this.declaredClass).error(new s2("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t2} to be included the layer's outFields for updates to be reflected on the map`)), null) : e6;
  }
  async _doUpdate() {
    var _a, _b;
    try {
      if (this.destroyed || !this._hasRequiredSupport(this.layer) || !this._tileStrategy)
        return;
      const { featureEffectView: t2, filter: r3 } = this;
      if (await this._updateRequiredFields(), this.destroyed)
        return;
      const { renderer: i5 } = this._getEffectiveRenderer();
      this._set("_effectiveRenderer", i5);
      const s6 = this._createSchemaConfig(), a6 = this._createConfiguration(s6, r3, t2.filter), o5 = this._lastDefinitionExpression !== a6.schema.source.definitionExpression;
      this._lastDefinitionExpression = a6.schema.source.definitionExpression;
      const l7 = a6.schema.tileRenderer, u4 = this._createTileRendererHash(l7);
      if ("snapshot" === this._serviceOptions.type && (a6.schema.source.initialFeatureCount = this._serviceOptions.featureCount), u4 !== this._tileRendererHash) {
        await this._initTileRenderer(l7, i5);
        const e6 = this.layer, t3 = "stream" === e6.type ? await this._initServiceOptions() : this._serviceOptions;
        this.tileRenderer.onConfigUpdate(i5), "stream" !== e6.type && $(e6.source) && (t3.source = await e6.source.openPorts());
        const r4 = { added: this._tileStrategy.tileKeys(), removed: [] };
        await this._proxy.startup(this.view.featuresTilingScheme, a6, t3, r4), this.hasHighlight() && await this._proxy.setHighlight(Array.from(this._highlightIds.keys())), await this._onceTilesUpdated(), this.tileRenderer.onConfigUpdate(i5);
      } else {
        "snapshot" === this._serviceOptions.type && o5 && (a6.schema.source.changedFeatureCount = await this.layer.queryFeatureCount());
        const t3 = await this._proxy.update(a6);
        (t3.mesh || ((_a = t3.targets) == null ? void 0 : _a.aggregate)) && this._lockGPUUploads();
        try {
          await this._proxy.applyUpdate(t3);
        } catch (e6) {
          j(e6) || s.getLogger(this.declaredClass).error(e6);
        }
        (t3.mesh || ((_b = t3.targets) == null ? void 0 : _b.aggregate)) && this._unlockGPUUploads(), this.tileRenderer.onConfigUpdate(i5), this._updateClusterSizeVariable(), this._forceAttributeTextureUpload();
      }
      this._tileRendererHash = u4, this.tileRenderer.invalidateLabels(), this.requestUpdate();
    } catch (e6) {
    }
  }
  async _doEdit(e6) {
    try {
      await this._proxy.onEdits(e6);
    } catch (t2) {
      j(t2), 0;
    }
  }
  async _doRefresh(e6) {
    this._lockGPUUploads();
    try {
      let t2;
      e6 && "snapshot" === this.queryMode && "queryFeatureCount" in this.layer && (t2 = await this.layer.queryFeatureCount()), await this._proxy.refresh({ dataChanged: e6, featureCount: t2 });
    } catch (t2) {
      j(t2), 0;
    }
    this._unlockGPUUploads(), this._effectiveFeatureReduction && this._updateClusterSizeVariable();
  }
  _updateClusterSizeVariable() {
    this._needsClusterSizeUpdate && (this.tileRenderer.onConfigUpdate(this._effectiveRenderer), this._needsClusterSizeUpdate = false);
  }
  _createUpdateClusterSizeTask(e6, t2) {
    return l(() => this._aggregateValueRanges, (r3) => {
      this._updateClusterEffectiveRendererSizeVariable(e6, t2, r3), this._needsClusterSizeUpdate = true, this._uploadsLocked || this._updateClusterSizeVariable();
    });
  }
  async _updateClusterEffectiveRendererSizeVariable(e6, t2, r3) {
    if (e6.dynamicClusterSize && "visualVariables" in e6 && e6.visualVariables) {
      const i5 = f2(e6.visualVariables);
      if (r(i5) && "cluster_count" === i5.field) {
        const s6 = e6.visualVariables.indexOf(i5);
        e6.visualVariables[s6] = b3(t2, r3);
        const a6 = e6.clone();
        a6.dynamicClusterSize = true, this._set("_effectiveRenderer", a6);
      }
    }
  }
  _getEffectiveRenderer() {
    var _a;
    const e6 = this.layer, t2 = "renderer" in e6 ? e6.renderer : null, r3 = this._effectiveFeatureReduction;
    if (this._updateClusterSizeTask = p(this._updateClusterSizeTask), r3 && "renderer" in r3 && r3.renderer && !((_a = r3.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
      const e7 = r3.fields;
      if ("cluster" === r3.type) {
        const { renderer: t3, didInject: i5 } = m(r3.renderer, r3, this._aggregateValueRanges);
        return i5 && (this._updateClusterSizeTask = this._createUpdateClusterSizeTask(t3, r3)), { renderer: t3, aggregateFields: e7, featureReduction: r3 };
      }
      return { renderer: r3.renderer, aggregateFields: e7, featureReduction: r3 };
    }
    if (r3 && "cluster" === r3.type && t2 && g3(t2)) {
      const e7 = r3, i5 = [], s6 = d(i5, t2, e7, this._aggregateValueRanges, true);
      return this._updateClusterSizeTask = this._createUpdateClusterSizeTask(s6, e7), { renderer: s6, aggregateFields: i5, featureReduction: r3 };
    }
    return { renderer: t2, aggregateFields: [], featureReduction: null };
  }
  _acquireTile(e6) {
    const t2 = this.tileRenderer.acquireTile(e6);
    return t2.once("attach", () => {
      this.requestUpdate();
    }), t2;
  }
  _releaseTile(e6) {
    this.tileRenderer.releaseTile(e6);
  }
  async _initTileRenderer(e6, t2) {
    const r3 = await e5(e6, { layerView: this, tileInfoView: this.view.featuresTilingScheme, layer: this.layer });
    return this.tileRenderer && (this._tileStrategy.clear(), this.tileRenderer.uninstall(this.container), this.tileRenderer = a(this.tileRenderer)), this.destroyed ? null : (this._proxy.tileRenderer = r3, this._set("tileRenderer", r3), this.tileRenderer.install(this.container), this.tileRenderer.onConfigUpdate(t2), this.requestUpdate(), this.tileRenderer);
  }
  _createTileRendererHash(e6) {
    return `${e6.type}`;
  }
  get hasFilter() {
    const e6 = !!("floorInfo" in this.layer && this.layer.floorInfo && this.view.floors && this.view.floors.length);
    return !!this.filter || e6 || !!this._visibilityOverrides.size || !!this.timeExtent;
  }
  _injectOverrides(e6) {
    const t2 = r(e6) ? e6.timeExtent : null, r3 = r(this.timeExtent) && r(t2) ? this.timeExtent.intersection(t2) : this.timeExtent || t2;
    let i5 = null;
    const s6 = "floorInfo" in this.layer && this.layer.floorInfo;
    if (s6) {
      const t3 = r(e6) ? e6.where : null;
      i5 = this._addFloorFilterClause(t3);
    }
    if (!this._visibilityOverrides.size && !r3 && !s6)
      return r(e6) ? e6.toJSON() : null;
    (e6 = r(e6) && e6.clone() || new y2()).timeExtent = r3, i5 && (e6.where = i5);
    const a6 = e6.toJSON();
    return a6.hiddenIds = Array.from(this._visibilityOverrides), a6;
  }
  _addFloorFilterClause(e6) {
    var _a;
    const t2 = this.layer;
    let r3 = e6 || "";
    if ("floorInfo" in t2 && t2.floorInfo) {
      let e7 = this.view.floors;
      if (!e7 || !e7.length)
        return r3;
      ((_a = t2.floorInfo.viewAllLevelIds) == null ? void 0 : _a.length) && (e7 = t2.floorInfo.viewAllLevelIds);
      const i5 = e7.filter((e8) => "" !== e8).map((e8) => "'" + e8 + "'");
      i5.push("''");
      const s6 = t2.floorInfo.floorField;
      let a6 = "(" + s6 + " IN ({ids}) OR " + s6 + " IS NULL)";
      if (a6 = a6.replace("{ids}", i5.join(", ")), r(r3) && r3.includes(s6)) {
        let e8 = new RegExp("AND \\(" + s6 + ".*NULL\\)", "g");
        r3 = r3.replace(e8, ""), e8 = new RegExp("\\(" + s6 + ".*NULL\\)", "g"), r3 = r3.replace(e8, ""), r3 = r3.replace(/\s+/g, " ").trim();
      }
      r3 = "" !== r3 ? "(" + r3 + ") AND " + a6 : a6;
    }
    return "" !== r3 ? r3 : null;
  }
  _createConfiguration(e6, t2, r3) {
    const i5 = "feature" === this.layer.type && this.layer.historicMoment ? this.layer.historicMoment.getTime() : void 0, s6 = "feature" === this.layer.type ? this.layer.gdbVersion ?? void 0 : void 0, a6 = new Array(S), n2 = this._injectOverrides(t2);
    a6[0] = n2, a6[1] = r(r3) ? r3.toJSON() : null;
    const o5 = I(e6);
    if (t(o5))
      return null;
    const u4 = l4("2d");
    return { availableFields: this.availableFields, gdbVersion: s6, historicMoment: i5, devicePixelRatio: window.devicePixelRatio || 1, filters: a6, schema: o5, supportsTextureFloat: u4.supportsTextureFloat, maxTextureSize: u4.maxTextureSize };
  }
  _hasRequiredSupport(e6) {
    return !("renderer" in e6) || h3(e6.renderer);
  }
  _onceTilesUpdated() {
    return this.requestUpdate(), j3(() => !this._pipelineIsUpdating);
  }
  _lockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = true, this.tileRenderer.lockGPUUploads());
  }
  _unlockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = false, this.tileRenderer.unlockGPUUploads());
  }
  _forceAttributeTextureUpload() {
    this.tileRenderer && this.tileRenderer.forceAttributeTextureUpload();
  }
  _createSchemaConfig() {
    const e6 = this.layer;
    return { renderer: "renderer" in e6 ? e6.renderer : null, spatialReference: e6.spatialReference, timeExtent: "timeExtent" in e6 ? e6.timeExtent : null, definitionExpression: e6.definitionExpression, featureReduction: this._effectiveFeatureReduction, fields: e6.fields, geometryType: e6.geometryType, historicMoment: "historicMoment" in e6 ? e6.historicMoment : null, labelsVisible: "labelsVisible" in e6 && e6.labelsVisible, labelingInfo: "labelingInfo" in e6 ? e6.labelingInfo : null, availableFields: this.availableFields, featureEffect: this.featureEffect, filter: this.filter, gdbVersion: "gdbVersion" in e6 ? e6.gdbVersion : null, pixelBuffer: 0, orderBy: "orderBy" in e6 && e6.orderBy ? e6.orderBy : null, customParameters: { ..."customParameters" in e6 ? e6.customParameters : void 0, token: "apiKey" in e6 ? e6.apiKey ?? void 0 : void 0 }, subtypeCode: "subtypeCode" in e6 ? e6.subtypeCode : void 0, subtypeField: "subtypeField" in e6 ? e6.subtypeField : void 0 };
  }
  _addHighlight(e6) {
    for (const t2 of e6)
      if (this._highlightIds.has(t2)) {
        const e7 = this._highlightIds.get(t2);
        this._highlightIds.set(t2, e7 + 1);
      } else
        this._highlightIds.set(t2, 1);
    this._updateHighlight().catch((e7) => {
      j(e7) || s.getLogger(this.declaredClass).error(e7);
    });
  }
  _removeHighlight(e6) {
    for (const t2 of e6)
      if (this._highlightIds.has(t2)) {
        const e7 = this._highlightIds.get(t2) - 1;
        0 === e7 ? this._highlightIds.delete(t2) : this._highlightIds.set(t2, e7);
      }
    this._updateHighlight().catch((e7) => {
      j(e7) || s.getLogger(this.declaredClass).error(e7);
    });
  }
  _setLayersForFeature(e6) {
    const t2 = this.layer;
    e6.layer = t2, e6.sourceLayer = t2;
  }
  _createGraphicHit(e6, t2) {
    return this._setLayersForFeature(t2), r(t2.geometry) && (t2.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t2, layer: this.layer, mapPoint: e6 };
  }
};
e2([y()], G.prototype, "_serviceOptions", void 0), e2([y()], G.prototype, "_proxy", void 0), e2([y()], G.prototype, "_pipelineIsUpdating", void 0), e2([y()], G.prototype, "_effectiveRenderer", void 0), e2([y()], G.prototype, "_effectiveFeatureReduction", null), e2([y()], G.prototype, "_aggregateValueRanges", void 0), e2([y()], G.prototype, "_commandsQueue", void 0), e2([y()], G.prototype, "featureEffectView", void 0), e2([y()], G.prototype, "labelsVisible", null), e2([y({ readOnly: true })], G.prototype, "queryMode", null), e2([y()], G.prototype, "renderingConfigHash", null), e2([y()], G.prototype, "tileRenderer", void 0), e2([y()], G.prototype, "updating", void 0), G = e2([a2("esri.views.2d.layers.FeatureLayerView2D")], G);
var D3 = G;

export {
  D3 as D
};
//# sourceMappingURL=chunk-RXXNX7SV.js.map

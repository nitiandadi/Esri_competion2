import {
  r as r2,
  t as t2
} from "./chunk-7D6F2QEN.js";
import {
  a as a2
} from "./chunk-PIAVWZTX.js";
import {
  d,
  h
} from "./chunk-4HI3DYZK.js";
import {
  a
} from "./chunk-VTZGYKHD.js";
import "./chunk-CBAVHWPY.js";
import "./chunk-MKMLHQNH.js";
import "./chunk-PHPHIDTF.js";
import {
  L,
  qt
} from "./chunk-P6SQPYDS.js";
import "./chunk-TTCQP5LX.js";
import {
  s2 as s
} from "./chunk-C2WY74GI.js";
import "./chunk-MCOYI7PX.js";
import "./chunk-EL4OGCJC.js";
import "./chunk-XPATKIHO.js";
import "./chunk-MKHZ5X6F.js";
import {
  r,
  t
} from "./chunk-HVCAHUYB.js";
import "./chunk-4EOJPDL2.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
var y = { FeatureLayer: true, SceneLayer: true };
async function m(e) {
  var _a;
  const r3 = (_a = e.properties) == null ? void 0 : _a.customParameters, a3 = await d2(e.url, r3), t3 = { ...e.properties, url: e.url };
  if (!a3.sublayerIds)
    return null != a3.layerOrTableId && (t3.layerId = a3.layerOrTableId, t3.sourceJSON = a3.sourceJSON), new a3.Constructor(t3);
  const s2 = new (0, (await import("./GroupLayer-QNI7BTPP.js")).default)({ title: a3.parsedUrl.title });
  return f(s2, a3, t3), s2;
}
function p(e, r3) {
  return e ? e.find((e2) => e2.id === r3) : null;
}
function f(e, r3, t3) {
  function s2(e2, s3) {
    const l = { ...t3, layerId: e2, sublayerTitleMode: "service-name" };
    return r(s3) && (l.sourceJSON = s3), new r3.Constructor(l);
  }
  r3.sublayerIds.forEach((a3) => {
    const t4 = s2(a3, p(r3.sublayerInfos, a3));
    e.add(t4);
  }), r3.tableIds.forEach((a3) => {
    const t4 = s2(a3, p(r3.tableInfos, a3));
    e.tables.add(t4);
  });
}
async function d2(a3, t3) {
  var _a, _b, _c, _d;
  let s2 = d(a3);
  if (t(s2) && (s2 = await I(a3, t3)), t(s2))
    throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: a3 });
  const { serverType: o, sublayer: n } = s2;
  let c;
  const m2 = { FeatureServer: "FeatureLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer" };
  switch (o) {
    case "MapServer":
      if (null != n)
        c = "FeatureLayer";
      else {
        c = await v(a3, t3) ? "TileLayer" : "MapImageLayer";
      }
      break;
    case "ImageServer": {
      const e = await t2(a3, { customParameters: t3 }), { tileInfo: r3, cacheType: s3 } = e;
      c = r3 ? "LERC" !== ((_a = r3 == null ? void 0 : r3.format) == null ? void 0 : _a.toUpperCase()) || s3 && "elevation" !== s3.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      break;
    }
    case "SceneServer": {
      const e = await t2(s2.url.path, { customParameters: t3 });
      if (c = "SceneLayer", e) {
        const r3 = e == null ? void 0 : e.layers;
        if ("Voxel" === (e == null ? void 0 : e.layerType))
          c = "VoxelLayer";
        else if (r3 == null ? void 0 : r3.length) {
          const e2 = (_b = r3[0]) == null ? void 0 : _b.layerType;
          null != e2 && null != a[e2] && (c = a[e2]);
        }
      }
      break;
    }
    default:
      c = m2[o];
  }
  const p2 = "FeatureServer" === o, f2 = { parsedUrl: s2, Constructor: null, layerOrTableId: p2 ? n : void 0, sublayerIds: null, tableIds: null };
  if (y[c] && null == n) {
    const e = await S(a3, o, t3);
    p2 && (f2.sublayerInfos = e.layerInfos, f2.tableInfos = e.tableInfos);
    1 !== e.layerIds.length + e.tableIds.length ? (f2.sublayerIds = e.layerIds, f2.tableIds = e.tableIds) : p2 && (f2.layerOrTableId = e.layerIds[0] ?? e.tableIds[0], f2.sourceJSON = ((_c = e.layerInfos) == null ? void 0 : _c[0]) ?? ((_d = e.tableInfos) == null ? void 0 : _d[0]));
  }
  return f2.Constructor = await w(c), f2;
}
async function I(e, r3) {
  var _a;
  const l = await t2(e, { customParameters: r3 });
  let n = null, u = null;
  const c = l.type;
  if ("Feature Layer" === c || "Table" === c ? (n = "FeatureServer", u = l.id ?? null) : "indexedVector" === c ? n = "VectorTileServer" : l.hasOwnProperty("mapName") ? n = "MapServer" : l.hasOwnProperty("bandCount") && l.hasOwnProperty("pixelSizeX") ? n = "ImageServer" : l.hasOwnProperty("maxRecordCount") && l.hasOwnProperty("allowGeometryUpdates") ? n = "FeatureServer" : l.hasOwnProperty("streamUrls") ? n = "StreamServer" : b(l) ? (n = "SceneServer", u = l.id) : l.hasOwnProperty("layers") && b((_a = l.layers) == null ? void 0 : _a[0]) && (n = "SceneServer"), !n)
    return null;
  const y2 = null != u ? h(e) : null;
  return { title: r(y2) && l.name || qt(e), serverType: n, sublayer: u, url: { path: r(y2) ? y2.serviceUrl : L(e).path } };
}
function b(e) {
  return null != e && e.hasOwnProperty("store") && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function S(e, r3, a3) {
  let t3, s2 = false;
  if ("FeatureServer" === r3) {
    const r4 = await r2(e, { customParameters: a3 });
    s2 = !!r4.layersJSON, t3 = r4.layersJSON || r4.serviceJSON;
  } else
    t3 = await t2(e, { customParameters: a3 });
  const l = t3 == null ? void 0 : t3.layers, o = t3 == null ? void 0 : t3.tables;
  return { layerIds: (l == null ? void 0 : l.map((e2) => e2.id).reverse()) || [], tableIds: (o == null ? void 0 : o.map((e2) => e2.id).reverse()) || [], layerInfos: s2 ? l : [], tableInfos: s2 ? o : [] };
}
async function w(e) {
  return (0, a2[e])();
}
async function v(e, r3) {
  return (await t2(e, { customParameters: r3 })).tileInfo;
}
export {
  m as fromUrl
};
//# sourceMappingURL=arcgisLayers-PTNAZOW6.js.map

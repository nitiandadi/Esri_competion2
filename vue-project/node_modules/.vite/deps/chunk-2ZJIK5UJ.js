import {
  C,
  M,
  a as a2,
  f,
  m,
  y
} from "./chunk-XTUZNPIG.js";
import {
  e as e3
} from "./chunk-6ZR5GOPR.js";
import {
  i
} from "./chunk-RZNNSB7A.js";
import {
  c as c2
} from "./chunk-BLEGKDS6.js";
import {
  a
} from "./chunk-HNMSCBZJ.js";
import {
  S3 as S,
  l as l3,
  x as x2
} from "./chunk-3ZZKMNU2.js";
import {
  U
} from "./chunk-MKMLHQNH.js";
import {
  l as l2
} from "./chunk-FFQG5TD2.js";
import {
  e as e2,
  u
} from "./chunk-F4DUNBGT.js";
import {
  l
} from "./chunk-PTCP7EIR.js";
import {
  c,
  e,
  r,
  t,
  x
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/symbols/support/cimSymbolUtils.js
function l4(e4, t2, o, r2) {
  if (e4)
    if ("CIMTextSymbol" !== e4.type) {
      if (o && e4.effects)
        for (const o2 of e4.effects)
          y2(o2, t2);
      if (e4.symbolLayers)
        for (const o2 of e4.symbolLayers)
          switch (o2.type) {
            case "CIMPictureMarker":
            case "CIMVectorMarker":
              m2(o2, t2, r2);
              break;
            case "CIMPictureStroke":
            case "CIMSolidStroke":
              !(r2 == null ? void 0 : r2.preserveOutlineWidth) && o2.width && (o2.width *= t2);
              break;
            case "CIMPictureFill":
              o2.height && (o2.height *= t2), o2.offsetX && (o2.offsetX *= t2), o2.offsetY && (o2.offsetY *= t2);
              break;
            case "CIMHatchFill":
              l4(o2.lineSymbol, t2, true, { ...r2, preserveOutlineWidth: false }), o2.offsetX && (o2.offsetX *= t2), o2.offsetY && (o2.offsetY *= t2), o2.separation && (o2.separation *= t2);
          }
    } else
      null != e4.height && (e4.height *= t2);
}
function m2(e4, t2, o) {
  if (e4 && (e4.markerPlacement && M2(e4.markerPlacement, t2), e4.offsetX && (e4.offsetX *= t2), e4.offsetY && (e4.offsetY *= t2), e4.anchorPoint && "Absolute" === e4.anchorPointUnits && (e4.anchorPoint = { x: e4.anchorPoint.x * t2, y: e4.anchorPoint.y * t2 }), e4.size = null != e4.size ? e4.size * t2 : 0, "CIMVectorMarker" === e4.type && e4.markerGraphics))
    for (const r2 of e4.markerGraphics)
      e4.scaleSymbolsProportionally || l4(r2.symbol, t2, true, o);
}
function M2(e4, t2) {
  switch (m(e4) && e4.offset && (e4.offset *= t2), e4.type) {
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAlongLineSameSize":
      if (e4.customEndingOffset && (e4.customEndingOffset *= t2), e4.offsetAlongLine && (e4.offsetAlongLine *= t2), e4.placementTemplate && e4.placementTemplate.length) {
        const o = e4.placementTemplate.map((e5) => e5 * t2);
        e4.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementAlongLineVariableSize":
      if (e4.maxRandomOffset && (e4.maxRandomOffset *= t2), e4.placementTemplate && e4.placementTemplate.length) {
        const o = e4.placementTemplate.map((e5) => e5 * t2);
        e4.placementTemplate = o;
      }
      break;
    case "CIMMarkerPlacementOnLine":
      e4.startPointOffset && (e4.startPointOffset *= t2);
      break;
    case "CIMMarkerPlacementAtExtremities":
      e4.offsetAlongLine && (e4.offsetAlongLine *= t2);
      break;
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementOnVertices":
      break;
    case "CIMMarkerPlacementAtRatioPositions":
      e4.beginPosition && (e4.beginPosition *= t2), e4.endPosition && (e4.endPosition *= t2);
      break;
    case "CIMMarkerPlacementPolygonCenter":
      e4.offsetX && (e4.offsetX *= t2), e4.offsetY && (e4.offsetY *= t2);
      break;
    case "CIMMarkerPlacementInsidePolygon":
      e4.offsetX && (e4.offsetX *= t2), e4.offsetY && (e4.offsetY *= t2), e4.stepX && (e4.stepX *= t2), e4.stepY && (e4.stepY *= t2);
  }
}
function y2(e4, t2) {
  switch (e4.type) {
    case "CIMGeometricEffectArrow":
    case "CIMGeometricEffectDonut":
      e4.width && (e4.width *= t2);
      break;
    case "CIMGeometricEffectBuffer":
      e4.size && (e4.size *= t2);
      break;
    case "CIMGeometricEffectCut":
      e4.beginCut && (e4.beginCut *= t2), e4.endCut && (e4.endCut *= t2), e4.middleCut && (e4.middleCut *= t2);
      break;
    case "CIMGeometricEffectDashes":
      if (e4.customEndingOffset && (e4.customEndingOffset *= t2), e4.offsetAlongLine && (e4.offsetAlongLine *= t2), e4.dashTemplate && e4.dashTemplate.length) {
        const o = e4.dashTemplate.map((e5) => e5 * t2);
        e4.dashTemplate = o;
      }
      break;
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectJog":
    case "CIMGeometricEffectRadial":
      e4.length && (e4.length *= t2);
      break;
    case "CIMGeometricEffectMove":
      e4.offsetX && (e4.offsetX *= t2), e4.offsetY && (e4.offsetY *= t2);
      break;
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      e4.offset && (e4.offset *= t2);
      break;
    case "CIMGeometricEffectRegularPolygon":
      e4.radius && (e4.radius *= t2);
      break;
    case "CIMGeometricEffectTaperedPolygon":
      e4.fromWidth && (e4.fromWidth *= t2), e4.length && (e4.length *= t2), e4.toWidth && (e4.toWidth *= t2);
      break;
    case "CIMGeometricEffectWave":
      e4.amplitude && (e4.amplitude *= t2), e4.period && (e4.period *= t2);
  }
}
function C2(o) {
  const r2 = [];
  return u2(f(o), r2), r2.length ? new l2(a2(r2[0])) : null;
}
function u2(e4, t2) {
  var _a;
  if (!e4)
    return;
  let n2;
  n2 = "CIMTextSymbol" === e4.type ? e4.symbol : e4;
  const a4 = "CIMPolygonSymbol" === e4.type;
  if (n2 == null ? void 0 : n2.symbolLayers) {
    for (const i2 of n2.symbolLayers)
      if (!(i2.colorLocked || a4 && (M(i2) || y(i2) && i2.markerPlacement && m(i2.markerPlacement))))
        switch (i2.type) {
          case "CIMPictureMarker":
          case "CIMPictureStroke":
          case "CIMPictureFill":
            i2.tintColor && b(t2, i2.tintColor);
            break;
          case "CIMVectorMarker":
            (_a = i2.markerGraphics) == null ? void 0 : _a.forEach((e5) => {
              u2(e5.symbol, t2);
            });
            break;
          case "CIMSolidStroke":
          case "CIMSolidFill":
            b(t2, i2.color);
            break;
          case "CIMHatchFill":
            u2(i2.lineSymbol, t2);
        }
  }
}
function b(e4, t2) {
  for (const o of e4)
    if (o.join(".") === t2.join("."))
      return;
  e4.push(t2);
}
function I(o, r2, n2) {
  r2 instanceof l2 || (r2 = new l2(r2));
  const s = f(o);
  s && k(s, r2, n2);
}
function k(e4, t2, a4) {
  var _a;
  if (!e4)
    return;
  let i2;
  i2 = "CIMTextSymbol" === e4.type ? e4.symbol : e4;
  const c4 = "CIMPolygonSymbol" === (i2 == null ? void 0 : i2.type);
  if (i2 == null ? void 0 : i2.symbolLayers)
    for (const f3 of i2.symbolLayers) {
      if (f3.colorLocked)
        continue;
      if (c4) {
        if (a4) {
          const { layersToColor: e6 } = a4;
          if ((M(f3) || y(f3) && f3.markerPlacement && m(f3.markerPlacement)) && "fill" === e6 || C(f3) && "outline" === e6)
            continue;
        } else if (M(f3) || y(f3) && f3.markerPlacement && m(f3.markerPlacement))
          continue;
      }
      const e5 = t2.toArray();
      switch (f3.type) {
        case "CIMPictureMarker":
        case "CIMPictureStroke":
        case "CIMPictureFill":
          f3.tintColor = e5;
          break;
        case "CIMVectorMarker":
          (_a = f3.markerGraphics) == null ? void 0 : _a.forEach((e6) => {
            k(e6.symbol, t2, a4);
          });
          break;
        case "CIMSolidStroke":
        case "CIMSolidFill":
          f3.color = e5;
          break;
        case "CIMHatchFill":
          k(f3.lineSymbol, t2, a4);
      }
    }
}

// node_modules/@arcgis/core/symbols/support/gfxUtils.js
var n = "picture-fill";
var l5 = "simple-fill";
var c3 = "simple-line";
var a3 = "simple-marker";
var m3 = "text";
var p = "cim";
var u3 = new e3(1e3);
function f2(t2) {
  const r2 = t2.style;
  let o = null;
  if (t2)
    switch (t2.type) {
      case a3:
        "cross" !== r2 && "x" !== r2 && (o = t2.color);
        break;
      case l5:
        "solid" === r2 ? o = t2.color : "none" !== r2 && (o = { type: "pattern", x: 0, y: 0, src: a(`esri/symbols/patterns/${r2}.png`), width: 5, height: 5 });
        break;
      case n:
        o = { type: "pattern", src: t2.url, width: u(t2.width) * t2.xscale, height: u(t2.height) * t2.yscale, x: u(t2.xoffset), y: u(t2.yoffset) };
        break;
      case m3:
        o = t2.color;
        break;
      case p:
        o = C2(t2);
    }
  return o;
}
function h(e4, t2) {
  const o = e4 + "-" + t2;
  return void 0 !== u3.get(o) ? Promise.resolve(u3.get(o)) : U(e4, { responseType: "image" }).then((e5) => {
    const r2 = e5.data, s = r2.naturalWidth, i2 = r2.naturalHeight, n2 = document.createElement("canvas");
    n2.width = s, n2.height = i2;
    const l6 = n2.getContext("2d");
    l6.fillStyle = t2, l6.fillRect(0, 0, s, i2), l6.globalCompositeOperation = "destination-in", l6.drawImage(r2, 0, 0);
    const c4 = n2.toDataURL();
    return u3.put(o, c4), c4;
  });
}
function y3(e4) {
  if (!e4)
    return null;
  let t2 = null;
  switch (e4.type) {
    case l5:
    case n:
    case a3:
      t2 = y3(e4.outline);
      break;
    case c3: {
      const r2 = u(e4.width);
      null != e4.style && "none" !== e4.style && 0 !== r2 && (t2 = { color: e4.color, style: d(e4.style), width: r2, cap: e4.cap, join: "miter" === e4.join ? u(e4.miterLimit) : e4.join });
      break;
    }
    default:
      t2 = null;
  }
  return t2;
}
var d = (() => {
  const e4 = {};
  return (t2) => {
    if (e4[t2])
      return e4[t2];
    const r2 = t2.replace(/-/g, "");
    return e4[t2] = r2, r2;
  };
})();
var g = new l2([128, 128, 128]);

// node_modules/@arcgis/core/symbols/support/utils.js
var p2 = new l2("white");
function h2(e4) {
  const t2 = e4.symbolLayers && e4.symbolLayers.length;
  if (!t2)
    return;
  const o = e4.symbolLayers.getItemAt(t2 - 1);
  return "outline" in o ? x(o, "outline", "size") : void 0;
}
function b2(e4) {
  var _a;
  if (!e4)
    return 0;
  if (x2(e4)) {
    const t2 = h2(e4);
    return r(t2) ? t2 : 0;
  }
  return e2((_a = y3(e4)) == null ? void 0 : _a.width);
}
function w(e4) {
  if (t(e4) || !("symbolLayers" in e4) || t(e4.symbolLayers))
    return false;
  switch (e4.type) {
    case "point-3d":
      return e4.symbolLayers.some((e5) => "object" === e5.type);
    case "line-3d":
      return e4.symbolLayers.some((e5) => "path" === e5.type);
    case "polygon-3d":
      return e4.symbolLayers.some((e5) => "object" === e5.type || "extrude" === e5.type);
    default:
      return false;
  }
}
function d2(e4) {
  return c(e4.resource).href;
}
function j(r2, n2) {
  if (!r2)
    return null;
  let l6 = null;
  return x2(r2) ? l6 = g2(r2) : S(r2) && (l6 = r2.color ? new l2(r2.color) : null), l6 ? k2(l6, n2) : null;
}
function g2(t2) {
  const o = t2.symbolLayers;
  if (!o)
    return null;
  let r2 = null;
  return o.forEach((e4) => {
    var _a;
    "object" === e4.type && null != ((_a = e4.resource) == null ? void 0 : _a.href) || (r2 = "water" === e4.type ? e(e4.color) : r(e4.material) ? e(e4.material.color) : null);
  }), r2 ? new l2(r2) : null;
}
function k2(t2, o) {
  if (null == o || null == t2)
    return t2;
  const r2 = t2.toRgba();
  return r2[3] = r2[3] * o, new l2(r2);
}
function L(e4, t2, o) {
  const r2 = e4.symbolLayers;
  if (!r2)
    return;
  const i2 = (e5) => {
    const r3 = r(e5) ? e5 : null;
    return k2(t2 = t2 ?? r3 ?? (null != o ? p2 : null), o);
  };
  r2.forEach((e5) => {
    var _a;
    if ("object" !== e5.type || null == ((_a = e5.resource) == null ? void 0 : _a.href) || t2)
      if ("water" === e5.type)
        e5.color = i2(e5.color);
      else {
        const t3 = r(e5.material) ? e5.material.color : null, r3 = i2(t3);
        t(e5.material) ? e5.material = new l3({ color: r3 }) : e5.material.color = r3, null != o && "outline" in e5 && r(e5.outline) && r(e5.outline.color) && (e5.outline.color = k2(e5.outline.color, o));
      }
  });
}
function z(e4, t2, o) {
  (t2 = t2 ?? e4.color) && (e4.color = k2(t2, o)), null != o && "outline" in e4 && e4.outline && e4.outline.color && (e4.outline.color = k2(e4.outline.color, o));
}
function S2(r2, n2, l6) {
  r2 && (n2 || null != l6) && (n2 && (n2 = new l2(n2)), x2(r2) ? L(r2, n2, l6) : S(r2) && z(r2, n2, l6));
}
async function x3(e4, t2) {
  const o = e4.symbolLayers;
  o && await c2(o, async (e5) => v(e5, t2));
}
async function v(e4, t2) {
  switch (e4.type) {
    case "extrude":
      O(e4, t2);
      break;
    case "icon":
    case "line":
    case "text":
      U2(e4, t2);
      break;
    case "path":
      I2(e4, t2);
      break;
    case "object":
      await C3(e4, t2);
  }
}
function U2(e4, t2) {
  const o = E(t2);
  r(o) && (e4.size = o);
}
function E(e4) {
  for (const t2 of e4)
    if ("number" == typeof t2)
      return t2;
  return null;
}
function O(e4, t2) {
  e4.size = "number" == typeof t2[2] ? t2[2] : 0;
}
async function C3(e4, t2) {
  const { resourceSize: o, symbolSize: r2 } = await R(e4), n2 = M3(t2, o, r2);
  e4.width = A(t2[0], r2[0], o[0], n2), e4.depth = A(t2[1], r2[1], o[1], n2), e4.height = A(t2[2], r2[2], o[2], n2);
}
function I2(e4, t2) {
  const o = M3(t2, l, [e4.width, void 0, e4.height]);
  e4.width = A(t2[0], e4.width, 1, o), e4.height = A(t2[2], e4.height, 1, o);
}
function M3(e4, t2, o) {
  for (let r2 = 0; r2 < 3; r2++) {
    const n2 = e4[r2];
    switch (n2) {
      case "symbol-value": {
        const e5 = o[r2];
        return null != e5 ? e5 / t2[r2] : 1;
      }
      case "proportional":
        break;
      default:
        if (n2 && t2[r2])
          return n2 / t2[r2];
    }
  }
  return 1;
}
async function R(e4) {
  const t2 = await import("./symbolLayerUtils-4YSTPACK.js"), o = await t2.computeObjectLayerResourceSize(e4, 10), { width: r2, height: n2, depth: l6 } = e4, i2 = [r2, l6, n2];
  let s = 1;
  for (let c4 = 0; c4 < 3; c4++) {
    const e5 = i2[c4];
    if (null != e5) {
      s = e5 / o[c4];
      break;
    }
  }
  for (let c4 = 0; c4 < 3; c4++)
    null == i2[c4] && (i2[c4] = o[c4] * s);
  return { resourceSize: o, symbolSize: i2 };
}
function A(e4, t2, o, r2) {
  switch (e4) {
    case "proportional":
      return o * r2;
    case "symbol-value":
      return null != t2 ? t2 : o;
    default:
      return e4;
  }
}
function D(e4, t2) {
  const o = E(t2);
  if (!t(o))
    switch (e4.type) {
      case "simple-marker":
        e4.size = o;
        break;
      case "picture-marker": {
        const t3 = e4.width / e4.height;
        t3 > 1 ? (e4.width = o, e4.height = o * t3) : (e4.width = o * t3, e4.height = o);
        break;
      }
      case "simple-line":
        e4.width = o;
        break;
      case "text":
        e4.font.size = o;
    }
}
async function J(e4, r2) {
  if (e4 && r2)
    return x2(e4) ? x3(e4, r2) : void (S(e4) && D(e4, r2));
}
function N(e4, r2, n2) {
  if (e4 && null != r2)
    if (x2(e4)) {
      const t2 = e4.symbolLayers;
      t2 && t2.forEach((e5) => {
        if (e5 && "object" === e5.type)
          switch (n2) {
            case "tilt":
              e5.tilt = r2;
              break;
            case "roll":
              e5.roll = r2;
              break;
            default:
              e5.heading = r2;
          }
      });
    } else
      S(e4) && ("simple-marker" !== e4.type && "picture-marker" !== e4.type && "text" !== e4.type || (e4.angle = r2));
}
function q(e4) {
  if (!e4)
    return null;
  const t2 = e4.effects.filter((e5) => "bloom" !== e5.type).map((e5) => e5.toJSON());
  return i(t2);
}
async function F(e4, t2) {
  const o = await e4.fetchSymbol(t2);
  return o || e4.fetchCIMSymbol(t2);
}

export {
  m2 as m,
  I,
  f2 as f,
  h,
  y3 as y,
  d,
  g,
  b2 as b,
  w,
  d2,
  j,
  S2 as S,
  J,
  N,
  q,
  F
};
//# sourceMappingURL=chunk-2ZJIK5UJ.js.map

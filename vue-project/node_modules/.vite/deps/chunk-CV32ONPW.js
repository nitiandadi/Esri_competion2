import {
  b as b2,
  c as c2,
  j as j2
} from "./chunk-NCSDM2FH.js";
import {
  a as a4
} from "./chunk-B4X5M3MB.js";
import {
  p as p3
} from "./chunk-CNIE5HLE.js";
import {
  m as m3
} from "./chunk-VB6BMHUU.js";
import {
  p as p2
} from "./chunk-H66NMTBW.js";
import {
  m as m2
} from "./chunk-HFRO4PG3.js";
import {
  l as l3
} from "./chunk-FXMJJBXP.js";
import {
  F,
  M,
  P,
  S,
  f,
  j2 as j
} from "./chunk-CRF4O3Y3.js";
import {
  a as a3
} from "./chunk-KSENJC5Z.js";
import {
  n as n2,
  r as r3
} from "./chunk-WAN4YZSB.js";
import {
  b as b3
} from "./chunk-YZRPNTZZ.js";
import {
  c,
  m
} from "./chunk-LVRAFE6T.js";
import {
  i
} from "./chunk-YMLMMCYX.js";
import {
  S as S2,
  w
} from "./chunk-YHZVWABO.js";
import {
  i as i2
} from "./chunk-WATRS3LJ.js";
import {
  o as o2
} from "./chunk-7FMLQXIT.js";
import {
  r as r2
} from "./chunk-H2ENCYR3.js";
import {
  o
} from "./chunk-SVHG5VY2.js";
import {
  s as s3
} from "./chunk-S47644HM.js";
import {
  s as s4
} from "./chunk-QXPN4D5D.js";
import {
  l as l2
} from "./chunk-DLM7WQKI.js";
import {
  a2,
  e as e2,
  t6 as t2,
  u2,
  v2 as v,
  y3 as y
} from "./chunk-7GTATSRF.js";
import {
  T,
  a,
  b,
  u
} from "./chunk-PXVSWY3C.js";
import {
  s,
  s2
} from "./chunk-UG2OEDEE.js";
import {
  n,
  p
} from "./chunk-PR6SXADK.js";
import {
  e,
  l,
  r,
  t
} from "./chunk-WHB7G7RI.js";

// node_modules/@arcgis/core/renderers/Renderer.js
var n3 = new s4({ simple: "simple", uniqueValue: "unique-value", classBreaks: "class-breaks", heatmap: "heatmap", dotDensity: "dot-density", dictionary: "dictionary", pieChart: "pie-chart" }, { ignoreUnknown: true });
var a5 = class extends l2 {
  constructor(r4) {
    super(r4), this.authoringInfo = null, this.type = null;
  }
  async getRequiredFields(r4) {
    if (!this.collectRequiredFields)
      return [];
    const e4 = /* @__PURE__ */ new Set();
    return await this.collectRequiredFields(e4, r4), Array.from(e4).sort();
  }
  getSymbol(r4, e4) {
  }
  async getSymbolAsync(r4, e4) {
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return JSON.stringify(this);
  }
  getMeshHash() {
    return JSON.stringify(this);
  }
};
e2([y({ type: j2, json: { write: true } })], a5.prototype, "authoringInfo", void 0), e2([y({ type: n3.apiValues, readOnly: true, json: { type: n3.jsonValues, read: false, write: { writer: n3.write, ignoreOrigin: true } } })], a5.prototype, "type", void 0), a5 = e2([a2("esri.renderers.Renderer")], a5);
var p4 = a5;

// node_modules/@arcgis/core/renderers/support/randomRotationExpression.js
function e3(e4) {
  var _a, _b;
  return ((_b = (_a = e4.match(t3)) == null ? void 0 : _a[1]) == null ? void 0 : _b.replace(/\\'/g, "'")) ?? null;
}
var t3 = /^hash\(\$feature\['((\\'|[^'])+)'\]\) \* 8\.381e-8$/;

// node_modules/@arcgis/core/renderers/visualVariables/ColorVariable.js
var i3;
var p5 = i3 = class extends c2 {
  constructor(t4) {
    super(t4), this.type = "color", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(t4) {
    t4 && Array.isArray(t4) && (t4 = t4.filter((t5) => !!t5)).sort((t5, s5) => t5.value - s5.value), this._set("stops", t4);
  }
  clone() {
    return new i3({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((t4) => t4.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((t4) => t4.value || 0);
  }
};
e2([y({ readOnly: true })], p5.prototype, "cache", null), e2([y({ type: ["color"], json: { type: ["colorInfo"] } })], p5.prototype, "type", void 0), e2([y({ type: String, json: { write: true } })], p5.prototype, "normalizationField", void 0), e2([y({ type: [a4], json: { write: true } })], p5.prototype, "stops", null), p5 = i3 = e2([a2("esri.renderers.visualVariables.ColorVariable")], p5);
var a6 = p5;

// node_modules/@arcgis/core/renderers/visualVariables/support/OpacityStop.js
var l4;
var u3 = l4 = class extends l2 {
  constructor(r4) {
    super(r4), this.label = null, this.opacity = null, this.value = null;
  }
  readOpacity(r4, t4) {
    return r3(t4.transparency);
  }
  writeOpacity(r4, t4, o3) {
    t4[o3] = n2(r4);
  }
  clone() {
    return new l4({ label: this.label, opacity: this.opacity, value: this.value });
  }
};
e2([y({ type: String, json: { write: true } })], u3.prototype, "label", void 0), e2([y({ type: Number, json: { type: T, write: { target: "transparency" } } })], u3.prototype, "opacity", void 0), e2([o("opacity", ["transparency"])], u3.prototype, "readOpacity", null), e2([r2("opacity")], u3.prototype, "writeOpacity", null), e2([y({ type: Number, json: { write: true } })], u3.prototype, "value", void 0), u3 = l4 = e2([a2("esri.renderers.visualVariables.support.OpacityStop")], u3);
var y2 = u3;

// node_modules/@arcgis/core/renderers/visualVariables/OpacityVariable.js
var i4;
var p6 = i4 = class extends c2 {
  constructor(t4) {
    super(t4), this.type = "opacity", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(t4) {
    t4 && Array.isArray(t4) && (t4 = t4.filter((t5) => !!t5)).sort((t5, s5) => t5.value - s5.value), this._set("stops", t4);
  }
  clone() {
    return new i4({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((t4) => t4.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((t4) => t4.value || 0);
  }
};
e2([y({ readOnly: true })], p6.prototype, "cache", null), e2([y({ type: ["opacity"], json: { type: ["transparencyInfo"] } })], p6.prototype, "type", void 0), e2([y({ type: String, json: { write: true } })], p6.prototype, "normalizationField", void 0), e2([y({ type: [y2], json: { write: true } })], p6.prototype, "stops", null), p6 = i4 = e2([a2("esri.renderers.visualVariables.OpacityVariable")], p6);
var a7 = p6;

// node_modules/@arcgis/core/renderers/visualVariables/RotationVariable.js
var p7;
var a8 = p7 = class extends c2 {
  constructor(e4) {
    super(e4), this.axis = null, this.type = "rotation", this.rotationType = "geographic", this.valueExpressionTitle = null;
  }
  get cache() {
    return { hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  writeValueExpressionTitleWebScene(e4, s5, o3, r4) {
    if (r4 && r4.messages) {
      const e5 = `visualVariables[${this.index}]`;
      r4.messages.push(new s2("property:unsupported", this.type + "VisualVariable.valueExpressionTitle is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: e5 + ".valueExpressionTitle", context: r4 }));
    }
  }
  clone() {
    return new p7({ axis: this.axis, rotationType: this.rotationType, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
};
e2([y({ readOnly: true })], a8.prototype, "cache", null), e2([y({ type: ["heading", "tilt", "roll"], json: { origins: { "web-scene": { default: "heading", write: true } } } })], a8.prototype, "axis", void 0), e2([y({ type: ["rotation"], json: { type: ["rotationInfo"] } })], a8.prototype, "type", void 0), e2([y({ type: ["geographic", "arithmetic"], json: { write: true, origins: { "web-document": { write: true, default: "geographic" } } } })], a8.prototype, "rotationType", void 0), e2([y({ type: String, json: { write: true } })], a8.prototype, "valueExpressionTitle", void 0), e2([r2("web-scene", "valueExpressionTitle")], a8.prototype, "writeValueExpressionTitleWebScene", null), a8 = p7 = e2([a2("esri.renderers.visualVariables.RotationVariable")], a8);
var n4 = a8;

// node_modules/@arcgis/core/renderers/visualVariables/VisualVariableFactory.js
var u4 = { color: a6, size: b2, opacity: a7, rotation: n4 };
var b4 = new s4({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" });
var h = /^\[([^\]]+)\]$/i;
var V = class extends v {
  constructor() {
    super(...arguments), this.colorVariables = null, this.opacityVariables = null, this.rotationVariables = null, this.sizeVariables = null;
  }
  set visualVariables(r4) {
    if (this._resetVariables(), (r4 = r4 && r4.filter((r5) => !!r5)) && r4.length) {
      for (const s5 of r4)
        switch (s5.type) {
          case "color":
            this.colorVariables.push(s5);
            break;
          case "opacity":
            this.opacityVariables.push(s5);
            break;
          case "rotation":
            this.rotationVariables.push(s5);
            break;
          case "size":
            this.sizeVariables.push(s5);
        }
      if (this.sizeVariables.length) {
        this.sizeVariables.some((r5) => !!r5.target) && r4.sort((r5, s5) => {
          let e4 = null;
          return e4 = r5.target === s5.target ? 0 : r5.target ? 1 : -1, e4;
        });
      }
      for (let s5 = 0; s5 < r4.length; s5++) {
        r4[s5].index = s5;
      }
      this._set("visualVariables", r4);
    } else
      this._set("visualVariables", r4);
  }
  readVariables(r4, s5, e4) {
    const { rotationExpression: a10, rotationType: i7 } = s5, l8 = a10 && a10.match(h), n7 = l8 && l8[1];
    if (n7 && (r4 || (r4 = []), r4.push({ type: "rotationInfo", rotationType: i7, field: n7 })), r4)
      return r4.map((r5) => {
        const s6 = b4.read(r5.type), a11 = u4[s6];
        a11 || (s.getLogger(this.declaredClass).warn(`Unknown variable type: ${s6}`), e4 && e4.messages && e4.messages.push(new t2("visual-variable:unsupported", `visualVariable of type '${s6}' is not supported`, { definition: r5, context: e4 })));
        const i8 = new a11();
        return i8.read(r5, e4), i8;
      });
  }
  writeVariables(r4, s5) {
    const e4 = [];
    for (const o3 of r4) {
      const r5 = o3.toJSON(s5);
      r5 && e4.push(r5);
    }
    return e4;
  }
  _resetVariables() {
    this.colorVariables = [], this.opacityVariables = [], this.rotationVariables = [], this.sizeVariables = [];
  }
};
e2([y()], V.prototype, "visualVariables", null), V = e2([a2("esri.renderers.visualVariables.VisualVariableFactory")], V);
var f2 = V;

// node_modules/@arcgis/core/renderers/mixins/VisualVariablesMixin.js
var v2 = { base: c2, key: "type", typeMap: { opacity: a7, color: a6, rotation: n4, size: b2 } };
var y3 = (a10) => {
  let u7 = class extends a10 {
    constructor() {
      super(...arguments), this._vvFactory = new f2();
    }
    set visualVariables(r4) {
      this._vvFactory.visualVariables = r4, this._set("visualVariables", this._vvFactory.visualVariables);
    }
    readVisualVariables(r4, a11, s5) {
      return this._vvFactory.readVariables(r4, a11, s5);
    }
    writeVisualVariables(r4, a11, s5, i7) {
      a11[s5] = this._vvFactory.writeVariables(r4, i7);
    }
    get arcadeRequiredForVisualVariables() {
      if (!this.visualVariables)
        return false;
      for (const r4 of this.visualVariables)
        if (r4.arcadeRequired)
          return true;
      return false;
    }
    hasVisualVariables(r4, a11) {
      return r4 ? this.getVisualVariablesForType(r4, a11).length > 0 : this.getVisualVariablesForType("size", a11).length > 0 || this.getVisualVariablesForType("color", a11).length > 0 || this.getVisualVariablesForType("opacity", a11).length > 0 || this.getVisualVariablesForType("rotation", a11).length > 0;
    }
    getVisualVariablesForType(r4, a11) {
      const s5 = this.visualVariables;
      return s5 ? s5.filter((s6) => s6.type === r4 && ("string" == typeof a11 ? s6.target === a11 : false !== a11 || !s6.target)) : [];
    }
    async collectVVRequiredFields(r4, a11) {
      let s5 = [];
      this.visualVariables && (s5 = s5.concat(this.visualVariables));
      for (const i7 of s5)
        i7 && (i7.field && w(r4, a11, i7.field), i7.normalizationField && w(r4, a11, i7.normalizationField), i7.valueExpression && (f3(i7.valueExpression, r4, a11) || await S2(r4, a11, i7.valueExpression)));
    }
  };
  return e2([y({ types: [v2], value: null, json: { write: true } })], u7.prototype, "visualVariables", null), e2([o("visualVariables", ["visualVariables", "rotationType", "rotationExpression"])], u7.prototype, "readVisualVariables", null), e2([r2("visualVariables")], u7.prototype, "writeVisualVariables", null), u7 = e2([a2("esri.renderers.mixins.VisualVariablesMixin")], u7), u7;
};
function f3(r4, s5, i7) {
  const e4 = e3(r4);
  return !!r(e4) && (w(s5, i7, e4), true);
}

// node_modules/@arcgis/core/renderers/support/commonProperties.js
var l5 = { types: M, json: { write: { writer: m3 }, origins: { "web-scene": { types: F, write: { writer: m3 }, read: { reader: u2({ types: F }) } } } } };
var y4 = { types: { base: a3, key: "type", typeMap: { "simple-fill": j.typeMap["simple-fill"], "picture-fill": j.typeMap["picture-fill"], "polygon-3d": j.typeMap["polygon-3d"] } }, json: { write: { writer: m3 }, origins: { "web-scene": { type: S, write: { writer: m3 } } } } };
var m4 = { cast: (e4) => null == e4 || "string" == typeof e4 || "number" == typeof e4 ? e4 : `${e4}`, json: { type: String, write: { writer: (e4, r4) => {
  r4.value = e4 == null ? void 0 : e4.toString();
} } } };

// node_modules/@arcgis/core/renderers/support/ClassBreakInfo.js
var i5;
var l6 = i5 = class extends l2 {
  constructor(s5) {
    super(s5), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new i5({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const s5 = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${s5}`;
  }
};
e2([y({ type: String, json: { write: true } })], l6.prototype, "description", void 0), e2([y({ type: String, json: { write: true } })], l6.prototype, "label", void 0), e2([y({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], l6.prototype, "minValue", void 0), e2([y({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], l6.prototype, "maxValue", void 0), e2([y(l5)], l6.prototype, "symbol", void 0), l6 = i5 = e2([a2("esri.renderers.support.ClassBreakInfo")], l6);
var a9 = l6;

// node_modules/@arcgis/core/renderers/ClassBreaksRenderer.js
var V2;
var E = "log";
var j3 = "percent-of-total";
var z = "field";
var w2 = new s4({ esriNormalizeByLog: E, esriNormalizeByPercentOfTotal: j3, esriNormalizeByField: z });
var T2 = b(a9);
var C = V2 = class extends y3(p4) {
  constructor(e4) {
    super(e4), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = true, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e4, s5, t4) {
    if (!Array.isArray(e4))
      return;
    let o3 = s5.minValue;
    return e4.map((e5) => {
      const s6 = new a9();
      return s6.read(e5, t4), null == s6.minValue && (s6.minValue = o3), null == s6.maxValue && (s6.maxValue = s6.minValue), o3 = s6.maxValue, s6;
    });
  }
  writeClassBreakInfos(e4, s5, t4, o3) {
    const i7 = e4.map((e5) => e5.write({}, o3));
    this._areClassBreaksConsecutive() && i7.forEach((e5) => delete e5.classMinValue), s5[t4] = i7;
  }
  castField(e4) {
    return null == e4 ? e4 : "function" == typeof e4 ? (s.getLogger(this.declaredClass).error(".field: field must be a string value"), null) : u(e4);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e4 = this._get("normalizationType");
    const s5 = !!this.normalizationField, t4 = null != this.normalizationTotal;
    return s5 || t4 ? (e4 = s5 && z || t4 && j3 || null, s5 && t4 && s.getLogger(this.declaredClass).warn("warning: both normalizationField and normalizationTotal are set!")) : e4 !== z && e4 !== j3 || (e4 = null), e4;
  }
  set normalizationType(e4) {
    this._set("normalizationType", e4);
  }
  addClassBreakInfo(e4, t4, i7) {
    let r4 = null;
    r4 = "number" == typeof e4 ? new a9({ minValue: e4, maxValue: t4, symbol: P(i7) }) : T2(p(e4)), this.classBreakInfos.push(r4), 1 === this.classBreakInfos.length && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e4, s5) {
    const t4 = this.classBreakInfos.length;
    for (let o3 = 0; o3 < t4; o3++) {
      const t5 = [this.classBreakInfos[o3].minValue, this.classBreakInfos[o3].maxValue];
      if (t5[0] === e4 && t5[1] === s5) {
        this.classBreakInfos.splice(o3, 1);
        break;
      }
    }
  }
  getBreakIndex(e4, s5) {
    return this.valueExpression && (t(s5) || t(s5.arcade)) && s.getLogger(this.declaredClass).warn(""), this.valueExpression ? this._getBreakIndexForExpression(e4, s5) : this._getBreakIndexForField(e4);
  }
  async getClassBreakInfo(e4, s5) {
    let t4 = s5;
    this.valueExpression && (t(s5) || t(s5.arcade)) && (t4 = { ...t4, arcade: await i2() });
    const o3 = this.getBreakIndex(e4, t4);
    return -1 !== o3 ? this.classBreakInfos[o3] : null;
  }
  getSymbol(e4, s5) {
    if (this.valueExpression && (t(s5) || t(s5.arcade)))
      return void s.getLogger(this.declaredClass).error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const t4 = this.getBreakIndex(e4, s5);
    return t4 > -1 ? this.classBreakInfos[t4].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e4, s5) {
    let t4 = s5;
    if (this.valueExpression && (t(s5) || t(s5.arcade))) {
      const e5 = await i2(), { arcadeUtils: s6 } = e5;
      s6.hasGeometryOperations(this.valueExpression) && await s6.enableGeometryOperations(), t4 = { ...t4, arcade: e5 };
    }
    const o3 = this.getBreakIndex(e4, t4);
    return o3 > -1 ? this.classBreakInfos[o3].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e4 = [];
    return this.classBreakInfos.forEach((s5) => {
      s5.symbol && e4.push(s5.symbol);
    }), this.defaultSymbol && e4.push(this.defaultSymbol), e4;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e4, s5) => e4 + s5.getAttributeHash(), "");
  }
  getMeshHash() {
    const e4 = JSON.stringify(this.backgroundFillSymbol), s5 = JSON.stringify(this.defaultSymbol), t4 = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e4}.${s5}.${this.classBreakInfos.reduce((e5, s6) => e5 + s6.getMeshHash(), "")}.${t4}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    return new V2({ field: this.field, backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(), defaultLabel: this.defaultLabel, defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: p(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: p(this.visualVariables), legendOptions: p(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e4, s5) {
    const t4 = [this.collectVVRequiredFields(e4, s5), this.collectSymbolFields(e4, s5)];
    await Promise.all(t4);
  }
  async collectSymbolFields(e4, s5) {
    const t4 = [...this.getSymbols().map((t5) => t5.collectRequiredFields(e4, s5)), S2(e4, s5, this.valueExpression)];
    w(e4, s5, this.field), w(e4, s5, this.normalizationField), await Promise.all(t4);
  }
  _getBreakIndexForExpression(e4, s5) {
    const { viewingMode: t4, scale: o3, spatialReference: i7, arcade: r4 } = l(s5, {}), { valueExpression: n7 } = this;
    let u7 = this._compiledValueExpression.valueExpression === n7 ? this._compiledValueExpression.compiledFunction : null;
    const c5 = e(r4).arcadeUtils;
    if (!u7) {
      const e5 = c5.createSyntaxTree(n7);
      u7 = c5.createFunction(e5), this._compiledValueExpression.compiledFunction = u7;
    }
    this._compiledValueExpression.valueExpression = n7;
    const p9 = c5.executeFunction(u7, c5.createExecContext(e4, c5.getViewInfo({ viewingMode: t4, scale: o3, spatialReference: i7 })));
    return this._getBreakIndexfromInfos(p9);
  }
  _getBreakIndexForField(e4) {
    const s5 = this.field, t4 = e4.attributes, o3 = this.normalizationType;
    let i7 = parseFloat(t4[s5]);
    if (o3) {
      const e5 = this.normalizationTotal, s6 = parseFloat(this.normalizationField ? t4[this.normalizationField] : void 0);
      if (o3 === E)
        i7 = Math.log(i7) * Math.LOG10E;
      else if (o3 !== j3 || null == e5 || isNaN(e5)) {
        if (o3 === z && !isNaN(s6)) {
          if (isNaN(i7) || isNaN(s6))
            return -1;
          i7 /= s6;
        }
      } else
        i7 = i7 / e5 * 100;
    }
    return this._getBreakIndexfromInfos(i7);
  }
  _getBreakIndexfromInfos(e4) {
    const s5 = this.isMaxInclusive;
    if (null != e4 && "number" == typeof e4 && !isNaN(e4))
      for (let t4 = 0; t4 < this.classBreakInfos.length; t4++) {
        const o3 = [this.classBreakInfos[t4].minValue, this.classBreakInfos[t4].maxValue];
        if (o3[0] <= e4 && (s5 ? e4 <= o3[1] : e4 < o3[1]))
          return t4;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e4 = this.classBreakInfos, s5 = e4.length;
    for (let t4 = 1; t4 < s5; t4++)
      if (e4[t4 - 1].maxValue !== e4[t4].minValue)
        return false;
    return true;
  }
};
e2([y(y4)], C.prototype, "backgroundFillSymbol", void 0), e2([y({ type: [a9] })], C.prototype, "classBreakInfos", void 0), e2([o("classBreakInfos")], C.prototype, "readClassBreakInfos", null), e2([r2("classBreakInfos")], C.prototype, "writeClassBreakInfos", null), e2([y({ type: String, json: { write: true } })], C.prototype, "defaultLabel", void 0), e2([y(l5)], C.prototype, "defaultSymbol", void 0), e2([y({ type: String, json: { write: true } })], C.prototype, "field", void 0), e2([s3("field")], C.prototype, "castField", null), e2([y({ type: Boolean })], C.prototype, "isMaxInclusive", void 0), e2([y({ type: p3, json: { write: true } })], C.prototype, "legendOptions", void 0), e2([y({ type: Number, readOnly: true, value: null, json: { read: false, write: { overridePolicy() {
  return 0 !== this.classBreakInfos.length && this._areClassBreaksConsecutive() ? { enabled: true } : { enabled: false };
} } } })], C.prototype, "minValue", null), e2([y({ type: String, json: { write: true } })], C.prototype, "normalizationField", void 0), e2([y({ type: Number, cast: (e4) => a(e4), json: { write: true } })], C.prototype, "normalizationTotal", void 0), e2([y({ type: w2.apiValues, value: null, json: { type: w2.jsonValues, read: w2.read, write: w2.write } })], C.prototype, "normalizationType", null), e2([o2({ classBreaks: "class-breaks" })], C.prototype, "type", void 0), e2([y({ type: String, json: { write: true } })], C.prototype, "valueExpression", void 0), e2([y({ type: String, json: { write: true } })], C.prototype, "valueExpressionTitle", void 0), C = V2 = e2([a2("esri.renderers.ClassBreaksRenderer")], C);
var _ = C;

// node_modules/@arcgis/core/renderers/support/UniqueValue.js
var u5 = class extends i(l2) {
  constructor(o3) {
    super(o3), this.value = null, this.value2 = null, this.value3 = null;
  }
};
e2([y(m4)], u5.prototype, "value", void 0), e2([y(m4)], u5.prototype, "value2", void 0), e2([y(m4)], u5.prototype, "value3", void 0), u5 = e2([a2("esri.renderers.support.UniqueValue")], u5);
var c3 = u5;

// node_modules/@arcgis/core/renderers/support/UniqueValueClass.js
var n5 = class extends i(l2) {
  constructor(r4) {
    super(r4), this.description = null, this.label = null, this.symbol = null, this.values = null;
  }
  castValues(r4) {
    if (null == r4)
      return null;
    const o3 = typeof (r4 = Array.isArray(r4) ? r4 : [r4])[0];
    return "string" === o3 || "number" === o3 ? r4.map((r5) => new c3({ value: r5 })) : "object" === o3 ? r4[0] instanceof c3 ? r4 : r4.map((r5) => new c3(r5)) : null;
  }
};
e2([y({ type: String, json: { write: true } })], n5.prototype, "description", void 0), e2([y({ type: String, json: { write: true } })], n5.prototype, "label", void 0), e2([y(l5)], n5.prototype, "symbol", void 0), e2([y({ type: [c3], json: { type: [[String]], read: { reader: (r4) => r4 ? r4.map((r5) => new c3({ value: r5[0], value2: r5[1], value3: r5[2] })) : null }, write: { writer: (r4, o3) => {
  const e4 = [];
  for (const s5 of r4) {
    const r5 = [s5.value, s5.value2, s5.value3].filter(r).map((r6) => r6.toString());
    e4.push(r5);
  }
  o3.values = e4;
} } } })], n5.prototype, "values", void 0), e2([s3("values")], n5.prototype, "castValues", null), n5 = e2([a2("esri.renderers.support.UniqueValueClass")], n5);
var u6 = n5;

// node_modules/@arcgis/core/renderers/support/UniqueValueGroup.js
var c4 = class extends i(l2) {
  constructor(r4) {
    super(r4), this.heading = null, this.classes = null;
  }
};
e2([y({ type: String, json: { write: true } })], c4.prototype, "heading", void 0), e2([y({ type: [u6], json: { write: true } })], c4.prototype, "classes", void 0), c4 = e2([a2("esri.renderers.support.UniqueValueGroup")], c4);
var i6 = c4;

// node_modules/@arcgis/core/renderers/support/UniqueValueInfo.js
var l7;
var p8 = l7 = class extends l2 {
  constructor(o3) {
    super(o3), this.description = null, this.label = null, this.symbol = null, this.value = null;
  }
  clone() {
    return new l7({ value: this.value, description: this.description, label: this.label, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const o3 = JSON.stringify(this.symbol && this.symbol.toJSON());
    return `${this.value}.${o3}`;
  }
};
e2([y({ type: String, json: { write: true } })], p8.prototype, "description", void 0), e2([y({ type: String, json: { write: true } })], p8.prototype, "label", void 0), e2([y(l5)], p8.prototype, "symbol", void 0), e2([y(m4)], p8.prototype, "value", void 0), p8 = l7 = e2([a2("esri.renderers.support.UniqueValueInfo")], p8);
var n6 = p8;

// node_modules/@arcgis/core/renderers/UniqueValueRenderer.js
var R;
var P2 = "esri.renderers.UniqueValueRenderer";
var C2 = s.getLogger(P2);
var $ = "uvInfos-watcher";
var z2 = "uvGroups-watcher";
var k = ",";
var A = b(n6);
function H(e4) {
  const { field1: t4, field2: s5, field3: i7, fieldDelimiter: o3, uniqueValueInfos: l8, valueExpression: r4 } = e4, u7 = !(!t4 || !s5);
  return [{ classes: (l8 ?? []).map((e5) => {
    var _a;
    const { symbol: l9, label: n7, value: a10, description: p9 } = e5, [f4, d, c5] = u7 ? ((_a = a10 == null ? void 0 : a10.toString()) == null ? void 0 : _a.split(o3 || "")) || [] : [a10], h2 = [];
    return (t4 || r4) && h2.push(f4), s5 && h2.push(d), i7 && h2.push(c5), { symbol: l9, label: n7, values: [h2], description: p9 };
  }) }];
}
var L = R = class extends y3(p4) {
  constructor(e4) {
    super(e4), this._valueInfoMap = {}, this._isDefaultSymbolDerived = false, this._isInfosSource = null, this.type = "unique-value", this.backgroundFillSymbol = null, this.orderByClassesEnabled = false, this.valueExpressionTitle = null, this.legendOptions = null, this.defaultLabel = null, this.portal = null, this.styleOrigin = null, this.diff = { uniqueValueInfos(e5, t4) {
      if (!e5 && !t4)
        return;
      if (!e5 || !t4)
        return { type: "complete", oldValue: e5, newValue: t4 };
      let s5 = false;
      const i7 = { type: "collection", added: [], removed: [], changed: [], unchanged: [] };
      for (let o3 = 0; o3 < t4.length; o3++) {
        const l8 = e5.find((e6) => e6.value === t4[o3].value);
        l8 ? m2(l8, t4[o3]) ? (i7.changed.push({ type: "complete", oldValue: l8, newValue: t4[o3] }), s5 = true) : i7.unchanged.push({ oldValue: l8, newValue: t4[o3] }) : (i7.added.push(t4[o3]), s5 = true);
      }
      for (let o3 = 0; o3 < e5.length; o3++) {
        t4.find((t5) => t5.value === e5[o3].value) || (i7.removed.push(e5[o3]), s5 = true);
      }
      return s5 ? i7 : void 0;
    } }, this._set("uniqueValueInfos", []), this._set("uniqueValueGroups", []);
  }
  get _cache() {
    return { compiledFunc: null };
  }
  set field(e4) {
    this._set("field", e4), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  castField(e4) {
    return null == e4 || "function" == typeof e4 ? e4 : u(e4);
  }
  writeField(e4, t4, i7, o3) {
    "string" == typeof e4 ? t4[i7] = e4 : o3 && o3.messages ? o3.messages.push(new s2("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : C2.error(".field: cannot write field to JSON since it's not a string value");
  }
  set field2(e4) {
    this._set("field2", e4), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  set field3(e4) {
    this._set("field3", e4), this._updateUniqueValues();
  }
  set valueExpression(e4) {
    this._set("valueExpression", e4), this._updateUniqueValues();
  }
  set defaultSymbol(e4) {
    this._isDefaultSymbolDerived = false, this._set("defaultSymbol", e4);
  }
  set fieldDelimiter(e4) {
    this._set("fieldDelimiter", e4), this._updateUniqueValues();
  }
  readPortal(e4, t4, s5) {
    return s5.portal || b3.getDefault();
  }
  readStyleOrigin(e4, t4, s5) {
    if (t4.styleName)
      return Object.freeze({ styleName: t4.styleName });
    if (t4.styleUrl) {
      const e5 = c(t4.styleUrl, s5);
      return Object.freeze({ styleUrl: e5 });
    }
  }
  writeStyleOrigin(e4, t4, s5, i7) {
    e4.styleName ? t4.styleName = e4.styleName : e4.styleUrl && (t4.styleUrl = m(e4.styleUrl, i7));
  }
  set uniqueValueGroups(e4) {
    this.styleOrigin ? C2.error("#uniqueValueGroups=", "Cannot modify unique value groups of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueGroups", e4), this._updateInfosFromGroups(), this._isInfosSource = false, this._watchUniqueValueGroups());
  }
  set uniqueValueInfos(e4) {
    this.styleOrigin ? C2.error("#uniqueValueInfos=", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", e4), this._updateValueInfoMap(), this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos());
  }
  addUniqueValueInfo(e4, s5) {
    var _a;
    if (this.styleOrigin)
      return void C2.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    let i7;
    i7 = "object" == typeof e4 ? A(e4) : new n6({ value: e4, symbol: P(s5) }), (_a = this.uniqueValueInfos) == null ? void 0 : _a.push(i7), this._valueInfoMap[i7.value] = i7, this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos();
  }
  removeUniqueValueInfo(e4) {
    if (this.styleOrigin)
      return void C2.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    const t4 = this.uniqueValueInfos;
    if (t4)
      for (let s5 = 0; s5 < t4.length; s5++) {
        if (t4[s5].value === e4 + "") {
          delete this._valueInfoMap[e4], t4.splice(s5, 1);
          break;
        }
      }
    this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos();
  }
  async getUniqueValueInfo(e4, t4) {
    let s5 = t4;
    return this.valueExpression && (t(t4) || t(t4.arcade)) && (s5 = { ...s5, arcade: await i2() }), this._getUniqueValueInfo(e4, s5);
  }
  getSymbol(e4, t4) {
    if (this.valueExpression && (t(t4) || t(t4.arcade)))
      return void C2.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const s5 = this._getUniqueValueInfo(e4, t4);
    return s5 && s5.symbol || this.defaultSymbol;
  }
  async getSymbolAsync(e4, t4) {
    let s5 = t4;
    if (this.valueExpression && (t(s5) || t(s5.arcade))) {
      const e5 = await i2(), { arcadeUtils: t5 } = e5;
      t5.hasGeometryOperations(this.valueExpression) && await t5.enableGeometryOperations(), s5 = { ...s5, arcade: e5 };
    }
    const i7 = this._getUniqueValueInfo(e4, s5);
    return i7 && i7.symbol || this.defaultSymbol;
  }
  getSymbols() {
    const e4 = [];
    for (const t4 of this.uniqueValueInfos ?? [])
      t4.symbol && e4.push(t4.symbol);
    return this.defaultSymbol && e4.push(this.defaultSymbol), e4;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e4, t4) => e4 + t4.getAttributeHash(), "");
  }
  getMeshHash() {
    var _a;
    const e4 = JSON.stringify(this.backgroundFillSymbol), t4 = JSON.stringify(this.defaultSymbol), s5 = (_a = this.uniqueValueInfos) == null ? void 0 : _a.reduce((e5, t5) => e5 + t5.getMeshHash(), "");
    return `${e4}.${t4}.${s5}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`;
  }
  clone() {
    const e4 = new R({ field: this.field, field2: this.field2, field3: this.field3, defaultLabel: this.defaultLabel, defaultSymbol: p(this.defaultSymbol), orderByClassesEnabled: this.orderByClassesEnabled, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, fieldDelimiter: this.fieldDelimiter, visualVariables: p(this.visualVariables), legendOptions: p(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone(), backgroundFillSymbol: p(this.backgroundFillSymbol) });
    this._isDefaultSymbolDerived && (e4._isDefaultSymbolDerived = true), e4._set("portal", this.portal);
    const t4 = p(this.uniqueValueInfos), s5 = p(this.uniqueValueGroups);
    return this.styleOrigin && (e4._set("styleOrigin", Object.freeze(p(this.styleOrigin))), Object.freeze(t4), Object.freeze(s5)), e4._set("uniqueValueInfos", t4), e4._updateValueInfoMap(), e4._set("uniqueValueGroups", s5), e4._isInfosSource = this._isInfosSource, e4._watchUniqueValueInfosAndGroups(), e4;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  async collectRequiredFields(e4, t4) {
    const s5 = [this.collectVVRequiredFields(e4, t4), this.collectSymbolFields(e4, t4)];
    await Promise.all(s5);
  }
  async collectSymbolFields(e4, t4) {
    const s5 = [...this.getSymbols().map((s6) => s6.collectRequiredFields(e4, t4)), S2(e4, t4, this.valueExpression)];
    w(e4, t4, this.field), w(e4, t4, this.field2), w(e4, t4, this.field3), await Promise.all(s5);
  }
  populateFromStyle() {
    return p2(this.styleOrigin, { portal: this.portal }).then((e4) => {
      var _a;
      const t4 = [];
      return this._valueInfoMap = {}, e4 && e4.data && Array.isArray(e4.data.items) && e4.data.items.forEach((s5) => {
        const i7 = new f({ styleUrl: e4.styleUrl, styleName: e4.styleName, portal: this.portal, name: s5.name });
        this.defaultSymbol || s5.name !== e4.data.defaultItem || (this.defaultSymbol = i7, this._isDefaultSymbolDerived = true);
        const o3 = new n6({ value: s5.name, symbol: i7 });
        t4.push(o3), this._valueInfoMap[s5.name] = o3;
      }), this._set("uniqueValueInfos", Object.freeze(t4)), this._updateGroupsFromInfos(true), this._isInfosSource = null, this._watchUniqueValueInfos(), !this.defaultSymbol && ((_a = this.uniqueValueInfos) == null ? void 0 : _a.length) && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = true), this;
    });
  }
  _updateFieldDelimiter() {
    this.field && this.field2 && !this.fieldDelimiter && this._set("fieldDelimiter", k);
  }
  _updateUniqueValues() {
    null != this._isInfosSource && (this._isInfosSource ? this._updateGroupsFromInfos() : this._updateInfosFromGroups());
  }
  _updateValueInfoMap() {
    this._valueInfoMap = {};
    const { uniqueValueInfos: e4 } = this;
    if (e4)
      for (const t4 of e4)
        this._valueInfoMap[t4.value + ""] = t4;
  }
  _watchUniqueValueInfosAndGroups() {
    this._watchUniqueValueInfos(), this._watchUniqueValueGroups();
  }
  _watchUniqueValueInfos() {
    this.removeHandles($);
    const { uniqueValueInfos: e4 } = this;
    if (e4) {
      const t4 = [];
      for (const s5 of e4)
        t4.push(l3(() => ({ symbol: s5.symbol, value: s5.value, label: s5.label, description: s5.description }), (e5, t5) => {
          e5 !== t5 && (this._updateGroupsFromInfos(), this._isInfosSource = true);
        }, { sync: true }));
      this.addHandles(t4, $);
    }
  }
  _watchUniqueValueGroups() {
    this.removeHandles(z2);
    const { uniqueValueGroups: e4 } = this;
    if (e4) {
      const t4 = [];
      for (const s5 of e4) {
        t4.push(l3(() => ({ classes: s5.classes }), (e5, t5) => {
          e5 !== t5 && (this._updateInfosFromGroups(), this._isInfosSource = false);
        }, { sync: true }));
        for (const e5 of s5.classes ?? [])
          t4.push(l3(() => ({ symbol: e5.symbol, values: e5.values, label: e5.label, description: e5.description }), (e6, t5) => {
            e6 !== t5 && (this._updateInfosFromGroups(), this._isInfosSource = false);
          }, { sync: true }));
      }
      this.addHandles(t4, z2);
    }
  }
  _updateInfosFromGroups() {
    if (!this.uniqueValueGroups)
      return this._set("uniqueValueInfos", null), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const e4 = [], { field: t4, field2: s5, field3: i7, fieldDelimiter: o3, uniqueValueGroups: l8, valueExpression: r4 } = this;
    if (!t4 && !r4)
      return this._set("uniqueValueInfos", e4), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const u7 = !(!t4 || !s5);
    for (const n7 of l8)
      for (const t5 of n7.classes ?? []) {
        const { symbol: l9, label: r5, values: n8, description: a10 } = t5;
        for (const t6 of n8 ?? []) {
          const { value: n9, value2: p9, value3: f4 } = t6, d = [n9];
          s5 && d.push(p9), i7 && d.push(f4);
          const c5 = u7 ? d.join(o3 || "") : d[0];
          e4.push(new n6({ symbol: l9, label: r5, value: c5, description: a10 }));
        }
      }
    this._set("uniqueValueInfos", e4), this._updateValueInfoMap(), this._watchUniqueValueInfos();
  }
  _updateGroupsFromInfos(e4 = false) {
    if (!this.uniqueValueInfos)
      return this._set("uniqueValueGroups", null), void this._watchUniqueValueGroups();
    const { field: t4, field2: s5, valueExpression: i7, fieldDelimiter: o3, uniqueValueInfos: l8 } = this;
    if (!t4 && !i7 || !l8.length)
      return this._set("uniqueValueGroups", []), void this._watchUniqueValueGroups();
    const r4 = !(!t4 || !s5), u7 = l8.map((e5) => {
      var _a;
      const { symbol: t5, label: s6, value: i8, description: l9 } = e5, [u8, n8, a10] = r4 ? ((_a = i8 == null ? void 0 : i8.toString()) == null ? void 0 : _a.split(o3 || "")) || [] : [i8];
      return new u6({ symbol: t5, label: s6, description: l9, values: [new c3({ value: u8, value2: n8, value3: a10 })] });
    }), n7 = [new i6({ classes: u7 })];
    e4 && Object.freeze(n7), this._set("uniqueValueGroups", n7), this._watchUniqueValueGroups();
  }
  _getUniqueValueInfo(e4, t4) {
    return this.valueExpression ? this._getUnqiueValueInfoForExpression(e4, t4) : this._getUnqiueValueInfoForFields(e4);
  }
  _getUnqiueValueInfoForExpression(e4, t4) {
    const { viewingMode: s5, scale: i7, spatialReference: o3, arcade: l8 } = l(t4, {});
    let n7 = this._cache.compiledFunc;
    const a10 = e(l8).arcadeUtils;
    if (!n7) {
      const e5 = a10.createSyntaxTree(this.valueExpression);
      n7 = a10.createFunction(e5), this._cache.compiledFunc = n7;
    }
    const p9 = a10.executeFunction(n7, a10.createExecContext(e4, a10.getViewInfo({ viewingMode: s5, scale: i7, spatialReference: o3 })));
    return this._valueInfoMap[p9 + ""];
  }
  _getUnqiueValueInfoForFields(e4) {
    const t4 = this.field, s5 = e4.attributes;
    let i7;
    if ("function" != typeof t4 && this.field2) {
      const e5 = this.field2, o3 = this.field3, l8 = [];
      t4 && l8.push(s5[t4]), e5 && l8.push(s5[e5]), o3 && l8.push(s5[o3]), i7 = l8.join(this.fieldDelimiter || "");
    } else
      "function" == typeof t4 ? i7 = t4(e4) : t4 && (i7 = s5[t4]);
    return this._valueInfoMap[i7 + ""];
  }
  static fromPortalStyle(e4, t4) {
    const s5 = new R(t4 && t4.properties);
    s5._set("styleOrigin", Object.freeze({ styleName: e4 })), s5._set("portal", t4 && t4.portal || b3.getDefault());
    const i7 = s5.populateFromStyle();
    return i7.catch((t5) => {
      C2.error(`#fromPortalStyle('${e4}'[, ...])`, "Failed to create unique value renderer from style name", t5);
    }), i7;
  }
  static fromStyleUrl(e4, t4) {
    const s5 = new R(t4 && t4.properties);
    s5._set("styleOrigin", Object.freeze({ styleUrl: e4 }));
    const i7 = s5.populateFromStyle();
    return i7.catch((t5) => {
      C2.error(`#fromStyleUrl('${e4}'[, ...])`, "Failed to create unique value renderer from style URL", t5);
    }), i7;
  }
};
e2([y({ readOnly: true })], L.prototype, "_cache", null), e2([o2({ uniqueValue: "unique-value" })], L.prototype, "type", void 0), e2([y(y4)], L.prototype, "backgroundFillSymbol", void 0), e2([y({ value: null, json: { type: String, read: { source: "field1" }, write: { target: "field1" } } })], L.prototype, "field", null), e2([s3("field")], L.prototype, "castField", null), e2([r2("field")], L.prototype, "writeField", null), e2([y({ type: String, value: null, json: { write: true } })], L.prototype, "field2", null), e2([y({ type: String, value: null, json: { write: true } })], L.prototype, "field3", null), e2([y({ type: Boolean, json: { name: "drawInClassOrder", default: false, write: true, origins: { "web-scene": { write: false } } } })], L.prototype, "orderByClassesEnabled", void 0), e2([y({ type: String, value: null, json: { write: true } })], L.prototype, "valueExpression", null), e2([y({ type: String, json: { write: true } })], L.prototype, "valueExpressionTitle", void 0), e2([y({ type: p3, json: { write: true } })], L.prototype, "legendOptions", void 0), e2([y({ type: String, json: { write: true } })], L.prototype, "defaultLabel", void 0), e2([y(n({ ...l5 }, { json: { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} }, origins: { "web-scene": { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} } } } } }))], L.prototype, "defaultSymbol", null), e2([y({ type: String, value: null, json: { write: true } })], L.prototype, "fieldDelimiter", null), e2([y({ type: b3, readOnly: true })], L.prototype, "portal", void 0), e2([o("portal", ["styleName"])], L.prototype, "readPortal", null), e2([y({ readOnly: true, json: { write: { enabled: false, overridePolicy: () => ({ enabled: true }) } } })], L.prototype, "styleOrigin", void 0), e2([o("styleOrigin", ["styleName", "styleUrl"])], L.prototype, "readStyleOrigin", null), e2([r2("styleOrigin", { styleName: { type: String }, styleUrl: { type: String } })], L.prototype, "writeStyleOrigin", null), e2([y({ type: [i6], json: { read: { source: ["uniqueValueGroups", "uniqueValueInfos"], reader: (e4, t4, s5) => (t4.uniqueValueGroups || H(t4)).map((e5) => i6.fromJSON(e5, s5)) }, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: false } : { enabled: true };
} } } })], L.prototype, "uniqueValueGroups", null), e2([y({ type: [n6], json: { read: false, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: false } : { enabled: true };
} } } })], L.prototype, "uniqueValueInfos", null), L = R = e2([a2(P2)], L);
var T3 = L;

export {
  p4 as p,
  n4 as n,
  y3 as y,
  l5 as l,
  a9 as a,
  _,
  n6 as n2,
  T3 as T
};
//# sourceMappingURL=chunk-CV32ONPW.js.map

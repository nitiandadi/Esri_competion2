import {
  n as n3
} from "./chunk-HERKGCCA.js";
import {
  c as c2,
  e,
  i as i3,
  n as n2,
  o
} from "./chunk-SB6UPWEY.js";
import {
  q
} from "./chunk-ZE4I5TQG.js";
import {
  p,
  y
} from "./chunk-VY77CAXT.js";
import {
  i as i2,
  n2 as n
} from "./chunk-4VWW5UU4.js";
import {
  U
} from "./chunk-JU2WP2RZ.js";
import {
  r
} from "./chunk-NI6ENKKR.js";
import {
  l
} from "./chunk-NXJOIK2O.js";
import {
  s3 as s
} from "./chunk-YVZY5LDV.js";
import {
  has
} from "./chunk-H32MMKAJ.js";
import {
  c,
  i
} from "./chunk-HVCAHUYB.js";

// node_modules/@arcgis/core/symbols/support/svgUtils.js
var f = "http://www.w3.org/2000/svg";
var c3 = 0;
var d = 0;
var u = has("android");
var y2 = has("chrome") || u && u >= 4 ? "auto" : "optimizeLegibility";
var p2 = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0 };
var g = /([A-DF-Za-df-z])|([-+]?\d*[.]?\d+(?:[eE][-+]?\d+)?)/g;
var m = {};
var x = {};
var w = { solid: "none", shortdash: [4, 1], shortdot: [1, 1], shortdashdot: [4, 1, 1, 1], shortdashdotdot: [4, 1, 1, 1, 1, 1], dot: [1, 3], dash: [4, 3], longdash: [8, 3], dashdot: [4, 3, 1, 3], longdashdot: [8, 3, 1, 3], longdashdotdot: [8, 3, 1, 3, 1, 3] };
var k = Math.PI;
var b = 1;
function j(t, e2) {
  const i4 = t * (k / 180);
  return Math.abs(e2 * Math.sin(i4)) + Math.abs(e2 * Math.cos(i4));
}
function v(t) {
  return t.map((t2) => `${t2.command} ${t2.values.join(" ")}`).join(" ").trim();
}
function M(t, i4, n4, r2) {
  if (t) {
    if ("circle" === t.type)
      return n("circle", { fill: i4, "fill-rule": "evenodd", stroke: n4.color, "stroke-width": n4.width, "stroke-linecap": n4.cap, "stroke-linejoin": n4.join, "stroke-dasharray": n4.dashArray, "stroke-dashoffset": n4.dashOffset, "stroke-miterlimit": "4", cx: t.cx, cy: t.cy, r: t.r });
    if ("ellipse" === t.type)
      return n("ellipse", { fill: i4, "fill-rule": "evenodd", stroke: n4.color, "stroke-width": n4.width, "stroke-linecap": n4.cap, "stroke-linejoin": n4.join, "stroke-dasharray": n4.dashArray, "stroke-miterlimit": "4", cx: t.cx, cy: t.cy, rx: t.rx, ry: t.ry });
    if ("rect" === t.type)
      return n("rect", { fill: i4, "fill-rule": "evenodd", stroke: n4.color, "stroke-width": n4.width, "stroke-linecap": n4.cap, "stroke-linejoin": n4.join, "stroke-dasharray": n4.dashArray, "stroke-miterlimit": "4", x: t.x, y: t.y, width: t.width, height: t.height });
    if ("image" === t.type)
      return n("image", { href: t.src, x: t.x, y: t.y, width: t.width, height: t.height, preserveAspectRatio: "none" });
    if ("path" === t.type) {
      const e2 = "string" != typeof t.path ? v(t.path) : t.path;
      return n("path", { fill: i4, "fill-rule": "evenodd", stroke: n4.color, "stroke-width": n4.width, "stroke-linecap": n4.cap, "stroke-linejoin": n4.join, "stroke-dasharray": n4.dashArray, "stroke-miterlimit": "4", d: e2 });
    }
    if ("text" === t.type)
      return i(r2), n("text", { "dominant-baseline": r2.dominantBaseline, fill: i4, "fill-rule": "evenodd", stroke: n4.color, "stroke-width": n4.width, "stroke-linecap": n4.cap, "stroke-linejoin": n4.join, "stroke-dasharray": n4.dashArray, "stroke-miterlimit": "4", "text-anchor": r2.align, "text-decoration": r2.decoration, kerning: r2.kerning, rotate: r2.rotate, "text-rendering": y2, "font-style": r2.font.style, "font-variant": r2.font.variant, "font-weight": r2.font.weight, "font-size": r2.font.size, "font-family": r2.font.family, x: t.x, y: t.y }, t.text);
  }
  return null;
}
function A(e2) {
  const i4 = { fill: "none", pattern: null, linearGradient: null };
  if (e2) {
    if ("type" in e2 && "pattern" === e2.type) {
      const t = "patternId-" + ++c3;
      i4.fill = `url(#${t})`, i4.pattern = { id: t, x: e2.x, y: e2.y, width: e2.width, height: e2.height, image: { x: 0, y: 0, width: e2.width, height: e2.height, href: e2.src } };
    } else if ("type" in e2 && "linear" === e2.type) {
      const n4 = "linearGradientId-" + ++d;
      i4.fill = `url(#${n4})`, i4.linearGradient = { id: n4, x1: e2.x1, y1: e2.y1, x2: e2.x2, y2: e2.y2, stops: e2.colors.map((e3) => ({ offset: e3.offset, color: e3.color && new l(e3.color).toString() })) };
    } else if (e2) {
      const n4 = new l(e2);
      i4.fill = n4.toString();
    }
  }
  return i4;
}
function S(e2) {
  const i4 = { color: "none", width: 1, cap: "butt", join: "4", dashArray: "none", dashOffset: "0" };
  if (e2 && (null != e2.width && (i4.width = e2.width), e2.cap && (i4.cap = e2.cap), e2.join && (i4.join = e2.join.toString()), e2.color && (i4.color = new l(e2.color).toString()), e2.dashArray && (i4.dashArray = e2.dashArray), e2.dashArray && (i4.dashOffset = e2.dashoffset), e2.style)) {
    let t = null;
    if (e2.style in w && (t = w[e2.style]), Array.isArray(t)) {
      t = t.slice(0);
      const i5 = e2.width ?? 0;
      for (let e3 = 0; e3 < t.length; ++e3)
        t[e3] *= i5;
      if ("butt" !== e2.cap) {
        for (let e3 = 0; e3 < t.length; e3 += 2)
          t[e3] -= i5, t[e3] < 1 && (t[e3] = 1);
        for (let e3 = 1; e3 < t.length; e3 += 2)
          t[e3] += i5;
      }
      t = t.join(",");
    }
    i4.dashArray = t;
  }
  return i4;
}
function $(t, i4) {
  const n4 = { align: null, decoration: null, kerning: null, rotate: null, font: { style: null, variant: null, weight: null, size: null, family: null } };
  if (t) {
    const r2 = t.alignBaseline, o2 = "baseline" === r2 ? "auto" : "top" === r2 ? "text-top" : "bottom" === r2 ? "hanging" : r2;
    n4.align = t.align, n4.dominantBaseline = o2, n4.decoration = t.decoration, n4.kerning = t.kerning ? "auto" : "0", n4.rotate = t.rotated ? "90" : "0", i(i4), n4.font.style = i4.style || "normal", n4.font.variant = i4.variant || "normal", n4.font.weight = i4.weight || "normal", n4.font.size = i4.size && i4.size.toString() || "10pt", n4.font.family = i4.family || "serif";
  }
  return n4;
}
function N(t) {
  const { pattern: e2, linearGradient: i4 } = t;
  if (e2)
    return n("pattern", { id: e2.id, patternUnits: "userSpaceOnUse", x: e2.x, y: e2.y, width: e2.width, height: e2.height }, n("image", { x: e2.image.x, y: e2.image.y, width: e2.image.width, height: e2.image.height, href: e2.image.href }));
  if (i4) {
    const t2 = i4.stops.map((t3, e3) => n("stop", { key: `${e3}-stop`, offset: t3.offset, "stop-color": t3.color }));
    return n("linearGradient", { id: i4.id, gradientUnits: "userSpaceOnUse", x1: i4.x1, y1: i4.y1, x2: i4.x2, y2: i4.y2 }, t2);
  }
  return null;
}
function G(t, e2) {
  if (!t)
    return null;
  const i4 = [];
  for (const n4 of t) {
    const { shape: t2, fill: e3, stroke: r2, font: o2 } = n4, s3 = A(e3), a = S(r2), l3 = "text" === t2.type ? $(t2, o2) : null, h2 = M(t2, s3.fill, a, l3);
    h2 && i4.push(h2);
  }
  return n("mask", { id: e2, maskUnits: "userSpaceOnUse" }, n("g", null, i4));
}
function I(t, e2, i4) {
  return i3(t, n2(t), [e2, i4]);
}
function z(t, e2, i4, n4, r2) {
  return c2(t, n2(t), [e2, i4]), t[4] = t[4] * e2 - n4 * e2 + n4, t[5] = t[5] * i4 - r2 * i4 + r2, t;
}
function B(t, e2, i4, n4) {
  const r2 = e2 % 360 * Math.PI / 180;
  e(t, n2(t), r2);
  const o2 = Math.cos(r2), a = Math.sin(r2), h2 = t[4], f3 = t[5];
  return t[4] = h2 * o2 - f3 * a + n4 * a - i4 * o2 + i4, t[5] = f3 * o2 + h2 * a - i4 * a - n4 * o2 + n4, t;
}
function U2(t, e2) {
  m && "left" in m ? (null != m.left && m.left > t && (m.left = t), (null == m.right || m.right < t) && (m.right = t), (null == m.top || m.top > e2) && (m.top = e2), (null == m.bottom || m.bottom < e2) && (m.bottom = e2)) : m = { left: t, bottom: e2, right: t, top: e2 };
}
function F(t) {
  const e2 = t.args, i4 = e2.length;
  let n4;
  switch (t.action) {
    case "M":
    case "L":
    case "C":
    case "S":
    case "Q":
    case "T":
      for (n4 = 0; n4 < i4; n4 += 2)
        U2(e2[n4], e2[n4 + 1]);
      x.x = e2[i4 - 2], x.y = e2[i4 - 1];
      break;
    case "H":
      for (n4 = 0; n4 < i4; ++n4)
        U2(e2[n4], x.y);
      x.x = e2[i4 - 1];
      break;
    case "V":
      for (n4 = 0; n4 < i4; ++n4)
        U2(x.x, e2[n4]);
      x.y = e2[i4 - 1];
      break;
    case "m": {
      let t2 = 0;
      "x" in x || (U2(x.x = e2[0], x.y = e2[1]), t2 = 2);
      for (n4 = t2; n4 < i4; n4 += 2)
        U2(x.x += e2[n4], x.y += e2[n4 + 1]);
      break;
    }
    case "l":
    case "t":
      for (n4 = 0; n4 < i4; n4 += 2)
        U2(x.x += e2[n4], x.y += e2[n4 + 1]);
      break;
    case "h":
      for (n4 = 0; n4 < i4; ++n4)
        U2(x.x += e2[n4], x.y);
      break;
    case "v":
      for (n4 = 0; n4 < i4; ++n4)
        U2(x.x, x.y += e2[n4]);
      break;
    case "c":
      for (n4 = 0; n4 < i4; n4 += 6)
        U2(x.x + e2[n4], x.y + e2[n4 + 1]), U2(x.x + e2[n4 + 2], x.y + e2[n4 + 3]), U2(x.x += e2[n4 + 4], x.y += e2[n4 + 5]);
      break;
    case "s":
    case "q":
      for (n4 = 0; n4 < i4; n4 += 4)
        U2(x.x + e2[n4], x.y + e2[n4 + 1]), U2(x.x += e2[n4 + 2], x.y += e2[n4 + 3]);
      break;
    case "A":
      for (n4 = 0; n4 < i4; n4 += 7)
        U2(e2[n4 + 5], e2[n4 + 6]);
      x.x = e2[i4 - 2], x.y = e2[i4 - 1];
      break;
    case "a":
      for (n4 = 0; n4 < i4; n4 += 7)
        U2(x.x += e2[n4 + 5], x.y += e2[n4 + 6]);
  }
}
function O(t, e2, i4) {
  const n4 = p2[t.toLowerCase()];
  let r2;
  "number" == typeof n4 && (n4 ? e2.length >= n4 && (r2 = { action: t, args: e2.slice(0, e2.length - e2.length % n4) }, i4.push(r2), F(r2)) : (r2 = { action: t, args: [] }, i4.push(r2), F(r2)));
}
function T(t) {
  const e2 = ("string" != typeof t.path ? v(t.path) : t.path).match(g), i4 = [];
  if (m = {}, x = {}, !e2)
    return null;
  let n4 = "", r2 = [];
  const o2 = e2.length;
  for (let a = 0; a < o2; ++a) {
    const t2 = e2[a], o3 = parseFloat(t2);
    isNaN(o3) ? (n4 && O(n4, r2, i4), r2 = [], n4 = t2) : r2.push(o3);
  }
  O(n4, r2, i4);
  const s3 = { x: 0, y: 0, width: 0, height: 0 };
  return m && "left" in m && (s3.x = m.left, s3.y = m.top, s3.width = m.right - m.left, s3.height = m.bottom - m.top), s3;
}
function E(t) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  if ("circle" === t.type)
    e2.x = t.cx - t.r, e2.y = t.cy - t.r, e2.width = 2 * t.r, e2.height = 2 * t.r;
  else if ("ellipse" === t.type)
    e2.x = t.cx - t.rx, e2.y = t.cy - t.ry, e2.width = 2 * t.rx, e2.height = 2 * t.ry;
  else if ("image" === t.type || "rect" === t.type)
    e2.x = t.x, e2.y = t.y, e2.width = t.width, e2.height = t.height;
  else if ("path" === t.type) {
    const n4 = c(T(t));
    e2.x = n4.x, e2.y = n4.y, e2.width = n4.width, e2.height = n4.height;
  }
  return e2;
}
function V(t) {
  const e2 = { x: 0, y: 0, width: 0, height: 0 };
  let i4 = null, n4 = Number.NEGATIVE_INFINITY, r2 = Number.NEGATIVE_INFINITY;
  for (const o2 of t)
    i4 ? (i4.x = Math.min(i4.x, o2.x), i4.y = Math.min(i4.y, o2.y), n4 = Math.max(n4, o2.x + o2.width), r2 = Math.max(r2, o2.y + o2.height)) : (i4 = e2, i4.x = o2.x, i4.y = o2.y, n4 = o2.x + o2.width, r2 = o2.y + o2.height);
  return i4 && (i4.width = n4 - i4.x, i4.height = r2 - i4.y), i4;
}
function C(t, e2, i4, o2, s3, a, l3, h2, f3) {
  let c4 = (l3 && a ? j(a, e2) : e2) / 2, d3 = (l3 && a ? j(a, i4) : i4) / 2;
  if (f3) {
    const t2 = f3[0], e3 = f3[1];
    c4 = (l3 && a ? j(a, t2) : t2) / 2, d3 = (l3 && a ? j(a, e3) : e3) / 2;
  }
  const u3 = t.width + o2, y3 = t.height + o2, p3 = n3(), g3 = n3();
  let m3 = false;
  if (s3 && 0 !== u3 && 0 !== y3) {
    const t2 = e2 !== i4 ? e2 / i4 : u3 / y3, n4 = e2 > i4 ? e2 : i4;
    let o3 = 1, s4 = 1;
    isNaN(n4) || (t2 > 1 ? (o3 = n4 / u3, s4 = n4 / t2 / y3) : (s4 = n4 / y3, o3 = n4 * t2 / u3)), o(g3, g3, z(p3, o3, s4, c4, d3)), m3 = true;
  }
  const x2 = t.x + (u3 - o2) / 2, w2 = t.y + (y3 - o2) / 2;
  if (o(g3, g3, I(p3, c4 - x2, d3 - w2)), !m3 && (u3 > e2 || y3 > i4)) {
    const t2 = u3 / e2 > y3 / i4, n4 = (t2 ? e2 : i4) / (t2 ? u3 : y3);
    o(g3, g3, z(p3, n4, n4, x2, w2));
  }
  return a && o(g3, g3, B(p3, a, x2, w2)), h2 && o(g3, g3, I(p3, h2[0], h2[1])), `matrix(${g3[0]},${g3[1]},${g3[2]},${g3[3]},${g3[4]},${g3[5]})`;
}
function D(t, e2, i4) {
  const n4 = t == null ? void 0 : t.effects.find((t2) => "bloom" === t2.type);
  if (!n4)
    return null;
  const { strength: r2, radius: o2 } = n4, s3 = r2 > 0 ? o2 : 0, a = (r2 + s3) * e2, l3 = 4 * r2 + 1;
  return n("filter", { id: `bloom${i4}`, x: "-100%", y: "-100%", width: "300%", height: "300%", filterUnits: "userSpaceOnUse" }, n("feMorphology", { operator: "dilate", radius: (r2 + 0.5 * s3) * (5 ** (e2 / 100) * (0.4 + e2 / 100)), in: "SourceGraphic", result: "dilate" }), n("feGaussianBlur", { in: "dilate", stdDeviation: a / 25, result: "blur" }), n("feGaussianBlur", { in: "blur", stdDeviation: a / 50, result: "intensityBlur" }), n("feComponentTransfer", { in: "SourceGraphic", result: "intensityBrightness" }, n("feFuncR", { type: "linear", slope: l3 }), n("feFuncG", { type: "linear", slope: l3 }), n("feFuncB", { type: "linear", slope: l3 })), n("feMerge", null, n("feMergeNode", { in: "intensityBlur" }), n("feMergeNode", { in: "intensityBrightness" }), n("feGaussianBlur", { stdDeviation: r2 / 10 })));
}
function R(t, n4, r2, o2 = {}) {
  var _a;
  const s3 = [], a = [], l3 = ++b, c4 = D(o2.effectView, n4, l3);
  let d3 = null;
  if (c4) {
    const t2 = (_a = o2.effectView) == null ? void 0 : _a.effects.find((t3) => "bloom" === t3.type), e2 = (t2.strength ? t2.strength + t2.radius / 2 : 0) / 3, i4 = n4 + n4 * e2, s4 = r2 + r2 * e2;
    d3 = [Math.max(i4, 10), Math.max(s4, 10)];
  }
  for (let e2 = 0; e2 < t.length; e2++) {
    const l4 = t[e2], f3 = [], c5 = [];
    let u3 = 0, y3 = 0, p3 = 0;
    for (const t2 of l4) {
      const { shape: e3, fill: i4, stroke: n5, font: r3, offset: a2 } = t2;
      o2.ignoreStrokeWidth || (u3 += n5 && n5.width || 0);
      const l5 = A(i4), h2 = S(n5), d4 = "text" === e3.type ? $(e3, r3) : null;
      s3.push(N(l5)), f3.push(M(e3, l5.fill, h2, d4)), c5.push(E(e3)), a2 && (y3 += a2[0], p3 += a2[1]);
    }
    const g3 = C(c(V(c5)), n4, r2, u3, o2.scale ?? false, o2.rotation, o2.useRotationSize ?? false, [y3, p3], d3);
    let m3 = null;
    if (o2.masking) {
      const t2 = `mask-${e2}`, i4 = o2.masking[e2];
      s3.push(G(i4, t2)), m3 = `url(#${t2})`;
    }
    a.push(m3 ? n("g", { mask: m3 }, n("g", { transform: g3 }, f3)) : n("g", { transform: g3 }, f3));
  }
  o2.useRotationSize && o2.rotation && (n4 = j(o2.rotation, n4), r2 = j(o2.rotation, r2)), c4 && (i(d3), n4 = d3[0], r2 = d3[1]);
  return n("svg", { xmlns: f, width: n4, height: r2, style: "display: block;" }, c4, n("defs", null, s3), c4 ? n("g", { filter: `url(#bloom${l3})` }, a) : a);
}

// node_modules/@arcgis/core/symbols/support/renderUtils.js
var s2 = i2();
function h(t, e2) {
  s2.append(t, e2), s2.detach(e2);
}
function l2(t, e2, i4) {
  const r2 = Math.ceil(e2[0]), n4 = Math.ceil(e2[1]);
  if (!t.some((t2) => !!t2.length))
    return null;
  const o2 = i4 && i4.node || document.createElement("div");
  null != i4.opacity && (o2.style.opacity = i4.opacity.toString()), null != i4.effectView && (o2.style.filter = q(i4.effectView));
  return h(o2, () => R(t, r2, n4, i4)), o2;
}
function m2(t, e2) {
  t = Math.ceil(t), e2 = Math.ceil(e2);
  const i4 = document.createElement("canvas");
  i4.width = t, i4.height = e2, i4.style.width = t + "px", i4.style.height = e2 + "px";
  const r2 = i4.getContext("2d");
  return r2.clearRect(0, 0, t, e2), r2;
}
function g2(t, i4, r2) {
  return t ? U(t, { responseType: "image" }).then((t2) => {
    const e2 = t2.data, n4 = e2.width, o2 = e2.height, a = n4 / o2;
    let c4 = i4;
    if (r2) {
      const t3 = Math.max(n4, o2);
      c4 = Math.min(c4, t3);
    }
    return { image: e2, width: a <= 1 ? Math.ceil(c4 * a) : c4, height: a <= 1 ? c4 : Math.ceil(c4 / a) };
  }) : Promise.reject(new s("renderUtils: imageDataSize", "href not provided."));
}
function u2(t, e2) {
  return !(!t || "ignore" === e2) && ("multiply" !== e2 || 255 !== t.r || 255 !== t.g || 255 !== t.b || 1 !== t.a);
}
function d2(t, e2, n4, o2, a) {
  switch (a) {
    case "multiply":
      t[e2 + 0] *= n4[0], t[e2 + 1] *= n4[1], t[e2 + 2] *= n4[2], t[e2 + 3] *= n4[3];
      break;
    default: {
      const a2 = y({ r: t[e2 + 0], g: t[e2 + 1], b: t[e2 + 2] });
      a2.h = o2.h, a2.s = o2.s, a2.v = a2.v / 100 * o2.v;
      const c4 = p(a2);
      t[e2 + 0] = c4.r, t[e2 + 1] = c4.g, t[e2 + 2] = c4.b, t[e2 + 3] *= n4[3];
      break;
    }
  }
}
function f2(e2, r2, n4, o2, a) {
  return g2(e2, r2, a).then((a2) => {
    const c4 = a2.width ? a2.width : r2, s3 = a2.height ? a2.height : r2;
    if (a2.image && u2(n4, o2)) {
      let t = a2.image.width, r3 = a2.image.height;
      has("edge") && /\.svg$/i.test(e2) && (t -= 1, r3 -= 1);
      const h2 = m2(c4, s3);
      h2.drawImage(a2.image, 0, 0, t, r3, 0, 0, c4, s3);
      const l3 = h2.getImageData(0, 0, c4, s3), g3 = [n4.r / 255, n4.g / 255, n4.b / 255, n4.a], u3 = y(n4);
      for (let e3 = 0; e3 < l3.data.length; e3 += 4)
        d2(l3.data, e3, g3, u3, o2);
      h2.putImageData(l3, 0, 0), e2 = h2.canvas.toDataURL("image/png");
    } else {
      const i4 = r && r.findCredential(e2);
      if (i4 && i4.token) {
        const t = e2.includes("?") ? "&" : "?";
        e2 = `${e2}${t}token=${i4.token}`;
      }
    }
    return { url: e2, width: c4, height: s3 };
  }).catch(() => ({ url: e2, width: r2, height: r2 }));
}

export {
  l2 as l,
  f2 as f
};
//# sourceMappingURL=chunk-ERKVJOMN.js.map

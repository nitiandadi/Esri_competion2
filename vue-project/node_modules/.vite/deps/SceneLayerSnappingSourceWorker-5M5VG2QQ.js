import {
  b,
  j,
  v
} from "./chunk-FLGF6PV2.js";
import {
  i
} from "./chunk-2BQRI7XV.js";
import "./chunk-UA55FIQK.js";
import {
  N,
  R,
  T,
  V,
  _,
  d,
  k,
  p as p2,
  s
} from "./chunk-6EA7KGPB.js";
import {
  m
} from "./chunk-NIOIEEDL.js";
import "./chunk-S4DOBTPL.js";
import "./chunk-IEBU4QQL.js";
import "./chunk-CPQSD22U.js";
import "./chunk-MNYWPBDW.js";
import "./chunk-4M3AMTD4.js";
import "./chunk-XCHMTTFV.js";
import "./chunk-MJIX5E4D.js";
import "./chunk-XSQFM27N.js";
import "./chunk-R5TZJ3KJ.js";
import "./chunk-A7PY25IH.js";
import "./chunk-LVBKIX3G.js";
import {
  D
} from "./chunk-OSLJAK5K.js";
import "./chunk-5Y2E66SG.js";
import "./chunk-33DQ3DIB.js";
import "./chunk-2E4SJPYR.js";
import "./chunk-U34LDFXK.js";
import "./chunk-Y5TO5CEM.js";
import "./chunk-BKGJHAJX.js";
import "./chunk-V2OTMPXZ.js";
import "./chunk-OEIEPNC6.js";
import "./chunk-CJ2YD4VU.js";
import "./chunk-JGIZLXNQ.js";
import "./chunk-D4SYZIFV.js";
import "./chunk-2VRWGZDB.js";
import "./chunk-5JG6YWQJ.js";
import "./chunk-7Q77X7UJ.js";
import "./chunk-NOYTM57S.js";
import "./chunk-OPQ632ST.js";
import "./chunk-U6GC73UT.js";
import "./chunk-YMSHUIGU.js";
import "./chunk-EPJSBV4J.js";
import "./chunk-RCZJUTGU.js";
import "./chunk-REIXEATJ.js";
import "./chunk-YEFLZ2OV.js";
import "./chunk-XP5MC636.js";
import {
  r as r4
} from "./chunk-FGXNBIU5.js";
import "./chunk-TM5UW7VI.js";
import "./chunk-WVLEGBEW.js";
import "./chunk-6YBCJ6DZ.js";
import "./chunk-Y3KJPDCE.js";
import "./chunk-LSUFI7PR.js";
import "./chunk-YT74S35I.js";
import "./chunk-U5I7FQWJ.js";
import "./chunk-M3KO43BW.js";
import "./chunk-JT54I3AY.js";
import {
  A,
  g,
  n,
  p,
  q,
  r as r2,
  r2 as r3,
  t as t2,
  u2 as u,
  x
} from "./chunk-TNTTCGVB.js";
import "./chunk-DC3QI5ZE.js";
import "./chunk-EGHLQERQ.js";
import "./chunk-I2U7UK6N.js";
import "./chunk-YHZVWABO.js";
import "./chunk-WATRS3LJ.js";
import "./chunk-CPUYSXBP.js";
import "./chunk-MJFFZ3MM.js";
import "./chunk-7FMLQXIT.js";
import "./chunk-B6GJAETG.js";
import "./chunk-FC74MT6E.js";
import "./chunk-H2ENCYR3.js";
import "./chunk-SVHG5VY2.js";
import "./chunk-S47644HM.js";
import "./chunk-QXPN4D5D.js";
import "./chunk-DLM7WQKI.js";
import {
  a2 as a,
  e,
  l as l2
} from "./chunk-7GTATSRF.js";
import "./chunk-MTJ2HM2W.js";
import {
  e as e2
} from "./chunk-PXVSWY3C.js";
import {
  f
} from "./chunk-QLY5H3XF.js";
import "./chunk-UG2OEDEE.js";
import "./chunk-HSFMVUPO.js";
import "./chunk-IOCWNUEO.js";
import "./chunk-PR6SXADK.js";
import "./chunk-MGJMBJDY.js";
import {
  l,
  r,
  t
} from "./chunk-WHB7G7RI.js";
import "./chunk-DFKQJ226.js";

// node_modules/@arcgis/core/geometry/support/clipRay.js
function a2(r6) {
  return r6 ? { ray: d(r6.ray), c0: r6.c0, c1: r6.c1 } : { ray: d(), c0: 0, c1: Number.MAX_VALUE };
}
var A2 = new s(() => a2());

// node_modules/@arcgis/core/geometry/support/frustum.js
function I() {
  return [n(), n(), n(), n(), n(), n(), n(), n()];
}
function i2(T3, _2) {
  for (let O2 = 0; O2 < v3.NUM; O2++) {
    const R3 = T3[O2];
    if (R3[0] * _2[0] + R3[1] * _2[1] + R3[2] * _2[2] + R3[3] >= _2[3])
      return false;
  }
  return true;
}
var U;
var l3;
!function(T3) {
  T3[T3.LEFT = 0] = "LEFT", T3[T3.RIGHT = 1] = "RIGHT", T3[T3.BOTTOM = 2] = "BOTTOM", T3[T3.TOP = 3] = "TOP", T3[T3.NEAR = 4] = "NEAR", T3[T3.FAR = 5] = "FAR";
}(U || (U = {})), function(T3) {
  T3[T3.NEAR_BOTTOM_LEFT = 0] = "NEAR_BOTTOM_LEFT", T3[T3.NEAR_BOTTOM_RIGHT = 1] = "NEAR_BOTTOM_RIGHT", T3[T3.NEAR_TOP_RIGHT = 2] = "NEAR_TOP_RIGHT", T3[T3.NEAR_TOP_LEFT = 3] = "NEAR_TOP_LEFT", T3[T3.FAR_BOTTOM_LEFT = 4] = "FAR_BOTTOM_LEFT", T3[T3.FAR_BOTTOM_RIGHT = 5] = "FAR_BOTTOM_RIGHT", T3[T3.FAR_TOP_RIGHT = 6] = "FAR_TOP_RIGHT", T3[T3.FAR_TOP_LEFT = 7] = "FAR_TOP_LEFT";
}(l3 || (l3 = {}));
var k3 = { bottom: [l3.FAR_BOTTOM_RIGHT, l3.NEAR_BOTTOM_RIGHT, l3.NEAR_BOTTOM_LEFT, l3.FAR_BOTTOM_LEFT], near: [l3.NEAR_BOTTOM_LEFT, l3.NEAR_BOTTOM_RIGHT, l3.NEAR_TOP_RIGHT, l3.NEAR_TOP_LEFT], far: [l3.FAR_BOTTOM_RIGHT, l3.FAR_BOTTOM_LEFT, l3.FAR_TOP_LEFT, l3.FAR_TOP_RIGHT], right: [l3.NEAR_BOTTOM_RIGHT, l3.FAR_BOTTOM_RIGHT, l3.FAR_TOP_RIGHT, l3.NEAR_TOP_RIGHT], left: [l3.FAR_BOTTOM_LEFT, l3.NEAR_BOTTOM_LEFT, l3.NEAR_TOP_LEFT, l3.FAR_TOP_LEFT], top: [l3.FAR_TOP_LEFT, l3.NEAR_TOP_LEFT, l3.NEAR_TOP_RIGHT, l3.FAR_TOP_RIGHT] };
var v3;
var h2;
!function(T3) {
  T3[T3.NUM = 6] = "NUM";
}(v3 || (v3 = {})), function(T3) {
  T3[T3.NUM = 8] = "NUM";
}(h2 || (h2 = {}));
var g2 = [r4(-1, -1, -1, 1), r4(1, -1, -1, 1), r4(1, 1, -1, 1), r4(-1, 1, -1, 1), r4(-1, -1, 1, 1), r4(1, -1, 1, 1), r4(1, 1, 1, 1), r4(-1, 1, 1, 1)];
var b2 = new s(a2);
var y2 = I();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var g3 = class {
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  constructor(e3, t4) {
    this._objectToBoundingSphere = e3, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new S(), this._objectCount = 0, t4 && (void 0 !== t4.maximumObjectsPerNode && (this._maximumObjectsPerNode = t4.maximumObjectsPerNode), void 0 !== t4.maximumDepth && (this._maximumDepth = t4.maximumDepth));
  }
  destroy() {
    this._degenerateObjects.clear(), S.clearPool(), R2[0] = null, w2.prune(), K.prune();
  }
  add(e3, t4 = e3.length) {
    this._objectCount += t4, this._grow(e3, t4);
    const n2 = S.acquire();
    for (let o2 = 0; o2 < t4; o2++) {
      const t5 = e3[o2];
      this._isDegenerate(t5) ? this._degenerateObjects.add(t5) : (n2.init(this._root), this._add(t5, n2));
    }
    S.release(n2);
  }
  remove(t4, n2 = null) {
    this._objectCount -= t4.length;
    const o2 = S.acquire();
    for (const s3 of t4) {
      const t5 = r(n2) ? n2 : _(this._objectToBoundingSphere(s3), C);
      M(t5[3]) ? (o2.init(this._root), this._remove(s3, t5, o2)) : this._degenerateObjects.delete(s3);
    }
    S.release(o2), this._shrink();
  }
  update(e3, t4) {
    if (!M(t4[3]) && this._isDegenerate(e3))
      return;
    const n2 = v4(e3);
    this.remove(n2, t4), this.add(n2);
  }
  forEachAlongRay(e3, t4, n2) {
    const o2 = p2(e3, t4);
    this._forEachNode(this._root, (e4) => {
      if (!this._intersectsNode(o2, e4))
        return false;
      const t5 = e4.node;
      return t5.terminals.forAll((e5) => {
        this._intersectsObject(o2, e5) && n2(e5);
      }), null !== t5.residents && t5.residents.forAll((e5) => {
        this._intersectsObject(o2, e5) && n2(e5);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e3, t4, n2, o2) {
    const s3 = p2(e3, t4);
    this._forEachNode(this._root, (e4) => {
      if (!this._intersectsNodeWithOffset(s3, e4, o2))
        return false;
      const t5 = e4.node;
      return t5.terminals.forAll((e5) => {
        this._intersectsObjectWithOffset(s3, e5, o2) && n2(e5);
      }), null !== t5.residents && t5.residents.forAll((e5) => {
        this._intersectsObjectWithOffset(s3, e5, o2) && n2(e5);
      }), true;
    });
  }
  forEach(e3) {
    this._forEachNode(this._root, (t4) => {
      const n2 = t4.node;
      return n2.terminals.forAll(e3), null !== n2.residents && n2.residents.forAll(e3), true;
    }), this._degenerateObjects.forEach(e3);
  }
  forEachDegenerateObject(e3) {
    this._degenerateObjects.forEach(e3);
  }
  findClosest(e3, t4, n2, i3 = () => true, r6 = 1 / 0) {
    let h3 = 1 / 0, a4 = 1 / 0, d2 = null;
    const u2 = z(e3, t4), c2 = (o2) => {
      if (--r6, !i3(o2))
        return;
      const s3 = this._objectToBoundingSphere(o2);
      if (!i2(n2, s3))
        return;
      const u3 = E(e3, t4, k(s3)), c3 = u3 - s3[3], f3 = u3 + s3[3];
      c3 < h3 && (h3 = c3, a4 = f3, d2 = o2);
    };
    return this._forEachNodeDepthOrdered(this._root, (i4) => {
      if (r6 <= 0 || !i2(n2, i4.bounds))
        return false;
      g(y3, u2, i4.halfSize), u(y3, y3, i4.bounds);
      if (E(e3, t4, y3) > a4)
        return false;
      const h4 = i4.node;
      return h4.terminals.forAll((e4) => c2(e4)), null !== h4.residents && h4.residents.forAll((e4) => c2(e4)), true;
    }, e3, t4), d2;
  }
  forEachInDepthRange(e3, t4, n2, i3, r6, h3, a4) {
    let d2 = -1 / 0, u2 = 1 / 0;
    const c2 = { setRange: (e4) => {
      n2 === g3.DepthOrder.FRONT_TO_BACK ? (d2 = Math.max(d2, e4.near), u2 = Math.min(u2, e4.far)) : (d2 = Math.max(d2, -e4.far), u2 = Math.min(u2, -e4.near));
    } };
    c2.setRange(i3);
    const f3 = E(t4, n2, e3), m3 = z(t4, n2), p4 = z(t4, -n2), b3 = (e4) => {
      if (!a4(e4))
        return;
      const o2 = this._objectToBoundingSphere(e4), s3 = k(o2), i4 = E(t4, n2, s3) - f3, m4 = i4 - o2[3], p5 = i4 + o2[3];
      m4 > u2 || p5 < d2 || !i2(h3, o2) || r6(e4, c2);
    };
    this._forEachNodeDepthOrdered(this._root, (e4) => {
      if (!i2(h3, e4.bounds))
        return false;
      g(y3, m3, e4.halfSize), u(y3, y3, e4.bounds);
      if (E(t4, n2, y3) - f3 > u2)
        return false;
      g(y3, p4, e4.halfSize), u(y3, y3, e4.bounds);
      if (E(t4, n2, y3) - f3 < d2)
        return false;
      const i4 = e4.node;
      return i4.terminals.forAll((e5) => b3(e5)), null !== i4.residents && i4.residents.forAll((e5) => b3(e5)), true;
    }, t4, n2);
  }
  forEachNode(e3) {
    this._forEachNode(this._root, (t4) => e3(t4.node, t4.bounds, t4.halfSize));
  }
  forEachNeighbor(e3, t4) {
    const n2 = T(t4), o2 = k(t4), s3 = (t5) => {
      const s4 = this._objectToBoundingSphere(t5), r7 = T(s4), h4 = n2 + r7;
      return !(p(k(s4), o2) - h4 * h4 <= 0) || e3(t5);
    };
    let r6 = true;
    const h3 = (e4) => {
      r6 && (r6 = s3(e4));
    };
    this._forEachNode(this._root, (e4) => {
      const t5 = T(e4.bounds), s4 = n2 + t5;
      if (p(k(e4.bounds), o2) - s4 * s4 > 0)
        return false;
      const a4 = e4.node;
      return a4.terminals.forAll(h3), r6 && null !== a4.residents && a4.residents.forAll(h3), r6;
    }), r6 && this.forEachDegenerateObject(h3);
  }
  _intersectsNode(e3, t4) {
    return x2(t4.bounds, 2 * -t4.halfSize, k4), x2(t4.bounds, 2 * t4.halfSize, q2), i(e3.origin, e3.direction, k4, q2);
  }
  _intersectsNodeWithOffset(e3, t4, n2) {
    return x2(t4.bounds, 2 * -t4.halfSize, k4), x2(t4.bounds, 2 * t4.halfSize, q2), n2.applyToMinMax(k4, q2), i(e3.origin, e3.direction, k4, q2);
  }
  _intersectsObject(e3, t4) {
    const n2 = this._objectToBoundingSphere(t4);
    return !(n2[3] > 0) || V(n2, e3);
  }
  _intersectsObjectWithOffset(e3, t4, n2) {
    const o2 = this._objectToBoundingSphere(t4);
    return !(o2[3] > 0) || V(n2.applyToBoundingSphere(o2), e3);
  }
  _forEachNode(e3, t4) {
    let n2 = S.acquire().init(e3);
    const o2 = [n2];
    for (; 0 !== o2.length; ) {
      if (n2 = o2.pop(), t4(n2) && !n2.isLeaf())
        for (let e4 = 0; e4 < n2.node.children.length; e4++) {
          n2.node.children[e4] && o2.push(S.acquire().init(n2).advance(e4));
        }
      S.release(n2);
    }
  }
  _forEachNodeDepthOrdered(e3, t4, n2, o2 = g3.DepthOrder.FRONT_TO_BACK) {
    let s3 = S.acquire().init(e3);
    const i3 = [s3];
    for (T2(n2, o2, W); 0 !== i3.length; ) {
      if (s3 = i3.pop(), t4(s3) && !s3.isLeaf())
        for (let e4 = 7; e4 >= 0; --e4) {
          const t5 = W[e4];
          s3.node.children[t5] && i3.push(S.acquire().init(s3).advance(t5));
        }
      S.release(s3);
    }
  }
  _remove(e3, t4, n2) {
    w2.clear();
    const o2 = n2.advanceTo(t4, (e4, t5) => {
      w2.push(e4.node), w2.push(t5);
    }) ? n2.node.terminals : n2.node.residents;
    if (o2.removeUnordered(e3), 0 === o2.length)
      for (let s3 = w2.length - 2; s3 >= 0; s3 -= 2) {
        const e4 = w2.data[s3], t5 = w2.data[s3 + 1];
        if (!this._purge(e4, t5))
          break;
      }
  }
  _nodeIsEmpty(e3) {
    if (0 !== e3.terminals.length)
      return false;
    if (null !== e3.residents)
      return 0 === e3.residents.length;
    for (let t4 = 0; t4 < e3.children.length; t4++)
      if (e3.children[t4])
        return false;
    return true;
  }
  _purge(e3, t4) {
    return t4 >= 0 && (e3.children[t4] = null), !!this._nodeIsEmpty(e3) && (null === e3.residents && (e3.residents = new l2({ shrink: true })), true);
  }
  _add(e3, t4) {
    t4.advanceTo(this._objectToBoundingSphere(e3)) ? t4.node.terminals.push(e3) : (t4.node.residents.push(e3), t4.node.residents.length > this._maximumObjectsPerNode && t4.depth < this._maximumDepth && this._split(t4));
  }
  _split(e3) {
    const t4 = e3.node.residents;
    e3.node.residents = null;
    for (let n2 = 0; n2 < t4.length; n2++) {
      const o2 = S.acquire().init(e3);
      this._add(t4.getItemAt(n2), o2), S.release(o2);
    }
  }
  _grow(e3, t4) {
    if (0 !== t4 && (N2(e3, t4, (e4) => this._objectToBoundingSphere(e4), I2), M(I2[3]) && !this._fitsInsideTree(I2)))
      if (this._nodeIsEmpty(this._root.node))
        _(I2, this._root.bounds), this._root.halfSize = 1.25 * this._root.bounds[3], this._root.updateBoundsRadiusFromHalfSize();
      else {
        const e4 = this._rootBoundsForRootAsSubNode(I2);
        this._placingRootViolatesMaxDepth(e4) ? this._rebuildTree(I2, e4) : this._growRootAsSubNode(e4), S.release(e4);
      }
  }
  _rebuildTree(e3, t4) {
    r3(P, t4.bounds), P[3] = t4.halfSize, N2([e3, P], 2, (e4) => e4, L);
    const n2 = S.acquire().init(this._root);
    this._root.initFrom(null, L, L[3]), this._root.increaseHalfSize(1.25), this._forEachNode(n2, (e4) => (this.add(e4.node.terminals.data, e4.node.terminals.length), null !== e4.node.residents && this.add(e4.node.residents.data, e4.node.residents.length), true)), S.release(n2);
  }
  _placingRootViolatesMaxDepth(e3) {
    const t4 = Math.log(e3.halfSize / this._root.halfSize) * Math.LOG2E;
    let n2 = 0;
    return this._forEachNode(this._root, (e4) => (n2 = Math.max(n2, e4.depth), n2 + t4 <= this._maximumDepth)), n2 + t4 > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e3) {
    const t4 = e3[3], n2 = e3;
    let o2 = -1 / 0;
    const s3 = this._root.bounds, i3 = this._root.halfSize;
    for (let h3 = 0; h3 < 3; h3++) {
      const e4 = s3[h3] - i3 - (n2[h3] - t4), r7 = n2[h3] + t4 - (s3[h3] + i3), a4 = Math.max(0, Math.ceil(e4 / (2 * i3))), d2 = Math.max(0, Math.ceil(r7 / (2 * i3))) + 1, l4 = 2 ** Math.ceil(Math.log(a4 + d2) * Math.LOG2E);
      o2 = Math.max(o2, l4), H2[h3].min = a4, H2[h3].max = d2;
    }
    for (let h3 = 0; h3 < 3; h3++) {
      let e4 = H2[h3].min, t5 = H2[h3].max;
      const n3 = (o2 - (e4 + t5)) / 2;
      e4 += Math.ceil(n3), t5 += Math.floor(n3);
      const r7 = s3[h3] - i3 - e4 * i3 * 2;
      F[h3] = r7 + (t5 + e4) * i3;
    }
    const r6 = o2 * i3;
    return F[3] = r6 * B, S.acquire().initFrom(null, F, r6, 0);
  }
  _growRootAsSubNode(e3) {
    const t4 = this._root.node;
    r3(I2, this._root.bounds), I2[3] = this._root.halfSize, this._root.init(e3), e3.advanceTo(I2, null, true), e3.node.children = t4.children, e3.node.residents = t4.residents, e3.node.terminals = t4.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e3 = this._findShrinkIndex();
      if (-1 === e3)
        break;
      this._root.advance(e3), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e3 = null;
    const t4 = this._root.node.children;
    let n2 = 0, o2 = 0;
    for (; o2 < t4.length && null == e3; )
      n2 = o2++, e3 = t4[n2];
    for (; o2 < t4.length; )
      if (t4[o2++])
        return -1;
    return n2;
  }
  _isDegenerate(e3) {
    return !M(this._objectToBoundingSphere(e3)[3]);
  }
  _fitsInsideTree(e3) {
    const t4 = this._root.bounds, n2 = this._root.halfSize;
    return e3[3] <= n2 && e3[0] >= t4[0] - n2 && e3[0] <= t4[0] + n2 && e3[1] >= t4[1] - n2 && e3[1] <= t4[1] + n2 && e3[2] >= t4[2] - n2 && e3[2] <= t4[2] + n2;
  }
};
var S = class {
  constructor() {
    this.bounds = R(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e3) {
    return this.initFrom(e3.node, e3.bounds, e3.halfSize, e3.depth);
  }
  initFrom(t4, n2, o2, s3 = this.depth) {
    return this.node = r(t4) ? t4 : S.createEmptyNode(), r(n2) && _(n2, this.bounds), this.halfSize = o2, this.depth = s3, this;
  }
  increaseHalfSize(e3) {
    this.halfSize *= e3, this.updateBoundsRadiusFromHalfSize();
  }
  updateBoundsRadiusFromHalfSize() {
    this.bounds[3] = this.halfSize * B;
  }
  advance(e3) {
    let t4 = this.node.children[e3];
    t4 || (t4 = S.createEmptyNode(), this.node.children[e3] = t4), this.node = t4, this.halfSize /= 2, this.depth++;
    const n2 = A4[e3];
    return this.bounds[0] += n2[0] * this.halfSize, this.bounds[1] += n2[1] * this.halfSize, this.bounds[2] += n2[2] * this.halfSize, this.updateBoundsRadiusFromHalfSize(), this;
  }
  advanceTo(e3, t4, n2 = false) {
    for (; ; ) {
      if (this.isTerminalFor(e3))
        return t4 && t4(this, -1), true;
      if (this.isLeaf()) {
        if (!n2)
          return t4 && t4(this, -1), false;
        this.node.residents = null;
      }
      const o2 = this._childIndex(e3);
      t4 && t4(this, o2), this.advance(o2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e3) {
    return e3[3] > this.halfSize / 2;
  }
  _childIndex(e3) {
    const t4 = this.bounds;
    return (t4[0] < e3[0] ? 1 : 0) + (t4[1] < e3[1] ? 2 : 0) + (t4[2] < e3[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l2({ shrink: true }), residents: new l2({ shrink: true }) };
  }
  static acquire() {
    return S._pool.acquire();
  }
  static release(e3) {
    S._pool.release(e3);
  }
  static clearPool() {
    S._pool.prune();
  }
};
function O(e3, t4) {
  e3[0] = Math.min(e3[0], t4[0] - t4[3]), e3[1] = Math.min(e3[1], t4[1] - t4[3]), e3[2] = Math.min(e3[2], t4[2] - t4[3]);
}
function j3(e3, t4) {
  e3[0] = Math.max(e3[0], t4[0] + t4[3]), e3[1] = Math.max(e3[1], t4[1] + t4[3]), e3[2] = Math.max(e3[2], t4[2] + t4[3]);
}
function x2(e3, t4, n2) {
  n2[0] = e3[0] + t4, n2[1] = e3[1] + t4, n2[2] = e3[2] + t4;
}
function N2(e3, t4, n2, o2) {
  if (1 === t4) {
    const t5 = n2(e3[0]);
    _(t5, o2);
  } else {
    k4[0] = 1 / 0, k4[1] = 1 / 0, k4[2] = 1 / 0, q2[0] = -1 / 0, q2[1] = -1 / 0, q2[2] = -1 / 0;
    for (let o3 = 0; o3 < t4; o3++) {
      const t5 = n2(e3[o3]);
      M(t5[3]) && (O(k4, t5), j3(q2, t5));
    }
    A(o2, k4, q2, 0.5), o2[3] = Math.max(q2[0] - k4[0], q2[1] - k4[1], q2[2] - k4[2]) / 2;
  }
}
function T2(e3, t4, n2) {
  if (!K.length)
    for (let o2 = 0; o2 < 8; ++o2)
      K.push({ index: 0, distance: 0 });
  for (let o2 = 0; o2 < 8; ++o2) {
    const n3 = A4[o2];
    K.data[o2].index = o2, K.data[o2].distance = E(e3, t4, n3);
  }
  K.sort((e4, t5) => e4.distance - t5.distance);
  for (let o2 = 0; o2 < 8; ++o2)
    n2[o2] = K.data[o2].index;
}
function z(e3, t4) {
  let n2, o2 = 1 / 0;
  for (let s3 = 0; s3 < 8; ++s3) {
    const i3 = E(e3, t4, D2[s3]);
    i3 < o2 && (o2 = i3, n2 = D2[s3]);
  }
  return n2;
}
function E(e3, t4, n2) {
  return t4 * (e3[0] * n2[0] + e3[1] * n2[1] + e3[2] * n2[2]);
}
function M(e3) {
  return !isNaN(e3) && e3 !== -1 / 0 && e3 !== 1 / 0 && e3 > 0;
}
S._pool = new e2(S), function(e3) {
  var t4;
  (t4 = e3.DepthOrder || (e3.DepthOrder = {}))[t4.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t4[t4.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(g3 || (g3 = {}));
var A4 = [r2(-1, -1, -1), r2(1, -1, -1), r2(-1, 1, -1), r2(1, 1, -1), r2(-1, -1, 1), r2(1, -1, 1), r2(-1, 1, 1), r2(1, 1, 1)];
var D2 = [r2(-1, -1, -1), r2(-1, -1, 1), r2(-1, 1, -1), r2(-1, 1, 1), r2(1, -1, -1), r2(1, -1, 1), r2(1, 1, -1), r2(1, 1, 1)];
var B = Math.sqrt(3);
var R2 = [null];
function v4(e3) {
  return R2[0] = e3, R2;
}
var F = R();
var y3 = n();
var k4 = n();
var q2 = n();
var w2 = new l2();
var C = R();
var I2 = R();
var P = R();
var L = R();
var H2 = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var K = new l2();
var W = [0, 0, 0, 0, 0, 0, 0, 0];
var V3 = g3;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t3 = 1e3;
function a3(t4, a4, e3) {
  const i3 = R(), m3 = k(i3);
  return q(m3, m3, t4, 0.5), q(m3, m3, a4, 0.5), i3[3] = x(m3, t4), u(m3, m3, e3), i3;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var j4 = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new V3((e3) => e3.bounds), this._edges = new V3((e3) => e3.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e3, t4) {
    await Promise.resolve(), f(t4), await this._ensureEdgeLocations(e3, t4);
    const s3 = [];
    return this._edges.forEachNeighbor((t5) => (this._addCandidates(e3, t5, s3), s3.length < t3), e3.bounds), { result: { candidates: s3 } };
  }
  async _ensureEdgeLocations(e3, o2) {
    const i3 = [];
    if (this._components.forEachNeighbor((e4) => {
      if (t(e4.info)) {
        const { id: t4, uid: s3 } = e4;
        i3.push({ id: t4, uid: s3 });
      }
      return true;
    }, e3.bounds), !i3.length)
      return;
    const n2 = { components: i3 }, r6 = await this.remoteClient.invoke("fetchAllEdgeLocations", n2, l(o2, {}));
    for (const t4 of r6.components)
      this._setFetchEdgeLocations(t4);
  }
  async add(e3) {
    const t4 = new E2(e3.id, e3.bounds);
    return this._idToComponent.set(t4.id, t4), this._components.add([t4]), { result: {} };
  }
  async remove(e3) {
    const t4 = this._idToComponent.get(e3.id);
    if (t4) {
      const e4 = [];
      this._edges.forEachNeighbor((s3) => (s3.component === t4 && e4.push(s3), true), t4.bounds), this._edges.remove(e4), this._components.remove([t4]), this._idToComponent.delete(t4.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e3) {
    const s3 = this._idToComponent.get(e3.id);
    if (t(s3) || e3.uid !== s3.uid)
      return;
    const o2 = m.createView(e3.locations), i3 = new Array(o2.count), n2 = n(), r6 = n();
    for (let t4 = 0; t4 < o2.count; t4++) {
      o2.position0.getVec(t4, n2), o2.position1.getVec(t4, r6);
      const d2 = a3(n2, r6, e3.origin), c3 = new C2(s3, t4, d2);
      i3[t4] = c3;
    }
    this._edges.add(i3);
    const { objectIds: c2, origin: a4 } = e3;
    s3.info = { locations: o2, objectIds: c2, origin: a4 };
  }
  _addCandidates(e3, t4, s3) {
    const { info: o2 } = t4.component, { origin: i3, objectIds: r6 } = o2, d2 = o2.locations, c2 = d2.position0.getVec(t4.index, this._tmpP1), a4 = d2.position1.getVec(t4.index, this._tmpP2);
    u(c2, c2, i3), u(a4, a4, i3);
    const p4 = r6[d2.componentIndex.get(t4.index)];
    this._addEdgeCandidate(e3, p4, c2, a4, s3), this._addVertexCandidate(e3, p4, c2, s3), this._addVertexCandidate(e3, p4, a4, s3);
  }
  _addEdgeCandidate(e3, t4, s3, o2, i3) {
    if (!(e3.types & D.EDGE))
      return;
    const n2 = k(e3.bounds), d2 = b(s3, o2, this._tmpLineSegment), a4 = j(d2, n2, this._tmpP3);
    N(e3.bounds, a4) && i3.push({ type: "edge", objectId: t4, target: t2(a4), distance: x(n2, a4), start: t2(s3), end: t2(o2) });
  }
  _addVertexCandidate(e3, t4, s3, o2) {
    if (!(e3.types & D.VERTEX))
      return;
    const i3 = k(e3.bounds);
    N(e3.bounds, s3) && o2.push({ type: "vertex", objectId: t4, target: t2(s3), distance: x(i3, s3) });
  }
};
j4 = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], j4);
var y4 = j4;
var E2 = class {
  constructor(e3, t4) {
    this.id = e3, this.bounds = t4, this.info = null, this.uid = ++E2.uid;
  }
};
E2.uid = 0;
var C2 = class {
  constructor(e3, t4, s3) {
    this.component = e3, this.index = t4, this.bounds = s3;
  }
};
export {
  y4 as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-5M5VG2QQ.js.map

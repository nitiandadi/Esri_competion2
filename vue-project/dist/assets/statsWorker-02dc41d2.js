import{a4 as C,eB as O,eC as U,eD as _,aD as A,q as B,eE as q,r as D,bB as R,eF as Y,eG as k,c as G}from"./mapviewstore-8a6f290e.js";import{c as V,D as W,m as Z,f as H,d as J,T as K,y as L,x as Q,z as X,S as ee,M as ae}from"./utils-da1501b7.js";let I=null;function ne(a,e,n){return a.x<0?a.x+=e:a.x>n&&(a.x-=e),a}function ie(a,e,n,t){const i=U(n)?_(n):null,o=i?Math.round((i.valid[1]-i.valid[0])/e.scale[0]):null;return a.map(s=>{const l=new A(B(s.geometry));return q(e,l,l,l.hasZ,l.hasM),s.geometry=i?ne(l,o,t[0]):l,s})}function te(a,e=18,n,t,i,o){const s=new Float64Array(i*o);e=Math.round(R(e));let l=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,u=0,d=0,m=0,c=0;const v=Y(t,n);for(const{geometry:T,attributes:y}of a){const{x:p,y:f}=T,x=Math.max(0,p-e),g=Math.max(0,f-e),E=Math.min(o,f+e),P=Math.min(i,p+e),N=+v(y);for(let h=g;h<E;h++)for(let $=x;$<P;$++){const M=h*i+$,S=k($-p,h-f,e),j=s[M];u=s[M]+=S*N;const b=u-j;d+=b,m+=b*b,u<l&&(l=u),u>r&&(r=u),c++}}if(!c)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const z=(r-l)/2;return{mean:d/c,stdDev:Math.sqrt((m-d*d/c)/c),min:l,max:r,mid:z,count:c}}async function w(a,e){if(!e)return[];const{field:n,field2:t,field3:i,fieldDelimiter:o}=a,s=a.valueExpression,l=a.normalizationType,r=a.normalizationField,u=a.normalizationTotal,d=[],m=a.viewInfoParams;let c=null,v=null;if(s){if(!I){const{arcadeUtils:y}=await C();I=y}c=I.createFunction(s),v=m&&I.getViewInfo({viewingMode:m.viewingMode,scale:m.scale,spatialReference:new O(m.spatialReference)})}const z=a.fieldInfos,T=!(e[0]&&"declaredClass"in e[0]&&e[0].declaredClass==="esri.Graphic")&&z?{fields:z}:null;return e.forEach(y=>{const p=y.attributes;let f;if(s){const x=T?{...y,layer:T}:y,g=I.createExecContext(x,v);f=I.executeFunction(c,g)}else p&&(f=p[n],t&&(f=`${V(f)}${o}${V(p[t])}`,i&&(f=`${f}${o}${V(p[i])}`)));if(l&&typeof f=="number"&&isFinite(f)){const x=p&&parseFloat(p[r]);f=W(f,l,x,u)}d.push(f)}),d}function ye(a){const e=a.field,n=a.normalizationType,t=a.normalizationField;let i;return n==="field"?i="(NOT "+t+" = 0)":n!=="log"&&n!=="natural-log"&&n!=="square-root"||(i=`(${e} > 0)`),i}function F(a,e){return new G(a,e)}function ve(a,e,n){const t=e!=null?a+" >= "+e:"",i=n!=null?a+" <= "+n:"";let o="";return o=t&&i?le(t,i):t||i,o?"("+o+")":""}function ze(a,e,n,t){let i=null;return e?e.name!==a.objectIdField&&t.includes(e.type)||(i=F(n,"'field' should be one of these types: "+t.join(","))):i=F(n,"'field' is not defined in the layer schema"),i}function le(a,e){let n=D(a)?a:"";return D(e)&&e&&(n=n?"("+n+") AND ("+e+")":e),n}function Ie(a,e,n){const t=oe({layer:a,fields:e});if(t.length)return F(n,"Unknown fields: "+t.join(", ")+". You can only use fields defined in the layer schema");const i=se({layer:a,fields:e});return i.length?F(n,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function oe(a){const e=a.layer;return a.fields.filter(n=>!e.getField(n))}function se(a){const e=a.layer;return a.fields.filter(n=>{const t=e.getFieldUsageInfo(n);return!t||!t.supportsStatistics})}async function re(a){const{attribute:e,features:n}=a,{normalizationType:t,normalizationField:i,minValue:o,maxValue:s,fieldType:l}=e,r=await w({field:e.field,valueExpression:e.valueExpression,normalizationType:t,normalizationField:i,normalizationTotal:e.normalizationTotal,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),u=Z({normalizationType:t,normalizationField:i,minValue:o,maxValue:s}),d={value:.5,fieldType:l},m=l==="esriFieldTypeString"?H({values:r,supportsNullCount:u,percentileParams:d}):J({values:r,minValue:o,maxValue:s,useSampleStdDev:!t,supportsNullCount:u,percentileParams:d});return K(m,l==="esriFieldTypeDate")}async function ue(a){const{attribute:e,features:n}=a,t=await w({field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:e.valueExpression,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),i=L(t);return Q(i,e.domains,e.returnAllCodedValues,e.fieldDelimiter)}async function fe(a){const{attribute:e,features:n}=a,{field:t,normalizationType:i,normalizationField:o,normalizationTotal:s,classificationMethod:l}=e,r=await w({field:t,valueExpression:e.valueExpression,normalizationType:i,normalizationField:o,normalizationTotal:s,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),u=X(r,{field:t,normalizationType:i,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:e.standardDeviationInterval,numClasses:e.numClasses,minValue:e.minValue,maxValue:e.maxValue});return ee(u,l)}async function de(a){const{attribute:e,features:n}=a,{field:t,normalizationType:i,normalizationField:o,normalizationTotal:s,classificationMethod:l}=e,r=await w({field:t,valueExpression:e.valueExpression,normalizationType:i,normalizationField:o,normalizationTotal:s,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n);return ae(r,{field:t,normalizationType:i,normalizationField:o,normalizationTotal:s,classificationMethod:l,standardDeviationInterval:e.standardDeviationInterval,numBins:e.numBins,minValue:e.minValue,maxValue:e.maxValue})}async function me(a){const{attribute:e,features:n}=a,{field:t,radius:i,fieldOffset:o,transform:s,spatialReference:l,size:r}=e,u=ie(n,s,l,r),{count:d,min:m,max:c,mean:v,stdDev:z}=te(u,i,o,t,r[0],r[1]);return{count:d,min:m,max:c,avg:v,stddev:z}}const xe=Object.freeze(Object.defineProperty({__proto__:null,classBreaks:fe,heatmapStatistics:me,histogram:de,summaryStatistics:re,uniqueValues:ue},Symbol.toStringTag,{value:"Module"}));export{Ie as M,le as N,ze as a,ve as b,de as c,re as d,w as j,ue as p,xe as s,fe as v,ye as x,me as z};

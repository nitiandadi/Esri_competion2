import{e as u,y as g,b as k,bP as G,cq as R,s$ as b,ff as S,t0 as Y,t1 as C,t2 as D,t3 as H,h3 as z,gI as m,h6 as E,t4 as f,gR as L,gH as P,jw as V,t5 as A,gT as J,t6 as U,t7 as W,t8 as X,aD as Z,r as T,fz as K,t9 as Q,fh as x,ta as tt,tb as B,tc as nt,t as h,td as $,jX as y,te as rt,tf as et,jf as at,tg as ot,th as it,ti as st,nv as lt,kL as ct,c2 as pt,h2 as ut,tj as gt,tk as ht,tl as ft}from"./mapviewstore-8a6f290e.js";var v;let p=v=class extends G{constructor(t){super(t),this.origin=R(),this.translation=R(),this.rotation=b(),this.scale=S(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return Y(N,D(this.rotation),C(this.rotation)),H(t,N,this.translation,this.scale),t}get localMatrixInverse(){return z(m(),this.localMatrix)}applyLocal(t,n){return E(n,t,this.localMatrix)}applyLocalInverse(t,n){return E(n,t,this.localMatrixInverse)}project(t,n){const r=new Float64Array(t.length),e=f.fromTypedArray(r),a=f.fromTypedArray(t);if(this.geographic){const s=L(n),c=m();return P(n,this.origin,c,s),V(c,c,this.localMatrix),A(e,a,c),J(r,s,0,r,n,0,r.length/3),r}const{localMatrix:o,origin:i}=this;U(o,W)?X(e,a):A(e,a,o);for(let s=0;s<r.length;s+=3)r[s+0]+=i[0],r[s+1]+=i[1],r[s+2]+=i[2];return r}getOriginPoint(t){const[n,r,e]=this.origin;return new Z({x:n,y:r,z:e,spatialReference:t})}equals(t){return T(t)&&this.geographic===t.geographic&&K(this.origin,t.origin)&&Q(this.localMatrix,t.localMatrix)}clone(){const t={origin:x(this.origin),translation:x(this.translation),rotation:b(this.rotation),scale:x(this.scale),geographic:this.geographic};return new v(t)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0),u([g()],p.prototype,"localMatrix",null),u([g()],p.prototype,"localMatrixInverse",null),p=v=u([k("esri.geometry.support.MeshTransform")],p);const N=tt(),yt=p;function M(t,n){return t.isGeographic||t.isWebMercator&&((n==null?void 0:n.geographic)??!0)}function _(t,n,r){return M(n.spatialReference,r)?$t(t,n,r):At(t,n,r)}function mt(t,n,r){const{position:e,normal:a,tangent:o}=t;if(h(n))return{position:e,normal:a,tangent:o};const i=n.localMatrix;return _({position:gt(e,new Float64Array(e.length),i),normal:T(a)?ht(a,new Float32Array(a.length),i):null,tangent:T(o)?ft(o,new Float32Array(o.length),i):null},n.getOriginPoint(r),{geographic:n.geographic})}function Nt(t,n,r){if(r!=null&&r.useTransform){const{position:e,normal:a,tangent:o}=t;return{vertexAttributes:{position:e,normal:a,tangent:o},transform:new yt({origin:[n.x,n.y,n.z??0],geographic:M(n.spatialReference,r)})}}return{vertexAttributes:_(t,n,r),transform:null}}function j(t,n,r){return M(n.spatialReference,r)?vt(t,n,r):I(t,n,r)}function jt(t,n,r,e){if(h(n))return j(t,r,e);const a=mt(t,n,r.spatialReference);return r.equals(n.getOriginPoint(r.spatialReference))?I(a,r,e):j(a,r,e)}function At(t,n,r){const e=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,s=n.z||0,{horizontal:c,vertical:w}=F(r?r.unit:null,n.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=a[l+0]*c+o,e[l+1]=a[l+1]*c+i,e[l+2]=a[l+2]*w+s;return{position:e,normal:t.normal,tangent:t.tangent}}function $t(t,n,r){const e=n.spatialReference,a=O(n,r,d),o=new Float64Array(t.position.length),i=wt(t.position,a,e,o),s=B(q,a);return{position:i,normal:xt(i,o,t.normal,s,e),tangent:Tt(i,o,t.tangent,s,e)}}function wt(t,n,r,e){A(f.fromTypedArray(e),f.fromTypedArray(t),n);const a=new Float64Array(t.length);return nt(e,a,r)}function xt(t,n,r,e,a){if(h(r))return null;const o=new Float32Array(r.length);return $(y.fromTypedArray(o),y.fromTypedArray(r),e),rt(o,t,n,a,o),o}function Tt(t,n,r,e,a){if(h(r))return null;const o=new Float32Array(r.length);$(y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(r,4*Float32Array.BYTES_PER_ELEMENT),e);for(let i=3;i<o.length;i+=4)o[i]=r[i];return et(o,t,n,a,o),o}function I(t,n,r){const e=new Float64Array(t.position.length),a=t.position,o=n.x,i=n.y,s=n.z||0,{horizontal:c,vertical:w}=F(r?r.unit:null,n.spatialReference);for(let l=0;l<a.length;l+=3)e[l+0]=(a[l+0]-o)/c,e[l+1]=(a[l+1]-i)/c,e[l+2]=(a[l+2]-s)/w;return{position:e,normal:t.normal,tangent:t.tangent}}function vt(t,n,r){const e=n.spatialReference;O(n,r,d);const a=z(Rt,d),o=new Float64Array(t.position.length),i=dt(t.position,e,a,o),s=B(q,a);return{position:i,normal:Mt(t.normal,t.position,o,e,s),tangent:Ft(t.tangent,t.position,o,e,s)}}function O(t,n,r){P(t.spatialReference,[t.x,t.y,t.z||0],r,L(t.spatialReference));const{horizontal:e,vertical:a}=F(n?n.unit:null,t.spatialReference);return at(r,r,[e,e,a]),r}function dt(t,n,r,e){const a=ot(t,n,e),o=f.fromTypedArray(a),i=new Float64Array(a.length),s=f.fromTypedArray(i);return A(s,o,r),i}function Mt(t,n,r,e,a){if(h(t))return null;const o=it(t,n,r,e,new Float32Array(t.length)),i=y.fromTypedArray(o);return $(i,i,a),o}function Ft(t,n,r,e,a){if(h(t))return null;const o=st(t,n,r,e,new Float32Array(t.length)),i=y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT);return $(i,i,a),o}function F(t,n){if(h(t))return bt;const r=n.isGeographic?1:lt(n),e=n.isGeographic?1:ct(n),a=pt(1,t,"meters");return{horizontal:a*r,vertical:a*e}}const d=m(),Rt=m(),q=ut(),bt={horizontal:1,vertical:1};export{yt as L,jt as M,Nt as _,j as b,mt as k,M as r,_ as x};
